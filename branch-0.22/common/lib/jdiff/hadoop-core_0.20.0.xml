<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Sun May 31 20:29:52 PDT 2009 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="hadoop-core 0.20.0"
  jdversion="1.0.9">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /home/gkesavan/release-0.20.0/build/ivy/lib/Hadoop/jdiff/jdiff-1.0.9.jar:/home/gkesavan/release-0.20.0/build/ivy/lib/Hadoop/jdiff/xerces-1.4.4.jar -classpath /home/gkesavan/release-0.20.0/build/classes:/home/gkesavan/release-0.20.0/lib/commons-cli-2.0-SNAPSHOT.jar:/home/gkesavan/release-0.20.0/lib/hsqldb-1.8.0.10.jar:/home/gkesavan/release-0.20.0/lib/jsp-2.1/jsp-2.1.jar:/home/gkesavan/release-0.20.0/lib/jsp-2.1/jsp-api-2.1.jar:/home/gkesavan/release-0.20.0/lib/kfs-0.2.2.jar:/home/gkesavan/release-0.20.0/conf:/home/gkesavan/.ivy2/cache/commons-logging/commons-logging/jars/commons-logging-1.0.4.jar:/home/gkesavan/.ivy2/cache/log4j/log4j/jars/log4j-1.2.15.jar:/home/gkesavan/.ivy2/cache/commons-httpclient/commons-httpclient/jars/commons-httpclient-3.0.1.jar:/home/gkesavan/.ivy2/cache/commons-codec/commons-codec/jars/commons-codec-1.3.jar:/home/gkesavan/.ivy2/cache/xmlenc/xmlenc/jars/xmlenc-0.52.jar:/home/gkesavan/.ivy2/cache/net.java.dev.jets3t/jets3t/jars/jets3t-0.6.1.jar:/home/gkesavan/.ivy2/cache/commons-net/commons-net/jars/commons-net-1.4.1.jar:/home/gkesavan/.ivy2/cache/org.mortbay.jetty/servlet-api-2.5/jars/servlet-api-2.5-6.1.14.jar:/home/gkesavan/.ivy2/cache/oro/oro/jars/oro-2.0.8.jar:/home/gkesavan/.ivy2/cache/org.mortbay.jetty/jetty/jars/jetty-6.1.14.jar:/home/gkesavan/.ivy2/cache/org.mortbay.jetty/jetty-util/jars/jetty-util-6.1.14.jar:/home/gkesavan/.ivy2/cache/tomcat/jasper-runtime/jars/jasper-runtime-5.5.12.jar:/home/gkesavan/.ivy2/cache/tomcat/jasper-compiler/jars/jasper-compiler-5.5.12.jar:/home/gkesavan/.ivy2/cache/commons-el/commons-el/jars/commons-el-1.0.jar:/home/gkesavan/.ivy2/cache/junit/junit/jars/junit-3.8.1.jar:/home/gkesavan/.ivy2/cache/commons-logging/commons-logging-api/jars/commons-logging-api-1.0.4.jar:/home/gkesavan/.ivy2/cache/org.slf4j/slf4j-api/jars/slf4j-api-1.4.3.jar:/home/gkesavan/.ivy2/cache/org.eclipse.jdt/core/jars/core-3.1.1.jar:/home/gkesavan/.ivy2/cache/org.slf4j/slf4j-log4j12/jars/slf4j-log4j12-1.4.3.jar:/home/gkesavan/.ivy2/cache/jdiff/jdiff/jars/jdiff-1.0.9.jar:/home/gkesavan/.ivy2/cache/xerces/xerces/jars/xerces-1.4.4.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-launcher.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-apache-resolver.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-starteam.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-netrexx.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-testutil.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-jai.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-swing.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-jmf.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-apache-bcel.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-jdepend.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-jsch.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-apache-bsf.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-antlr.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-weblogic.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-junit.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-apache-log4j.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/xercesImpl.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-apache-oro.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-trax.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-nodeps.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-commons-logging.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-apache-regexp.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-stylebook.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-javamail.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/ant-commons-net.jar:/home/gkesavan/tools/apache-ant-1.7.1/lib/xml-apis.jar:/home/gkesavan/tools/jdk1.6.0_07-32bit/lib/tools.jar -sourcepath /home/gkesavan/release-0.20.0/src/core -apidir /home/gkesavan/release-0.20.0/lib/jdiff -apiname Hadoop-core 0.20.1-dev -->
<package name="org.apache.hadoop">
  <!-- start interface org.apache.hadoop.HadoopVersionAnnotation -->
  <interface name="HadoopVersionAnnotation"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <method name="version" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the Hadoop version
 @return the version string "0.6.3-dev"]]>
      </doc>
    </method>
    <method name="user" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the username that compiled Hadoop.]]>
      </doc>
    </method>
    <method name="date" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the date when Hadoop was compiled.
 @return the date in unix 'date' format]]>
      </doc>
    </method>
    <method name="url" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the url for the subversion repository.]]>
      </doc>
    </method>
    <method name="revision" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the subversion revision.
 @return the revision number as a string (eg. "451451")]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A package attribute that captures the version of Hadoop that was compiled.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.HadoopVersionAnnotation -->
</package>
<package name="org.apache.hadoop.conf">
  <!-- start interface org.apache.hadoop.conf.Configurable -->
  <interface name="Configurable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Set the configuration to be used by this object.]]>
      </doc>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the configuration used by this object.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Something that may be configured with a {@link Configuration}.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.conf.Configurable -->
  <!-- start class org.apache.hadoop.conf.Configuration -->
  <class name="Configuration" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Iterable"/>
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A new configuration.]]>
      </doc>
    </constructor>
    <constructor name="Configuration" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A new configuration where the behavior of reading from the default 
 resources can be turned off.
 
 If the parameter {@code loadDefaults} is false, the new instance
 will not load resources from the default files. 
 @param loadDefaults specifies whether to load from the default files]]>
      </doc>
    </constructor>
    <constructor name="Configuration" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A new configuration with the same settings cloned from another.
 
 @param other the configuration from which to clone settings.]]>
      </doc>
    </constructor>
    <method name="addDefaultResource"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a default resource. Resources are loaded in the order of the resources 
 added.
 @param name file name. File should be present in the classpath.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 @param name resource to be added, the classpath is examined for a file 
             with that name.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 @param url url of the resource to be added, the local filesystem is 
            examined directly to find the resource, without referring to 
            the classpath.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 @param file file-path of resource to be added, the local filesystem is
             examined directly to find the resource, without referring to 
             the classpath.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 @param in InputStream to deserialize the object from.]]>
      </doc>
    </method>
    <method name="reloadConfiguration"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reload configuration from previously added resources.

 This method will clear all the configuration read from the added 
 resources, and final parameters. This will make the resources to 
 be read again before accessing the values. Values that are added
 via set methods will overlay values read from the resources.]]>
      </doc>
    </method>
    <method name="get" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property, <code>null</code> if
 no such property exists.
 
 Values are processed for <a href="#VariableExpansion">variable expansion</a> 
 before being returned. 
 
 @param name the property name.
 @return the value of the <code>name</code> property, 
         or null if no such property exists.]]>
      </doc>
    </method>
    <method name="getRaw" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property, without doing
 <a href="#VariableExpansion">variable expansion</a>.
 
 @param name the property name.
 @return the value of the <code>name</code> property, 
         or null if no such property exists.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the <code>value</code> of the <code>name</code> property.
 
 @param name property name.
 @param value property value.]]>
      </doc>
    </method>
    <method name="setIfUnset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets a property if it is currently unset.
 @param name the property name
 @param value the new value]]>
      </doc>
    </method>
    <method name="get" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property. If no such property 
 exists, then <code>defaultValue</code> is returned.
 
 @param name property name.
 @param defaultValue default value.
 @return property value, or <code>defaultValue</code> if the property 
         doesn't exist.]]>
      </doc>
    </method>
    <method name="getInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="int"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as an <code>int</code>.
   
 If no such property exists, or if the specified value is not a valid
 <code>int</code>, then <code>defaultValue</code> is returned.
 
 @param name property name.
 @param defaultValue default value.
 @return property value as an <code>int</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to an <code>int</code>.
 
 @param name property name.
 @param value <code>int</code> value of the property.]]>
      </doc>
    </method>
    <method name="getLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="long"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>long</code>.  
 If no such property is specified, or if the specified value is not a valid
 <code>long</code>, then <code>defaultValue</code> is returned.
 
 @param name property name.
 @param defaultValue default value.
 @return property value as a <code>long</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to a <code>long</code>.
 
 @param name property name.
 @param value <code>long</code> value of the property.]]>
      </doc>
    </method>
    <method name="getFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="float"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>float</code>.  
 If no such property is specified, or if the specified value is not a valid
 <code>float</code>, then <code>defaultValue</code> is returned.
 
 @param name property name.
 @param defaultValue default value.
 @return property value as a <code>float</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to a <code>float</code>.
 
 @param name property name.
 @param value property value.]]>
      </doc>
    </method>
    <method name="getBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="boolean"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>boolean</code>.  
 If no such property is specified, or if the specified value is not a valid
 <code>boolean</code>, then <code>defaultValue</code> is returned.
 
 @param name property name.
 @param defaultValue default value.
 @return property value as a <code>boolean</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setBoolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to a <code>boolean</code>.
 
 @param name property name.
 @param value <code>boolean</code> value of the property.]]>
      </doc>
    </method>
    <method name="setBooleanIfUnset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Set the given property, if it is currently unset.
 @param name property name
 @param value new value]]>
      </doc>
    </method>
    <method name="getRange" return="org.apache.hadoop.conf.Configuration.IntegerRanges"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Parse the given attribute as a set of integer ranges
 @param name the attribute name
 @param defaultValue the default value if it is not set
 @return a new set of ranges from the configured value]]>
      </doc>
    </method>
    <method name="getStringCollection" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 a collection of <code>String</code>s.  
 If no such property is specified then empty collection is returned.
 <p>
 This is an optimized version of {@link #getStrings(String)}
 
 @param name property name.
 @return property value as a collection of <code>String</code>s.]]>
      </doc>
    </method>
    <method name="getStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 an array of <code>String</code>s.  
 If no such property is specified then <code>null</code> is returned.
 
 @param name property name.
 @return property value as an array of <code>String</code>s, 
         or <code>null</code>.]]>
      </doc>
    </method>
    <method name="getStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 an array of <code>String</code>s.  
 If no such property is specified then default value is returned.
 
 @param name property name.
 @param defaultValue The default value
 @return property value as an array of <code>String</code>s, 
         or default value.]]>
      </doc>
    </method>
    <method name="setStrings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="values" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Set the array of string values for the <code>name</code> property as 
 as comma delimited values.  
 
 @param name property name.
 @param values The values]]>
      </doc>
    </method>
    <method name="getClassByName" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
      <doc>
      <![CDATA[Load a class by name.
 
 @param name the class name.
 @return the class object.
 @throws ClassNotFoundException if the class is not found.]]>
      </doc>
    </method>
    <method name="getClasses" return="java.lang.Class[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property
 as an array of <code>Class</code>.
 The value of the property specifies a list of comma separated class names.  
 If no such property is specified, then <code>defaultValue</code> is 
 returned.
 
 @param name the property name.
 @param defaultValue default value.
 @return property value as a <code>Class[]</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.Class"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>Class</code>.  
 If no such property is specified, then <code>defaultValue</code> is 
 returned.
 
 @param name the class name.
 @param defaultValue default value.
 @return property value as a <code>Class</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.Class"/>
      <param name="xface" type="java.lang.Class"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>Class</code>
 implementing the interface specified by <code>xface</code>.
   
 If no such property is specified, then <code>defaultValue</code> is 
 returned.
 
 An exception is thrown if the returned class does not implement the named
 interface. 
 
 @param name the class name.
 @param defaultValue default value.
 @param xface the interface implemented by the named class.
 @return property value as a <code>Class</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setClass"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="theClass" type="java.lang.Class"/>
      <param name="xface" type="java.lang.Class"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to the name of a 
 <code>theClass</code> implementing the given interface <code>xface</code>.
 
 An exception is thrown if <code>theClass</code> does not implement the 
 interface <code>xface</code>. 
 
 @param name property name.
 @param theClass property value.
 @param xface the interface implemented by the named class.]]>
      </doc>
    </method>
    <method name="getLocalPath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dirsProp" type="java.lang.String"/>
      <param name="path" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a local file under a directory named by <i>dirsProp</i> with
 the given <i>path</i>.  If <i>dirsProp</i> contains multiple directories,
 then one is chosen based on <i>path</i>'s hash code.  If the selected
 directory does not exist, an attempt is made to create it.
 
 @param dirsProp directory in which to locate the file.
 @param path file-path.
 @return local file under the directory with the given path.]]>
      </doc>
    </method>
    <method name="getFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dirsProp" type="java.lang.String"/>
      <param name="path" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a local file name under a directory named in <i>dirsProp</i> with
 the given <i>path</i>.  If <i>dirsProp</i> contains multiple directories,
 then one is chosen based on <i>path</i>'s hash code.  If the selected
 directory does not exist, an attempt is made to create it.
 
 @param dirsProp directory in which to locate the file.
 @param path file-path.
 @return local file under the directory with the given path.]]>
      </doc>
    </method>
    <method name="getResource" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the {@link URL} for the named resource.
 
 @param name resource name.
 @return the url for the named resource.]]>
      </doc>
    </method>
    <method name="getConfResourceAsInputStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get an input stream attached to the configuration resource with the
 given <code>name</code>.
 
 @param name configuration resource name.
 @return an input stream attached to the resource.]]>
      </doc>
    </method>
    <method name="getConfResourceAsReader" return="java.io.Reader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a {@link Reader} attached to the configuration resource with the
 given <code>name</code>.
 
 @param name configuration resource name.
 @return a reader attached to the resource.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the number of keys in the configuration.

 @return number of keys in the configuration.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears all keys from the configuration.]]>
      </doc>
    </method>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an {@link Iterator} to go through the list of <code>String</code> 
 key-value pairs in the configuration.
 
 @return an iterator over the entries.]]>
      </doc>
    </method>
    <method name="writeXml"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write out the non-default properties in this configuration to the give
 {@link OutputStream}.
 
 @param out the output stream to write to.]]>
      </doc>
    </method>
    <method name="getClassLoader" return="java.lang.ClassLoader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link ClassLoader} for this job.
 
 @return the correct class loader.]]>
      </doc>
    </method>
    <method name="setClassLoader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classLoader" type="java.lang.ClassLoader"/>
      <doc>
      <![CDATA[Set the class loader that will be used to load the various objects.
 
 @param classLoader the new class loader.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setQuietMode"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="quietmode" type="boolean"/>
      <doc>
      <![CDATA[Set the quietness-mode. 
 
 In the quiet-mode, error and informational messages might not be logged.
 
 @param quietmode <code>true</code> to set quiet-mode on, <code>false</code>
              to turn it off.]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[For debugging.  List non-default properties to the terminal and exit.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Provides access to configuration parameters.

 <h4 id="Resources">Resources</h4>

 <p>Configurations are specified by resources. A resource contains a set of
 name/value pairs as XML data. Each resource is named by either a 
 <code>String</code> or by a {@link Path}. If named by a <code>String</code>, 
 then the classpath is examined for a file with that name.  If named by a 
 <code>Path</code>, then the local filesystem is examined directly, without 
 referring to the classpath.

 <p>Unless explicitly turned off, Hadoop by default specifies two 
 resources, loaded in-order from the classpath: <ol>
 <li><tt><a href="{@docRoot}/../core-default.html">core-default.xml</a>
 </tt>: Read-only defaults for hadoop.</li>
 <li><tt>core-site.xml</tt>: Site-specific configuration for a given hadoop
 installation.</li>
 </ol>
 Applications may add additional resources, which are loaded
 subsequent to these resources in the order they are added.
 
 <h4 id="FinalParams">Final Parameters</h4>

 <p>Configuration parameters may be declared <i>final</i>. 
 Once a resource declares a value final, no subsequently-loaded 
 resource can alter that value.  
 For example, one might define a final parameter with:
 <tt><pre>
  &lt;property&gt;
    &lt;name&gt;dfs.client.buffer.dir&lt;/name&gt;
    &lt;value&gt;/tmp/hadoop/dfs/client&lt;/value&gt;
    <b>&lt;final&gt;true&lt;/final&gt;</b>
  &lt;/property&gt;</pre></tt>

 Administrators typically define parameters as final in 
 <tt>core-site.xml</tt> for values that user applications may not alter.

 <h4 id="VariableExpansion">Variable Expansion</h4>

 <p>Value strings are first processed for <i>variable expansion</i>. The
 available properties are:<ol>
 <li>Other properties defined in this Configuration; and, if a name is
 undefined here,</li>
 <li>Properties in {@link System#getProperties()}.</li>
 </ol>

 <p>For example, if a configuration resource contains the following property
 definitions: 
 <tt><pre>
  &lt;property&gt;
    &lt;name&gt;basedir&lt;/name&gt;
    &lt;value&gt;/user/${<i>user.name</i>}&lt;/value&gt;
  &lt;/property&gt;
  
  &lt;property&gt;
    &lt;name&gt;tempdir&lt;/name&gt;
    &lt;value&gt;${<i>basedir</i>}/tmp&lt;/value&gt;
  &lt;/property&gt;</pre></tt>

 When <tt>conf.get("tempdir")</tt> is called, then <tt>${<i>basedir</i>}</tt>
 will be resolved to another property in this Configuration, while
 <tt>${<i>user.name</i>}</tt> would then ordinarily be resolved to the value
 of the System property with that name.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.Configuration -->
  <!-- start class org.apache.hadoop.conf.Configuration.IntegerRanges -->
  <class name="Configuration.IntegerRanges" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Configuration.IntegerRanges"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Configuration.IntegerRanges" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isIncluded" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Is the given value in the set of ranges
 @param value the value to check
 @return is the value in the ranges?]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A class that represents a set of positive integer ranges. It parses 
 strings of the form: "2-3,5,7-" where ranges are separated by comma and 
 the lower/upper bounds are separated by dash. Either the lower or upper 
 bound may be omitted meaning all values up to or over. So the string 
 above means 2, 3, 5, and 7, 8, 9, ...]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.Configuration.IntegerRanges -->
  <!-- start class org.apache.hadoop.conf.Configured -->
  <class name="Configured" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="Configured"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a Configured.]]>
      </doc>
    </constructor>
    <constructor name="Configured" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a Configured.]]>
      </doc>
    </constructor>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Base class for things that may be configured with a {@link Configuration}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.Configured -->
  <doc>
  <![CDATA[Configuration of system parameters.]]>
  </doc>
</package>
<package name="org.apache.hadoop.filecache">
  <!-- start class org.apache.hadoop.filecache.DistributedCache -->
  <class name="DistributedCache" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DistributedCache"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLocalCache" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cache" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="baseDir" type="org.apache.hadoop.fs.Path"/>
      <param name="fileStatus" type="org.apache.hadoop.fs.FileStatus"/>
      <param name="isArchive" type="boolean"/>
      <param name="confFileStamp" type="long"/>
      <param name="currentWorkDir" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the locally cached file or archive; it could either be 
 previously cached (and valid) or copy it from the {@link FileSystem} now.
 
 @param cache the cache to be localized, this should be specified as 
 new URI(hdfs://hostname:port/absolute_path_to_file#LINKNAME). If no schema 
 or hostname:port is provided the file is assumed to be in the filesystem
 being used in the Configuration
 @param conf The Confguration file which contains the filesystem
 @param baseDir The base cache Dir where you wnat to localize the files/archives
 @param fileStatus The file status on the dfs.
 @param isArchive if the cache is an archive or a file. In case it is an
  archive with a .zip or .jar or .tar or .tgz or .tar.gz extension it will
  be unzipped/unjarred/untarred automatically 
  and the directory where the archive is unzipped/unjarred/untarred is
  returned as the Path.
  In case of a file, the path to the file is returned
 @param confFileStamp this is the hdfs file modification timestamp to verify that the 
 file to be cached hasn't changed since the job started
 @param currentWorkDir this is the directory where you would want to create symlinks 
 for the locally cached files/archives
 @return the path to directory where the archives are unjarred in case of archives,
 the path to the file where the file is copied locally 
 @throws IOException]]>
      </doc>
    </method>
    <method name="getLocalCache" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cache" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="baseDir" type="org.apache.hadoop.fs.Path"/>
      <param name="fileStatus" type="org.apache.hadoop.fs.FileStatus"/>
      <param name="isArchive" type="boolean"/>
      <param name="confFileStamp" type="long"/>
      <param name="currentWorkDir" type="org.apache.hadoop.fs.Path"/>
      <param name="honorSymLinkConf" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the locally cached file or archive; it could either be 
 previously cached (and valid) or copy it from the {@link FileSystem} now.
 
 @param cache the cache to be localized, this should be specified as 
 new URI(hdfs://hostname:port/absolute_path_to_file#LINKNAME). If no schema 
 or hostname:port is provided the file is assumed to be in the filesystem
 being used in the Configuration
 @param conf The Confguration file which contains the filesystem
 @param baseDir The base cache Dir where you wnat to localize the files/archives
 @param fileStatus The file status on the dfs.
 @param isArchive if the cache is an archive or a file. In case it is an
  archive with a .zip or .jar or .tar or .tgz or .tar.gz extension it will
  be unzipped/unjarred/untarred automatically 
  and the directory where the archive is unzipped/unjarred/untarred is
  returned as the Path.
  In case of a file, the path to the file is returned
 @param confFileStamp this is the hdfs file modification timestamp to verify that the 
 file to be cached hasn't changed since the job started
 @param currentWorkDir this is the directory where you would want to create symlinks 
 for the locally cached files/archives
 @param honorSymLinkConf if this is false, then the symlinks are not
 created even if conf says so (this is required for an optimization in task
 launches
 @return the path to directory where the archives are unjarred in case of archives,
 the path to the file where the file is copied locally 
 @throws IOException]]>
      </doc>
    </method>
    <method name="getLocalCache" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cache" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="baseDir" type="org.apache.hadoop.fs.Path"/>
      <param name="isArchive" type="boolean"/>
      <param name="confFileStamp" type="long"/>
      <param name="currentWorkDir" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the locally cached file or archive; it could either be 
 previously cached (and valid) or copy it from the {@link FileSystem} now.
 
 @param cache the cache to be localized, this should be specified as 
 new URI(hdfs://hostname:port/absolute_path_to_file#LINKNAME). If no schema 
 or hostname:port is provided the file is assumed to be in the filesystem
 being used in the Configuration
 @param conf The Confguration file which contains the filesystem
 @param baseDir The base cache Dir where you wnat to localize the files/archives
 @param isArchive if the cache is an archive or a file. In case it is an 
  archive with a .zip or .jar or .tar or .tgz or .tar.gz extension it will 
  be unzipped/unjarred/untarred automatically 
  and the directory where the archive is unzipped/unjarred/untarred 
  is returned as the Path.
  In case of a file, the path to the file is returned
 @param confFileStamp this is the hdfs file modification timestamp to verify that the 
 file to be cached hasn't changed since the job started
 @param currentWorkDir this is the directory where you would want to create symlinks 
 for the locally cached files/archives
 @return the path to directory where the archives are unjarred in case of archives,
 the path to the file where the file is copied locally 
 @throws IOException]]>
      </doc>
    </method>
    <method name="releaseCache"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cache" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This is the opposite of getlocalcache. When you are done with
 using the cache, you need to release the cache
 @param cache The cache URI to be released
 @param conf configuration which contains the filesystem the cache 
 is contained in.
 @throws IOException]]>
      </doc>
    </method>
    <method name="makeRelative" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cache" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getTimestamp" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="cache" type="java.net.URI"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns mtime of a given cache file on hdfs.
 @param conf configuration
 @param cache cache file 
 @return mtime of a given cache file on hdfs
 @throws IOException]]>
      </doc>
    </method>
    <method name="createAllSymlink"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="jobCacheDir" type="java.io.File"/>
      <param name="workDir" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This method create symlinks for all files in a given dir in another directory
 @param conf the configuration
 @param jobCacheDir the target directory for creating symlinks
 @param workDir the directory in which the symlinks are created
 @throws IOException]]>
      </doc>
    </method>
    <method name="setCacheArchives"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="archives" type="java.net.URI[]"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Set the configuration with the given set of archives
 @param archives The list of archives that need to be localized
 @param conf Configuration which will be changed]]>
      </doc>
    </method>
    <method name="setCacheFiles"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="files" type="java.net.URI[]"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Set the configuration with the given set of files
 @param files The list of files that need to be localized
 @param conf Configuration which will be changed]]>
      </doc>
    </method>
    <method name="getCacheArchives" return="java.net.URI[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get cache archives set in the Configuration
 @param conf The configuration which contains the archives
 @return A URI array of the caches set in the Configuration
 @throws IOException]]>
      </doc>
    </method>
    <method name="getCacheFiles" return="java.net.URI[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get cache files set in the Configuration
 @param conf The configuration which contains the files
 @return A URI array of the files set in the Configuration
 @throws IOException]]>
      </doc>
    </method>
    <method name="getLocalCacheArchives" return="org.apache.hadoop.fs.Path[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the path array of the localized caches
 @param conf Configuration that contains the localized archives
 @return A path array of localized caches
 @throws IOException]]>
      </doc>
    </method>
    <method name="getLocalCacheFiles" return="org.apache.hadoop.fs.Path[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the path array of the localized files
 @param conf Configuration that contains the localized files
 @return A path array of localized files
 @throws IOException]]>
      </doc>
    </method>
    <method name="getArchiveTimestamps" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the timestamps of the archives
 @param conf The configuration which stored the timestamps
 @return a string array of timestamps 
 @throws IOException]]>
      </doc>
    </method>
    <method name="getFileTimestamps" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the timestamps of the files
 @param conf The configuration which stored the timestamps
 @return a string array of timestamps 
 @throws IOException]]>
      </doc>
    </method>
    <method name="setArchiveTimestamps"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="timestamps" type="java.lang.String"/>
      <doc>
      <![CDATA[This is to check the timestamp of the archives to be localized
 @param conf Configuration which stores the timestamp's
 @param timestamps comma separated list of timestamps of archives.
 The order should be the same as the order in which the archives are added.]]>
      </doc>
    </method>
    <method name="setFileTimestamps"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="timestamps" type="java.lang.String"/>
      <doc>
      <![CDATA[This is to check the timestamp of the files to be localized
 @param conf Configuration which stores the timestamp's
 @param timestamps comma separated list of timestamps of files.
 The order should be the same as the order in which the files are added.]]>
      </doc>
    </method>
    <method name="setLocalArchives"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="str" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the conf to contain the location for localized archives 
 @param conf The conf to modify to contain the localized caches
 @param str a comma separated list of local archives]]>
      </doc>
    </method>
    <method name="setLocalFiles"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="str" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the conf to contain the location for localized files 
 @param conf The conf to modify to contain the localized caches
 @param str a comma separated list of local files]]>
      </doc>
    </method>
    <method name="addCacheArchive"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Add a archives to be localized to the conf
 @param uri The uri of the cache to be localized
 @param conf Configuration to add the cache to]]>
      </doc>
    </method>
    <method name="addCacheFile"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Add a file to be localized to the conf
 @param uri The uri of the cache to be localized
 @param conf Configuration to add the cache to]]>
      </doc>
    </method>
    <method name="addFileToClassPath"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Add an file path to the current set of classpath entries It adds the file
 to cache as well.
 
 @param file Path of the file to be added
 @param conf Configuration that contains the classpath setting]]>
      </doc>
    </method>
    <method name="getFileClassPaths" return="org.apache.hadoop.fs.Path[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the file entries in classpath as an array of Path
 
 @param conf Configuration that contains the classpath setting]]>
      </doc>
    </method>
    <method name="addArchiveToClassPath"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="archive" type="org.apache.hadoop.fs.Path"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Add an archive path to the current set of classpath entries. It adds the
 archive to cache as well.
 
 @param archive Path of the archive to be added
 @param conf Configuration that contains the classpath setting]]>
      </doc>
    </method>
    <method name="getArchiveClassPaths" return="org.apache.hadoop.fs.Path[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the archive entries in classpath as an array of Path
 
 @param conf Configuration that contains the classpath setting]]>
      </doc>
    </method>
    <method name="createSymlink"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[This method allows you to create symlinks in the current working directory
 of the task to all the cache files/archives
 @param conf the jobconf]]>
      </doc>
    </method>
    <method name="getSymlink" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[This method checks to see if symlinks are to be create for the 
 localized cache files in the current working directory 
 @param conf the jobconf
 @return true if symlinks are to be created- else return false]]>
      </doc>
    </method>
    <method name="checkURIs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uriFiles" type="java.net.URI[]"/>
      <param name="uriArchives" type="java.net.URI[]"/>
      <doc>
      <![CDATA[This method checks if there is a conflict in the fragment names 
 of the uris. Also makes sure that each uri has a fragment. It 
 is only to be called if you want to create symlinks for 
 the various archives and files.
 @param uriFiles The uri array of urifiles
 @param uriArchives the uri array of uri archives]]>
      </doc>
    </method>
    <method name="purgeCache"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Clear the entire contents of the cache and delete the backing files. This
 should only be used when the server is reinitializing, because the users
 are going to lose their files.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Distribute application-specific large, read-only files efficiently.
 
 <p><code>DistributedCache</code> is a facility provided by the Map-Reduce
 framework to cache files (text, archives, jars etc.) needed by applications.
 </p>
 
 <p>Applications specify the files, via urls (hdfs:// or http://) to be cached 
 via the {@link org.apache.hadoop.mapred.JobConf}.
 The <code>DistributedCache</code> assumes that the
 files specified via hdfs:// urls are already present on the 
 {@link FileSystem} at the path specified by the url.</p>
 
 <p>The framework will copy the necessary files on to the slave node before 
 any tasks for the job are executed on that node. Its efficiency stems from 
 the fact that the files are only copied once per job and the ability to 
 cache archives which are un-archived on the slaves.</p> 

 <p><code>DistributedCache</code> can be used to distribute simple, read-only
 data/text files and/or more complex types such as archives, jars etc. 
 Archives (zip, tar and tgz/tar.gz files) are un-archived at the slave nodes. 
 Jars may be optionally added to the classpath of the tasks, a rudimentary 
 software distribution mechanism.  Files have execution permissions.
 Optionally users can also direct it to symlink the distributed cache file(s)
 into the working directory of the task.</p>
 
 <p><code>DistributedCache</code> tracks modification timestamps of the cache 
 files. Clearly the cache files should not be modified by the application 
 or externally while the job is executing.</p>
 
 <p>Here is an illustrative example on how to use the 
 <code>DistributedCache</code>:</p>
 <p><blockquote><pre>
     // Setting up the cache for the application
     
     1. Copy the requisite files to the <code>FileSystem</code>:
     
     $ bin/hadoop fs -copyFromLocal lookup.dat /myapp/lookup.dat  
     $ bin/hadoop fs -copyFromLocal map.zip /myapp/map.zip  
     $ bin/hadoop fs -copyFromLocal mylib.jar /myapp/mylib.jar
     $ bin/hadoop fs -copyFromLocal mytar.tar /myapp/mytar.tar
     $ bin/hadoop fs -copyFromLocal mytgz.tgz /myapp/mytgz.tgz
     $ bin/hadoop fs -copyFromLocal mytargz.tar.gz /myapp/mytargz.tar.gz
     
     2. Setup the application's <code>JobConf</code>:
     
     JobConf job = new JobConf();
     DistributedCache.addCacheFile(new URI("/myapp/lookup.dat#lookup.dat"), 
                                   job);
     DistributedCache.addCacheArchive(new URI("/myapp/map.zip", job);
     DistributedCache.addFileToClassPath(new Path("/myapp/mylib.jar"), job);
     DistributedCache.addCacheArchive(new URI("/myapp/mytar.tar", job);
     DistributedCache.addCacheArchive(new URI("/myapp/mytgz.tgz", job);
     DistributedCache.addCacheArchive(new URI("/myapp/mytargz.tar.gz", job);
     
     3. Use the cached files in the {@link org.apache.hadoop.mapred.Mapper}
     or {@link org.apache.hadoop.mapred.Reducer}:
     
     public static class MapClass extends MapReduceBase  
     implements Mapper&lt;K, V, K, V&gt; {
     
       private Path[] localArchives;
       private Path[] localFiles;
       
       public void configure(JobConf job) {
         // Get the cached archives/files
         localArchives = DistributedCache.getLocalCacheArchives(job);
         localFiles = DistributedCache.getLocalCacheFiles(job);
       }
       
       public void map(K key, V value, 
                       OutputCollector&lt;K, V&gt; output, Reporter reporter) 
       throws IOException {
         // Use data from the cached archives/files here
         // ...
         // ...
         output.collect(k, v);
       }
     }
     
 </pre></blockquote></p>
 
 @see org.apache.hadoop.mapred.JobConf
 @see org.apache.hadoop.mapred.JobClient]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.filecache.DistributedCache -->
</package>
<package name="org.apache.hadoop.fs">
  <!-- start class org.apache.hadoop.fs.BlockLocation -->
  <class name="BlockLocation" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="BlockLocation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default Constructor]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with host, name, offset and length]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], java.lang.String[], long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with host, name, network topology, offset and length]]>
      </doc>
    </constructor>
    <method name="getHosts" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the list of hosts (hostname) hosting this block]]>
      </doc>
    </method>
    <method name="getNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the list of names (hostname:port) hosting this block]]>
      </doc>
    </method>
    <method name="getTopologyPaths" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the list of network topology paths for each of the hosts.
 The last component of the path is the host.]]>
      </doc>
    </method>
    <method name="getOffset" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the start offset of file associated with this block]]>
      </doc>
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the length of the block]]>
      </doc>
    </method>
    <method name="setOffset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="offset" type="long"/>
      <doc>
      <![CDATA[Set the start offset of file associated with this block]]>
      </doc>
    </method>
    <method name="setLength"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="length" type="long"/>
      <doc>
      <![CDATA[Set the length of block]]>
      </doc>
    </method>
    <method name="setHosts"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hosts" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the hosts hosting this block]]>
      </doc>
    </method>
    <method name="setNames"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the names (host:port) hosting this block]]>
      </doc>
    </method>
    <method name="setTopologyPaths"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="topologyPaths" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the network topology paths of the hosts]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Implement write of Writable]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Implement readFields of Writable]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.fs.BlockLocation -->
  <!-- start class org.apache.hadoop.fs.BufferedFSInputStream -->
  <class name="BufferedFSInputStream" extends="java.io.BufferedInputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.Seekable"/>
    <implements name="org.apache.hadoop.fs.PositionedReadable"/>
    <constructor name="BufferedFSInputStream" type="org.apache.hadoop.fs.FSInputStream, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a <code>BufferedFSInputStream</code>
 with the specified buffer size,
 and saves its  argument, the input stream
 <code>in</code>, for later use.  An internal
 buffer array of length  <code>size</code>
 is created and stored in <code>buf</code>.

 @param   in     the underlying input stream.
 @param   size   the buffer size.
 @exception IllegalArgumentException if size <= 0.]]>
      </doc>
    </constructor>
    <method name="getPos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="seek"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="seekToNewSource" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetPos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A class optimizes reading from FSInputStream by bufferring]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.BufferedFSInputStream -->
  <!-- start class org.apache.hadoop.fs.ChecksumException -->
  <class name="ChecksumException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ChecksumException" type="java.lang.String, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown for checksum errors.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ChecksumException -->
  <!-- start class org.apache.hadoop.fs.ChecksumFileSystem -->
  <class name="ChecksumFileSystem" extends="org.apache.hadoop.fs.FilterFileSystem"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ChecksumFileSystem" type="org.apache.hadoop.fs.FileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getApproxChkSumLength" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="long"/>
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="setVerifyChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="verifyChecksum" type="boolean"/>
      <doc>
      <![CDATA[Set whether to verify checksum.]]>
      </doc>
    </method>
    <method name="getRawFileSystem" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the raw file system]]>
      </doc>
    </method>
    <method name="getChecksumFile" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Return the name of the checksum file associated with a file.]]>
      </doc>
    </method>
    <method name="isChecksumFile" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Return true iff file is a checksum file name.]]>
      </doc>
    </method>
    <method name="getChecksumFileLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="fileSize" type="long"/>
      <doc>
      <![CDATA[Return the length of the checksum file given the size of the 
 actual file.]]>
      </doc>
    </method>
    <method name="getBytesPerSum" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the bytes Per Checksum]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataInputStream at the indicated Path.
 @param f the file name to open
 @param bufferSize the size of the buffer to be used.]]>
      </doc>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="getChecksumLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="long"/>
      <param name="bytesPerSum" type="int"/>
      <doc>
      <![CDATA[Calculated the length of the checksum file in bytes.
 @param size the length of the data file in bytes
 @param bytesPerSum the number of bytes in a checksum block
 @return the number of bytes in the checksum file]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="setReplication" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set replication for an existing file.
 Implement the abstract <tt>setReplication</tt> of <tt>FileSystem</tt>
 @param src file name
 @param replication new replication
 @throws IOException
 @return true if successful;
         false if file does not exist or is a directory]]>
      </doc>
    </method>
    <method name="rename" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Rename files/dirs]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Implement the delete(Path, boolean) in checksum
 file system.]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses of the files/directories in the given path if the path is
 a directory.
 
 @param f
          given path
 @return the statuses of the files/directories in the given patch
 @throws IOException]]>
      </doc>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under FS, and the dst is on the local disk.
 Copy it from FS control to the local dst name.]]>
      </doc>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="copyCrc" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under FS, and the dst is on the local disk.
 Copy it from FS control to the local dst name.
 If src and dst are directories, the copyCrc parameter
 determines whether to copy CRC files.]]>
      </doc>
    </method>
    <method name="startLocalOutput" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="completeLocalOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="reportChecksumFailure" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="in" type="org.apache.hadoop.fs.FSDataInputStream"/>
      <param name="inPos" type="long"/>
      <param name="sums" type="org.apache.hadoop.fs.FSDataInputStream"/>
      <param name="sumsPos" type="long"/>
      <doc>
      <![CDATA[Report a checksum error to the file system.
 @param f the file name containing the error
 @param in the stream open on the file
 @param inPos the position of the beginning of the bad data in the file
 @param sums the stream open on the checksum file
 @param sumsPos the position of the beginning of the bad data in the checksum file
 @return if retry is neccessary]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstract Checksumed FileSystem.
 It provide a basice implementation of a Checksumed FileSystem,
 which creates a checksum file for each raw file.
 It generates & verifies checksums at the client side.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ChecksumFileSystem -->
  <!-- start class org.apache.hadoop.fs.ContentSummary -->
  <class name="ContentSummary" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="ContentSummary"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor]]>
      </doc>
    </constructor>
    <constructor name="ContentSummary" type="long, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor]]>
      </doc>
    </constructor>
    <constructor name="ContentSummary" type="long, long, long, long, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor]]>
      </doc>
    </constructor>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the length]]>
      </doc>
    </method>
    <method name="getDirectoryCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the directory count]]>
      </doc>
    </method>
    <method name="getFileCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the file count]]>
      </doc>
    </method>
    <method name="getQuota" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the directory quota]]>
      </doc>
    </method>
    <method name="getSpaceConsumed" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retuns (disk) space consumed]]>
      </doc>
    </method>
    <method name="getSpaceQuota" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns (disk) space quota]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="getHeader" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="qOption" type="boolean"/>
      <doc>
      <![CDATA[Return the header of the output.
 if qOption is false, output directory count, file count, and content size;
 if qOption is true, output quota and remaining quota as well.
 
 @param qOption a flag indicating if quota needs to be printed or not
 @return the header of the output]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="qOption" type="boolean"/>
      <doc>
      <![CDATA[Return the string representation of the object in the output format.
 if qOption is false, output directory count, file count, and content size;
 if qOption is true, output quota and remaining quota as well.
 
 @param qOption a flag indicating if quota needs to be printed or not
 @return the string representation of the object]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Store the summary of a content (a directory or a file).]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ContentSummary -->
  <!-- start class org.apache.hadoop.fs.DF -->
  <class name="DF" extends="org.apache.hadoop.util.Shell"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DF" type="java.io.File, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="DF" type="java.io.File, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="getDirPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFilesystem" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCapacity" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getUsed" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getAvailable" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getPercentUsed" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getMount" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getExecString" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="parseExecResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="lines" type="java.io.BufferedReader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <field name="DF_INTERVAL_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Filesystem disk space usage statistics.  Uses the unix 'df' program.
 Tested on Linux, FreeBSD, Cygwin.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.DF -->
  <!-- start class org.apache.hadoop.fs.DU -->
  <class name="DU" extends="org.apache.hadoop.util.Shell"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DU" type="java.io.File, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Keeps track of disk usage.
 @param path the path to check disk usage in
 @param interval refresh the disk usage at this interval
 @throws IOException if we fail to refresh the disk usage]]>
      </doc>
    </constructor>
    <constructor name="DU" type="java.io.File, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Keeps track of disk usage.
 @param path the path to check disk usage in
 @param conf configuration object
 @throws IOException if we fail to refresh the disk usage]]>
      </doc>
    </constructor>
    <method name="decDfsUsed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Decrease how much disk space we use.
 @param value decrease by this value]]>
      </doc>
    </method>
    <method name="incDfsUsed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Increase how much disk space we use.
 @param value increase by this value]]>
      </doc>
    </method>
    <method name="getUsed" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@return disk space used 
 @throws IOException if the shell command fails]]>
      </doc>
    </method>
    <method name="getDirPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the path of which we're keeping track of disk usage]]>
      </doc>
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Start the disk usage checking thread.]]>
      </doc>
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shut down the refreshing thread.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getExecString" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="parseExecResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="lines" type="java.io.BufferedReader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[Filesystem disk space usage statistics.  Uses the unix 'du' program]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.DU -->
  <!-- start class org.apache.hadoop.fs.FileChecksum -->
  <class name="FileChecksum" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="FileChecksum"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAlgorithmName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The checksum algorithm name]]>
      </doc>
    </method>
    <method name="getLength" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The length of the checksum in bytes]]>
      </doc>
    </method>
    <method name="getBytes" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The value of the checksum in bytes]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
      <doc>
      <![CDATA[Return true if both the algorithms and the values are the same.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An abstract class representing file checksums for files.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileChecksum -->
  <!-- start class org.apache.hadoop.fs.FileStatus -->
  <class name="FileStatus" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <implements name="java.lang.Comparable"/>
    <constructor name="FileStatus"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FileStatus" type="long, boolean, int, long, long, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FileStatus" type="long, boolean, int, long, long, long, org.apache.hadoop.fs.permission.FsPermission, java.lang.String, java.lang.String, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLen" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isDir" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Is this a directory?
 @return true if this is a directory]]>
      </doc>
    </method>
    <method name="getBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the block size of the file.
 @return the number of bytes]]>
      </doc>
    </method>
    <method name="getReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the replication factor of a file.
 @return the replication factor of a file.]]>
      </doc>
    </method>
    <method name="getModificationTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the modification time of the file.
 @return the modification time of file in milliseconds since January 1, 1970 UTC.]]>
      </doc>
    </method>
    <method name="getAccessTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the access time of the file.
 @return the access time of file in milliseconds since January 1, 1970 UTC.]]>
      </doc>
    </method>
    <method name="getPermission" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get FsPermission associated with the file.
 @return permssion. If a filesystem does not have a notion of permissions
         or if permissions could not be determined, then default 
         permissions equivalent of "rwxrwxrwx" is returned.]]>
      </doc>
    </method>
    <method name="getOwner" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the owner of the file.
 @return owner of the file. The string could be empty if there is no
         notion of owner of a file in a filesystem or if it could not 
         be determined (rare).]]>
      </doc>
    </method>
    <method name="getGroup" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the group associated with the file.
 @return group for the file. The string could be empty if there is no
         notion of group of a file in a filesystem or if it could not 
         be determined (rare).]]>
      </doc>
    </method>
    <method name="getPath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <doc>
      <![CDATA[Sets permission.
 @param permission if permission is null, default value is set]]>
      </doc>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="owner" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets owner.
 @param owner if it is null, default value is set]]>
      </doc>
    </method>
    <method name="setGroup"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="group" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets group.
 @param group if it is null, default value is set]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compare this object to another object
 
 @param   o the object to be compared.
 @return  a negative integer, zero, or a positive integer as this object
   is less than, equal to, or greater than the specified object.
 
 @throws ClassCastException if the specified object's is not of 
         type FileStatus]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compare if this object is equal to another object
 @param   o the object to be compared.
 @return  true if two file status has the same path name; false if not.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash code value for the object, which is defined as
 the hash code of the path name.

 @return  a hash code value for the path name.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface that represents the client side information for a file.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileStatus -->
  <!-- start class org.apache.hadoop.fs.FileSystem -->
  <class name="FileSystem" extends="org.apache.hadoop.conf.Configured"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="FileSystem"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the configured filesystem implementation.]]>
      </doc>
    </method>
    <method name="getDefaultUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the default filesystem URI from a configuration.
 @param conf the configuration to access
 @return the uri of the default filesystem]]>
      </doc>
    </method>
    <method name="setDefaultUri"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Set the default filesystem URI in a configuration.
 @param conf the configuration to alter
 @param uri the new default filesystem uri]]>
      </doc>
    </method>
    <method name="setDefaultUri"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the default filesystem URI in a configuration.
 @param conf the configuration to alter
 @param uri the new default filesystem uri]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Called after a new FileSystem instance is constructed.
 @param name a uri whose authority section names the host, port, etc.
   for this FileSystem
 @param conf the configuration]]>
      </doc>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a URI whose scheme and authority identify this FileSystem.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="call #getUri() instead.">
      <doc>
      <![CDATA[@deprecated call #getUri() instead.]]>
      </doc>
    </method>
    <method name="getNamed" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="call #get(URI,Configuration) instead.">
      <param name="name" type="java.lang.String"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@deprecated call #get(URI,Configuration) instead.]]>
      </doc>
    </method>
    <method name="getLocal" return="org.apache.hadoop.fs.LocalFileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the local file syste
 @param conf the configuration to configure the file system with
 @return a LocalFileSystem]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the FileSystem for this URI's scheme and authority.  The scheme
 of the URI determines a configuration property name,
 <tt>fs.<i>scheme</i>.class</tt> whose value names the FileSystem class.
 The entire URI is passed to the FileSystem instance's initialize method.]]>
      </doc>
    </method>
    <method name="closeAll"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close all cached filesystems. Be sure those filesystems are not
 used anymore.
 
 @throws IOException]]>
      </doc>
    </method>
    <method name="makeQualified" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Make sure that a path specifies a FileSystem.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[create a file with the provided permission
 The permission of the file is set to be the provided permission as in
 setPermission, not permission&~umask
 
 It is implemented using two RPCs. It is understood that it is inefficient,
 but the implementation is thread-safe. The other option is to change the
 value of umask in configuration to be 0, but it is not thread-safe.
 
 @param fs file system handle
 @param file the name of the file to be created
 @param permission the permission of the file
 @return an output stream
 @throws IOException]]>
      </doc>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dir" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[create a directory with the provided permission
 The permission of the directory is set to be the provided permission as in
 setPermission, not permission&~umask
 
 @see #create(FileSystem, Path, FsPermission)
 
 @param fs file system handle
 @param dir the name of the directory to be created
 @param permission the permission of the directory
 @return true if the directory creation succeeds; false otherwise
 @throws IOException]]>
      </doc>
    </method>
    <method name="checkPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Check that a Path belongs to this FileSystem.]]>
      </doc>
    </method>
    <method name="getFileBlockLocations" return="org.apache.hadoop.fs.BlockLocation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.FileStatus"/>
      <param name="start" type="long"/>
      <param name="len" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return an array containing hostnames, offset and size of 
 portions of the given file.  For a nonexistent 
 file or regions, null will be returned.

 This call is most helpful with DFS, where it returns 
 hostnames of machines that contain the given file.

 The FileSystem will simply return an elt containing 'localhost'.]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataInputStream at the indicated Path.
 @param f the file name to open
 @param bufferSize the size of the buffer to be used.]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataInputStream at the indicated Path.
 @param f the file to open]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataOutputStream at the indicated Path.
 Files are overwritten by default.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataOutputStream at the indicated Path.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path with write-progress
 reporting.
 Files are overwritten by default.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataOutputStream at the indicated Path.
 Files are overwritten by default.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataOutputStream at the indicated Path with write-progress
 reporting.
 Files are overwritten by default.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataOutputStream at the indicated Path.
 @param f the file name to open
 @param overwrite if a file with this name already exists, then if true,
   the file will be overwritten, and if false an error will be thrown.
 @param bufferSize the size of the buffer to be used.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataOutputStream at the indicated Path with write-progress
 reporting.
 @param f the file name to open
 @param overwrite if a file with this name already exists, then if true,
   the file will be overwritten, and if false an error will be thrown.
 @param bufferSize the size of the buffer to be used.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataOutputStream at the indicated Path.
 @param f the file name to open
 @param overwrite if a file with this name already exists, then if true,
   the file will be overwritten, and if false an error will be thrown.
 @param bufferSize the size of the buffer to be used.
 @param replication required block replication for the file.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataOutputStream at the indicated Path with write-progress
 reporting.
 @param f the file name to open
 @param overwrite if a file with this name already exists, then if true,
   the file will be overwritten, and if false an error will be thrown.
 @param bufferSize the size of the buffer to be used.
 @param replication required block replication for the file.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataOutputStream at the indicated Path with write-progress
 reporting.
 @param f the file name to open
 @param permission
 @param overwrite if a file with this name already exists, then if true,
   the file will be overwritten, and if false an error will be thrown.
 @param bufferSize the size of the buffer to be used.
 @param replication required block replication for the file.
 @param blockSize
 @param progress
 @throws IOException
 @see #setPermission(Path, FsPermission)]]>
      </doc>
    </method>
    <method name="createNewFile" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates the given Path as a brand-new zero-length file.  If
 create fails, or if it already existed, return false.]]>
      </doc>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Append to an existing file (optional operation).
 Same as append(f, getConf().getInt("io.file.buffer.size", 4096), null)
 @param f the existing file to be appended.
 @throws IOException]]>
      </doc>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Append to an existing file (optional operation).
 Same as append(f, bufferSize, null).
 @param f the existing file to be appended.
 @param bufferSize the size of the buffer to be used.
 @throws IOException]]>
      </doc>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Append to an existing file (optional operation).
 @param f the existing file to be appended.
 @param bufferSize the size of the buffer to be used.
 @param progress for reporting progress if it is not null.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use getFileStatus() instead">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get replication.
 
 @deprecated Use getFileStatus() instead
 @param src file name
 @return file replication
 @throws IOException]]>
      </doc>
    </method>
    <method name="setReplication" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set replication for an existing file.
 
 @param src file name
 @param replication new replication
 @throws IOException
 @return true if successful;
         false if file does not exist or is a directory]]>
      </doc>
    </method>
    <method name="rename" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Renames Path src to Path dst.  Can take place on local fs
 or remote DFS.]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use delete(Path, boolean) instead">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@deprecated Use delete(Path, boolean) instead]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete a file.

 @param f the path to delete.
 @param recursive if path is a directory and set to 
 true, the directory is deleted else throws an exception. In
 case of a file the recursive can be set to either true or false. 
 @return  true if delete is successful else false. 
 @throws IOException]]>
      </doc>
    </method>
    <method name="deleteOnExit" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Mark a path to be deleted when FileSystem is closed.
 When the JVM shuts down,
 all FileSystem objects will be closed automatically.
 Then,
 the marked path will be deleted as a result of closing the FileSystem.

 The path has to exist in the file system.
 
 @param f the path to delete.
 @return  true if deleteOnExit is successful, otherwise false.
 @throws IOException]]>
      </doc>
    </method>
    <method name="processDeleteOnExit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Delete all files that were marked as delete-on-exit. This recursively
 deletes all files in the specified paths.]]>
      </doc>
    </method>
    <method name="exists" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Check if exists.
 @param f source file]]>
      </doc>
    </method>
    <method name="isDirectory" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use getFileStatus() instead">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@deprecated Use getFileStatus() instead]]>
      </doc>
    </method>
    <method name="isFile" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[True iff the named path is a regular file.]]>
      </doc>
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use getFileStatus() instead">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@deprecated Use getFileStatus() instead]]>
      </doc>
    </method>
    <method name="getContentSummary" return="org.apache.hadoop.fs.ContentSummary"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the {@link ContentSummary} of a given {@link Path}.]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses of the files/directories in the given path if the path is
 a directory.
 
 @param f
          given path
 @return the statuses of the files/directories in the given patch
 @throws IOException]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="filter" type="org.apache.hadoop.fs.PathFilter"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Filter files/directories in the given path using the user-supplied path
 filter.
 
 @param f
          a path name
 @param filter
          the user-supplied path filter
 @return an array of FileStatus objects for the files under the given path
         after applying the filter
 @throws IOException
           if encounter any problem while fetching the status]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="files" type="org.apache.hadoop.fs.Path[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Filter files/directories in the given list of paths using default
 path filter.
 
 @param files
          a list of paths
 @return a list of statuses for the files under the given paths after
         applying the filter default Path filter
 @exception IOException]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="files" type="org.apache.hadoop.fs.Path[]"/>
      <param name="filter" type="org.apache.hadoop.fs.PathFilter"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Filter files/directories in the given list of paths using user-supplied
 path filter.
 
 @param files
          a list of paths
 @param filter
          the user-supplied path filter
 @return a list of statuses for the files under the given paths after
         applying the filter
 @exception IOException]]>
      </doc>
    </method>
    <method name="globStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pathPattern" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Return all the files that match filePattern and are not checksum
 files. Results are sorted by their names.
 
 <p>
 A filename pattern is composed of <i>regular</i> characters and
 <i>special pattern matching</i> characters, which are:

 <dl>
  <dd>
   <dl>
    <p>
    <dt> <tt> ? </tt>
    <dd> Matches any single character.

    <p>
    <dt> <tt> * </tt>
    <dd> Matches zero or more characters.

    <p>
    <dt> <tt> [<i>abc</i>] </tt>
    <dd> Matches a single character from character set
     <tt>{<i>a,b,c</i>}</tt>.

    <p>
    <dt> <tt> [<i>a</i>-<i>b</i>] </tt>
    <dd> Matches a single character from the character range
     <tt>{<i>a...b</i>}</tt>.  Note that character <tt><i>a</i></tt> must be
     lexicographically less than or equal to character <tt><i>b</i></tt>.

    <p>
    <dt> <tt> [^<i>a</i>] </tt>
    <dd> Matches a single character that is not from character set or range
     <tt>{<i>a</i>}</tt>.  Note that the <tt>^</tt> character must occur
     immediately to the right of the opening bracket.

    <p>
    <dt> <tt> \<i>c</i> </tt>
    <dd> Removes (escapes) any special meaning of character <i>c</i>.

    <p>
    <dt> <tt> {ab,cd} </tt>
    <dd> Matches a string from the string set <tt>{<i>ab, cd</i>} </tt>
    
    <p>
    <dt> <tt> {ab,c{de,fh}} </tt>
    <dd> Matches a string from the string set <tt>{<i>ab, cde, cfh</i>}</tt>

   </dl>
  </dd>
 </dl>

 @param pathPattern a regular expression specifying a pth pattern

 @return an array of paths that match the path pattern
 @throws IOException]]>
      </doc>
    </method>
    <method name="globStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pathPattern" type="org.apache.hadoop.fs.Path"/>
      <param name="filter" type="org.apache.hadoop.fs.PathFilter"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return an array of FileStatus objects whose path names match pathPattern
 and is accepted by the user-supplied path filter. Results are sorted by
 their path names.
 Return null if pathPattern has no glob and the path does not exist.
 Return an empty array if pathPattern has a glob and no path matches it. 
 
 @param pathPattern
          a regular expression specifying the path pattern
 @param filter
          a user-supplied path filter
 @return an array of FileStatus objects
 @throws IOException if any I/O error occurs when fetching file status]]>
      </doc>
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the current user's home directory in this filesystem.
 The default implementation returns "/user/$USER/".]]>
      </doc>
    </method>
    <method name="setWorkingDirectory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="new_dir" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Set the current working directory for the given file system. All relative
 paths will be resolved relative to it.
 
 @param new_dir]]>
      </doc>
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current working directory for the given file system
 @return the directory pathname]]>
      </doc>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Call {@link #mkdirs(Path, FsPermission)} with default permission.]]>
      </doc>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Make the given file and all non-existent parents into
 directories. Has the semantics of Unix 'mkdir -p'.
 Existence of the directory hierarchy is not an error.]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is on the local disk.  Add it to FS at
 the given dst name and the source is kept intact afterwards]]>
      </doc>
    </method>
    <method name="moveFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcs" type="org.apache.hadoop.fs.Path[]"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src files is on the local disk.  Add it to FS at
 the given dst name, removing the source afterwards.]]>
      </doc>
    </method>
    <method name="moveFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is on the local disk.  Add it to FS at
 the given dst name, removing the source afterwards.]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is on the local disk.  Add it to FS at
 the given dst name.
 delSrc indicates if the source should be removed]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <param name="srcs" type="org.apache.hadoop.fs.Path[]"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src files are on the local disk.  Add it to FS at
 the given dst name.
 delSrc indicates if the source should be removed]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is on the local disk.  Add it to FS at
 the given dst name.
 delSrc indicates if the source should be removed]]>
      </doc>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under FS, and the dst is on the local disk.
 Copy it from FS control to the local dst name.]]>
      </doc>
    </method>
    <method name="moveToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under FS, and the dst is on the local disk.
 Copy it from FS control to the local dst name.
 Remove the source afterwards]]>
      </doc>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under FS, and the dst is on the local disk.
 Copy it from FS control to the local dst name.
 delSrc indicates if the src will be removed or not.]]>
      </doc>
    </method>
    <method name="startLocalOutput" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a local File that the user can write output to.  The caller
 provides both the eventual FS target name and the local working
 file.  If the FS is local, we write directly into the target.  If
 the FS is remote, we write into the tmp local area.]]>
      </doc>
    </method>
    <method name="completeLocalOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Called when we're all done writing to the target.  A local FS will
 do nothing, because we've written to exactly the right place.  A remote
 FS will copy the contents of tmpLocalFile to the correct target at
 fsOutputFile.]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[No more filesystem operations are needed.  Will
 release any held locks.]]>
      </doc>
    </method>
    <method name="getUsed" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the total size of all files in the filesystem.]]>
      </doc>
    </method>
    <method name="getBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use getFileStatus() instead">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@deprecated Use getFileStatus() instead]]>
      </doc>
    </method>
    <method name="getDefaultBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the number of bytes that large input files should be optimally
 be split into to minimize i/o time.]]>
      </doc>
    </method>
    <method name="getDefaultReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the default replication.]]>
      </doc>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a file status object that represents the path.
 @param f The path we want information from
 @return a FileStatus object
 @throws FileNotFoundException when the path does not exist;
         IOException see specific implementation]]>
      </doc>
    </method>
    <method name="getFileChecksum" return="org.apache.hadoop.fs.FileChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the checksum of a file.

 @param f The file path
 @return The file checksum.  The default return value is null,
  which indicates that no checksum algorithm is implemented
  in the corresponding FileSystem.]]>
      </doc>
    </method>
    <method name="setVerifyChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="verifyChecksum" type="boolean"/>
      <doc>
      <![CDATA[Set the verify checksum flag. This is only applicable if the 
 corresponding FileSystem supports checksum. By default doesn't do anything.
 @param verifyChecksum]]>
      </doc>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set permission of a path.
 @param p
 @param permission]]>
      </doc>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set owner of a path (i.e. a file or a directory).
 The parameters username and groupname cannot both be null.
 @param p The path
 @param username If it is null, the original username remains unchanged.
 @param groupname If it is null, the original groupname remains unchanged.]]>
      </doc>
    </method>
    <method name="setTimes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="mtime" type="long"/>
      <param name="atime" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set access time of a file
 @param p The path
 @param mtime Set the modification time of this file.
              The number of milliseconds since Jan 1, 1970. 
              A value of -1 means that this call should not set modification time.
 @param atime Set the access time of this file.
              The number of milliseconds since Jan 1, 1970. 
              A value of -1 means that this call should not set access time.]]>
      </doc>
    </method>
    <method name="getStatistics" return="java.util.Map"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="use {@link #getAllStatistics} instead">
      <doc>
      <![CDATA[Get the Map of Statistics object indexed by URI Scheme.
 @return a Map having a key as URI scheme and value as Statistics object
 @deprecated use {@link #getAllStatistics} instead]]>
      </doc>
    </method>
    <method name="getAllStatistics" return="java.util.List"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the FileSystem classes that have Statistics]]>
      </doc>
    </method>
    <method name="getStatistics" return="org.apache.hadoop.fs.FileSystem.Statistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scheme" type="java.lang.String"/>
      <param name="cls" type="java.lang.Class"/>
      <doc>
      <![CDATA[Get the statistics for a particular file system
 @param cls the class to lookup
 @return a statistics object]]>
      </doc>
    </method>
    <method name="clearStatistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="printStatistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="statistics" type="org.apache.hadoop.fs.FileSystem.Statistics"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The statistics for this file system.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[An abstract base class for a fairly generic filesystem.  It
 may be implemented as a distributed filesystem, or as a "local"
 one that reflects the locally-connected disk.  The local version
 exists for small Hadoop instances and for testing.

 <p>

 All user code that may potentially use the Hadoop Distributed
 File System should be written to use a FileSystem object.  The
 Hadoop DFS is a multi-machine system that appears as a single
 disk.  It's useful because of its fault tolerance and potentially
 very large capacity.
 
 <p>
 The local implementation is {@link LocalFileSystem} and distributed
 implementation is DistributedFileSystem.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileSystem -->
  <!-- start class org.apache.hadoop.fs.FileSystem.Statistics -->
  <class name="FileSystem.Statistics" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="FileSystem.Statistics" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="incrementBytesRead"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newBytes" type="long"/>
      <doc>
      <![CDATA[Increment the bytes read in the statistics
 @param newBytes the additional bytes read]]>
      </doc>
    </method>
    <method name="incrementBytesWritten"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newBytes" type="long"/>
      <doc>
      <![CDATA[Increment the bytes written in the statistics
 @param newBytes the additional bytes written]]>
      </doc>
    </method>
    <method name="getBytesRead" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the total number of bytes read
 @return the number of bytes]]>
      </doc>
    </method>
    <method name="getBytesWritten" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the total number of bytes written
 @return the number of bytes]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reset the counts of bytes to 0.]]>
      </doc>
    </method>
    <method name="getScheme" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the uri scheme associated with this statistics object.
 @return the schema associated with this set of statistics]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.fs.FileSystem.Statistics -->
  <!-- start class org.apache.hadoop.fs.FileUtil -->
  <class name="FileUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FileUtil"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="stat2Paths" return="org.apache.hadoop.fs.Path[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stats" type="org.apache.hadoop.fs.FileStatus[]"/>
      <doc>
      <![CDATA[convert an array of FileStatus to an array of Path
 
 @param stats
          an array of FileStatus objects
 @return an array of paths corresponding to the input]]>
      </doc>
    </method>
    <method name="stat2Paths" return="org.apache.hadoop.fs.Path[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stats" type="org.apache.hadoop.fs.FileStatus[]"/>
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[convert an array of FileStatus to an array of Path.
 If stats if null, return path
 @param stats
          an array of FileStatus objects
 @param path
          default path to return in stats is null
 @return an array of paths corresponding to the input]]>
      </doc>
    </method>
    <method name="fullyDelete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete a directory and all its contents.  If
 we return false, the directory may be partially-deleted.]]>
      </doc>
    </method>
    <method name="fullyDelete"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link FileSystem#delete(Path, boolean)}">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dir" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Recursively delete a directory.
 
 @param fs {@link FileSystem} on which the path is present
 @param dir directory to recursively delete 
 @throws IOException
 @deprecated Use {@link FileSystem#delete(Path, boolean)}]]>
      </doc>
    </method>
    <method name="copy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dstFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteSource" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy files between FileSystems.]]>
      </doc>
    </method>
    <method name="copy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="srcs" type="org.apache.hadoop.fs.Path[]"/>
      <param name="dstFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteSource" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="copy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dstFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteSource" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy files between FileSystems.]]>
      </doc>
    </method>
    <method name="copyMerge" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="srcDir" type="org.apache.hadoop.fs.Path"/>
      <param name="dstFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dstFile" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteSource" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="addString" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy all files in a directory to one output file (merge).]]>
      </doc>
    </method>
    <method name="copy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="java.io.File"/>
      <param name="dstFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteSource" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy local files to a FileSystem.]]>
      </doc>
    </method>
    <method name="copy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="java.io.File"/>
      <param name="deleteSource" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy FileSystem files to local files.]]>
      </doc>
    </method>
    <method name="makeShellPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Convert a os-native filename to a path that works for the shell.
 @param filename The filename to convert
 @return The unix pathname
 @throws IOException on windows, there can be problems with the subprocess]]>
      </doc>
    </method>
    <method name="makeShellPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Convert a os-native filename to a path that works for the shell.
 @param file The filename to convert
 @return The unix pathname
 @throws IOException on windows, there can be problems with the subprocess]]>
      </doc>
    </method>
    <method name="makeShellPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="makeCanonicalPath" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Convert a os-native filename to a path that works for the shell.
 @param file The filename to convert
 @param makeCanonicalPath 
          Whether to make canonical path for the file passed
 @return The unix pathname
 @throws IOException on windows, there can be problems with the subprocess]]>
      </doc>
    </method>
    <method name="getDU" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <doc>
      <![CDATA[Takes an input dir and returns the du on that local directory. Very basic
 implementation.
 
 @param dir
          The input dir to get the disk space of this local dir
 @return The total disk space of the input local directory]]>
      </doc>
    </method>
    <method name="unZip"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inFile" type="java.io.File"/>
      <param name="unzipDir" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Given a File input it will unzip the file in a the unzip directory
 passed as the second parameter
 @param inFile The zip file as input
 @param unzipDir The unzip directory where to unzip the zip file.
 @throws IOException]]>
      </doc>
    </method>
    <method name="unTar"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inFile" type="java.io.File"/>
      <param name="untarDir" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Given a Tar File as input it will untar the file in a the untar directory
 passed as the second parameter
 
 This utility will untar ".tar" files and ".tar.gz","tgz" files.
  
 @param inFile The tar file as input. 
 @param untarDir The untar directory where to untar the tar file.
 @throws IOException]]>
      </doc>
    </method>
    <method name="symLink" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="java.lang.String"/>
      <param name="linkname" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a soft link between a src and destination
 only on a local disk. HDFS does not support this
 @param target the target for symlink 
 @param linkname the symlink
 @return value returned by the command]]>
      </doc>
    </method>
    <method name="chmod" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="java.lang.String"/>
      <param name="perm" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Change the permissions on a filename.
 @param filename the name of the file to change
 @param perm the permission string
 @return the exit code from the command
 @throws IOException
 @throws InterruptedException]]>
      </doc>
    </method>
    <method name="createLocalTempFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="basefile" type="java.io.File"/>
      <param name="prefix" type="java.lang.String"/>
      <param name="isDeleteOnExit" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a tmp file for a base file.
 @param basefile the base file of the tmp
 @param prefix file name prefix of tmp
 @param isDeleteOnExit if true, the tmp will be deleted when the VM exits
 @return a newly created tmp file
 @exception IOException If a tmp file cannot created
 @see java.io.File#createTempFile(String, String, File)
 @see java.io.File#deleteOnExit()]]>
      </doc>
    </method>
    <method name="replaceFile"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="java.io.File"/>
      <param name="target" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Move the src file to the name specified by target.
 @param src the source file
 @param target the target file
 @exception IOException If this operation fails]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A collection of file-processing util methods]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileUtil -->
  <!-- start class org.apache.hadoop.fs.FileUtil.HardLink -->
  <class name="FileUtil.HardLink" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FileUtil.HardLink"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createHardLink"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="java.io.File"/>
      <param name="linkName" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates a hardlink]]>
      </doc>
    </method>
    <method name="getLinkCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileName" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Retrieves the number of links to the specified file.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Class for creating hardlinks.
 Supports Unix, Cygwin, WindXP.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileUtil.HardLink -->
  <!-- start class org.apache.hadoop.fs.FilterFileSystem -->
  <class name="FilterFileSystem" extends="org.apache.hadoop.fs.FileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FilterFileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FilterFileSystem" type="org.apache.hadoop.fs.FileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Called after a new FileSystem instance is constructed.
 @param name a uri whose authority section names the host, port, etc.
   for this FileSystem
 @param conf the configuration]]>
      </doc>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a URI whose scheme and authority identify this FileSystem.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="call #getUri() instead.">
      <doc>
      <![CDATA[@deprecated call #getUri() instead.]]>
      </doc>
    </method>
    <method name="makeQualified" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Make sure that a path specifies a FileSystem.]]>
      </doc>
    </method>
    <method name="checkPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Check that a Path belongs to this FileSystem.]]>
      </doc>
    </method>
    <method name="getFileBlockLocations" return="org.apache.hadoop.fs.BlockLocation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.FileStatus"/>
      <param name="start" type="long"/>
      <param name="len" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataInputStream at the indicated Path.
 @param f the file name to open
 @param bufferSize the size of the buffer to be used.]]>
      </doc>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="setReplication" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set replication for an existing file.
 
 @param src file name
 @param replication new replication
 @throws IOException
 @return true if successful;
         false if file does not exist or is a directory]]>
      </doc>
    </method>
    <method name="rename" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Renames Path src to Path dst.  Can take place on local fs
 or remote DFS.]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete a file]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete a file]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List files in a directory.]]>
      </doc>
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setWorkingDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newDir" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Set the current working directory for the given file system. All relative
 paths will be resolved relative to it.
 
 @param newDir]]>
      </doc>
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current working directory for the given file system
 
 @return the directory pathname]]>
      </doc>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is on the local disk.  Add it to FS at
 the given dst name.
 delSrc indicates if the source should be removed]]>
      </doc>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under FS, and the dst is on the local disk.
 Copy it from FS control to the local dst name.
 delSrc indicates if the src will be removed or not.]]>
      </doc>
    </method>
    <method name="startLocalOutput" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a local File that the user can write output to.  The caller
 provides both the eventual FS target name and the local working
 file.  If the FS is local, we write directly into the target.  If
 the FS is remote, we write into the tmp local area.]]>
      </doc>
    </method>
    <method name="completeLocalOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Called when we're all done writing to the target.  A local FS will
 do nothing, because we've written to exactly the right place.  A remote
 FS will copy the contents of tmpLocalFile to the correct target at
 fsOutputFile.]]>
      </doc>
    </method>
    <method name="getDefaultBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the number of bytes that large input files should be optimally
 be split into to minimize i/o time.]]>
      </doc>
    </method>
    <method name="getDefaultReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the default replication.]]>
      </doc>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get file status.]]>
      </doc>
    </method>
    <method name="getFileChecksum" return="org.apache.hadoop.fs.FileChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="setVerifyChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="verifyChecksum" type="boolean"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <field name="fs" type="org.apache.hadoop.fs.FileSystem"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A <code>FilterFileSystem</code> contains
 some other file system, which it uses as
 its  basic file system, possibly transforming
 the data along the way or providing  additional
 functionality. The class <code>FilterFileSystem</code>
 itself simply overrides all  methods of
 <code>FileSystem</code> with versions that
 pass all requests to the contained  file
 system. Subclasses of <code>FilterFileSystem</code>
 may further override some of  these methods
 and may also provide additional methods
 and fields.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FilterFileSystem -->
  <!-- start class org.apache.hadoop.fs.FSDataInputStream -->
  <class name="FSDataInputStream" extends="java.io.DataInputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.Seekable"/>
    <implements name="org.apache.hadoop.fs.PositionedReadable"/>
    <constructor name="FSDataInputStream" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="seek"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="desired" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getPos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="seekToNewSource" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetPos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Utility that wraps a {@link FSInputStream} in a {@link DataInputStream}
 and buffers input through a {@link BufferedInputStream}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FSDataInputStream -->
  <!-- start class org.apache.hadoop.fs.FSDataOutputStream -->
  <class name="FSDataOutputStream" extends="java.io.DataOutputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.Syncable"/>
    <constructor name="FSDataOutputStream" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="FSDataOutputStream" type="java.io.OutputStream, org.apache.hadoop.fs.FileSystem.Statistics"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="FSDataOutputStream" type="java.io.OutputStream, org.apache.hadoop.fs.FileSystem.Statistics, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="getPos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getWrappedStream" return="java.io.OutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="sync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility that wraps a {@link OutputStream} in a {@link DataOutputStream},
 buffers output through a {@link BufferedOutputStream} and creates a checksum
 file.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FSDataOutputStream -->
  <!-- start class org.apache.hadoop.fs.FSError -->
  <class name="FSError" extends="java.lang.Error"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Thrown for unexpected filesystem errors, presumed to reflect disk errors
 in the native filesystem.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FSError -->
  <!-- start class org.apache.hadoop.fs.FSInputChecker -->
  <class name="FSInputChecker" extends="org.apache.hadoop.fs.FSInputStream"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FSInputChecker" type="org.apache.hadoop.fs.Path, int"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor
 
 @param file The name of the file to be read
 @param numOfRetries Number of read retries when ChecksumError occurs]]>
      </doc>
    </constructor>
    <constructor name="FSInputChecker" type="org.apache.hadoop.fs.Path, int, boolean, java.util.zip.Checksum, int, int"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor
 
 @param file The name of the file to be read
 @param numOfRetries Number of read retries when ChecksumError occurs
 @param sum the type of Checksum engine
 @param chunkSize maximun chunk size
 @param checksumSize the number byte of each checksum]]>
      </doc>
    </constructor>
    <method name="readChunk" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="pos" type="long"/>
      <param name="buf" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="len" type="int"/>
      <param name="checksum" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads in next checksum chunk data into <code>buf</code> at <code>offset</code>
 and checksum into <code>checksum</code>.
 The method is used for implementing read, therefore, it should be optimized
 for sequential reading
 @param pos chunkPos
 @param buf desitination buffer
 @param offset offset in buf at which to store data
 @param len maximun number of bytes to read
 @return number of bytes read]]>
      </doc>
    </method>
    <method name="getChunkPosition" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="pos" type="long"/>
      <doc>
      <![CDATA[Return position of beginning of chunk containing pos. 

 @param pos a postion in the file
 @return the starting position of the chunk which contains the byte]]>
      </doc>
    </method>
    <method name="needChecksum" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return true if there is a need for checksum verification]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read one checksum-verified byte
 
 @return     the next byte of data, or <code>-1</code> if the end of the
             stream is reached.
 @exception  IOException  if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read checksum verified bytes from this byte-input stream into 
 the specified byte array, starting at the given offset.

 <p> This method implements the general contract of the corresponding
 <code>{@link InputStream#read(byte[], int, int) read}</code> method of
 the <code>{@link InputStream}</code> class.  As an additional
 convenience, it attempts to read as many bytes as possible by repeatedly
 invoking the <code>read</code> method of the underlying stream.  This
 iterated <code>read</code> continues until one of the following
 conditions becomes true: <ul>

   <li> The specified number of bytes have been read,

   <li> The <code>read</code> method of the underlying stream returns
   <code>-1</code>, indicating end-of-file.

 </ul> If the first <code>read</code> on the underlying stream returns
 <code>-1</code> to indicate end-of-file then this method returns
 <code>-1</code>.  Otherwise this method returns the number of bytes
 actually read.

 @param      b     destination buffer.
 @param      off   offset at which to start storing bytes.
 @param      len   maximum number of bytes to read.
 @return     the number of bytes read, or <code>-1</code> if the end of
             the stream has been reached.
 @exception  IOException  if an I/O error occurs.
             ChecksumException if any checksum error occurs]]>
      </doc>
    </method>
    <method name="checksum2long" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="checksum" type="byte[]"/>
      <doc>
      <![CDATA[Convert a checksum byte array to a long]]>
      </doc>
    </method>
    <method name="getPos" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="available" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Skips over and discards <code>n</code> bytes of data from the
 input stream.

 <p>This method may skip more bytes than are remaining in the backing
 file. This produces no exception and the number of bytes skipped
 may include some number of bytes that were beyond the EOF of the
 backing file. Attempting to read from the stream after skipping past
 the end will result in -1 indicating the end of the file.

<p>If <code>n</code> is negative, no bytes are skipped.

 @param      n   the number of bytes to be skipped.
 @return     the actual number of bytes skipped.
 @exception  IOException  if an I/O error occurs.
             ChecksumException if the chunk to skip to is corrupted]]>
      </doc>
    </method>
    <method name="seek"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Seek to the given position in the stream.
 The next read() will be from that position.
 
 <p>This method may seek past the end of the file.
 This produces no exception and an attempt to read from
 the stream will result in -1 indicating the end of the file.

 @param      pos   the postion to seek to.
 @exception  IOException  if an I/O error occurs.
             ChecksumException if the chunk to seek to is corrupted]]>
      </doc>
    </method>
    <method name="readFully" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="stm" type="java.io.InputStream"/>
      <param name="buf" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A utility function that tries to read up to <code>len</code> bytes from
 <code>stm</code>
 
 @param stm    an input stream
 @param buf    destiniation buffer
 @param offset offset at which to store data
 @param len    number of bytes to read
 @return actual number of bytes read
 @throws IOException if there is any IO error]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="verifyChecksum" type="boolean"/>
      <param name="sum" type="java.util.zip.Checksum"/>
      <param name="maxChunkSize" type="int"/>
      <param name="checksumSize" type="int"/>
      <doc>
      <![CDATA[Set the checksum related parameters
 @param verifyChecksum whether to verify checksum
 @param sum which type of checksum to use
 @param maxChunkSize maximun chunk size
 @param checksumSize checksum size]]>
      </doc>
    </method>
    <method name="markSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="readlimit" type="int"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="file" type="org.apache.hadoop.fs.Path"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The file name from which data is read from]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This is a generic input stream for verifying checksums for
 data before it is read by a user.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FSInputChecker -->
  <!-- start class org.apache.hadoop.fs.FSInputStream -->
  <class name="FSInputStream" extends="java.io.InputStream"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.Seekable"/>
    <implements name="org.apache.hadoop.fs.PositionedReadable"/>
    <constructor name="FSInputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="seek"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Seek to the given offset from the start of the file.
 The next read() will be from that location.  Can't
 seek past the end of the file.]]>
      </doc>
    </method>
    <method name="getPos" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the current offset from the start of the file]]>
      </doc>
    </method>
    <method name="seekToNewSource" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetPos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Seeks a different copy of the data.  Returns true if 
 found a new source, false otherwise.]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[FSInputStream is a generic old InputStream with a little bit
 of RAF-style seek ability.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FSInputStream -->
  <!-- start class org.apache.hadoop.fs.FSOutputSummer -->
  <class name="FSOutputSummer" extends="java.io.OutputStream"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FSOutputSummer" type="java.util.zip.Checksum, int, int"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="writeChunk"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="len" type="int"/>
      <param name="checksum" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write one byte]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes <code>len</code> bytes from the specified byte array 
 starting at offset <code>off</code> and generate a checksum for
 each data chunk.

 <p> This method stores bytes from the given array into this
 stream's buffer before it gets checksumed. The buffer gets checksumed 
 and flushed to the underlying output stream when all data 
 in a checksum chunk are in the buffer.  If the buffer is empty and
 requested length is at least as large as the size of next checksum chunk
 size, this method will checksum and write the chunk directly 
 to the underlying output stream.  Thus it avoids uneccessary data copy.

 @param      b     the data.
 @param      off   the start offset in the data.
 @param      len   the number of bytes to write.
 @exception  IOException  if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="flushBuffer"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flushBuffer"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="keep" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="convertToByteStream" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sum" type="java.util.zip.Checksum"/>
      <param name="checksumSize" type="int"/>
      <doc>
      <![CDATA[Converts a checksum integer value to a byte stream]]>
      </doc>
    </method>
    <method name="resetChecksumChunk"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Resets existing buffer with a new one of the specified size.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This is a generic output stream for generating checksums for
 data before it is written to the underlying stream]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FSOutputSummer -->
  <!-- start class org.apache.hadoop.fs.FsShell -->
  <class name="FsShell" extends="org.apache.hadoop.conf.Configured"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.Tool"/>
    <constructor name="FsShell"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FsShell" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCurrentTrashDir" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the Trash object associated with this shell.]]>
      </doc>
    </method>
    <method name="byteDesc" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Consider using {@link org.apache.hadoop.util.StringUtils#byteDesc} instead.">
      <param name="len" type="long"/>
      <doc>
      <![CDATA[Return an abbreviated English-language desc of the byte length
 @deprecated Consider using {@link org.apache.hadoop.util.StringUtils#byteDesc} instead.]]>
      </doc>
    </method>
    <method name="limitDecimalTo2" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="Consider using {@link org.apache.hadoop.util.StringUtils#limitDecimalTo2} instead.">
      <param name="d" type="double"/>
      <doc>
      <![CDATA[@deprecated Consider using {@link org.apache.hadoop.util.StringUtils#limitDecimalTo2} instead.]]>
      </doc>
    </method>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="argv" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[run]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="argv" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[main() has some simple utility methods]]>
      </doc>
    </method>
    <field name="fs" type="org.apache.hadoop.fs.FileSystem"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="dateForm" type="java.text.SimpleDateFormat"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="modifFmt" type="java.text.SimpleDateFormat"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Provide command line access to a FileSystem.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FsShell -->
  <!-- start class org.apache.hadoop.fs.FsUrlStreamHandlerFactory -->
  <class name="FsUrlStreamHandlerFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.net.URLStreamHandlerFactory"/>
    <constructor name="FsUrlStreamHandlerFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FsUrlStreamHandlerFactory" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createURLStreamHandler" return="java.net.URLStreamHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Factory for URL stream handlers.
 
 There is only one handler whose job is to create UrlConnections. A
 FsUrlConnection relies on FileSystem to choose the appropriate FS
 implementation.
 
 Before returning our handler, we make sure that FileSystem knows an
 implementation for the requested scheme/protocol.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FsUrlStreamHandlerFactory -->
  <!-- start class org.apache.hadoop.fs.HarFileSystem -->
  <class name="HarFileSystem" extends="org.apache.hadoop.fs.FilterFileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HarFileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[public construction of harfilesystem]]>
      </doc>
    </constructor>
    <constructor name="HarFileSystem" type="org.apache.hadoop.fs.FileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor to create a HarFileSystem with an
 underlying filesystem.
 @param fs]]>
      </doc>
    </constructor>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Initialize a Har filesystem per har archive. The 
 archive home directory is the top level directory
 in the filesystem that contains the HAR archive.
 Be careful with this method, you do not want to go 
 on creating new Filesystem instances per call to 
 path.getFileSystem().
 the uri of Har is 
 har://underlyingfsscheme-host:port/archivepath.
 or 
 har:///archivepath. This assumes the underlying filesystem
 to be used in case not specified.]]>
      </doc>
    </method>
    <method name="getHarVersion" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[return the top level archive.]]>
      </doc>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the uri of this filesystem.
 The uri is of the form 
 har://underlyingfsschema-host:port/pathintheunderlyingfs]]>
      </doc>
    </method>
    <method name="makeQualified" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="getFileBlockLocations" return="org.apache.hadoop.fs.BlockLocation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.FileStatus"/>
      <param name="start" type="long"/>
      <param name="len" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[get block locations from the underlying fs
 @param file the input filestatus to get block locations
 @param start the start in the file
 @param len the length in the file
 @return block locations for this segment of file
 @throws IOException]]>
      </doc>
    </method>
    <method name="getHarHash" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[the hash of the path p inside iniside
 the filesystem
 @param p the path in the harfilesystem
 @return the hash code of the path.]]>
      </doc>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[return the filestatus of files in har archive.
 The permission returned are that of the archive
 index files. The permissions are not persisted 
 while creating a hadoop archive.
 @param f the path in har filesystem
 @return filestatus.
 @throws IOException]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a har input stream which fakes end of 
 file. It reads the index files to get the part 
 file name and the size and start of the file.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setReplication" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Not implemented.]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Not implemented.]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[liststatus returns the children of a directory 
 after looking up the index files.]]>
      </doc>
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[return the top level archive path.]]>
      </doc>
    </method>
    <method name="setWorkingDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newDir" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[not implemented.]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[not implemented.]]>
      </doc>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[copies the file in the har filesystem to a local file.]]>
      </doc>
    </method>
    <method name="startLocalOutput" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[not implemented.]]>
      </doc>
    </method>
    <method name="completeLocalOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[not implemented.]]>
      </doc>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[not implemented.]]>
      </doc>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="permisssion" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Not implemented.]]>
      </doc>
    </method>
    <field name="VERSION" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This is an implementation of the Hadoop Archive 
 Filesystem. This archive Filesystem has index files
 of the form _index* and has contents of the form
 part-*. The index files store the indexes of the 
 real files. The index files are of the form _masterindex
 and _index. The master index is a level of indirection 
 in to the index file to make the look ups faster. the index
 file is sorted with hash code of the paths that it contains 
 and the master index contains pointers to the positions in 
 index for ranges of hashcodes.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.HarFileSystem -->
  <!-- start class org.apache.hadoop.fs.InMemoryFileSystem -->
  <class name="InMemoryFileSystem" extends="org.apache.hadoop.fs.ChecksumFileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InMemoryFileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="InMemoryFileSystem" type="java.net.URI, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="reserveSpaceWithCheckSum" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="size" type="long"/>
      <doc>
      <![CDATA[Register a file with its size. This will also register a checksum for the
 file that the user is trying to create. This is required since none of
 the FileSystem APIs accept the size of the file as argument. But since it
 is required for us to apriori know the size of the file we are going to
 create, the user must call this method for each file he wants to create
 and reserve memory for that file. We either succeed in reserving memory
 for both the main file and the checksum file and return true, or return
 false.]]>
      </doc>
    </method>
    <method name="getFiles" return="org.apache.hadoop.fs.Path[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.fs.PathFilter"/>
    </method>
    <method name="getNumFiles" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.fs.PathFilter"/>
    </method>
    <method name="getFSSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPercentUsed" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An implementation of the in-memory filesystem. This implementation assumes
 that the file lengths are known ahead of time and the total lengths of all
 the files is below a certain number (like 100 MB, configurable). Use the API
 reserveSpaceWithCheckSum(Path f, int size) (see below for a description of
 the API for reserving space in the FS. The uri of this filesystem starts with
 ramfs:// .]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.InMemoryFileSystem -->
  <!-- start class org.apache.hadoop.fs.LocalDirAllocator -->
  <class name="LocalDirAllocator" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LocalDirAllocator" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an allocator object
 @param contextCfgItemName]]>
      </doc>
    </constructor>
    <method name="getLocalPathForWrite" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pathStr" type="java.lang.String"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a path from the local FS. This method should be used if the size of 
  the file is not known apriori. We go round-robin over the set of disks
  (via the configured dirs) and return the first complete path where
  we could create the parent directory of the passed path. 
  @param pathStr the requested path (this will be created on the first 
  available disk)
  @param conf the Configuration object
  @return the complete path to the file on a local disk
  @throws IOException]]>
      </doc>
    </method>
    <method name="getLocalPathForWrite" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pathStr" type="java.lang.String"/>
      <param name="size" type="long"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a path from the local FS. Pass size as -1 if not known apriori. We
  round-robin over the set of disks (via the configured dirs) and return
  the first complete path which has enough space 
  @param pathStr the requested path (this will be created on the first 
  available disk)
  @param size the size of the file that is going to be written
  @param conf the Configuration object
  @return the complete path to the file on a local disk
  @throws IOException]]>
      </doc>
    </method>
    <method name="getLocalPathToRead" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pathStr" type="java.lang.String"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a path from the local FS for reading. We search through all the
  configured dirs for the file's existence and return the complete
  path to the file when we find one 
  @param pathStr the requested file (this will be searched)
  @param conf the Configuration object
  @return the complete path to the file on a local disk
  @throws IOException]]>
      </doc>
    </method>
    <method name="createTmpFileForWrite" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pathStr" type="java.lang.String"/>
      <param name="size" type="long"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates a temporary file in the local FS. Pass size as -1 if not known 
  apriori. We round-robin over the set of disks (via the configured dirs) 
  and select the first complete path which has enough space. A file is
  created on this directory. The file is guaranteed to go away when the
  JVM exits.
  @param pathStr prefix for the temporary file
  @param size the size of the file that is going to be written
  @param conf the Configuration object
  @return a unique temporary file
  @throws IOException]]>
      </doc>
    </method>
    <method name="isContextValid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextCfgItemName" type="java.lang.String"/>
      <doc>
      <![CDATA[Method to check whether a context is valid
 @param contextCfgItemName
 @return true/false]]>
      </doc>
    </method>
    <method name="ifExists" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pathStr" type="java.lang.String"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[We search through all the configured dirs for the file's existence
  and return true when we find  
  @param pathStr the requested file (this will be searched)
  @param conf the Configuration object
  @return true if files exist. false otherwise
  @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An implementation of a round-robin scheme for disk allocation for creating
 files. The way it works is that it is kept track what disk was last
 allocated for a file write. For the current request, the next disk from
 the set of disks would be allocated if the free space on the disk is 
 sufficient enough to accomodate the file that is being considered for
 creation. If the space requirements cannot be met, the next disk in order
 would be tried and so on till a disk is found with sufficient capacity.
 Once a disk with sufficient space is identified, a check is done to make
 sure that the disk is writable. Also, there is an API provided that doesn't
 take the space requirements into consideration but just checks whether the
 disk under consideration is writable (this should be used for cases where
 the file size is not known apriori). An API is provided to read a path that
 was created earlier. That API works by doing a scan of all the disks for the
 input pathname.
 This implementation also provides the functionality of having multiple 
 allocators per JVM (one for each unique functionality or context, like 
 mapred, dfs-client, etc.). It ensures that there is only one instance of
 an allocator per context per JVM.
 Note:
 1. The contexts referred above are actually the configuration items defined
 in the Configuration class like "mapred.local.dir" (for which we want to 
 control the dir allocations). The context-strings are exactly those 
 configuration items.
 2. This implementation does not take into consideration cases where
 a disk becomes read-only or goes out of space while a file is being written
 to (disks are shared between multiple processes, and so the latter situation
 is probable).
 3. In the class implementation, "Disk" is referred to as "Dir", which
 actually points to the configured directory on the Disk which will be the
 parent for all file write/read allocations.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.LocalDirAllocator -->
  <!-- start class org.apache.hadoop.fs.LocalFileSystem -->
  <class name="LocalFileSystem" extends="org.apache.hadoop.fs.ChecksumFileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LocalFileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LocalFileSystem" type="org.apache.hadoop.fs.FileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getRaw" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pathToFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Convert a path to a File.]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="reportChecksumFailure" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="in" type="org.apache.hadoop.fs.FSDataInputStream"/>
      <param name="inPos" type="long"/>
      <param name="sums" type="org.apache.hadoop.fs.FSDataInputStream"/>
      <param name="sumsPos" type="long"/>
      <doc>
      <![CDATA[Moves files to a bad file directory on the same device, so that their
 storage will not be reused.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implement the FileSystem API for the checksumed local filesystem.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.LocalFileSystem -->
  <!-- start class org.apache.hadoop.fs.MD5MD5CRC32FileChecksum -->
  <class name="MD5MD5CRC32FileChecksum" extends="org.apache.hadoop.fs.FileChecksum"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MD5MD5CRC32FileChecksum"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Same as this(0, 0, null)]]>
      </doc>
    </constructor>
    <constructor name="MD5MD5CRC32FileChecksum" type="int, long, org.apache.hadoop.io.MD5Hash"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a MD5FileChecksum]]>
      </doc>
    </constructor>
    <method name="getAlgorithmName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="getLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="getBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xml" type="org.znerd.xmlenc.XMLOutputter"/>
      <param name="that" type="org.apache.hadoop.fs.MD5MD5CRC32FileChecksum"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write that object to xml output.]]>
      </doc>
    </method>
    <method name="valueOf" return="org.apache.hadoop.fs.MD5MD5CRC32FileChecksum"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attrs" type="org.xml.sax.Attributes"/>
      <exception name="SAXException" type="org.xml.sax.SAXException"/>
      <doc>
      <![CDATA[Return the object represented in the attributes.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <field name="LENGTH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[MD5 of MD5 of CRC32.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.MD5MD5CRC32FileChecksum -->
  <!-- start class org.apache.hadoop.fs.Path -->
  <class name="Path" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <constructor name="Path" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resolve a child path against a parent path.]]>
      </doc>
    </constructor>
    <constructor name="Path" type="org.apache.hadoop.fs.Path, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resolve a child path against a parent path.]]>
      </doc>
    </constructor>
    <constructor name="Path" type="java.lang.String, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resolve a child path against a parent path.]]>
      </doc>
    </constructor>
    <constructor name="Path" type="org.apache.hadoop.fs.Path, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resolve a child path against a parent path.]]>
      </doc>
    </constructor>
    <constructor name="Path" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a path from a String.  Path strings are URIs, but with
 unescaped elements and some additional normalization.]]>
      </doc>
    </constructor>
    <constructor name="Path" type="java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a Path from components.]]>
      </doc>
    </constructor>
    <method name="toUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Convert this to a URI.]]>
      </doc>
    </method>
    <method name="getFileSystem" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the FileSystem that owns this Path.]]>
      </doc>
    </method>
    <method name="isAbsolute" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[True if the directory of this path is absolute.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the final component of this path.]]>
      </doc>
    </method>
    <method name="getParent" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the parent of a path or null if at root.]]>
      </doc>
    </method>
    <method name="suffix" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="suffix" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds a suffix to the final name in the path.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="depth" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the number of elements in this path.]]>
      </doc>
    </method>
    <method name="makeQualified" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <doc>
      <![CDATA[Returns a qualified path object.]]>
      </doc>
    </method>
    <field name="SEPARATOR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The directory separator, a slash.]]>
      </doc>
    </field>
    <field name="SEPARATOR_CHAR" type="char"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CUR_DIR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Names a file or directory in a {@link FileSystem}.
 Path strings use slash as the directory separator.  A path string is
 absolute if it begins with a slash.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.Path -->
  <!-- start interface org.apache.hadoop.fs.PathFilter -->
  <interface name="PathFilter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="accept" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Tests whether or not the specified abstract pathname should be
 included in a pathname list.

 @param  path  The abstract pathname to be tested
 @return  <code>true</code> if and only if <code>pathname</code>
          should be included]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.fs.PathFilter -->
  <!-- start interface org.apache.hadoop.fs.PositionedReadable -->
  <interface name="PositionedReadable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read upto the specified number of bytes, from a given
 position within a file, and return the number of bytes read. This does not
 change the current offset of a file, and is thread-safe.]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read the specified number of bytes, from a given
 position within a file. This does not
 change the current offset of a file, and is thread-safe.]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read number of bytes equalt to the length of the buffer, from a given
 position within a file. This does not
 change the current offset of a file, and is thread-safe.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Stream that permits positional reading.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.PositionedReadable -->
  <!-- start class org.apache.hadoop.fs.RawLocalFileSystem -->
  <class name="RawLocalFileSystem" extends="org.apache.hadoop.fs.FileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RawLocalFileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="pathToFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Convert a path to a File.]]>
      </doc>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="rename" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates the specified directory hierarchy. Does not
 treat existence as an error.]]>
      </doc>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setWorkingDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newDir" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Set the working directory to the given directory.]]>
      </doc>
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="moveFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startLocalOutput" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="completeLocalOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsWorkingFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Use the command chown to set owner.]]>
      </doc>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Use the command chmod to set permission.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implement the FileSystem API for the raw local filesystem.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.RawLocalFileSystem -->
  <!-- start interface org.apache.hadoop.fs.Seekable -->
  <interface name="Seekable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="seek"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Seek to the given offset from the start of the file.
 The next read() will be from that location.  Can't
 seek past the end of the file.]]>
      </doc>
    </method>
    <method name="getPos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the current offset from the start of the file]]>
      </doc>
    </method>
    <method name="seekToNewSource" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetPos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Seeks a different copy of the data.  Returns true if 
 found a new source, false otherwise.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Stream that permits seeking.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.Seekable -->
  <!-- start interface org.apache.hadoop.fs.Syncable -->
  <interface name="Syncable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="sync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Synchronize all buffer with the underlying devices.
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This interface declare the sync() operation.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.Syncable -->
  <!-- start class org.apache.hadoop.fs.Trash -->
  <class name="Trash" extends="org.apache.hadoop.conf.Configured"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Trash" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a trash can accessor.
 @param conf a Configuration]]>
      </doc>
    </constructor>
    <constructor name="Trash" type="org.apache.hadoop.fs.FileSystem, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a trash can accessor for the FileSystem provided.]]>
      </doc>
    </constructor>
    <method name="moveToTrash" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Move a file or directory to the current trash directory.
 @return false if the item is already in the trash or trash is disabled]]>
      </doc>
    </method>
    <method name="checkpoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a trash checkpoint.]]>
      </doc>
    </method>
    <method name="expunge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete old checkpoints.]]>
      </doc>
    </method>
    <method name="getEmptier" return="java.lang.Runnable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a {@link Runnable} that periodically empties the trash of all
 users, intended to be run by the superuser.  Only one checkpoint is kept
 at a time.]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Run an emptier.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides a <i>trash</i> feature.  Files are moved to a user's trash
 directory, a subdirectory of their home directory named ".Trash".  Files are
 initially moved to a <i>current</i> sub-directory of the trash directory.
 Within that sub-directory their original path is preserved.  Periodically
 one may checkpoint the current trash and remove older checkpoints.  (This
 design permits trash management without enumeration of the full trash
 content, without date support in the filesystem, and without clock
 synchronization.)]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.Trash -->
  <doc>
  <![CDATA[An abstract file system API.]]>
  </doc>
</package>
<package name="org.apache.hadoop.fs.ftp">
  <!-- start class org.apache.hadoop.fs.ftp.FTPException -->
  <class name="FTPException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FTPException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FTPException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FTPException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[A class to wrap a {@link Throwable} into a Runtime Exception.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ftp.FTPException -->
  <!-- start class org.apache.hadoop.fs.ftp.FTPFileSystem -->
  <class name="FTPFileSystem" extends="org.apache.hadoop.fs.FileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FTPFileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A stream obtained via this call must be closed before using other APIs of
 this class or else the invocation will block.]]>
      </doc>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This optional operation is not yet supported.]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use delete(Path, boolean) instead">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@deprecated Use delete(Path, boolean) instead]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="rename" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setWorkingDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newDir" type="org.apache.hadoop.fs.Path"/>
    </method>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_BUFFER_SIZE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_BLOCK_SIZE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[<p>
 A {@link FileSystem} backed by an FTP client provided by <a
 href="http://commons.apache.org/net/">Apache Commons Net</a>.
 </p>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ftp.FTPFileSystem -->
  <!-- start class org.apache.hadoop.fs.ftp.FTPInputStream -->
  <class name="FTPInputStream" extends="org.apache.hadoop.fs.FSInputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FTPInputStream" type="java.io.InputStream, org.apache.commons.net.ftp.FTPClient, org.apache.hadoop.fs.FileSystem.Statistics"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="seek"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="seekToNewSource" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetPos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="markSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readLimit" type="int"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.fs.ftp.FTPInputStream -->
</package>
<package name="org.apache.hadoop.fs.kfs">
  <!-- start class org.apache.hadoop.fs.kfs.KosmosFileSystem -->
  <class name="KosmosFileSystem" extends="org.apache.hadoop.fs.FileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KosmosFileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setWorkingDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="isDirectory" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="isFile" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This optional operation is not yet supported.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="rename" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getDefaultReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setReplication" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getDefaultBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="lock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="shared" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="release"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileBlockLocations" return="org.apache.hadoop.fs.BlockLocation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.FileStatus"/>
      <param name="start" type="long"/>
      <param name="len" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return null if the file doesn't exist; otherwise, get the
 locations of the various chunks of the file file from KFS.]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startLocalOutput" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="completeLocalOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A FileSystem backed by KFS.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.kfs.KosmosFileSystem -->
  <doc>
  <![CDATA[<h1>A client for the Kosmos filesystem (KFS)</h1>

<h3>Introduction</h3>

This pages describes how to use Kosmos Filesystem 
(<a href="http://kosmosfs.sourceforge.net"> KFS </a>) as a backing
store with Hadoop.   This page assumes that you have downloaded the
KFS software and installed necessary binaries as outlined in the KFS
documentation.

<h3>Steps</h3>

        <ul>
          <li>In the Hadoop conf directory edit core-site.xml,
          add the following:
            <pre>
&lt;property&gt;
  &lt;name&gt;fs.kfs.impl&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.fs.kfs.KosmosFileSystem&lt;/value&gt;
  &lt;description&gt;The FileSystem for kfs: uris.&lt;/description&gt;
&lt;/property&gt;
            </pre>

          <li>In the Hadoop conf directory edit core-site.xml,
          adding the following (with appropriate values for
          &lt;server&gt; and &lt;port&gt;):
            <pre>
&lt;property&gt;
  &lt;name&gt;fs.default.name&lt;/name&gt;
  &lt;value&gt;kfs://&lt;server:port&gt;&lt;/value&gt; 
&lt;/property&gt;

&lt;property&gt;
  &lt;name&gt;fs.kfs.metaServerHost&lt;/name&gt;
  &lt;value&gt;&lt;server&gt;&lt;/value&gt;
  &lt;description&gt;The location of the KFS meta server.&lt;/description&gt;
&lt;/property&gt;

&lt;property&gt;
  &lt;name&gt;fs.kfs.metaServerPort&lt;/name&gt;
  &lt;value&gt;&lt;port&gt;&lt;/value&gt;
  &lt;description&gt;The location of the meta server's port.&lt;/description&gt;
&lt;/property&gt;

</pre>
          </li>

          <li>Copy KFS's <i> kfs-0.1.jar </i> to Hadoop's lib directory.  This step
          enables Hadoop's to load the KFS specific modules.  Note
          that, kfs-0.1.jar was built when you compiled KFS source
          code.  This jar file contains code that calls KFS's client
          library code via JNI; the native code is in KFS's <i>
          libkfsClient.so </i> library.
          </li>

          <li> When the Hadoop map/reduce trackers start up, those
processes (on local as well as remote nodes) will now need to load
KFS's <i> libkfsClient.so </i> library.  To simplify this process, it is advisable to
store libkfsClient.so in an NFS accessible directory (similar to where
Hadoop binaries/scripts are stored); then, modify Hadoop's
conf/hadoop-env.sh adding the following line and providing suitable
value for &lt;path&gt;:
<pre>
export LD_LIBRARY_PATH=&lt;path&gt;
</pre>


          <li>Start only the map/reduce trackers
          <br />
          example: execute Hadoop's bin/start-mapred.sh</li>
        </ul>
<br/>

If the map/reduce job trackers start up, all file-I/O is done to KFS.]]>
  </doc>
</package>
<package name="org.apache.hadoop.fs.permission">
  <!-- start class org.apache.hadoop.fs.permission.AccessControlException -->
  <class name="AccessControlException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Use {@link org.apache.hadoop.security.AccessControlException} 
             instead.">
    <constructor name="AccessControlException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor is needed for unwrapping from 
 {@link org.apache.hadoop.ipc.RemoteException}.]]>
      </doc>
    </constructor>
    <constructor name="AccessControlException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an {@link AccessControlException}
 with the specified detail message.
 @param s the detail message.]]>
      </doc>
    </constructor>
    <constructor name="AccessControlException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new exception with the specified cause and a detail
 message of <tt>(cause==null ? null : cause.toString())</tt> (which
 typically contains the class and detail message of <tt>cause</tt>).
 @param  cause the cause (which is saved for later retrieval by the
         {@link #getCause()} method).  (A <tt>null</tt> value is
         permitted, and indicates that the cause is nonexistent or
         unknown.)]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[An exception class for access control related issues.
 @deprecated Use {@link org.apache.hadoop.security.AccessControlException} 
             instead.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.permission.AccessControlException -->
  <!-- start class org.apache.hadoop.fs.permission.FsAction -->
  <class name="FsAction" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.fs.permission.FsAction[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.fs.permission.FsAction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="implies" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="that" type="org.apache.hadoop.fs.permission.FsAction"/>
      <doc>
      <![CDATA[Return true if this action implies that action.
 @param that]]>
      </doc>
    </method>
    <method name="and" return="org.apache.hadoop.fs.permission.FsAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="that" type="org.apache.hadoop.fs.permission.FsAction"/>
      <doc>
      <![CDATA[AND operation.]]>
      </doc>
    </method>
    <method name="or" return="org.apache.hadoop.fs.permission.FsAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="that" type="org.apache.hadoop.fs.permission.FsAction"/>
      <doc>
      <![CDATA[OR operation.]]>
      </doc>
    </method>
    <method name="not" return="org.apache.hadoop.fs.permission.FsAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[NOT operation.]]>
      </doc>
    </method>
    <field name="NONE" type="org.apache.hadoop.fs.permission.FsAction"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EXECUTE" type="org.apache.hadoop.fs.permission.FsAction"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WRITE" type="org.apache.hadoop.fs.permission.FsAction"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WRITE_EXECUTE" type="org.apache.hadoop.fs.permission.FsAction"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="READ" type="org.apache.hadoop.fs.permission.FsAction"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="READ_EXECUTE" type="org.apache.hadoop.fs.permission.FsAction"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="READ_WRITE" type="org.apache.hadoop.fs.permission.FsAction"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ALL" type="org.apache.hadoop.fs.permission.FsAction"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SYMBOL" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Symbolic representation]]>
      </doc>
    </field>
    <doc>
    <![CDATA[File system actions, e.g. read, write, etc.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.permission.FsAction -->
  <!-- start class org.apache.hadoop.fs.permission.FsPermission -->
  <class name="FsPermission" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="FsPermission" type="org.apache.hadoop.fs.permission.FsAction, org.apache.hadoop.fs.permission.FsAction, org.apache.hadoop.fs.permission.FsAction"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct by the given {@link FsAction}.
 @param u user action
 @param g group action
 @param o other action]]>
      </doc>
    </constructor>
    <constructor name="FsPermission" type="short"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct by the given mode.
 @param mode
 @see #toShort()]]>
      </doc>
    </constructor>
    <constructor name="FsPermission" type="org.apache.hadoop.fs.permission.FsPermission"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Copy constructor
 
 @param other other permission]]>
      </doc>
    </constructor>
    <method name="createImmutable" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permission" type="short"/>
      <doc>
      <![CDATA[Create an immutable {@link FsPermission} object.]]>
      </doc>
    </method>
    <method name="getUserAction" return="org.apache.hadoop.fs.permission.FsAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return user {@link FsAction}.]]>
      </doc>
    </method>
    <method name="getGroupAction" return="org.apache.hadoop.fs.permission.FsAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return group {@link FsAction}.]]>
      </doc>
    </method>
    <method name="getOtherAction" return="org.apache.hadoop.fs.permission.FsAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return other {@link FsAction}.]]>
      </doc>
    </method>
    <method name="fromShort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="short"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="read" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create and initialize a {@link FsPermission} from {@link DataInput}.]]>
      </doc>
    </method>
    <method name="toShort" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Encode the object to a short.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="applyUMask" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="umask" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <doc>
      <![CDATA[Apply a umask to this permission and return a new one]]>
      </doc>
    </method>
    <method name="getUMask" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the user file creation mask (umask)]]>
      </doc>
    </method>
    <method name="setUMask"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="umask" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <doc>
      <![CDATA[Set the user file creation mask (umask)]]>
      </doc>
    </method>
    <method name="getDefault" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the default permission.]]>
      </doc>
    </method>
    <method name="valueOf" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unixSymbolicPermission" type="java.lang.String"/>
      <doc>
      <![CDATA[Create a FsPermission from a Unix symbolic permission string
 @param unixSymbolicPermission e.g. "-rw-rw-rw-"]]>
      </doc>
    </method>
    <field name="UMASK_LABEL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[umask property label]]>
      </doc>
    </field>
    <field name="DEFAULT_UMASK" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A class for file/directory permissions.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.permission.FsPermission -->
  <!-- start class org.apache.hadoop.fs.permission.PermissionStatus -->
  <class name="PermissionStatus" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="PermissionStatus" type="java.lang.String, java.lang.String, org.apache.hadoop.fs.permission.FsPermission"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor]]>
      </doc>
    </constructor>
    <method name="createImmutable" return="org.apache.hadoop.fs.permission.PermissionStatus"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <param name="group" type="java.lang.String"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <doc>
      <![CDATA[Create an immutable {@link PermissionStatus} object.]]>
      </doc>
    </method>
    <method name="getUserName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return user name]]>
      </doc>
    </method>
    <method name="getGroupName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return group name]]>
      </doc>
    </method>
    <method name="getPermission" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return permission]]>
      </doc>
    </method>
    <method name="applyUMask" return="org.apache.hadoop.fs.permission.PermissionStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="umask" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <doc>
      <![CDATA[Apply umask.
 @see FsPermission#applyUMask(FsPermission)]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="read" return="org.apache.hadoop.fs.permission.PermissionStatus"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create and initialize a {@link PermissionStatus} from {@link DataInput}.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serialize a {@link PermissionStatus} from its base components.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Store permission related information.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.permission.PermissionStatus -->
</package>
<package name="org.apache.hadoop.fs.s3">
  <!-- start class org.apache.hadoop.fs.s3.Block -->
  <class name="Block" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Block" type="long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getId" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Holds metadata about a block of data being stored in a {@link FileSystemStore}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.s3.Block -->
  <!-- start interface org.apache.hadoop.fs.s3.FileSystemStore -->
  <interface name="FileSystemStore"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="storeINode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="inode" type="org.apache.hadoop.fs.s3.INode"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="storeBlock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="block" type="org.apache.hadoop.fs.s3.Block"/>
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="inodeExists" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="blockExists" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="blockId" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="retrieveINode" return="org.apache.hadoop.fs.s3.INode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="retrieveBlock" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="block" type="org.apache.hadoop.fs.s3.Block"/>
      <param name="byteRangeStart" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="deleteINode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="deleteBlock"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="block" type="org.apache.hadoop.fs.s3.Block"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="listSubPaths" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="listDeepSubPaths" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="purge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete everything. Used for testing.
 @throws IOException]]>
      </doc>
    </method>
    <method name="dump"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Diagnostic method to dump all INodes to the console.
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A facility for storing and retrieving {@link INode}s and {@link Block}s.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.s3.FileSystemStore -->
  <!-- start class org.apache.hadoop.fs.s3.INode -->
  <class name="INode" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="INode" type="org.apache.hadoop.fs.s3.INode.FileType, org.apache.hadoop.fs.s3.Block[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBlocks" return="org.apache.hadoop.fs.s3.Block[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFileType" return="org.apache.hadoop.fs.s3.INode.FileType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isDirectory" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isFile" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSerializedLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="serialize" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="deserialize" return="org.apache.hadoop.fs.s3.INode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="FILE_TYPES" type="org.apache.hadoop.fs.s3.INode.FileType[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DIRECTORY_INODE" type="org.apache.hadoop.fs.s3.INode"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Holds file metadata including type (regular file, or directory),
 and the list of blocks that are pointers to the data.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.s3.INode -->
  <!-- start class org.apache.hadoop.fs.s3.MigrationTool -->
  <class name="MigrationTool" extends="org.apache.hadoop.conf.Configured"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.Tool"/>
    <constructor name="MigrationTool"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[<p>
 This class is a tool for migrating data from an older to a newer version
 of an S3 filesystem.
 </p>
 <p>
 All files in the filesystem are migrated by re-writing the block metadata
 - no datafiles are touched.
 </p>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.s3.MigrationTool -->
  <!-- start class org.apache.hadoop.fs.s3.S3Credentials -->
  <class name="S3Credentials" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="S3Credentials"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[@throws IllegalArgumentException if credentials for S3 cannot be
 determined.]]>
      </doc>
    </method>
    <method name="getAccessKey" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSecretAccessKey" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 Extracts AWS credentials from the filesystem URI or configuration.
 </p>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.s3.S3Credentials -->
  <!-- start class org.apache.hadoop.fs.s3.S3Exception -->
  <class name="S3Exception" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="S3Exception" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Thrown if there is a problem communicating with Amazon S3.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.s3.S3Exception -->
  <!-- start class org.apache.hadoop.fs.s3.S3FileSystem -->
  <class name="S3FileSystem" extends="org.apache.hadoop.fs.FileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="S3FileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="S3FileSystem" type="org.apache.hadoop.fs.s3.FileSystemStore"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setWorkingDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@param permission Currently ignored.]]>
      </doc>
    </method>
    <method name="isFile" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This optional operation is not yet supported.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@param permission Currently ignored.]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="rename" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[FileStatus for S3 file systems.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 A block-based {@link FileSystem} backed by
 <a href="http://aws.amazon.com/s3">Amazon S3</a>.
 </p>
 @see NativeS3FileSystem]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.s3.S3FileSystem -->
  <!-- start class org.apache.hadoop.fs.s3.S3FileSystemException -->
  <class name="S3FileSystemException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="S3FileSystemException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Thrown when there is a fatal exception while using {@link S3FileSystem}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.s3.S3FileSystemException -->
  <!-- start class org.apache.hadoop.fs.s3.VersionMismatchException -->
  <class name="VersionMismatchException" extends="org.apache.hadoop.fs.s3.S3FileSystemException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="VersionMismatchException" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Thrown when Hadoop cannot read the version of the data stored
 in {@link S3FileSystem}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.s3.VersionMismatchException -->
  <doc>
  <![CDATA[<p>A distributed, block-based implementation of {@link
org.apache.hadoop.fs.FileSystem} that uses <a href="http://aws.amazon.com/s3">Amazon S3</a>
as a backing store.</p>

<p>
Files are stored in S3 as blocks (represented by 
{@link org.apache.hadoop.fs.s3.Block}), which have an ID and a length.
Block metadata is stored in S3 as a small record (represented by 
{@link org.apache.hadoop.fs.s3.INode}) using the URL-encoded
path string as a key. Inodes record the file type (regular file or directory) and the list of blocks.
This design makes it easy to seek to any given position in a file by reading the inode data to compute
which block to access, then using S3's support for 
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.2">HTTP Range</a> headers
to start streaming from the correct position.
Renames are also efficient since only the inode is moved (by a DELETE followed by a PUT since 
S3 does not support renames).
</p>
<p>
For a single file <i>/dir1/file1</i> which takes two blocks of storage, the file structure in S3
would be something like this:
</p>
<pre>
/
/dir1
/dir1/file1
block-6415776850131549260
block-3026438247347758425
</pre>
<p>
Inodes start with a leading <code>/</code>, while blocks are prefixed with <code>block-</code>.
</p>]]>
  </doc>
</package>
<package name="org.apache.hadoop.fs.s3native">
  <!-- start class org.apache.hadoop.fs.s3native.NativeS3FileSystem -->
  <class name="NativeS3FileSystem" extends="org.apache.hadoop.fs.FileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NativeS3FileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="NativeS3FileSystem" type="org.apache.hadoop.fs.s3native.NativeFileSystemStore"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This optional operation is not yet supported.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 If <code>f</code> is a file, this method will make a single call to S3.
 If <code>f</code> is a directory, this method will make a maximum of
 (<i>n</i> / 1000) + 2 calls to S3, where <i>n</i> is the total number of
 files and directories contained directly in <code>f</code>.
 </p>]]>
      </doc>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="rename" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setWorkingDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newDir" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Set the working directory to the given directory.]]>
      </doc>
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[<p>
 A {@link FileSystem} for reading and writing files stored on
 <a href="http://aws.amazon.com/s3">Amazon S3</a>.
 Unlike {@link org.apache.hadoop.fs.s3.S3FileSystem} this implementation
 stores files on S3 in their
 native form so they can be read by other S3 tools.
 </p>
 @see org.apache.hadoop.fs.s3.S3FileSystem]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.s3native.NativeS3FileSystem -->
  <doc>
  <![CDATA[<p>
A distributed implementation of {@link
org.apache.hadoop.fs.FileSystem} for reading and writing files on
<a href="http://aws.amazon.com/s3">Amazon S3</a>.
Unlike {@link org.apache.hadoop.fs.s3.S3FileSystem}, which is block-based,
this implementation stores
files on S3 in their native form for interoperability with other S3 tools.
</p>]]>
  </doc>
</package>
<package name="org.apache.hadoop.fs.shell">
  <!-- start class org.apache.hadoop.fs.shell.Command -->
  <class name="Command" extends="org.apache.hadoop.conf.Configured"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Command" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor]]>
      </doc>
    </constructor>
    <method name="getCommandName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the command's name excluding the leading character -]]>
      </doc>
    </method>
    <method name="run"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Execute the command on the input path
 
 @param path the input path
 @throws IOException if any error occurs]]>
      </doc>
    </method>
    <method name="runAll" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[For each source path, execute the command
 
 @return 0 if it runs successfully; -1 if it fails]]>
      </doc>
    </method>
    <field name="args" type="java.lang.String[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[An abstract class for the execution of a file system command]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.shell.Command -->
  <!-- start class org.apache.hadoop.fs.shell.CommandFormat -->
  <class name="CommandFormat" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CommandFormat" type="java.lang.String, int, int, java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[constructor]]>
      </doc>
    </constructor>
    <method name="parse" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <param name="pos" type="int"/>
      <doc>
      <![CDATA[Parse parameters starting from the given position
 
 @param args an array of input arguments
 @param pos the position at which starts to parse
 @return a list of parameters]]>
      </doc>
    </method>
    <method name="getOpt" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="option" type="java.lang.String"/>
      <doc>
      <![CDATA[Return if the option is set or not
 
 @param option String representation of an option
 @return true is the option is set; false otherwise]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Parse the args of a command and check the format of args.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.shell.CommandFormat -->
  <!-- start class org.apache.hadoop.fs.shell.Count -->
  <class name="Count" extends="org.apache.hadoop.fs.shell.Command"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Count" type="java.lang.String[], int, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor
 
 @param cmd the count command
 @param pos the starting index of the arguments]]>
      </doc>
    </constructor>
    <method name="matches" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cmd" type="java.lang.String"/>
      <doc>
      <![CDATA[Check if a command is the count command
 
 @param cmd A string representation of a command starting with "-"
 @return true if this is a count command; false otherwise]]>
      </doc>
    </method>
    <method name="getCommandName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="run"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="USAGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DESCRIPTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Count the number of directories, files, bytes, quota, and remaining quota.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.shell.Count -->
</package>
<package name="org.apache.hadoop.http">
  <!-- start interface org.apache.hadoop.http.FilterContainer -->
  <interface name="FilterContainer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="addFilter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="classname" type="java.lang.String"/>
      <param name="parameters" type="java.util.Map"/>
      <doc>
      <![CDATA[Add a filter to the container.
 @param name Filter name
 @param classname Filter class name
 @param parameters a map from parameter names to initial values]]>
      </doc>
    </method>
    <method name="addGlobalFilter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="classname" type="java.lang.String"/>
      <param name="parameters" type="java.util.Map"/>
      <doc>
      <![CDATA[Add a global filter to the container.
 @param name filter name
 @param classname filter class name
 @param parameters a map from parameter names to initial values]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A container class for javax.servlet.Filter.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.http.FilterContainer -->
  <!-- start class org.apache.hadoop.http.FilterInitializer -->
  <class name="FilterInitializer" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FilterInitializer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Initialize a javax.servlet.Filter.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.http.FilterInitializer -->
  <!-- start class org.apache.hadoop.http.HttpServer -->
  <class name="HttpServer" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.http.FilterContainer"/>
    <constructor name="HttpServer" type="java.lang.String, java.lang.String, int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Same as this(name, bindAddress, port, findPort, null);]]>
      </doc>
    </constructor>
    <constructor name="HttpServer" type="java.lang.String, java.lang.String, int, boolean, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a status server on the given port.
 The jsp scripts are taken from src/webapps/<name>.
 @param name The name of the server
 @param port The port to use on the server
 @param findPort whether the server should start at the given port and 
        increment by 1 until it finds a free port.
 @param conf Configuration]]>
      </doc>
    </constructor>
    <method name="createBaseListener" return="org.mortbay.jetty.Connector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a required listener for the Jetty instance listening on the port
 provided. This wrapper and all subclasses must create at least one
 listener.]]>
      </doc>
    </method>
    <method name="addDefaultApps"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="parent" type="org.mortbay.jetty.handler.ContextHandlerCollection"/>
      <param name="appDir" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Add default apps.
 @param appDir The application directory
 @throws IOException]]>
      </doc>
    </method>
    <method name="addDefaultServlets"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Add default servlets.]]>
      </doc>
    </method>
    <method name="addContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ctxt" type="org.mortbay.jetty.servlet.Context"/>
      <param name="isFiltered" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="addContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="pathSpec" type="java.lang.String"/>
      <param name="dir" type="java.lang.String"/>
      <param name="isFiltered" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Add a context 
 @param pathSpec The path spec for the context
 @param dir The directory containing the context
 @param isFiltered if true, the servlet is added to the filter path mapping 
 @throws IOException]]>
      </doc>
    </method>
    <method name="setAttribute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Set a value in the webapp context. These values are available to the jsp
 pages as "application.getAttribute(name)".
 @param name The name of the attribute
 @param value The value of the attribute]]>
      </doc>
    </method>
    <method name="addServlet"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="pathSpec" type="java.lang.String"/>
      <param name="clazz" type="java.lang.Class"/>
      <doc>
      <![CDATA[Add a servlet in the server.
 @param name The name of the servlet (can be passed as null)
 @param pathSpec The path spec for the servlet
 @param clazz The servlet class]]>
      </doc>
    </method>
    <method name="addInternalServlet"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="this is a temporary method">
      <param name="name" type="java.lang.String"/>
      <param name="pathSpec" type="java.lang.String"/>
      <param name="clazz" type="java.lang.Class"/>
      <doc>
      <![CDATA[Add an internal servlet in the server.
 @param name The name of the servlet (can be passed as null)
 @param pathSpec The path spec for the servlet
 @param clazz The servlet class
 @deprecated this is a temporary method]]>
      </doc>
    </method>
    <method name="addFilter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="classname" type="java.lang.String"/>
      <param name="parameters" type="java.util.Map"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="addGlobalFilter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="classname" type="java.lang.String"/>
      <param name="parameters" type="java.util.Map"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="defineFilter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="ctx" type="org.mortbay.jetty.servlet.Context"/>
      <param name="name" type="java.lang.String"/>
      <param name="classname" type="java.lang.String"/>
      <param name="parameters" type="java.util.Map"/>
      <param name="urls" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Define a filter for a context and set up default url mappings.]]>
      </doc>
    </method>
    <method name="addFilterPathMapping"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="pathSpec" type="java.lang.String"/>
      <param name="webAppCtx" type="org.mortbay.jetty.servlet.Context"/>
      <doc>
      <![CDATA[Add the path spec to the filter path mapping.
 @param pathSpec The path spec
 @param webAppCtx The WebApplicationContext to add to]]>
      </doc>
    </method>
    <method name="getAttribute" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value in the webapp context.
 @param name The name of the attribute
 @return The value of the attribute]]>
      </doc>
    </method>
    <method name="getWebAppsPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the pathname to the webapps files.
 @return the pathname as a URL
 @throws IOException if 'webapps' directory cannot be found on CLASSPATH.]]>
      </doc>
    </method>
    <method name="getPort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the port that the server is on
 @return the port]]>
      </doc>
    </method>
    <method name="setThreads"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="min" type="int"/>
      <param name="max" type="int"/>
      <doc>
      <![CDATA[Set the min, max number of worker threads (simultaneous connections).]]>
      </doc>
    </method>
    <method name="addSslListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #addSslListener(InetSocketAddress, Configuration, boolean)}">
      <param name="addr" type="java.net.InetSocketAddress"/>
      <param name="keystore" type="java.lang.String"/>
      <param name="storPass" type="java.lang.String"/>
      <param name="keyPass" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Configure an ssl listener on the server.
 @param addr address to listen on
 @param keystore location of the keystore
 @param storPass password for the keystore
 @param keyPass password for the key
 @deprecated Use {@link #addSslListener(InetSocketAddress, Configuration, boolean)}]]>
      </doc>
    </method>
    <method name="addSslListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addr" type="java.net.InetSocketAddress"/>
      <param name="sslConf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="needClientAuth" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Configure an ssl listener on the server.
 @param addr address to listen on
 @param sslConf conf to retrieve ssl options
 @param needClientAuth whether client authentication is required]]>
      </doc>
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Start the server. Does not wait for the server to start.]]>
      </doc>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[stop the server]]>
      </doc>
    </method>
    <method name="join"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="webServer" type="org.mortbay.jetty.Server"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="listener" type="org.mortbay.jetty.Connector"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="webAppContext" type="org.mortbay.jetty.webapp.WebAppContext"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="findPort" type="boolean"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="defaultContexts" type="java.util.Map"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="filterNames" type="java.util.List"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Create a Jetty embedded server to answer http requests. The primary goal
 is to serve up status information for the server.
 There are three contexts:
   "/logs/" -> points to the log directory
   "/static/" -> points to common static files (src/webapps/static)
   "/" -> the jsp server code from (src/webapps/<name>)]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.http.HttpServer -->
  <!-- start class org.apache.hadoop.http.HttpServer.StackServlet -->
  <class name="HttpServer.StackServlet" extends="javax.servlet.http.HttpServlet"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HttpServer.StackServlet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="doGet"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="javax.servlet.http.HttpServletRequest"/>
      <param name="response" type="javax.servlet.http.HttpServletResponse"/>
      <exception name="ServletException" type="javax.servlet.ServletException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A very simple servlet to serve up a text representation of the current
 stack traces. It both returns the stacks to the caller and logs them.
 Currently the stack traces are done sequentially rather than exactly the
 same data.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.http.HttpServer.StackServlet -->
</package>
<package name="org.apache.hadoop.io">
  <!-- start class org.apache.hadoop.io.AbstractMapWritable -->
  <class name="AbstractMapWritable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="AbstractMapWritable"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[constructor.]]>
      </doc>
    </constructor>
    <method name="addToMap"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <doc>
      <![CDATA[Add a Class to the maps if it is not already present.]]>
      </doc>
    </method>
    <method name="getClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="id" type="byte"/>
      <doc>
      <![CDATA[@return the Class class for the specified id]]>
      </doc>
    </method>
    <method name="getId" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <doc>
      <![CDATA[@return the id for the specified Class]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.io.Writable"/>
      <doc>
      <![CDATA[Used by child copy constructors.]]>
      </doc>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the conf]]>
      </doc>
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[@param conf the conf to set]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstract base class for MapWritable and SortedMapWritable
 
 Unlike org.apache.nutch.crawl.MapWritable, this class allows creation of
 MapWritable&lt;Writable, MapWritable&gt; so the CLASS_TO_ID and ID_TO_CLASS
 maps travel with the class instead of being static.
 
 Class ids range from 1 to 127 so there can be at most 127 distinct classes
 in any specific map instance.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.AbstractMapWritable -->
  <!-- start class org.apache.hadoop.io.ArrayFile -->
  <class name="ArrayFile" extends="org.apache.hadoop.io.MapFile"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ArrayFile"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[A dense file-based mapping from integers to values.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ArrayFile -->
  <!-- start class org.apache.hadoop.io.ArrayFile.Reader -->
  <class name="ArrayFile.Reader" extends="org.apache.hadoop.io.MapFile.Reader"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ArrayFile.Reader" type="org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct an array reader for the named file.]]>
      </doc>
    </constructor>
    <method name="seek"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Positions the reader before its <code>n</code>th value.]]>
      </doc>
    </method>
    <method name="next" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read and return the next value in the file.]]>
      </doc>
    </method>
    <method name="key" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the key associated with the most recent call to {@link
 #seek(long)}, {@link #next(Writable)}, or {@link
 #get(long,Writable)}.]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <param name="value" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the <code>n</code>th value in the file.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provide access to an existing array file.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ArrayFile.Reader -->
  <!-- start class org.apache.hadoop.io.ArrayFile.Writer -->
  <class name="ArrayFile.Writer" extends="org.apache.hadoop.io.MapFile.Writer"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ArrayFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named file for values of the named class.]]>
      </doc>
    </constructor>
    <constructor name="ArrayFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType, org.apache.hadoop.util.Progressable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named file for values of the named class.]]>
      </doc>
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Append a value to the file.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Write a new array file.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ArrayFile.Writer -->
  <!-- start class org.apache.hadoop.io.ArrayWritable -->
  <class name="ArrayWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="ArrayWritable" type="java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ArrayWritable" type="java.lang.Class, org.apache.hadoop.io.Writable[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ArrayWritable" type="java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getValueClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toArray" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="org.apache.hadoop.io.Writable[]"/>
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A Writable for arrays containing instances of a class. The elements of this
 writable must all be instances of the same class. If this writable will be
 the input for a Reducer, you will need to create a subclass that sets the
 value to be of the proper type.

 For example:
 <code>
 public class IntArrayWritable extends ArrayWritable {
   public IntArrayWritable() { 
     super(IntWritable.class); 
   }	
 }
 </code>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ArrayWritable -->
  <!-- start class org.apache.hadoop.io.BinaryComparable -->
  <class name="BinaryComparable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <constructor name="BinaryComparable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLength" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return n st bytes 0..n-1 from {#getBytes()} are valid.]]>
      </doc>
    </method>
    <method name="getBytes" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return representative byte array for this instance.]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.io.BinaryComparable"/>
      <doc>
      <![CDATA[Compare bytes from {#getBytes()}.
 @see org.apache.hadoop.io.WritableComparator#compareBytes(byte[],int,int,byte[],int,int)]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Compare bytes from {#getBytes()} to those provided.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
      <doc>
      <![CDATA[Return true if bytes from {#getBytes()} match.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a hash of the bytes returned from {#getBytes()}.
 @see org.apache.hadoop.io.WritableComparator#hashBytes(byte[],int)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface supported by {@link org.apache.hadoop.io.WritableComparable}
 types supporting ordering/permutation by a representative set of bytes.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.BinaryComparable -->
  <!-- start class org.apache.hadoop.io.BloomMapFile -->
  <class name="BloomMapFile" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BloomMapFile"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="delete"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="BLOOM_FILE_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HASH_COUNT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This class extends {@link MapFile} and provides very much the same
 functionality. However, it uses dynamic Bloom filters to provide
 quick membership test for keys, and it offers a fast version of 
 {@link Reader#get(WritableComparable, Writable)} operation, especially in
 case of sparsely populated MapFile-s.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.BloomMapFile -->
  <!-- start class org.apache.hadoop.io.BloomMapFile.Reader -->
  <class name="BloomMapFile.Reader" extends="org.apache.hadoop.io.MapFile.Reader"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BloomMapFile.Reader" type="org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="BloomMapFile.Reader" type="org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, org.apache.hadoop.conf.Configuration, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="BloomMapFile.Reader" type="org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="probablyHasKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Checks if this MapFile has the indicated key. The membership test is
 performed using a Bloom filter, so the result has always non-zero
 probability of false positives.
 @param key key to check
 @return  false iff key doesn't exist, true if key probably exists.
 @throws IOException]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="val" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fast version of the
 {@link MapFile.Reader#get(WritableComparable, Writable)} method. First
 it checks the Bloom filter for the existence of the key, and only if
 present it performs the real get operation. This yields significant
 performance improvements for get operations on sparsely populated files.]]>
      </doc>
    </method>
    <method name="getBloomFilter" return="org.apache.hadoop.util.bloom.Filter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieve the Bloom filter used by this instance of the Reader.
 @return a Bloom filter (see {@link Filter})]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.io.BloomMapFile.Reader -->
  <!-- start class org.apache.hadoop.io.BloomMapFile.Writer -->
  <class name="BloomMapFile.Writer" extends="org.apache.hadoop.io.MapFile.Writer"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BloomMapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType, org.apache.hadoop.io.compress.CompressionCodec, org.apache.hadoop.util.Progressable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="BloomMapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType, org.apache.hadoop.util.Progressable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="BloomMapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="BloomMapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType, org.apache.hadoop.io.compress.CompressionCodec, org.apache.hadoop.util.Progressable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="BloomMapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType, org.apache.hadoop.util.Progressable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="BloomMapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="BloomMapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="BloomMapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="val" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.io.BloomMapFile.Writer -->
  <!-- start class org.apache.hadoop.io.BooleanWritable -->
  <class name="BooleanWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="BooleanWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BooleanWritable" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Set the value of the BooleanWritable]]>
      </doc>
    </method>
    <method name="get" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of the BooleanWritable]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for booleans.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.BooleanWritable -->
  <!-- start class org.apache.hadoop.io.BooleanWritable.Comparator -->
  <class name="BooleanWritable.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BooleanWritable.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A Comparator optimized for BooleanWritable.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.BooleanWritable.Comparator -->
  <!-- start class org.apache.hadoop.io.BytesWritable -->
  <class name="BytesWritable" extends="org.apache.hadoop.io.BinaryComparable"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="BytesWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a zero-size sequence.]]>
      </doc>
    </constructor>
    <constructor name="BytesWritable" type="byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a BytesWritable using the byte array as the initial value.
 @param bytes This array becomes the backing storage for the object.]]>
      </doc>
    </constructor>
    <method name="getBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the data from the BytesWritable.
 @return The data is only valid between 0 and getLength() - 1.]]>
      </doc>
    </method>
    <method name="get" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #getBytes()} instead.">
      <doc>
      <![CDATA[Get the data from the BytesWritable.
 @deprecated Use {@link #getBytes()} instead.]]>
      </doc>
    </method>
    <method name="getLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current size of the buffer.]]>
      </doc>
    </method>
    <method name="getSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #getLength()} instead.">
      <doc>
      <![CDATA[Get the current size of the buffer.
 @deprecated Use {@link #getLength()} instead.]]>
      </doc>
    </method>
    <method name="setSize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Change the size of the buffer. The values in the old range are preserved
 and any new values are undefined. The capacity is changed if it is 
 necessary.
 @param size The new number of bytes]]>
      </doc>
    </method>
    <method name="getCapacity" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the capacity, which is the maximum size that could handled without
 resizing the backing storage.
 @return The number of bytes]]>
      </doc>
    </method>
    <method name="setCapacity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="new_cap" type="int"/>
      <doc>
      <![CDATA[Change the capacity of the backing storage.
 The data is preserved.
 @param new_cap The new capacity in bytes.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newData" type="org.apache.hadoop.io.BytesWritable"/>
      <doc>
      <![CDATA[Set the BytesWritable to the contents of the given newData.
 @param newData the value to set this BytesWritable to.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newData" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Set the value to a copy of the given byte range
 @param newData the new values to copy in
 @param offset the offset in newData to start at
 @param length the number of bytes to copy]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="right_obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Are the two byte sequences equal?]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Generate the stream of bytes as hex pairs separated by ' '.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A byte sequence that is usable as a key or value.
 It is resizable and distinguishes between the size of the seqeunce and
 the current capacity. The hash function is the front of the md5 of the 
 buffer. The sort order is the same as memcmp.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.BytesWritable -->
  <!-- start class org.apache.hadoop.io.BytesWritable.Comparator -->
  <class name="BytesWritable.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BytesWritable.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
      <doc>
      <![CDATA[Compare the buffers in serialized form.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A Comparator optimized for BytesWritable.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.BytesWritable.Comparator -->
  <!-- start class org.apache.hadoop.io.ByteWritable -->
  <class name="ByteWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="ByteWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ByteWritable" type="byte"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Set the value of this ByteWritable.]]>
      </doc>
    </method>
    <method name="get" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the value of this ByteWritable.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a ByteWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares two ByteWritables.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for a single byte.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ByteWritable -->
  <!-- start class org.apache.hadoop.io.ByteWritable.Comparator -->
  <class name="ByteWritable.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ByteWritable.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A Comparator optimized for ByteWritable.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ByteWritable.Comparator -->
  <!-- start interface org.apache.hadoop.io.Closeable -->
  <interface name="Closeable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="use java.io.Closeable">
    <implements name="java.io.Closeable"/>
    <doc>
    <![CDATA[@deprecated use java.io.Closeable]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.Closeable -->
  <!-- start class org.apache.hadoop.io.CompressedWritable -->
  <class name="CompressedWritable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="CompressedWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="ensureInflated"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Must be called by all methods which access fields to ensure that the data
 has been uncompressed.]]>
      </doc>
    </method>
    <method name="readFieldsCompressed"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Subclasses implement this instead of {@link #readFields(DataInput)}.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCompressed"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Subclasses implement this instead of {@link #write(DataOutput)}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A base-class for Writables which store themselves compressed and lazily
 inflate on field access.  This is useful for large objects whose fields are
 not be altered during a map or reduce operation: leaving the field data
 compressed makes copying the instance from one file to another much
 faster.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.CompressedWritable -->
  <!-- start class org.apache.hadoop.io.DataInputBuffer -->
  <class name="DataInputBuffer" extends="java.io.DataInputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DataInputBuffer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new empty buffer.]]>
      </doc>
    </constructor>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="byte[]"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Resets the data that the buffer reads.]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Resets the data that the buffer reads.]]>
      </doc>
    </method>
    <method name="getData" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPosition" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current position in the input.]]>
      </doc>
    </method>
    <method name="getLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the length of the input.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A reusable {@link DataInput} implementation that reads from an in-memory
 buffer.

 <p>This saves memory over creating a new DataInputStream and
 ByteArrayInputStream each time data is read.

 <p>Typical usage is something like the following:<pre>

 DataInputBuffer buffer = new DataInputBuffer();
 while (... loop condition ...) {
   byte[] data = ... get data ...;
   int dataLength = ... get data length ...;
   buffer.reset(data, dataLength);
   ... read buffer using DataInput methods ...
 }
 </pre>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.DataInputBuffer -->
  <!-- start class org.apache.hadoop.io.DataOutputBuffer -->
  <class name="DataOutputBuffer" extends="java.io.DataOutputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DataOutputBuffer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new empty buffer.]]>
      </doc>
    </constructor>
    <constructor name="DataOutputBuffer" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getData" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current contents of the buffer.
  Data is only valid to {@link #getLength()}.]]>
      </doc>
    </method>
    <method name="getLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the length of the valid data currently in the buffer.]]>
      </doc>
    </method>
    <method name="reset" return="org.apache.hadoop.io.DataOutputBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resets the buffer to empty.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes bytes from a DataInput directly into the buffer.]]>
      </doc>
    </method>
    <method name="writeTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write to a file stream]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A reusable {@link DataOutput} implementation that writes to an in-memory
 buffer.

 <p>This saves memory over creating a new DataOutputStream and
 ByteArrayOutputStream each time data is written.

 <p>Typical usage is something like the following:<pre>

 DataOutputBuffer buffer = new DataOutputBuffer();
 while (... loop condition ...) {
   buffer.reset();
   ... write buffer using DataOutput methods ...
   byte[] data = buffer.getData();
   int dataLength = buffer.getLength();
   ... write data to its ultimate destination ...
 }
 </pre>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.DataOutputBuffer -->
  <!-- start class org.apache.hadoop.io.DefaultStringifier -->
  <class name="DefaultStringifier" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Stringifier"/>
    <constructor name="DefaultStringifier" type="org.apache.hadoop.conf.Configuration, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="fromString" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="store"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="item" type="java.lang.Object"/>
      <param name="keyName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Stores the item in the configuration with the given keyName.
 
 @param <K>  the class of the item
 @param conf the configuration to store
 @param item the object to be stored
 @param keyName the name of the key to use
 @throws IOException : forwards Exceptions from the underlying 
 {@link Serialization} classes.]]>
      </doc>
    </method>
    <method name="load" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="keyName" type="java.lang.String"/>
      <param name="itemClass" type="java.lang.Class"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Restores the object from the configuration.
 
 @param <K> the class of the item
 @param conf the configuration to use
 @param keyName the name of the key to use
 @param itemClass the class of the item
 @return restored object
 @throws IOException : forwards Exceptions from the underlying 
 {@link Serialization} classes.]]>
      </doc>
    </method>
    <method name="storeArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="items" type="java.lang.Object[]"/>
      <param name="keyName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Stores the array of items in the configuration with the given keyName.
 
 @param <K> the class of the item
 @param conf the configuration to use 
 @param items the objects to be stored
 @param keyName the name of the key to use
 @throws IndexOutOfBoundsException if the items array is empty
 @throws IOException : forwards Exceptions from the underlying 
 {@link Serialization} classes.]]>
      </doc>
    </method>
    <method name="loadArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="keyName" type="java.lang.String"/>
      <param name="itemClass" type="java.lang.Class"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Restores the array of objects from the configuration.
 
 @param <K> the class of the item
 @param conf the configuration to use
 @param keyName the name of the key to use
 @param itemClass the class of the item
 @return restored object
 @throws IOException : forwards Exceptions from the underlying 
 {@link Serialization} classes.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[DefaultStringifier is the default implementation of the {@link Stringifier}
 interface which stringifies the objects using base64 encoding of the
 serialized version of the objects. The {@link Serializer} and
 {@link Deserializer} are obtained from the {@link SerializationFactory}.
 <br>
 DefaultStringifier offers convenience methods to store/load objects to/from
 the configuration.
 
 @param <T> the class of the objects to stringify]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.DefaultStringifier -->
  <!-- start class org.apache.hadoop.io.DoubleWritable -->
  <class name="DoubleWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="DoubleWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DoubleWritable" type="double"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
    </method>
    <method name="get" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a DoubleWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Writable for Double values.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.DoubleWritable -->
  <!-- start class org.apache.hadoop.io.DoubleWritable.Comparator -->
  <class name="DoubleWritable.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DoubleWritable.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A Comparator optimized for DoubleWritable.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.DoubleWritable.Comparator -->
  <!-- start class org.apache.hadoop.io.FloatWritable -->
  <class name="FloatWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="FloatWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FloatWritable" type="float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Set the value of this FloatWritable.]]>
      </doc>
    </method>
    <method name="get" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the value of this FloatWritable.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a FloatWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares two FloatWritables.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for floats.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.FloatWritable -->
  <!-- start class org.apache.hadoop.io.FloatWritable.Comparator -->
  <class name="FloatWritable.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FloatWritable.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A Comparator optimized for FloatWritable.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.FloatWritable.Comparator -->
  <!-- start class org.apache.hadoop.io.GenericWritable -->
  <class name="GenericWritable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="GenericWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="org.apache.hadoop.io.Writable"/>
      <doc>
      <![CDATA[Set the instance that is wrapped.
 
 @param obj]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the wrapped instance.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getTypes" return="java.lang.Class[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return all classes that may be wrapped.  Subclasses should implement this
 to return a constant array of classes.]]>
      </doc>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <doc>
    <![CDATA[A wrapper for Writable instances.
 <p>
 When two sequence files, which have same Key type but different Value
 types, are mapped out to reduce, multiple Value types is not allowed.
 In this case, this class can help you wrap instances with different types.
 </p>
 
 <p>
 Compared with <code>ObjectWritable</code>, this class is much more effective,
 because <code>ObjectWritable</code> will append the class declaration as a String 
 into the output file in every Key-Value pair.
 </p>
 
 <p>
 Generic Writable implements {@link Configurable} interface, so that it will be 
 configured by the framework. The configuration is passed to the wrapped objects
 implementing {@link Configurable} interface <i>before deserialization</i>. 
 </p>
 
 how to use it: <br>
 1. Write your own class, such as GenericObject, which extends GenericWritable.<br> 
 2. Implements the abstract method <code>getTypes()</code>, defines 
    the classes which will be wrapped in GenericObject in application.
    Attention: this classes defined in <code>getTypes()</code> method, must
    implement <code>Writable</code> interface.
 <br><br>
 
 The code looks like this:
 <blockquote><pre>
 public class GenericObject extends GenericWritable {
 
   private static Class[] CLASSES = {
               ClassType1.class, 
               ClassType2.class,
               ClassType3.class,
               };

   protected Class[] getTypes() {
       return CLASSES;
   }

 }
 </pre></blockquote>
 
 @since Nov 8, 2006]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.GenericWritable -->
  <!-- start class org.apache.hadoop.io.InputBuffer -->
  <class name="InputBuffer" extends="java.io.FilterInputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InputBuffer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new empty buffer.]]>
      </doc>
    </constructor>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="byte[]"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Resets the data that the buffer reads.]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Resets the data that the buffer reads.]]>
      </doc>
    </method>
    <method name="getPosition" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current position in the input.]]>
      </doc>
    </method>
    <method name="getLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the length of the input.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A reusable {@link InputStream} implementation that reads from an in-memory
 buffer.

 <p>This saves memory over creating a new InputStream and
 ByteArrayInputStream each time data is read.

 <p>Typical usage is something like the following:<pre>

 InputBuffer buffer = new InputBuffer();
 while (... loop condition ...) {
   byte[] data = ... get data ...;
   int dataLength = ... get data length ...;
   buffer.reset(data, dataLength);
   ... read buffer using InputStream methods ...
 }
 </pre>
 @see DataInputBuffer
 @see DataOutput]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.InputBuffer -->
  <!-- start class org.apache.hadoop.io.IntWritable -->
  <class name="IntWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="IntWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="IntWritable" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Set the value of this IntWritable.]]>
      </doc>
    </method>
    <method name="get" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the value of this IntWritable.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a IntWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares two IntWritables.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for ints.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.IntWritable -->
  <!-- start class org.apache.hadoop.io.IntWritable.Comparator -->
  <class name="IntWritable.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="IntWritable.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A Comparator optimized for IntWritable.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.IntWritable.Comparator -->
  <!-- start class org.apache.hadoop.io.IOUtils -->
  <class name="IOUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="IOUtils"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="copyBytes"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="out" type="java.io.OutputStream"/>
      <param name="buffSize" type="int"/>
      <param name="close" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies from one stream to another.
 @param in InputStrem to read from
 @param out OutputStream to write to
 @param buffSize the size of the buffer 
 @param close whether or not close the InputStream and 
 OutputStream at the end. The streams are closed in the finally clause.]]>
      </doc>
    </method>
    <method name="copyBytes"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="out" type="java.io.OutputStream"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies from one stream to another. <strong>closes the input and output streams 
 at the end</strong>.
 @param in InputStrem to read from
 @param out OutputStream to write to
 @param conf the Configuration object]]>
      </doc>
    </method>
    <method name="copyBytes"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="out" type="java.io.OutputStream"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="close" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies from one stream to another.
 @param in InputStrem to read from
 @param out OutputStream to write to
 @param conf the Configuration object
 @param close whether or not close the InputStream and 
 OutputStream at the end. The streams are closed in the finally clause.]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="buf" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads len bytes in a loop.
 @param in The InputStream to read from
 @param buf The buffer to fill
 @param off offset from the buffer
 @param len the length of bytes to read
 @throws IOException if it could not read requested number of bytes 
 for any reason (including EOF)]]>
      </doc>
    </method>
    <method name="skipFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="len" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Similar to readFully(). Skips bytes in a loop.
 @param in The InputStream to skip bytes from
 @param len number of bytes to skip.
 @throws IOException if it could not skip requested number of bytes 
 for any reason (including EOF)]]>
      </doc>
    </method>
    <method name="cleanup"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="log" type="org.apache.commons.logging.Log"/>
      <param name="closeables" type="java.io.Closeable[]"/>
      <doc>
      <![CDATA[Close the Closeable objects and <b>ignore</b> any {@link IOException} or 
 null pointers. Must only be used for cleanup in exception handlers.
 @param log the log to record problems to at debug level. Can be null.
 @param closeables the objects to close]]>
      </doc>
    </method>
    <method name="closeStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.Closeable"/>
      <doc>
      <![CDATA[Closes the stream ignoring {@link IOException}.
 Must only be called in cleaning up from exception handlers.
 @param stream the Stream to close]]>
      </doc>
    </method>
    <method name="closeSocket"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sock" type="java.net.Socket"/>
      <doc>
      <![CDATA[Closes the socket ignoring {@link IOException} 
 @param sock the Socket to close]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An utility class for I/O related functionality.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.IOUtils -->
  <!-- start class org.apache.hadoop.io.IOUtils.NullOutputStream -->
  <class name="IOUtils.NullOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="IOUtils.NullOutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[/dev/null of OutputStreams.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.IOUtils.NullOutputStream -->
  <!-- start class org.apache.hadoop.io.LongWritable -->
  <class name="LongWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="LongWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LongWritable" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Set the value of this LongWritable.]]>
      </doc>
    </method>
    <method name="get" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the value of this LongWritable.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a LongWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares two LongWritables.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for longs.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.LongWritable -->
  <!-- start class org.apache.hadoop.io.LongWritable.Comparator -->
  <class name="LongWritable.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LongWritable.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A Comparator optimized for LongWritable.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.LongWritable.Comparator -->
  <!-- start class org.apache.hadoop.io.LongWritable.DecreasingComparator -->
  <class name="LongWritable.DecreasingComparator" extends="org.apache.hadoop.io.LongWritable.Comparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LongWritable.DecreasingComparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="b" type="org.apache.hadoop.io.WritableComparable"/>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A decreasing Comparator optimized for LongWritable.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.LongWritable.DecreasingComparator -->
  <!-- start class org.apache.hadoop.io.MapFile -->
  <class name="MapFile" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MapFile"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="rename"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="oldName" type="java.lang.String"/>
      <param name="newName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Renames an existing map directory.]]>
      </doc>
    </method>
    <method name="delete"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deletes the named map file.]]>
      </doc>
    </method>
    <method name="fix" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dir" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valueClass" type="java.lang.Class"/>
      <param name="dryrun" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[This method attempts to fix a corrupt MapFile by re-creating its index.
 @param fs filesystem
 @param dir directory containing the MapFile data and index
 @param keyClass key class (has to be a subclass of Writable)
 @param valueClass value class (has to be a subclass of Writable)
 @param dryrun do not perform any changes, just report what needs to be done
 @return number of valid entries in this MapFile, or -1 if no fixing was needed
 @throws Exception]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <field name="INDEX_FILE_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The name of the index file.]]>
      </doc>
    </field>
    <field name="DATA_FILE_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The name of the data file.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A file-based map from keys to values.
 
 <p>A map is a directory containing two files, the <code>data</code> file,
 containing all keys and values in the map, and a smaller <code>index</code>
 file, containing a fraction of the keys.  The fraction is determined by
 {@link Writer#getIndexInterval()}.

 <p>The index file is read entirely into memory.  Thus key implementations
 should try to keep themselves small.

 <p>Map files are created by adding entries in-order.  To maintain a large
 database, perform updates by copying the previous version of a database and
 merging in a sorted change list, to create a new version of the database in
 a new file.  Sorting large change lists can be done with {@link
 SequenceFile.Sorter}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.MapFile -->
  <!-- start class org.apache.hadoop.io.MapFile.Reader -->
  <class name="MapFile.Reader" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="MapFile.Reader" type="org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a map reader for the named map.]]>
      </doc>
    </constructor>
    <constructor name="MapFile.Reader" type="org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a map reader for the named map using the named comparator.]]>
      </doc>
    </constructor>
    <constructor name="MapFile.Reader" type="org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, org.apache.hadoop.conf.Configuration, boolean"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Hook to allow subclasses to defer opening streams until further
 initialization is complete.
 @see #createDataFileReader(FileSystem, Path, Configuration)]]>
      </doc>
    </constructor>
    <method name="getKeyClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the class of keys in this file.]]>
      </doc>
    </method>
    <method name="getValueClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the class of values in this file.]]>
      </doc>
    </method>
    <method name="open"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dirName" type="java.lang.String"/>
      <param name="comparator" type="org.apache.hadoop.io.WritableComparator"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createDataFileReader" return="org.apache.hadoop.io.SequenceFile.Reader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dataFile" type="org.apache.hadoop.fs.Path"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Override this method to specialize the type of
 {@link SequenceFile.Reader} returned.]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Re-positions the reader before its first key.]]>
      </doc>
    </method>
    <method name="midKey" return="org.apache.hadoop.io.WritableComparable"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the key at approximately the middle of the file.
 
 @throws IOException]]>
      </doc>
    </method>
    <method name="finalKey"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads the final key from the file.

 @param key key to read into]]>
      </doc>
    </method>
    <method name="seek" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Positions the reader at the named key, or if none such exists, at the
 first entry after the named key.  Returns true iff the named key exists
 in this map.]]>
      </doc>
    </method>
    <method name="next" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="val" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read the next key/value pair in the map into <code>key</code> and
 <code>val</code>.  Returns true if such a pair exists and false when at
 the end of the map]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="val" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the value for the named key, or null if none exists.]]>
      </doc>
    </method>
    <method name="getClosest" return="org.apache.hadoop.io.WritableComparable"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="val" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Finds the record that is the closest match to the specified key.
 Returns <code>key</code> or if it does not exist, at the first entry
 after the named key.
 
-     * @param key       - key that we're trying to find
-     * @param val       - data value if key is found
-     * @return          - the key that was the closest match or null if eof.]]>
      </doc>
    </method>
    <method name="getClosest" return="org.apache.hadoop.io.WritableComparable"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="val" type="org.apache.hadoop.io.Writable"/>
      <param name="before" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Finds the record that is the closest match to the specified key.
 
 @param key       - key that we're trying to find
 @param val       - data value if key is found
 @param before    - IF true, and <code>key</code> does not exist, return
 the first entry that falls just before the <code>key</code>.  Otherwise,
 return the record that sorts just after.
 @return          - the key that was the closest match or null if eof.]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close the map.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provide access to an existing map.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.MapFile.Reader -->
  <!-- start class org.apache.hadoop.io.MapFile.Writer -->
  <class name="MapFile.Writer" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="MapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named map for keys of the named class.]]>
      </doc>
    </constructor>
    <constructor name="MapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType, org.apache.hadoop.util.Progressable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named map for keys of the named class.]]>
      </doc>
    </constructor>
    <constructor name="MapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType, org.apache.hadoop.io.compress.CompressionCodec, org.apache.hadoop.util.Progressable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named map for keys of the named class.]]>
      </doc>
    </constructor>
    <constructor name="MapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named map for keys of the named class.]]>
      </doc>
    </constructor>
    <constructor name="MapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named map using the named key comparator.]]>
      </doc>
    </constructor>
    <constructor name="MapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named map using the named key comparator.]]>
      </doc>
    </constructor>
    <constructor name="MapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType, org.apache.hadoop.util.Progressable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named map using the named key comparator.]]>
      </doc>
    </constructor>
    <constructor name="MapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType, org.apache.hadoop.io.compress.CompressionCodec, org.apache.hadoop.util.Progressable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named map using the named key comparator.]]>
      </doc>
    </constructor>
    <method name="getIndexInterval" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of entries that are added before an index entry is added.]]>
      </doc>
    </method>
    <method name="setIndexInterval"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interval" type="int"/>
      <doc>
      <![CDATA[Sets the index interval.
 @see #getIndexInterval()]]>
      </doc>
    </method>
    <method name="setIndexInterval"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="interval" type="int"/>
      <doc>
      <![CDATA[Sets the index interval and stores it in conf
 @see #getIndexInterval()]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close the map.]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="val" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Append a key/value pair to the map.  The key must be greater or equal
 to the previous key added to the map.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Writes a new map.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.MapFile.Writer -->
  <!-- start class org.apache.hadoop.io.MapWritable -->
  <class name="MapWritable" extends="org.apache.hadoop.io.AbstractMapWritable"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map"/>
    <constructor name="MapWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.]]>
      </doc>
    </constructor>
    <constructor name="MapWritable" type="org.apache.hadoop.io.MapWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Copy constructor.
 
 @param other the map to copy from]]>
      </doc>
    </constructor>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="entrySet" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="keySet" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="put" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.Writable"/>
      <param name="value" type="org.apache.hadoop.io.Writable"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.util.Map"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="remove" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="values" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A Writable Map.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.MapWritable -->
  <!-- start class org.apache.hadoop.io.MD5Hash -->
  <class name="MD5Hash" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="MD5Hash"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an MD5Hash.]]>
      </doc>
    </constructor>
    <constructor name="MD5Hash" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an MD5Hash from a hex string.]]>
      </doc>
    </constructor>
    <constructor name="MD5Hash" type="byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an MD5Hash with a specified value.]]>
      </doc>
    </constructor>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="org.apache.hadoop.io.MD5Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Constructs, reads and returns an instance.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="that" type="org.apache.hadoop.io.MD5Hash"/>
      <doc>
      <![CDATA[Copy the contents of another instance into this instance.]]>
      </doc>
    </method>
    <method name="getDigest" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the digest bytes.]]>
      </doc>
    </method>
    <method name="digest" return="org.apache.hadoop.io.MD5Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="byte[]"/>
      <doc>
      <![CDATA[Construct a hash value for a byte array.]]>
      </doc>
    </method>
    <method name="digest" return="org.apache.hadoop.io.MD5Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a hash value for the content from the InputStream.]]>
      </doc>
    </method>
    <method name="digest" return="org.apache.hadoop.io.MD5Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Construct a hash value for a byte array.]]>
      </doc>
    </method>
    <method name="digest" return="org.apache.hadoop.io.MD5Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Construct a hash value for a String.]]>
      </doc>
    </method>
    <method name="digest" return="org.apache.hadoop.io.MD5Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="org.apache.hadoop.io.UTF8"/>
      <doc>
      <![CDATA[Construct a hash value for a String.]]>
      </doc>
    </method>
    <method name="halfDigest" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a half-sized version of this MD5.  Fits in a long]]>
      </doc>
    </method>
    <method name="quarterDigest" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a 32-bit digest of the MD5.
 @return the first 4 bytes of the md5]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is an MD5Hash whose digest contains the
 same values.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash code value for this object.
 Only uses the first 4 bytes, since md5s are evenly distributed.]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="that" type="org.apache.hadoop.io.MD5Hash"/>
      <doc>
      <![CDATA[Compares this object with the specified object for order.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of this object.]]>
      </doc>
    </method>
    <method name="setDigest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hex" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the digest value from a hex string.]]>
      </doc>
    </method>
    <field name="MD5_LEN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A Writable for MD5 hash values.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.MD5Hash -->
  <!-- start class org.apache.hadoop.io.MD5Hash.Comparator -->
  <class name="MD5Hash.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MD5Hash.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A WritableComparator optimized for MD5Hash keys.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.MD5Hash.Comparator -->
  <!-- start class org.apache.hadoop.io.MultipleIOException -->
  <class name="MultipleIOException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getExceptions" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the underlying exceptions]]>
      </doc>
    </method>
    <method name="createIOException" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exceptions" type="java.util.List"/>
      <doc>
      <![CDATA[A convenient method to create an {@link IOException}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Encapsulate a list of {@link IOException} into an {@link IOException}]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.MultipleIOException -->
  <!-- start class org.apache.hadoop.io.NullWritable -->
  <class name="NullWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <method name="get" return="org.apache.hadoop.io.NullWritable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the single instance of this class.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Singleton Writable with no data.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.NullWritable -->
  <!-- start class org.apache.hadoop.io.NullWritable.Comparator -->
  <class name="NullWritable.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NullWritable.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
      <doc>
      <![CDATA[Compare the buffers in serialized form.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A Comparator &quot;optimized&quot; for NullWritable.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.NullWritable.Comparator -->
  <!-- start class org.apache.hadoop.io.ObjectWritable -->
  <class name="ObjectWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="ObjectWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectWritable" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectWritable" type="java.lang.Class, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the instance, or null if none.]]>
      </doc>
    </method>
    <method name="getDeclaredClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the class this is meant to be.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[Reset the instance.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeObject"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="instance" type="java.lang.Object"/>
      <param name="declaredClass" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a {@link Writable}, {@link String}, primitive type, or an array of
 the preceding.]]>
      </doc>
    </method>
    <method name="readObject" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a {@link Writable}, {@link String}, primitive type, or an array of
 the preceding.]]>
      </doc>
    </method>
    <method name="readObject" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="objectWritable" type="org.apache.hadoop.io.ObjectWritable"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a {@link Writable}, {@link String}, primitive type, or an array of
 the preceding.]]>
      </doc>
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A polymorphic Writable that writes an instance with it's class name.
 Handles arrays, strings and primitive types without a Writable wrapper.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ObjectWritable -->
  <!-- start class org.apache.hadoop.io.OutputBuffer -->
  <class name="OutputBuffer" extends="java.io.FilterOutputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="OutputBuffer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new empty buffer.]]>
      </doc>
    </constructor>
    <method name="getData" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current contents of the buffer.
  Data is only valid to {@link #getLength()}.]]>
      </doc>
    </method>
    <method name="getLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the length of the valid data currently in the buffer.]]>
      </doc>
    </method>
    <method name="reset" return="org.apache.hadoop.io.OutputBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resets the buffer to empty.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes bytes from a InputStream directly into the buffer.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A reusable {@link OutputStream} implementation that writes to an in-memory
 buffer.

 <p>This saves memory over creating a new OutputStream and
 ByteArrayOutputStream each time data is written.

 <p>Typical usage is something like the following:<pre>

 OutputBuffer buffer = new OutputBuffer();
 while (... loop condition ...) {
   buffer.reset();
   ... write buffer using OutputStream methods ...
   byte[] data = buffer.getData();
   int dataLength = buffer.getLength();
   ... write data to its ultimate destination ...
 }
 </pre>
 @see DataOutputBuffer
 @see InputBuffer]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.OutputBuffer -->
  <!-- start interface org.apache.hadoop.io.RawComparator -->
  <interface name="RawComparator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Comparator"/>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[<p>
 A {@link Comparator} that operates directly on byte representations of
 objects.
 </p>
 @param <T>
 @see DeserializerComparator]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.RawComparator -->
  <!-- start class org.apache.hadoop.io.SequenceFile -->
  <class name="SequenceFile" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getCompressionType" return="org.apache.hadoop.io.SequenceFile.CompressionType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use 
             {@link org.apache.hadoop.mapred.SequenceFileOutputFormat#getOutputCompressionType(org.apache.hadoop.mapred.JobConf)} 
             to get {@link CompressionType} for job-outputs.">
      <param name="job" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the compression type for the reduce outputs
 @param job the job config to look in
 @return the kind of compression to use
 @deprecated Use 
             {@link org.apache.hadoop.mapred.SequenceFileOutputFormat#getOutputCompressionType(org.apache.hadoop.mapred.JobConf)} 
             to get {@link CompressionType} for job-outputs.]]>
      </doc>
    </method>
    <method name="setCompressionType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use the one of the many SequenceFile.createWriter methods to specify
             the {@link CompressionType} while creating the {@link SequenceFile} or
             {@link org.apache.hadoop.mapred.SequenceFileOutputFormat#setOutputCompressionType(org.apache.hadoop.mapred.JobConf, org.apache.hadoop.io.SequenceFile.CompressionType)}
             to specify the {@link CompressionType} for job-outputs. 
 or">
      <param name="job" type="org.apache.hadoop.conf.Configuration"/>
      <param name="val" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <doc>
      <![CDATA[Set the compression type for sequence files.
 @param job the configuration to modify
 @param val the new compression type (none, block, record)
 @deprecated Use the one of the many SequenceFile.createWriter methods to specify
             the {@link CompressionType} while creating the {@link SequenceFile} or
             {@link org.apache.hadoop.mapred.SequenceFileOutputFormat#setOutputCompressionType(org.apache.hadoop.mapred.JobConf, org.apache.hadoop.io.SequenceFile.CompressionType)}
             to specify the {@link CompressionType} for job-outputs. 
 or]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem. 
 @param conf The configuration.
 @param name The name of the file. 
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem. 
 @param conf The configuration.
 @param name The name of the file. 
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem. 
 @param conf The configuration.
 @param name The name of the file. 
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @param progress The Progressable object to track progress.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem. 
 @param conf The configuration.
 @param name The name of the file. 
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @param codec The compression codec.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="metadata" type="org.apache.hadoop.io.SequenceFile.Metadata"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem. 
 @param conf The configuration.
 @param name The name of the file. 
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @param codec The compression codec.
 @param progress The Progressable object to track progress.
 @param metadata The metadata of the file.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="metadata" type="org.apache.hadoop.io.SequenceFile.Metadata"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem.
 @param conf The configuration.
 @param name The name of the file.
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param bufferSize buffer size for the underlaying outputstream.
 @param replication replication factor for the file.
 @param blockSize block size for the file.
 @param compressionType The compression type.
 @param codec The compression codec.
 @param progress The Progressable object to track progress.
 @param metadata The metadata of the file.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem. 
 @param conf The configuration.
 @param name The name of the file. 
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @param codec The compression codec.
 @param progress The Progressable object to track progress.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="out" type="org.apache.hadoop.fs.FSDataOutputStream"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <param name="metadata" type="org.apache.hadoop.io.SequenceFile.Metadata"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of 'raw' SequenceFile Writer.
 @param conf The configuration.
 @param out The stream on top which the writer is to be constructed.
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @param codec The compression codec.
 @param metadata The metadata of the file.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="out" type="org.apache.hadoop.fs.FSDataOutputStream"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of 'raw' SequenceFile Writer.
 @param conf The configuration.
 @param out The stream on top which the writer is to be constructed.
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @param codec The compression codec.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException]]>
      </doc>
    </method>
    <field name="SYNC_INTERVAL" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes between sync points.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[<code>SequenceFile</code>s are flat files consisting of binary key/value 
 pairs.
 
 <p><code>SequenceFile</code> provides {@link Writer}, {@link Reader} and
 {@link Sorter} classes for writing, reading and sorting respectively.</p>
 
 There are three <code>SequenceFile</code> <code>Writer</code>s based on the 
 {@link CompressionType} used to compress key/value pairs:
 <ol>
   <li>
   <code>Writer</code> : Uncompressed records.
   </li>
   <li>
   <code>RecordCompressWriter</code> : Record-compressed files, only compress 
                                       values.
   </li>
   <li>
   <code>BlockCompressWriter</code> : Block-compressed files, both keys & 
                                      values are collected in 'blocks' 
                                      separately and compressed. The size of 
                                      the 'block' is configurable.
 </ol>
 
 <p>The actual compression algorithm used to compress key and/or values can be
 specified by using the appropriate {@link CompressionCodec}.</p>
 
 <p>The recommended way is to use the static <tt>createWriter</tt> methods
 provided by the <code>SequenceFile</code> to chose the preferred format.</p>

 <p>The {@link Reader} acts as the bridge and can read any of the above 
 <code>SequenceFile</code> formats.</p>

 <h4 id="Formats">SequenceFile Formats</h4>
 
 <p>Essentially there are 3 different formats for <code>SequenceFile</code>s
 depending on the <code>CompressionType</code> specified. All of them share a
 <a href="#Header">common header</a> described below.
 
 <h5 id="Header">SequenceFile Header</h5>
 <ul>
   <li>
   version - 3 bytes of magic header <b>SEQ</b>, followed by 1 byte of actual 
             version number (e.g. SEQ4 or SEQ6)
   </li>
   <li>
   keyClassName -key class
   </li>
   <li>
   valueClassName - value class
   </li>
   <li>
   compression - A boolean which specifies if compression is turned on for 
                 keys/values in this file.
   </li>
   <li>
   blockCompression - A boolean which specifies if block-compression is 
                      turned on for keys/values in this file.
   </li>
   <li>
   compression codec - <code>CompressionCodec</code> class which is used for  
                       compression of keys and/or values (if compression is 
                       enabled).
   </li>
   <li>
   metadata - {@link Metadata} for this file.
   </li>
   <li>
   sync - A sync marker to denote end of the header.
   </li>
 </ul>
 
 <h5 id="#UncompressedFormat">Uncompressed SequenceFile Format</h5>
 <ul>
 <li>
 <a href="#Header">Header</a>
 </li>
 <li>
 Record
   <ul>
     <li>Record length</li>
     <li>Key length</li>
     <li>Key</li>
     <li>Value</li>
   </ul>
 </li>
 <li>
 A sync-marker every few <code>100</code> bytes or so.
 </li>
 </ul>

 <h5 id="#RecordCompressedFormat">Record-Compressed SequenceFile Format</h5>
 <ul>
 <li>
 <a href="#Header">Header</a>
 </li>
 <li>
 Record
   <ul>
     <li>Record length</li>
     <li>Key length</li>
     <li>Key</li>
     <li><i>Compressed</i> Value</li>
   </ul>
 </li>
 <li>
 A sync-marker every few <code>100</code> bytes or so.
 </li>
 </ul>
 
 <h5 id="#BlockCompressedFormat">Block-Compressed SequenceFile Format</h5>
 <ul>
 <li>
 <a href="#Header">Header</a>
 </li>
 <li>
 Record <i>Block</i>
   <ul>
     <li>Compressed key-lengths block-size</li>
     <li>Compressed key-lengths block</li>
     <li>Compressed keys block-size</li>
     <li>Compressed keys block</li>
     <li>Compressed value-lengths block-size</li>
     <li>Compressed value-lengths block</li>
     <li>Compressed values block-size</li>
     <li>Compressed values block</li>
   </ul>
 </li>
 <li>
 A sync-marker every few <code>100</code> bytes or so.
 </li>
 </ul>
 
 <p>The compressed blocks of key lengths and value lengths consist of the 
 actual lengths of individual keys/values encoded in ZeroCompressedInteger 
 format.</p>
 
 @see CompressionCodec]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SequenceFile -->
  <!-- start class org.apache.hadoop.io.SequenceFile.CompressionType -->
  <class name="SequenceFile.CompressionType" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.io.SequenceFile.CompressionType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.io.SequenceFile.CompressionType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="NONE" type="org.apache.hadoop.io.SequenceFile.CompressionType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Do not compress records.]]>
      </doc>
    </field>
    <field name="RECORD" type="org.apache.hadoop.io.SequenceFile.CompressionType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Compress values only, each separately.]]>
      </doc>
    </field>
    <field name="BLOCK" type="org.apache.hadoop.io.SequenceFile.CompressionType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Compress sequences of records together in blocks.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[The compression type used to compress key/value pairs in the 
 {@link SequenceFile}.
 
 @see SequenceFile.Writer]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SequenceFile.CompressionType -->
  <!-- start class org.apache.hadoop.io.SequenceFile.Metadata -->
  <class name="SequenceFile.Metadata" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="SequenceFile.Metadata"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SequenceFile.Metadata" type="java.util.TreeMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="org.apache.hadoop.io.Text"/>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="org.apache.hadoop.io.Text"/>
      <param name="value" type="org.apache.hadoop.io.Text"/>
    </method>
    <method name="getMetadata" return="java.util.TreeMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.io.SequenceFile.Metadata"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[The class encapsulating with the metadata of a file.
 The metadata of a file is a list of attribute name/value
 pairs of Text type.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SequenceFile.Metadata -->
  <!-- start class org.apache.hadoop.io.SequenceFile.Reader -->
  <class name="SequenceFile.Reader" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="SequenceFile.Reader" type="org.apache.hadoop.fs.FileSystem, org.apache.hadoop.fs.Path, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Open the named file.]]>
      </doc>
    </constructor>
    <method name="openFile" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="length" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Override this method to specialize the type of
 {@link FSDataInputStream} returned.]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close the file.]]>
      </doc>
    </method>
    <method name="getKeyClassName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of the key class.]]>
      </doc>
    </method>
    <method name="getKeyClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the class of keys in this file.]]>
      </doc>
    </method>
    <method name="getValueClassName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of the value class.]]>
      </doc>
    </method>
    <method name="getValueClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the class of values in this file.]]>
      </doc>
    </method>
    <method name="isCompressed" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if values are compressed.]]>
      </doc>
    </method>
    <method name="isBlockCompressed" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if records are block-compressed.]]>
      </doc>
    </method>
    <method name="getCompressionCodec" return="org.apache.hadoop.io.compress.CompressionCodec"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the compression codec of data in this file.]]>
      </doc>
    </method>
    <method name="getMetadata" return="org.apache.hadoop.io.SequenceFile.Metadata"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the metadata object of the file]]>
      </doc>
    </method>
    <method name="getCurrentValue"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the 'value' corresponding to the last read 'key'.
 @param val : The 'value' to be read.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getCurrentValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the 'value' corresponding to the last read 'key'.
 @param val : The 'value' to be read.
 @throws IOException]]>
      </doc>
    </method>
    <method name="next" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read the next key in the file into <code>key</code>, skipping its
 value.  True if another entry exists, and false at end of file.]]>
      </doc>
    </method>
    <method name="next" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.Writable"/>
      <param name="val" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read the next key/value pair in the file into <code>key</code> and
 <code>val</code>.  Returns true if such a pair exists and false when at
 end of file]]>
      </doc>
    </method>
    <method name="next" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="Call {@link #nextRaw(DataOutputBuffer,SequenceFile.ValueBytes)}.">
      <param name="buffer" type="org.apache.hadoop.io.DataOutputBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@deprecated Call {@link #nextRaw(DataOutputBuffer,SequenceFile.ValueBytes)}.]]>
      </doc>
    </method>
    <method name="createValueBytes" return="org.apache.hadoop.io.SequenceFile.ValueBytes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="nextRaw" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.DataOutputBuffer"/>
      <param name="val" type="org.apache.hadoop.io.SequenceFile.ValueBytes"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read 'raw' records.
 @param key - The buffer into which the key is read
 @param val - The 'raw' value
 @return Returns the total record length or -1 for end of file
 @throws IOException]]>
      </doc>
    </method>
    <method name="nextRawKey" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.DataOutputBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read 'raw' keys.
 @param key - The buffer into which the key is read
 @return Returns the key length or -1 for end of file
 @throws IOException]]>
      </doc>
    </method>
    <method name="next" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read the next key in the file, skipping its
 value.  Return null at end of file.]]>
      </doc>
    </method>
    <method name="nextRawValue" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="org.apache.hadoop.io.SequenceFile.ValueBytes"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read 'raw' values.
 @param val - The 'raw' value
 @return Returns the value length
 @throws IOException]]>
      </doc>
    </method>
    <method name="seek"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the current byte position in the input file.

 <p>The position passed must be a position returned by {@link
 SequenceFile.Writer#getLength()} when writing this file.  To seek to an arbitrary
 position, use {@link SequenceFile.Reader#sync(long)}.]]>
      </doc>
    </method>
    <method name="sync"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Seek to the next sync mark past a given position.]]>
      </doc>
    </method>
    <method name="syncSeen" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true iff the previous call to next passed a sync mark.]]>
      </doc>
    </method>
    <method name="getPosition" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the current byte position in the input file.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of the file.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Reads key/value pairs from a sequence-format file.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SequenceFile.Reader -->
  <!-- start class org.apache.hadoop.io.SequenceFile.Sorter -->
  <class name="SequenceFile.Sorter" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SequenceFile.Sorter" type="org.apache.hadoop.fs.FileSystem, java.lang.Class, java.lang.Class, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sort and merge files containing the named classes.]]>
      </doc>
    </constructor>
    <constructor name="SequenceFile.Sorter" type="org.apache.hadoop.fs.FileSystem, org.apache.hadoop.io.RawComparator, java.lang.Class, java.lang.Class, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sort and merge using an arbitrary {@link RawComparator}.]]>
      </doc>
    </constructor>
    <method name="setFactor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="factor" type="int"/>
      <doc>
      <![CDATA[Set the number of streams to merge at once.]]>
      </doc>
    </method>
    <method name="getFactor" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the number of streams to merge at once.]]>
      </doc>
    </method>
    <method name="setMemory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="memory" type="int"/>
      <doc>
      <![CDATA[Set the total amount of buffer memory, in bytes.]]>
      </doc>
    </method>
    <method name="getMemory" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the total amount of buffer memory, in bytes.]]>
      </doc>
    </method>
    <method name="setProgressable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="progressable" type="org.apache.hadoop.util.Progressable"/>
      <doc>
      <![CDATA[Set the progressable object in order to report progress.]]>
      </doc>
    </method>
    <method name="sort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inFiles" type="org.apache.hadoop.fs.Path[]"/>
      <param name="outFile" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteInput" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Perform a file sort from a set of input files into an output file.
 @param inFiles the files to be sorted
 @param outFile the sorted output file
 @param deleteInput should the input files be deleted as they are read?]]>
      </doc>
    </method>
    <method name="sortAndIterate" return="org.apache.hadoop.io.SequenceFile.Sorter.RawKeyValueIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inFiles" type="org.apache.hadoop.fs.Path[]"/>
      <param name="tempDir" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteInput" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Perform a file sort from a set of input files and return an iterator.
 @param inFiles the files to be sorted
 @param tempDir the directory where temp files are created during sort
 @param deleteInput should the input files be deleted as they are read?
 @return iterator the RawKeyValueIterator]]>
      </doc>
    </method>
    <method name="sort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inFile" type="org.apache.hadoop.fs.Path"/>
      <param name="outFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The backwards compatible interface to sort.
 @param inFile the input file to sort
 @param outFile the sorted output file]]>
      </doc>
    </method>
    <method name="merge" return="org.apache.hadoop.io.SequenceFile.Sorter.RawKeyValueIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="segments" type="java.util.List"/>
      <param name="tmpDir" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Merges the list of segments of type <code>SegmentDescriptor</code>
 @param segments the list of SegmentDescriptors
 @param tmpDir the directory to write temporary files into
 @return RawKeyValueIterator
 @throws IOException]]>
      </doc>
    </method>
    <method name="merge" return="org.apache.hadoop.io.SequenceFile.Sorter.RawKeyValueIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inNames" type="org.apache.hadoop.fs.Path[]"/>
      <param name="deleteInputs" type="boolean"/>
      <param name="tmpDir" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Merges the contents of files passed in Path[] using a max factor value
 that is already set
 @param inNames the array of path names
 @param deleteInputs true if the input files should be deleted when 
 unnecessary
 @param tmpDir the directory to write temporary files into
 @return RawKeyValueIteratorMergeQueue
 @throws IOException]]>
      </doc>
    </method>
    <method name="merge" return="org.apache.hadoop.io.SequenceFile.Sorter.RawKeyValueIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inNames" type="org.apache.hadoop.fs.Path[]"/>
      <param name="deleteInputs" type="boolean"/>
      <param name="factor" type="int"/>
      <param name="tmpDir" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Merges the contents of files passed in Path[]
 @param inNames the array of path names
 @param deleteInputs true if the input files should be deleted when 
 unnecessary
 @param factor the factor that will be used as the maximum merge fan-in
 @param tmpDir the directory to write temporary files into
 @return RawKeyValueIteratorMergeQueue
 @throws IOException]]>
      </doc>
    </method>
    <method name="merge" return="org.apache.hadoop.io.SequenceFile.Sorter.RawKeyValueIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inNames" type="org.apache.hadoop.fs.Path[]"/>
      <param name="tempDir" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteInputs" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Merges the contents of files passed in Path[]
 @param inNames the array of path names
 @param tempDir the directory for creating temp files during merge
 @param deleteInputs true if the input files should be deleted when 
 unnecessary
 @return RawKeyValueIteratorMergeQueue
 @throws IOException]]>
      </doc>
    </method>
    <method name="cloneFileAttributes" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="outputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="prog" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Clones the attributes (like compression of the input file and creates a 
 corresponding Writer
 @param inputFile the path of the input file whose attributes should be 
 cloned
 @param outputFile the path of the output file 
 @param prog the Progressable to report status during the file write
 @return Writer
 @throws IOException]]>
      </doc>
    </method>
    <method name="writeFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="records" type="org.apache.hadoop.io.SequenceFile.Sorter.RawKeyValueIterator"/>
      <param name="writer" type="org.apache.hadoop.io.SequenceFile.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes records from RawKeyValueIterator into a file represented by the 
 passed writer
 @param records the RawKeyValueIterator
 @param writer the Writer created earlier 
 @throws IOException]]>
      </doc>
    </method>
    <method name="merge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inFiles" type="org.apache.hadoop.fs.Path[]"/>
      <param name="outFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Merge the provided files.
 @param inFiles the array of input path names
 @param outFile the final output file
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Sorts key/value pairs in a sequence-format file.

 <p>For best performance, applications should make sure that the {@link
 Writable#readFields(DataInput)} implementation of their keys is
 very efficient.  In particular, it should avoid allocating memory.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SequenceFile.Sorter -->
  <!-- start interface org.apache.hadoop.io.SequenceFile.Sorter.RawKeyValueIterator -->
  <interface name="SequenceFile.Sorter.RawKeyValueIterator"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getKey" return="org.apache.hadoop.io.DataOutputBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets the current raw key
 @return DataOutputBuffer
 @throws IOException]]>
      </doc>
    </method>
    <method name="getValue" return="org.apache.hadoop.io.SequenceFile.ValueBytes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets the current raw value
 @return ValueBytes 
 @throws IOException]]>
      </doc>
    </method>
    <method name="next" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Sets up the current key and value (for getKey and getValue)
 @return true if there exists a key/value, false otherwise 
 @throws IOException]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[closes the iterator so that the underlying streams can be closed
 @throws IOException]]>
      </doc>
    </method>
    <method name="getProgress" return="org.apache.hadoop.util.Progress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Progress object; this has a float (0.0 - 1.0) 
 indicating the bytes processed by the iterator so far]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The interface to iterate over raw keys/values of SequenceFiles.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.SequenceFile.Sorter.RawKeyValueIterator -->
  <!-- start class org.apache.hadoop.io.SequenceFile.Sorter.SegmentDescriptor -->
  <class name="SequenceFile.Sorter.SegmentDescriptor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <constructor name="SequenceFile.Sorter.SegmentDescriptor" type="long, long, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a segment
 @param segmentOffset the offset of the segment in the file
 @param segmentLength the length of the segment
 @param segmentPathName the path name of the file containing the segment]]>
      </doc>
    </constructor>
    <method name="doSync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Do the sync checks]]>
      </doc>
    </method>
    <method name="preserveInput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preserve" type="boolean"/>
      <doc>
      <![CDATA[Whether to delete the files when no longer needed]]>
      </doc>
    </method>
    <method name="shouldPreserveInput" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="nextRawKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fills up the rawKey object with the key returned by the Reader
 @return true if there is a key returned; false, otherwise
 @throws IOException]]>
      </doc>
    </method>
    <method name="nextRawValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rawValue" type="org.apache.hadoop.io.SequenceFile.ValueBytes"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fills up the passed rawValue with the value corresponding to the key
 read earlier
 @param rawValue
 @return the length of the value
 @throws IOException]]>
      </doc>
    </method>
    <method name="getKey" return="org.apache.hadoop.io.DataOutputBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the stored rawKey]]>
      </doc>
    </method>
    <method name="cleanup"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The default cleanup. Subclasses can override this with a custom 
 cleanup]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class defines a merge segment. This class can be subclassed to 
 provide a customized cleanup method implementation. In this 
 implementation, cleanup closes the file handle and deletes the file]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SequenceFile.Sorter.SegmentDescriptor -->
  <!-- start interface org.apache.hadoop.io.SequenceFile.ValueBytes -->
  <interface name="SequenceFile.ValueBytes"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="writeUncompressedBytes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="outStream" type="java.io.DataOutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the uncompressed bytes to the outStream.
 @param outStream : Stream to write uncompressed bytes into.
 @throws IOException]]>
      </doc>
    </method>
    <method name="writeCompressedBytes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="outStream" type="java.io.DataOutputStream"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write compressed bytes to outStream. 
 Note: that it will NOT compress the bytes if they are not compressed.
 @param outStream : Stream to write compressed bytes into.]]>
      </doc>
    </method>
    <method name="getSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Size of stored data.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The interface to 'raw' values of SequenceFiles.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.SequenceFile.ValueBytes -->
  <!-- start class org.apache.hadoop.io.SequenceFile.Writer -->
  <class name="SequenceFile.Writer" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="SequenceFile.Writer" type="org.apache.hadoop.fs.FileSystem, org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.Path, java.lang.Class, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named file.]]>
      </doc>
    </constructor>
    <constructor name="SequenceFile.Writer" type="org.apache.hadoop.fs.FileSystem, org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.Path, java.lang.Class, java.lang.Class, org.apache.hadoop.util.Progressable, org.apache.hadoop.io.SequenceFile.Metadata"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named file with write-progress reporter.]]>
      </doc>
    </constructor>
    <constructor name="SequenceFile.Writer" type="org.apache.hadoop.fs.FileSystem, org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.Path, java.lang.Class, java.lang.Class, int, short, long, org.apache.hadoop.util.Progressable, org.apache.hadoop.io.SequenceFile.Metadata"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named file with write-progress reporter.]]>
      </doc>
    </constructor>
    <method name="getKeyClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the class of keys in this file.]]>
      </doc>
    </method>
    <method name="getValueClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the class of values in this file.]]>
      </doc>
    </method>
    <method name="getCompressionCodec" return="org.apache.hadoop.io.compress.CompressionCodec"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the compression codec of data in this file.]]>
      </doc>
    </method>
    <method name="sync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[create a sync point]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close the file.]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.Writable"/>
      <param name="val" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Append a key/value pair.]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="val" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Append a key/value pair.]]>
      </doc>
    </method>
    <method name="appendRaw"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyData" type="byte[]"/>
      <param name="keyOffset" type="int"/>
      <param name="keyLength" type="int"/>
      <param name="val" type="org.apache.hadoop.io.SequenceFile.ValueBytes"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the current length of the output file.

 <p>This always returns a synchronized position.  In other words,
 immediately after calling {@link SequenceFile.Reader#seek(long)} with a position
 returned by this method, {@link SequenceFile.Reader#next(Writable)} may be called.  However
 the key may be earlier in the file than key last written when this
 method was called (e.g., with block-compression, it may be the first key
 in the block that was being written when this method was called).]]>
      </doc>
    </method>
    <field name="keySerializer" type="org.apache.hadoop.io.serializer.Serializer"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="uncompressedValSerializer" type="org.apache.hadoop.io.serializer.Serializer"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="compressedValSerializer" type="org.apache.hadoop.io.serializer.Serializer"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Write key/value pairs to a sequence-format file.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SequenceFile.Writer -->
  <!-- start class org.apache.hadoop.io.SetFile -->
  <class name="SetFile" extends="org.apache.hadoop.io.MapFile"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SetFile"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[A file-based set of keys.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SetFile -->
  <!-- start class org.apache.hadoop.io.SetFile.Reader -->
  <class name="SetFile.Reader" extends="org.apache.hadoop.io.MapFile.Reader"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SetFile.Reader" type="org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a set reader for the named set.]]>
      </doc>
    </constructor>
    <constructor name="SetFile.Reader" type="org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a set reader for the named set using the named comparator.]]>
      </doc>
    </constructor>
    <method name="seek" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="next" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read the next key in a set into <code>key</code>.  Returns
 true if such a key exists and false when at the end of the set.]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.io.WritableComparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read the matching key from a set into <code>key</code>.
 Returns <code>key</code>, or null if no match exists.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provide access to an existing set file.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SetFile.Reader -->
  <!-- start class org.apache.hadoop.io.SetFile.Writer -->
  <class name="SetFile.Writer" extends="org.apache.hadoop.io.MapFile.Writer"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SetFile.Writer" type="org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="pass a Configuration too">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named set for keys of the named class. 
  @deprecated pass a Configuration too]]>
      </doc>
    </constructor>
    <constructor name="SetFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a set naming the element class and compression type.]]>
      </doc>
    </constructor>
    <constructor name="SetFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, org.apache.hadoop.io.SequenceFile.CompressionType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a set naming the element comparator and compression type.]]>
      </doc>
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Append a key to a set.  The key must be strictly greater than the
 previous key added to the set.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Write a new set file.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SetFile.Writer -->
  <!-- start class org.apache.hadoop.io.SortedMapWritable -->
  <class name="SortedMapWritable" extends="org.apache.hadoop.io.AbstractMapWritable"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.SortedMap"/>
    <constructor name="SortedMapWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[default constructor.]]>
      </doc>
    </constructor>
    <constructor name="SortedMapWritable" type="org.apache.hadoop.io.SortedMapWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Copy constructor.
 
 @param other the map to copy from]]>
      </doc>
    </constructor>
    <method name="comparator" return="java.util.Comparator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="firstKey" return="org.apache.hadoop.io.WritableComparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="headMap" return="java.util.SortedMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toKey" type="org.apache.hadoop.io.WritableComparable"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="lastKey" return="org.apache.hadoop.io.WritableComparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="subMap" return="java.util.SortedMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="toKey" type="org.apache.hadoop.io.WritableComparable"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="tailMap" return="java.util.SortedMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="org.apache.hadoop.io.WritableComparable"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="entrySet" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="keySet" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="put" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="value" type="org.apache.hadoop.io.Writable"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.util.Map"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="remove" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="values" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A Writable SortedMap.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SortedMapWritable -->
  <!-- start interface org.apache.hadoop.io.Stringifier -->
  <interface name="Stringifier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Converts the object to a string representation
 @param obj the object to convert
 @return the string representation of the object
 @throws IOException if the object cannot be converted]]>
      </doc>
    </method>
    <method name="fromString" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Restores the object from its string representation.
 @param str the string representation of the object
 @return restored object
 @throws IOException if the object cannot be restored]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Closes this object. 
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Stringifier interface offers two methods to convert an object 
 to a string representation and restore the object given its 
 string representation.
 @param <T> the class of the objects to stringify]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.Stringifier -->
  <!-- start class org.apache.hadoop.io.Text -->
  <class name="Text" extends="org.apache.hadoop.io.BinaryComparable"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="Text"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Text" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct from a string.]]>
      </doc>
    </constructor>
    <constructor name="Text" type="org.apache.hadoop.io.Text"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct from another text.]]>
      </doc>
    </constructor>
    <constructor name="Text" type="byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct from a byte array.]]>
      </doc>
    </constructor>
    <method name="getBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the raw bytes; however, only data up to {@link #getLength()} is
 valid.]]>
      </doc>
    </method>
    <method name="getLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of bytes in the byte array]]>
      </doc>
    </method>
    <method name="charAt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="int"/>
      <doc>
      <![CDATA[Returns the Unicode Scalar Value (32-bit integer value)
 for the character at <code>position</code>. Note that this
 method avoids using the converter or doing String instatiation
 @return the Unicode scalar value at position or -1
          if the position is invalid or points to a
          trailing byte]]>
      </doc>
    </method>
    <method name="find" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="java.lang.String"/>
    </method>
    <method name="find" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="java.lang.String"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Finds any occurence of <code>what</code> in the backing
 buffer, starting as position <code>start</code>. The starting
 position is measured in bytes and the return value is in
 terms of byte position in the buffer. The backing buffer is
 not converted to a string for this operation.
 @return byte position of the first occurence of the search
         string in the UTF-8 buffer or -1 if not found]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Set to contain the contents of a string.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <doc>
      <![CDATA[Set to a utf8 byte array]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.io.Text"/>
      <doc>
      <![CDATA[copy a text.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Set the Text to range of bytes
 @param utf8 the data to copy from
 @param start the first position of the new string
 @param len the number of bytes of the new string]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Append a range of bytes to the end of the given text
 @param utf8 the data to copy from
 @param start the first position to append from utf8
 @param len the number of bytes to append]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clear the string to empty.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Convert text back to string
 @see java.lang.Object#toString()]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[deserialize]]>
      </doc>
    </method>
    <method name="skip"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Skips over one Text in the input.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[serialize
 write this object to out
 length uses zero-compressed encoding
 @see Writable#write(DataOutput)]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a Text with the same contents.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="decode" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <exception name="CharacterCodingException" type="java.nio.charset.CharacterCodingException"/>
      <doc>
      <![CDATA[Converts the provided byte array to a String using the
 UTF-8 encoding. If the input is malformed,
 replace by a default value.]]>
      </doc>
    </method>
    <method name="decode" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="length" type="int"/>
      <exception name="CharacterCodingException" type="java.nio.charset.CharacterCodingException"/>
    </method>
    <method name="decode" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="length" type="int"/>
      <param name="replace" type="boolean"/>
      <exception name="CharacterCodingException" type="java.nio.charset.CharacterCodingException"/>
      <doc>
      <![CDATA[Converts the provided byte array to a String using the
 UTF-8 encoding. If <code>replace</code> is true, then
 malformed input is replaced with the
 substitution character, which is U+FFFD. Otherwise the
 method throws a MalformedInputException.]]>
      </doc>
    </method>
    <method name="encode" return="java.nio.ByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <exception name="CharacterCodingException" type="java.nio.charset.CharacterCodingException"/>
      <doc>
      <![CDATA[Converts the provided String to bytes using the
 UTF-8 encoding. If the input is malformed,
 invalid chars are replaced by a default value.
 @return ByteBuffer: bytes stores at ByteBuffer.array() 
                     and length is ByteBuffer.limit()]]>
      </doc>
    </method>
    <method name="encode" return="java.nio.ByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="replace" type="boolean"/>
      <exception name="CharacterCodingException" type="java.nio.charset.CharacterCodingException"/>
      <doc>
      <![CDATA[Converts the provided String to bytes using the
 UTF-8 encoding. If <code>replace</code> is true, then
 malformed input is replaced with the
 substitution character, which is U+FFFD. Otherwise the
 method throws a MalformedInputException.
 @return ByteBuffer: bytes stores at ByteBuffer.array() 
                     and length is ByteBuffer.limit()]]>
      </doc>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a UTF8 encoded string from in]]>
      </doc>
    </method>
    <method name="writeString" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="s" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a UTF8 encoded string to out]]>
      </doc>
    </method>
    <method name="validateUTF8"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <exception name="MalformedInputException" type="java.nio.charset.MalformedInputException"/>
      <doc>
      <![CDATA[Check if a byte array contains valid utf-8
 @param utf8 byte array
 @throws MalformedInputException if the byte array contains invalid utf-8]]>
      </doc>
    </method>
    <method name="validateUTF8"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="len" type="int"/>
      <exception name="MalformedInputException" type="java.nio.charset.MalformedInputException"/>
      <doc>
      <![CDATA[Check to see if a byte array is valid utf-8
 @param utf8 the array of bytes
 @param start the offset of the first byte in the array
 @param len the length of the byte sequence
 @throws MalformedInputException if the byte array contains invalid bytes]]>
      </doc>
    </method>
    <method name="bytesToCodePoint" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="java.nio.ByteBuffer"/>
      <doc>
      <![CDATA[Returns the next code point at the current position in
 the buffer. The buffer's position will be incremented.
 Any mark set on this buffer will be changed by this method!]]>
      </doc>
    </method>
    <method name="utf8Length" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[For the given string, returns the number of UTF-8 bytes
 required to encode the string.
 @param string text to encode
 @return number of UTF-8 bytes required to encode]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class stores text using standard UTF8 encoding.  It provides methods
 to serialize, deserialize, and compare texts at byte level.  The type of
 length is integer and is serialized using zero-compressed format.  <p>In
 addition, it provides methods for string traversal without converting the
 byte array to a string.  <p>Also includes utilities for
 serializing/deserialing a string, coding/decoding a string, checking if a
 byte array contains valid UTF8 code, calculating the length of an encoded
 string.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.Text -->
  <!-- start class org.apache.hadoop.io.Text.Comparator -->
  <class name="Text.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Text.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A WritableComparator optimized for Text keys.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.Text.Comparator -->
  <!-- start class org.apache.hadoop.io.TwoDArrayWritable -->
  <class name="TwoDArrayWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="TwoDArrayWritable" type="java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TwoDArrayWritable" type="java.lang.Class, org.apache.hadoop.io.Writable[][]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="toArray" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="org.apache.hadoop.io.Writable[][]"/>
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable[][]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A Writable for 2D arrays containing a matrix of instances of a class.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.TwoDArrayWritable -->
  <!-- start class org.apache.hadoop.io.UTF8 -->
  <class name="UTF8" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="replaced by Text">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="UTF8"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UTF8" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct from a given string.]]>
      </doc>
    </constructor>
    <constructor name="UTF8" type="org.apache.hadoop.io.UTF8"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct from a given string.]]>
      </doc>
    </constructor>
    <method name="getBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The raw bytes.]]>
      </doc>
    </method>
    <method name="getLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes in the encoded string.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Set to contain the contents of a string.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.io.UTF8"/>
      <doc>
      <![CDATA[Set to contain the contents of a string.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Skips over one UTF8 in the input.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compare two UTF8s.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Convert to a String.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a UTF8 with the same contents.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Convert a string to a UTF-8 encoded byte array.
 @see String#getBytes(String)]]>
      </doc>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a UTF-8 encoded string.

 @see DataInput#readUTF()]]>
      </doc>
    </method>
    <method name="writeString" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="s" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a UTF-8 encoded string.

 @see DataOutput#writeUTF(String)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A WritableComparable for strings that uses the UTF8 encoding.
 
 <p>Also includes utilities for efficiently reading and writing UTF-8.

 @deprecated replaced by Text]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.UTF8 -->
  <!-- start class org.apache.hadoop.io.UTF8.Comparator -->
  <class name="UTF8.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UTF8.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A WritableComparator optimized for UTF8 keys.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.UTF8.Comparator -->
  <!-- start class org.apache.hadoop.io.VersionedWritable -->
  <class name="VersionedWritable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="VersionedWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getVersion" return="byte"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the version number of the current implementation.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A base class for Writables that provides version checking.

 <p>This is useful when a class may evolve, so that instances written by the
 old version of the class may still be processed by the new version.  To
 handle this situation, {@link #readFields(DataInput)}
 implementations should catch {@link VersionMismatchException}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.VersionedWritable -->
  <!-- start class org.apache.hadoop.io.VersionMismatchException -->
  <class name="VersionMismatchException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="VersionMismatchException" type="byte, byte"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of this object.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Thrown by {@link VersionedWritable#readFields(DataInput)} when the
 version of an object being read does not match the current implementation
 version as returned by {@link VersionedWritable#getVersion()}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.VersionMismatchException -->
  <!-- start class org.apache.hadoop.io.VIntWritable -->
  <class name="VIntWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="VIntWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="VIntWritable" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Set the value of this VIntWritable.]]>
      </doc>
    </method>
    <method name="get" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the value of this VIntWritable.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a VIntWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares two VIntWritables.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for integer values stored in variable-length format.
 Such values take between one and five bytes.  Smaller values take fewer bytes.
 
 @see org.apache.hadoop.io.WritableUtils#readVInt(DataInput)]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.VIntWritable -->
  <!-- start class org.apache.hadoop.io.VLongWritable -->
  <class name="VLongWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="VLongWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="VLongWritable" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Set the value of this LongWritable.]]>
      </doc>
    </method>
    <method name="get" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the value of this LongWritable.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a VLongWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compares two VLongWritables.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for longs in a variable-length format. Such values take
  between one and five bytes.  Smaller values take fewer bytes.
  
  @see org.apache.hadoop.io.WritableUtils#readVLong(DataInput)]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.VLongWritable -->
  <!-- start interface org.apache.hadoop.io.Writable -->
  <interface name="Writable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serialize the fields of this object to <code>out</code>.
 
 @param out <code>DataOuput</code> to serialize this object into.
 @throws IOException]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deserialize the fields of this object from <code>in</code>.  
 
 <p>For efficiency, implementations should attempt to re-use storage in the 
 existing object where possible.</p>
 
 @param in <code>DataInput</code> to deseriablize this object from.
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A serializable object which implements a simple, efficient, serialization 
 protocol, based on {@link DataInput} and {@link DataOutput}.

 <p>Any <code>key</code> or <code>value</code> type in the Hadoop Map-Reduce
 framework implements this interface.</p>
 
 <p>Implementations typically implement a static <code>read(DataInput)</code>
 method which constructs a new instance, calls {@link #readFields(DataInput)} 
 and returns the instance.</p>
 
 <p>Example:</p>
 <p><blockquote><pre>
     public class MyWritable implements Writable {
       // Some data     
       private int counter;
       private long timestamp;
       
       public void write(DataOutput out) throws IOException {
         out.writeInt(counter);
         out.writeLong(timestamp);
       }
       
       public void readFields(DataInput in) throws IOException {
         counter = in.readInt();
         timestamp = in.readLong();
       }
       
       public static MyWritable read(DataInput in) throws IOException {
         MyWritable w = new MyWritable();
         w.readFields(in);
         return w;
       }
     }
 </pre></blockquote></p>]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.Writable -->
  <!-- start interface org.apache.hadoop.io.WritableComparable -->
  <interface name="WritableComparable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <implements name="java.lang.Comparable"/>
    <doc>
    <![CDATA[A {@link Writable} which is also {@link Comparable}. 

 <p><code>WritableComparable</code>s can be compared to each other, typically 
 via <code>Comparator</code>s. Any type which is to be used as a 
 <code>key</code> in the Hadoop Map-Reduce framework should implement this
 interface.</p>
  
 <p>Example:</p>
 <p><blockquote><pre>
     public class MyWritableComparable implements WritableComparable {
       // Some data
       private int counter;
       private long timestamp;
       
       public void write(DataOutput out) throws IOException {
         out.writeInt(counter);
         out.writeLong(timestamp);
       }
       
       public void readFields(DataInput in) throws IOException {
         counter = in.readInt();
         timestamp = in.readLong();
       }
       
       public int compareTo(MyWritableComparable w) {
         int thisValue = this.value;
         int thatValue = ((IntWritable)o).value;
         return (thisValue &lt; thatValue ? -1 : (thisValue==thatValue ? 0 : 1));
       }
     }
 </pre></blockquote></p>]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.WritableComparable -->
  <!-- start class org.apache.hadoop.io.WritableComparator -->
  <class name="WritableComparator" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.RawComparator"/>
    <constructor name="WritableComparator" type="java.lang.Class"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct for a {@link WritableComparable} implementation.]]>
      </doc>
    </constructor>
    <constructor name="WritableComparator" type="java.lang.Class, boolean"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="org.apache.hadoop.io.WritableComparator"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <doc>
      <![CDATA[Get a comparator for a {@link WritableComparable} implementation.]]>
      </doc>
    </method>
    <method name="define"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="comparator" type="org.apache.hadoop.io.WritableComparator"/>
      <doc>
      <![CDATA[Register an optimized comparator for a {@link WritableComparable}
 implementation.]]>
      </doc>
    </method>
    <method name="getKeyClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the WritableComparable implementation class.]]>
      </doc>
    </method>
    <method name="newKey" return="org.apache.hadoop.io.WritableComparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a new {@link WritableComparable} instance.]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
      <doc>
      <![CDATA[Optimization hook.  Override this to make SequenceFile.Sorter's scream.

 <p>The default implementation reads the data into two {@link
 WritableComparable}s (using {@link
 Writable#readFields(DataInput)}, then calls {@link
 #compare(WritableComparable,WritableComparable)}.]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="b" type="org.apache.hadoop.io.WritableComparable"/>
      <doc>
      <![CDATA[Compare two WritableComparables.

 <p> The default implementation uses the natural ordering, calling {@link
 Comparable#compareTo(Object)}.]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Object"/>
      <param name="b" type="java.lang.Object"/>
    </method>
    <method name="compareBytes" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
      <doc>
      <![CDATA[Lexicographic order of binary data.]]>
      </doc>
    </method>
    <method name="hashBytes" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Compute hash for binary data.]]>
      </doc>
    </method>
    <method name="readUnsignedShort" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Parse an unsigned short from a byte array.]]>
      </doc>
    </method>
    <method name="readInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Parse an integer from a byte array.]]>
      </doc>
    </method>
    <method name="readFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Parse a float from a byte array.]]>
      </doc>
    </method>
    <method name="readLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Parse a long from a byte array.]]>
      </doc>
    </method>
    <method name="readDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Parse a double from a byte array.]]>
      </doc>
    </method>
    <method name="readVLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a zero-compressed encoded long from a byte array and returns it.
 @param bytes byte array with decode long
 @param start starting index
 @throws java.io.IOException 
 @return deserialized long]]>
      </doc>
    </method>
    <method name="readVInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a zero-compressed encoded integer from a byte array and returns it.
 @param bytes byte array with the encoded integer
 @param start start index
 @throws java.io.IOException 
 @return deserialized integer]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A Comparator for {@link WritableComparable}s.

 <p>This base implemenation uses the natural ordering.  To define alternate
 orderings, override {@link #compare(WritableComparable,WritableComparable)}.

 <p>One may optimize compare-intensive operations by overriding
 {@link #compare(byte[],int,int,byte[],int,int)}.  Static utility methods are
 provided to assist in optimized implementations of this method.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.WritableComparator -->
  <!-- start class org.apache.hadoop.io.WritableFactories -->
  <class name="WritableFactories" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setFactory"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="factory" type="org.apache.hadoop.io.WritableFactory"/>
      <doc>
      <![CDATA[Define a factory for a class.]]>
      </doc>
    </method>
    <method name="getFactory" return="org.apache.hadoop.io.WritableFactory"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <doc>
      <![CDATA[Define a factory for a class.]]>
      </doc>
    </method>
    <method name="newInstance" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Create a new instance of a class with a defined factory.]]>
      </doc>
    </method>
    <method name="newInstance" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <doc>
      <![CDATA[Create a new instance of a class with a defined factory.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factories for non-public writables.  Defining a factory permits {@link
 ObjectWritable} to be able to construct instances of non-public classes.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.WritableFactories -->
  <!-- start interface org.apache.hadoop.io.WritableFactory -->
  <interface name="WritableFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newInstance" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a new instance.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A factory for a class of Writable.
 @see WritableFactories]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.WritableFactory -->
  <!-- start class org.apache.hadoop.io.WritableName -->
  <class name="WritableName" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setName"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writableClass" type="java.lang.Class"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the name that a class should be known as to something other than the
 class name.]]>
      </doc>
    </method>
    <method name="addName"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writableClass" type="java.lang.Class"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Add an alternate name for a class.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writableClass" type="java.lang.Class"/>
      <doc>
      <![CDATA[Return the name for a class.  Default is {@link Class#getName()}.]]>
      </doc>
    </method>
    <method name="getClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the class for a name.  Default is {@link Class#forName(String)}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility to permit renaming of Writable implementation classes without
 invalidiating files that contain their class name.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.WritableName -->
  <!-- start class org.apache.hadoop.io.WritableUtils -->
  <class name="WritableUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="WritableUtils"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="readCompressedByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skipCompressedByteArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCompressedByteArray" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="bytes" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readCompressedString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCompressedString" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="s" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="s" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeStringArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="s" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCompressedStringArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="s" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readStringArray" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readCompressedStringArray" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="displayByteArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="byte[]"/>
    </method>
    <method name="clone" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="orig" type="org.apache.hadoop.io.Writable"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Make a copy of a writable object using serialization to a buffer.
 @param orig The object to copy
 @return The copied object]]>
      </doc>
    </method>
    <method name="cloneInto"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use ReflectionUtils.cloneInto instead.">
      <param name="dst" type="org.apache.hadoop.io.Writable"/>
      <param name="src" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Make a copy of the writable object using serialiation to a buffer
 @param dst the object to copy from
 @param src the object to copy into, which is destroyed
 @throws IOException
 @deprecated use ReflectionUtils.cloneInto instead.]]>
      </doc>
    </method>
    <method name="writeVInt"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.DataOutput"/>
      <param name="i" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serializes an integer to a binary stream with zero-compressed encoding.
 For -120 <= i <= 127, only one byte is used with the actual value.
 For other values of i, the first byte value indicates whether the
 integer is positive or negative, and the number of bytes that follow.
 If the first byte value v is between -121 and -124, the following integer
 is positive, with number of bytes that follow are -(v+120).
 If the first byte value v is between -125 and -128, the following integer
 is negative, with number of bytes that follow are -(v+124). Bytes are
 stored in the high-non-zero-byte-first order.

 @param stream Binary output stream
 @param i Integer to be serialized
 @throws java.io.IOException]]>
      </doc>
    </method>
    <method name="writeVLong"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.DataOutput"/>
      <param name="i" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serializes a long to a binary stream with zero-compressed encoding.
 For -112 <= i <= 127, only one byte is used with the actual value.
 For other values of i, the first byte value indicates whether the
 long is positive or negative, and the number of bytes that follow.
 If the first byte value v is between -113 and -120, the following long
 is positive, with number of bytes that follow are -(v+112).
 If the first byte value v is between -121 and -128, the following long
 is negative, with number of bytes that follow are -(v+120). Bytes are
 stored in the high-non-zero-byte-first order.
 
 @param stream Binary output stream
 @param i Long to be serialized
 @throws java.io.IOException]]>
      </doc>
    </method>
    <method name="readVLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a zero-compressed encoded long from input stream and returns it.
 @param stream Binary input stream
 @throws java.io.IOException 
 @return deserialized long from stream.]]>
      </doc>
    </method>
    <method name="readVInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a zero-compressed encoded integer from input stream and returns it.
 @param stream Binary input stream
 @throws java.io.IOException 
 @return deserialized integer from stream.]]>
      </doc>
    </method>
    <method name="isNegativeVInt" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Given the first byte of a vint/vlong, determine the sign
 @param value the first byte
 @return is the value negative]]>
      </doc>
    </method>
    <method name="decodeVIntSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Parse the first byte of a vint/vlong to determine the number of bytes
 @param value the first byte of the vint/vlong
 @return the total number of bytes (1 to 9)]]>
      </doc>
    </method>
    <method name="getVIntSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="long"/>
      <doc>
      <![CDATA[Get the encoded length if an integer is stored in a variable-length format
 @return the encoded length]]>
      </doc>
    </method>
    <method name="readEnum" return="java.lang.Enum"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="enumType" type="java.lang.Class"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read an Enum value from DataInput, Enums are read and written 
 using String values. 
 @param <T> Enum type
 @param in DataInput to read from 
 @param enumType Class type of Enum
 @return Enum represented by String read from DataInput
 @throws IOException]]>
      </doc>
    </method>
    <method name="writeEnum"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="enumVal" type="java.lang.Enum"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[writes String value of enum to DataOutput. 
 @param out Dataoutput stream
 @param enumVal enum value
 @throws IOException]]>
      </doc>
    </method>
    <method name="skipFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Skip <i>len</i> number of bytes in input stream<i>in</i>
 @param in input stream
 @param len number of bytes to skip
 @throws IOException when skipped less number of bytes]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writables" type="org.apache.hadoop.io.Writable[]"/>
      <doc>
      <![CDATA[Convert writables to a byte array]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.io.WritableUtils -->
  <doc>
  <![CDATA[Generic i/o code for use when reading and writing data to the network,
to databases, and to files.]]>
  </doc>
</package>
<package name="org.apache.hadoop.io.compress">
  <!-- start class org.apache.hadoop.io.compress.BlockCompressorStream -->
  <class name="BlockCompressorStream" extends="org.apache.hadoop.io.compress.CompressorStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlockCompressorStream" type="java.io.OutputStream, org.apache.hadoop.io.compress.Compressor, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a {@link BlockCompressorStream}.
 
 @param out stream
 @param compressor compressor to be used
 @param bufferSize size of buffer
 @param compressionOverhead maximum 'overhead' of the compression 
                            algorithm with given bufferSize]]>
      </doc>
    </constructor>
    <constructor name="BlockCompressorStream" type="java.io.OutputStream, org.apache.hadoop.io.compress.Compressor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a {@link BlockCompressorStream} with given output-stream and 
 compressor.
 Use default of 512 as bufferSize and compressionOverhead of 
 (1% of bufferSize + 12 bytes) =  18 bytes (zlib algorithm).
 
 @param out stream
 @param compressor compressor to be used]]>
      </doc>
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write the data provided to the compression codec, compressing no more
 than the buffer size less the compression overhead as specified during
 construction for each block.

 Each block contains the uncompressed length for the block, followed by
 one or more length-prefixed blocks of compressed data.]]>
      </doc>
    </method>
    <method name="finish"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="compress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A {@link org.apache.hadoop.io.compress.CompressorStream} which works
 with 'block-based' based compression algorithms, as opposed to 
 'stream-based' compression algorithms.

 It should be noted that this wrapper does not guarantee that blocks will
 be sized for the compressor. If the
 {@link org.apache.hadoop.io.compress.Compressor} requires buffering to
 effect meaningful compression, it is responsible for it.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.BlockCompressorStream -->
  <!-- start class org.apache.hadoop.io.compress.BlockDecompressorStream -->
  <class name="BlockDecompressorStream" extends="org.apache.hadoop.io.compress.DecompressorStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlockDecompressorStream" type="java.io.InputStream, org.apache.hadoop.io.compress.Decompressor, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a {@link BlockDecompressorStream}.
 
 @param in input stream
 @param decompressor decompressor to use
 @param bufferSize size of buffer]]>
      </doc>
    </constructor>
    <constructor name="BlockDecompressorStream" type="java.io.InputStream, org.apache.hadoop.io.compress.Decompressor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a {@link BlockDecompressorStream}.
 
 @param in input stream
 @param decompressor decompressor to use]]>
      </doc>
    </constructor>
    <constructor name="BlockDecompressorStream" type="java.io.InputStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="decompress" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCompressedData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="resetState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A {@link org.apache.hadoop.io.compress.DecompressorStream} which works
 with 'block-based' based compression algorithms, as opposed to 
 'stream-based' compression algorithms.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.BlockDecompressorStream -->
  <!-- start class org.apache.hadoop.io.compress.BZip2Codec -->
  <class name="BZip2Codec" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.compress.CompressionCodec"/>
    <constructor name="BZip2Codec"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of BZip2Codec]]>
      </doc>
    </constructor>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates CompressionOutputStream for BZip2

 @param out
            The output Stream
 @return The BZip2 CompressionOutputStream
 @throws java.io.IOException
             Throws IO exception]]>
      </doc>
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="compressor" type="org.apache.hadoop.io.compress.Compressor"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This functionality is currently not supported.

 @throws java.lang.UnsupportedOperationException
             Throws UnsupportedOperationException]]>
      </doc>
    </method>
    <method name="getCompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This functionality is currently not supported.

 @throws java.lang.UnsupportedOperationException
             Throws UnsupportedOperationException]]>
      </doc>
    </method>
    <method name="createCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This functionality is currently not supported.

 @throws java.lang.UnsupportedOperationException
             Throws UnsupportedOperationException]]>
      </doc>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates CompressionInputStream to be used to read off uncompressed data.

 @param in
            The InputStream
 @return Returns CompressionInputStream for BZip2
 @throws java.io.IOException
             Throws IOException]]>
      </doc>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This functionality is currently not supported.

 @throws java.lang.UnsupportedOperationException
             Throws UnsupportedOperationException]]>
      </doc>
    </method>
    <method name="getDecompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This functionality is currently not supported.

 @throws java.lang.UnsupportedOperationException
             Throws UnsupportedOperationException]]>
      </doc>
    </method>
    <method name="createDecompressor" return="org.apache.hadoop.io.compress.Decompressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This functionality is currently not supported.

 @throws java.lang.UnsupportedOperationException
             Throws UnsupportedOperationException]]>
      </doc>
    </method>
    <method name="getDefaultExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[.bz2 is recognized as the default extension for compressed BZip2 files

 @return A String telling the default bzip2 file extension]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class provides CompressionOutputStream and CompressionInputStream for
 compression and decompression. Currently we dont have an implementation of
 the Compressor and Decompressor interfaces, so those methods of
 CompressionCodec which have a Compressor or Decompressor type argument, throw
 UnsupportedOperationException.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.BZip2Codec -->
  <!-- start class org.apache.hadoop.io.compress.CodecPool -->
  <class name="CodecPool" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CodecPool"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <doc>
      <![CDATA[Get a {@link Compressor} for the given {@link CompressionCodec} from the 
 pool or a new one.

 @param codec the <code>CompressionCodec</code> for which to get the 
              <code>Compressor</code>
 @return <code>Compressor</code> for the given 
         <code>CompressionCodec</code> from the pool or a new one]]>
      </doc>
    </method>
    <method name="getDecompressor" return="org.apache.hadoop.io.compress.Decompressor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <doc>
      <![CDATA[Get a {@link Decompressor} for the given {@link CompressionCodec} from the
 pool or a new one.
  
 @param codec the <code>CompressionCodec</code> for which to get the 
              <code>Decompressor</code>
 @return <code>Decompressor</code> for the given 
         <code>CompressionCodec</code> the pool or a new one]]>
      </doc>
    </method>
    <method name="returnCompressor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="compressor" type="org.apache.hadoop.io.compress.Compressor"/>
      <doc>
      <![CDATA[Return the {@link Compressor} to the pool.
 
 @param compressor the <code>Compressor</code> to be returned to the pool]]>
      </doc>
    </method>
    <method name="returnDecompressor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <doc>
      <![CDATA[Return the {@link Decompressor} to the pool.
 
 @param decompressor the <code>Decompressor</code> to be returned to the 
                     pool]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A global compressor/decompressor pool used to save and reuse 
 (possibly native) compression/decompression codecs.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.CodecPool -->
  <!-- start interface org.apache.hadoop.io.compress.CompressionCodec -->
  <interface name="CompressionCodec"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionOutputStream} that will write to the given 
 {@link OutputStream}.
 
 @param out the location for the final output stream
 @return a stream the user can write uncompressed data to have it compressed
 @throws IOException]]>
      </doc>
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="compressor" type="org.apache.hadoop.io.compress.Compressor"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionOutputStream} that will write to the given 
 {@link OutputStream} with the given {@link Compressor}.
 
 @param out the location for the final output stream
 @param compressor compressor to use
 @return a stream the user can write uncompressed data to have it compressed
 @throws IOException]]>
      </doc>
    </method>
    <method name="getCompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of {@link Compressor} needed by this {@link CompressionCodec}.
 
 @return the type of compressor needed by this codec.]]>
      </doc>
    </method>
    <method name="createCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link Compressor} for use by this {@link CompressionCodec}.
 
 @return a new compressor for use by this codec]]>
      </doc>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a stream decompressor that will read from the given input stream.
 
 @param in the stream to read compressed bytes from
 @return a stream to read uncompressed bytes from
 @throws IOException]]>
      </doc>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionInputStream} that will read from the given 
 {@link InputStream} with the given {@link Decompressor}.
 
 @param in the stream to read compressed bytes from
 @param decompressor decompressor to use
 @return a stream to read uncompressed bytes from
 @throws IOException]]>
      </doc>
    </method>
    <method name="getDecompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of {@link Decompressor} needed by this {@link CompressionCodec}.
 
 @return the type of decompressor needed by this codec.]]>
      </doc>
    </method>
    <method name="createDecompressor" return="org.apache.hadoop.io.compress.Decompressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link Decompressor} for use by this {@link CompressionCodec}.
 
 @return a new decompressor for use by this codec]]>
      </doc>
    </method>
    <method name="getDefaultExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the default filename extension for this kind of compression.
 @return the extension including the '.']]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class encapsulates a streaming compression/decompression pair.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.compress.CompressionCodec -->
  <!-- start class org.apache.hadoop.io.compress.CompressionCodecFactory -->
  <class name="CompressionCodecFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CompressionCodecFactory" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Find the codecs specified in the config value io.compression.codecs 
 and register them. Defaults to gzip and zip.]]>
      </doc>
    </constructor>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Print the extension map out as a string.]]>
      </doc>
    </method>
    <method name="getCodecClasses" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the list of codecs listed in the configuration
 @param conf the configuration to look in
 @return a list of the Configuration classes or null if the attribute
         was not set]]>
      </doc>
    </method>
    <method name="setCodecClasses"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="classes" type="java.util.List"/>
      <doc>
      <![CDATA[Sets a list of codec classes in the configuration.
 @param conf the configuration to modify
 @param classes the list of classes to set]]>
      </doc>
    </method>
    <method name="getCodec" return="org.apache.hadoop.io.compress.CompressionCodec"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Find the relevant compression codec for the given file based on its
 filename suffix.
 @param file the filename to check
 @return the codec object]]>
      </doc>
    </method>
    <method name="removeSuffix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="java.lang.String"/>
      <param name="suffix" type="java.lang.String"/>
      <doc>
      <![CDATA[Removes a suffix from a filename, if it has it.
 @param filename the filename to strip
 @param suffix the suffix to remove
 @return the shortened filename]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[A little test program.
 @param args]]>
      </doc>
    </method>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A factory that will find the correct codec for a given filename.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.CompressionCodecFactory -->
  <!-- start class org.apache.hadoop.io.compress.CompressionInputStream -->
  <class name="CompressionInputStream" extends="java.io.InputStream"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CompressionInputStream" type="java.io.InputStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a compression input stream that reads
 the decompressed bytes from the given stream.
 
 @param in The input stream to be compressed.]]>
      </doc>
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read bytes from the stream.
 Made abstract to prevent leakage to underlying stream.]]>
      </doc>
    </method>
    <method name="resetState"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reset the decompressor to its initial state and discard any buffered data,
 as the underlying stream may have been repositioned.]]>
      </doc>
    </method>
    <field name="in" type="java.io.InputStream"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The input stream to be compressed.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A compression input stream.

 <p>Implementations are assumed to be buffered.  This permits clients to
 reposition the underlying input stream then call {@link #resetState()},
 without having to also synchronize client buffers.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.CompressionInputStream -->
  <!-- start class org.apache.hadoop.io.compress.CompressionOutputStream -->
  <class name="CompressionOutputStream" extends="java.io.OutputStream"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CompressionOutputStream" type="java.io.OutputStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a compression output stream that writes
 the compressed bytes to the given stream.
 @param out]]>
      </doc>
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write compressed bytes to the stream.
 Made abstract to prevent leakage to underlying stream.]]>
      </doc>
    </method>
    <method name="finish"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Finishes writing compressed data to the output stream 
 without closing the underlying stream.]]>
      </doc>
    </method>
    <method name="resetState"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reset the compression to the initial state. 
 Does not reset the underlying stream.]]>
      </doc>
    </method>
    <field name="out" type="java.io.OutputStream"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The output stream to be compressed.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A compression output stream.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.CompressionOutputStream -->
  <!-- start interface org.apache.hadoop.io.compress.Compressor -->
  <interface name="Compressor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setInput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Sets input data for compression. 
 This should be called whenever #needsInput() returns 
 <code>true</code> indicating that more input data is required.
 
 @param b Input data
 @param off Start offset
 @param len Length]]>
      </doc>
    </method>
    <method name="needsInput" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the input data buffer is empty and 
 #setInput() should be called to provide more input. 
 
 @return <code>true</code> if the input data buffer is empty and 
 #setInput() should be called in order to provide more input.]]>
      </doc>
    </method>
    <method name="setDictionary"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Sets preset dictionary for compression. A preset dictionary 
 is used when the history buffer can be predetermined. 

 @param b Dictionary data bytes
 @param off Start offset
 @param len Length]]>
      </doc>
    </method>
    <method name="getBytesRead" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return number of uncompressed bytes input so far.]]>
      </doc>
    </method>
    <method name="getBytesWritten" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return number of compressed bytes output so far.]]>
      </doc>
    </method>
    <method name="finish"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When called, indicates that compression should end
 with the current contents of the input buffer.]]>
      </doc>
    </method>
    <method name="finished" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the end of the compressed 
 data output stream has been reached.
 @return <code>true</code> if the end of the compressed
 data output stream has been reached.]]>
      </doc>
    </method>
    <method name="compress" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fills specified buffer with compressed data. Returns actual number
 of bytes of compressed data. A return value of 0 indicates that
 needsInput() should be called in order to determine if more input
 data is required.
 
 @param b Buffer for the compressed data
 @param off Start offset of the data
 @param len Size of the buffer
 @return The actual number of bytes of compressed data.]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resets compressor so that a new set of input data can be processed.]]>
      </doc>
    </method>
    <method name="end"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Closes the compressor and discards any unprocessed input.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Specification of a stream-based 'compressor' which can be  
 plugged into a {@link CompressionOutputStream} to compress data.
 This is modelled after {@link java.util.zip.Deflater}]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.compress.Compressor -->
  <!-- start class org.apache.hadoop.io.compress.CompressorStream -->
  <class name="CompressorStream" extends="org.apache.hadoop.io.compress.CompressionOutputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CompressorStream" type="java.io.OutputStream, org.apache.hadoop.io.compress.Compressor, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CompressorStream" type="java.io.OutputStream, org.apache.hadoop.io.compress.Compressor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CompressorStream" type="java.io.OutputStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Allow derived classes to directly set the underlying stream.
 
 @param out Underlying output stream.]]>
      </doc>
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="compress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="finish"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="resetState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="compressor" type="org.apache.hadoop.io.compress.Compressor"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="buffer" type="byte[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="closed" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.io.compress.CompressorStream -->
  <!-- start interface org.apache.hadoop.io.compress.Decompressor -->
  <interface name="Decompressor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setInput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Sets input data for decompression. 
 This should be called whenever #needsInput() returns 
 <code>true</code> indicating that more input data is required.
 
 @param b Input data
 @param off Start offset
 @param len Length]]>
      </doc>
    </method>
    <method name="needsInput" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the input data buffer is empty and 
 #setInput() should be called to provide more input. 
 
 @return <code>true</code> if the input data buffer is empty and 
 #setInput() should be called in order to provide more input.]]>
      </doc>
    </method>
    <method name="setDictionary"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Sets preset dictionary for compression. A preset dictionary
 is used when the history buffer can be predetermined. 

 @param b Dictionary data bytes
 @param off Start offset
 @param len Length]]>
      </doc>
    </method>
    <method name="needsDictionary" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if a preset dictionary is needed for decompression.
 @return <code>true</code> if a preset dictionary is needed for decompression]]>
      </doc>
    </method>
    <method name="finished" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the end of the compressed 
 data output stream has been reached.
 @return <code>true</code> if the end of the compressed
 data output stream has been reached.]]>
      </doc>
    </method>
    <method name="decompress" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fills specified buffer with uncompressed data. Returns actual number
 of bytes of uncompressed data. A return value of 0 indicates that
 #needsInput() should be called in order to determine if more input
 data is required.
 
 @param b Buffer for the compressed data
 @param off Start offset of the data
 @param len Size of the buffer
 @return The actual number of bytes of compressed data.
 @throws IOException]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resets decompressor so that a new set of input data can be processed.]]>
      </doc>
    </method>
    <method name="end"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Closes the decompressor and discards any unprocessed input.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Specification of a stream-based 'de-compressor' which can be  
 plugged into a {@link CompressionInputStream} to compress data.
 This is modelled after {@link java.util.zip.Inflater}]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.compress.Decompressor -->
  <!-- start class org.apache.hadoop.io.compress.DecompressorStream -->
  <class name="DecompressorStream" extends="org.apache.hadoop.io.compress.CompressionInputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DecompressorStream" type="java.io.InputStream, org.apache.hadoop.io.compress.Decompressor, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DecompressorStream" type="java.io.InputStream, org.apache.hadoop.io.compress.Decompressor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DecompressorStream" type="java.io.InputStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Allow derived classes to directly set the underlying stream.
 
 @param in Underlying input stream.]]>
      </doc>
    </constructor>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="decompress" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCompressedData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="checkStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="resetState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="available" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="markSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readlimit" type="int"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="buffer" type="byte[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="eof" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="closed" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.io.compress.DecompressorStream -->
  <!-- start class org.apache.hadoop.io.compress.DefaultCodec -->
  <class name="DefaultCodec" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <implements name="org.apache.hadoop.io.compress.CompressionCodec"/>
    <constructor name="DefaultCodec"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="compressor" type="org.apache.hadoop.io.compress.Compressor"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getDecompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createDecompressor" return="org.apache.hadoop.io.compress.Decompressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDefaultExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.io.compress.DefaultCodec -->
  <!-- start class org.apache.hadoop.io.compress.GzipCodec -->
  <class name="GzipCodec" extends="org.apache.hadoop.io.compress.DefaultCodec"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GzipCodec"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="compressor" type="org.apache.hadoop.io.compress.Compressor"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createDecompressor" return="org.apache.hadoop.io.compress.Decompressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDecompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDefaultExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This class creates gzip compressors/decompressors.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.GzipCodec -->
  <!-- start class org.apache.hadoop.io.compress.GzipCodec.GzipInputStream -->
  <class name="GzipCodec.GzipInputStream" extends="org.apache.hadoop.io.compress.DecompressorStream"
    abstract="false"
    static="true" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="GzipCodec.GzipInputStream" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="GzipCodec.GzipInputStream" type="org.apache.hadoop.io.compress.DecompressorStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Allow subclasses to directly set the inflater stream.]]>
      </doc>
    </constructor>
    <method name="available" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="offset" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="resetState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.io.compress.GzipCodec.GzipInputStream -->
  <!-- start class org.apache.hadoop.io.compress.GzipCodec.GzipOutputStream -->
  <class name="GzipCodec.GzipOutputStream" extends="org.apache.hadoop.io.compress.CompressorStream"
    abstract="false"
    static="true" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="GzipCodec.GzipOutputStream" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="GzipCodec.GzipOutputStream" type="org.apache.hadoop.io.compress.CompressorStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Allow children types to put a different type in here.
 @param out the Deflater stream to use]]>
      </doc>
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="finish"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="resetState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A bridge that wraps around a DeflaterOutputStream to make it 
 a CompressionOutputStream.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.GzipCodec.GzipOutputStream -->
</package>
<package name="org.apache.hadoop.io.compress.bzip2">
  <!-- start interface org.apache.hadoop.io.compress.bzip2.BZip2Constants -->
  <interface name="BZip2Constants"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="baseBlockSize" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MAX_ALPHA_SIZE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MAX_CODE_LEN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RUNA" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RUNB" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="N_GROUPS" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="G_SIZE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="N_ITERS" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MAX_SELECTORS" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NUM_OVERSHOOT_BYTES" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="rNums" type="int[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This array really shouldn't be here. Again, for historical purposes it
 is.

 <p>
 FIXME: This array should be in a private or package private location,
 since it could be modified by malicious code.
 </p>]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Base class for both the compress and decompress classes. Holds common arrays,
 and static data.
 <p>
 This interface is public for historical purposes. You should have no need to
 use it.
 </p>]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.compress.bzip2.BZip2Constants -->
  <!-- start class org.apache.hadoop.io.compress.bzip2.BZip2DummyCompressor -->
  <class name="BZip2DummyCompressor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.compress.Compressor"/>
    <constructor name="BZip2DummyCompressor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compress" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="end"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="finish"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="finished" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBytesRead" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBytesWritten" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="needsInput" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setDictionary"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="setInput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <doc>
    <![CDATA[This is a dummy compressor for BZip2.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.bzip2.BZip2DummyCompressor -->
  <!-- start class org.apache.hadoop.io.compress.bzip2.BZip2DummyDecompressor -->
  <class name="BZip2DummyDecompressor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.compress.Decompressor"/>
    <constructor name="BZip2DummyDecompressor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="decompress" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="end"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="finished" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="needsDictionary" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="needsInput" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setDictionary"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="setInput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <doc>
    <![CDATA[This is a dummy decompressor for BZip2.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.bzip2.BZip2DummyDecompressor -->
  <!-- start class org.apache.hadoop.io.compress.bzip2.CBZip2InputStream -->
  <class name="CBZip2InputStream" extends="java.io.InputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.compress.bzip2.BZip2Constants"/>
    <constructor name="CBZip2InputStream" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Constructs a new CBZip2InputStream which decompresses bytes read from the
 specified stream.

 <p>
 Although BZip2 headers are marked with the magic <tt>"Bz"</tt> this
 constructor expects the next byte in the stream to be the first one after
 the magic. Thus callers have to skip the first two bytes. Otherwise this
 constructor will throw an exception.
 </p>

 @throws IOException
             if the stream content is malformed or an I/O error occurs.
 @throws NullPointerException
             if <tt>in == null</tt>]]>
      </doc>
    </constructor>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dest" type="byte[]"/>
      <param name="offs" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[An input stream that decompresses from the BZip2 format (without the file
 header chars) to be read as any other stream.

 <p>
 The decompression requires large amounts of memory. Thus you should call the
 {@link #close() close()} method as soon as possible, to force
 <tt>CBZip2InputStream</tt> to release the allocated memory. See
 {@link CBZip2OutputStream CBZip2OutputStream} for information about memory
 usage.
 </p>

 <p>
 <tt>CBZip2InputStream</tt> reads bytes from the compressed source stream via
 the single byte {@link java.io.InputStream#read() read()} method exclusively.
 Thus you should consider to use a buffered source stream.
 </p>

 <p>
 Instances of this class are not threadsafe.
 </p>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.bzip2.CBZip2InputStream -->
  <!-- start class org.apache.hadoop.io.compress.bzip2.CBZip2OutputStream -->
  <class name="CBZip2OutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.compress.bzip2.BZip2Constants"/>
    <constructor name="CBZip2OutputStream" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Constructs a new <tt>CBZip2OutputStream</tt> with a blocksize of 900k.

 <p>
 <b>Attention: </b>The caller is resonsible to write the two BZip2 magic
 bytes <tt>"BZ"</tt> to the specified stream prior to calling this
 constructor.
 </p>

 @param out *
            the destination stream.

 @throws IOException
             if an I/O error occurs in the specified stream.
 @throws NullPointerException
             if <code>out == null</code>.]]>
      </doc>
    </constructor>
    <constructor name="CBZip2OutputStream" type="java.io.OutputStream, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Constructs a new <tt>CBZip2OutputStream</tt> with specified blocksize.

 <p>
 <b>Attention: </b>The caller is resonsible to write the two BZip2 magic
 bytes <tt>"BZ"</tt> to the specified stream prior to calling this
 constructor.
 </p>


 @param out
            the destination stream.
 @param blockSize
            the blockSize as 100k units.

 @throws IOException
             if an I/O error occurs in the specified stream.
 @throws IllegalArgumentException
             if <code>(blockSize < 1) || (blockSize > 9)</code>.
 @throws NullPointerException
             if <code>out == null</code>.

 @see #MIN_BLOCKSIZE
 @see #MAX_BLOCKSIZE]]>
      </doc>
    </constructor>
    <method name="hbMakeCodeLengths"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="len" type="char[]"/>
      <param name="freq" type="int[]"/>
      <param name="alphaSize" type="int"/>
      <param name="maxLen" type="int"/>
      <doc>
      <![CDATA[This method is accessible by subclasses for historical purposes. If you
 don't know what it does then you don't need it.]]>
      </doc>
    </method>
    <method name="chooseBlockSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputLength" type="long"/>
      <doc>
      <![CDATA[Chooses a blocksize based on the given length of the data to compress.

 @return The blocksize, between {@link #MIN_BLOCKSIZE} and
         {@link #MAX_BLOCKSIZE} both inclusive. For a negative
         <tt>inputLength</tt> this method returns <tt>MAX_BLOCKSIZE</tt>
         always.

 @param inputLength
            The length of the data which will be compressed by
            <tt>CBZip2OutputStream</tt>.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="finalize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Overriden to close the stream.]]>
      </doc>
    </method>
    <method name="finish"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getBlockSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the blocksize parameter specified at construction time.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="byte[]"/>
      <param name="offs" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="MIN_BLOCKSIZE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The minimum supported blocksize <tt> == 1</tt>.]]>
      </doc>
    </field>
    <field name="MAX_BLOCKSIZE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The maximum supported blocksize <tt> == 9</tt>.]]>
      </doc>
    </field>
    <field name="SETMASK" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This constant is accessible by subclasses for historical purposes. If you
 don't know what it means then you don't need it.]]>
      </doc>
    </field>
    <field name="CLEARMASK" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This constant is accessible by subclasses for historical purposes. If you
 don't know what it means then you don't need it.]]>
      </doc>
    </field>
    <field name="GREATER_ICOST" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This constant is accessible by subclasses for historical purposes. If you
 don't know what it means then you don't need it.]]>
      </doc>
    </field>
    <field name="LESSER_ICOST" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This constant is accessible by subclasses for historical purposes. If you
 don't know what it means then you don't need it.]]>
      </doc>
    </field>
    <field name="SMALL_THRESH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This constant is accessible by subclasses for historical purposes. If you
 don't know what it means then you don't need it.]]>
      </doc>
    </field>
    <field name="DEPTH_THRESH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This constant is accessible by subclasses for historical purposes. If you
 don't know what it means then you don't need it.]]>
      </doc>
    </field>
    <field name="WORK_FACTOR" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This constant is accessible by subclasses for historical purposes. If you
 don't know what it means then you don't need it.]]>
      </doc>
    </field>
    <field name="QSORT_STACK_SIZE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This constant is accessible by subclasses for historical purposes. If you
 don't know what it means then you don't need it.
 <p>
 If you are ever unlucky/improbable enough to get a stack overflow whilst
 sorting, increase the following constant and try again. In practice I
 have never seen the stack go above 27 elems, so the following limit seems
 very generous.
 </p>]]>
      </doc>
    </field>
    <doc>
    <![CDATA[An output stream that compresses into the BZip2 format (without the file
 header chars) into another stream.

 <p>
 The compression requires large amounts of memory. Thus you should call the
 {@link #close() close()} method as soon as possible, to force
 <tt>CBZip2OutputStream</tt> to release the allocated memory.
 </p>

 <p>
 You can shrink the amount of allocated memory and maybe raise the compression
 speed by choosing a lower blocksize, which in turn may cause a lower
 compression ratio. You can avoid unnecessary memory allocation by avoiding
 using a blocksize which is bigger than the size of the input.
 </p>

 <p>
 You can compute the memory usage for compressing by the following formula:
 </p>

 <pre>
 &lt;code&gt;400k + (9 * blocksize)&lt;/code&gt;.
 </pre>

 <p>
 To get the memory required for decompression by {@link CBZip2InputStream
 CBZip2InputStream} use
 </p>

 <pre>
 &lt;code&gt;65k + (5 * blocksize)&lt;/code&gt;.
 </pre>

 <table width="100%" border="1">
 <colgroup> <col width="33%" /> <col width="33%" /> <col width="33%" />
 </colgroup>
 <tr>
 <th colspan="3">Memory usage by blocksize</th>
 </tr>
 <tr>
 <th align="right">Blocksize</th> <th align="right">Compression<br>
 memory usage</th> <th align="right">Decompression<br>
 memory usage</th>
 </tr>
 <tr>
 <td align="right">100k</td>
 <td align="right">1300k</td>
 <td align="right">565k</td>
 </tr>
 <tr>
 <td align="right">200k</td>
 <td align="right">2200k</td>
 <td align="right">1065k</td>
 </tr>
 <tr>
 <td align="right">300k</td>
 <td align="right">3100k</td>
 <td align="right">1565k</td>
 </tr>
 <tr>
 <td align="right">400k</td>
 <td align="right">4000k</td>
 <td align="right">2065k</td>
 </tr>
 <tr>
 <td align="right">500k</td>
 <td align="right">4900k</td>
 <td align="right">2565k</td>
 </tr>
 <tr>
 <td align="right">600k</td>
 <td align="right">5800k</td>
 <td align="right">3065k</td>
 </tr>
 <tr>
 <td align="right">700k</td>
 <td align="right">6700k</td>
 <td align="right">3565k</td>
 </tr>
 <tr>
 <td align="right">800k</td>
 <td align="right">7600k</td>
 <td align="right">4065k</td>
 </tr>
 <tr>
 <td align="right">900k</td>
 <td align="right">8500k</td>
 <td align="right">4565k</td>
 </tr>
 </table>

 <p>
 For decompression <tt>CBZip2InputStream</tt> allocates less memory if the
 bzipped input is smaller than one block.
 </p>

 <p>
 Instances of this class are not threadsafe.
 </p>

 <p>
 TODO: Update to BZip2 1.0.1
 </p>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.bzip2.CBZip2OutputStream -->
</package>
<package name="org.apache.hadoop.io.compress.zlib">
  <!-- start class org.apache.hadoop.io.compress.zlib.BuiltInZlibDeflater -->
  <class name="BuiltInZlibDeflater" extends="java.util.zip.Deflater"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.compress.Compressor"/>
    <constructor name="BuiltInZlibDeflater" type="int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BuiltInZlibDeflater" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BuiltInZlibDeflater"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compress" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A wrapper around java.util.zip.Deflater to make it conform 
 to org.apache.hadoop.io.compress.Compressor interface.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.zlib.BuiltInZlibDeflater -->
  <!-- start class org.apache.hadoop.io.compress.zlib.BuiltInZlibInflater -->
  <class name="BuiltInZlibInflater" extends="java.util.zip.Inflater"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.compress.Decompressor"/>
    <constructor name="BuiltInZlibInflater" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BuiltInZlibInflater"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="decompress" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A wrapper around java.util.zip.Inflater to make it conform 
 to org.apache.hadoop.io.compress.Decompressor interface.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.zlib.BuiltInZlibInflater -->
  <!-- start class org.apache.hadoop.io.compress.zlib.ZlibCompressor -->
  <class name="ZlibCompressor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.compress.Compressor"/>
    <constructor name="ZlibCompressor" type="org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionLevel, org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionStrategy, org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionHeader, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new compressor using the specified compression level.
 Compressed data will be generated in ZLIB format.
 
 @param level Compression level #CompressionLevel
 @param strategy Compression strategy #CompressionStrategy
 @param header Compression header #CompressionHeader
 @param directBufferSize Size of the direct buffer to be used.]]>
      </doc>
    </constructor>
    <constructor name="ZlibCompressor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new compressor with the default compression level.
 Compressed data will be generated in ZLIB format.]]>
      </doc>
    </constructor>
    <method name="setInput"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="setDictionary"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="needsInput" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="finish"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="finished" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compress" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getBytesWritten" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the total number of compressed bytes output so far.

 @return the total (non-negative) number of compressed bytes output so far]]>
      </doc>
    </method>
    <method name="getBytesRead" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the total number of uncompressed bytes input so far.</p>

 @return the total (non-negative) number of uncompressed bytes input so far]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="end"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A {@link Compressor} based on the popular 
 zlib compression algorithm.
 http://www.zlib.net/]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.zlib.ZlibCompressor -->
  <!-- start class org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionHeader -->
  <class name="ZlibCompressor.CompressionHeader" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionHeader[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionHeader"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="windowBits" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="NO_HEADER" type="org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionHeader"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[No headers/trailers/checksums.]]>
      </doc>
    </field>
    <field name="DEFAULT_HEADER" type="org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionHeader"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default headers/trailers/checksums.]]>
      </doc>
    </field>
    <field name="GZIP_FORMAT" type="org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionHeader"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Simple gzip headers/trailers.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[The type of header for compressed data.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionHeader -->
  <!-- start class org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionLevel -->
  <class name="ZlibCompressor.CompressionLevel" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionLevel[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionLevel"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="NO_COMPRESSION" type="org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionLevel"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Compression level for no compression.]]>
      </doc>
    </field>
    <field name="BEST_SPEED" type="org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionLevel"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Compression level for fastest compression.]]>
      </doc>
    </field>
    <field name="BEST_COMPRESSION" type="org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionLevel"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Compression level for best compression.]]>
      </doc>
    </field>
    <field name="DEFAULT_COMPRESSION" type="org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionLevel"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default compression level.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[The compression level for zlib library.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionLevel -->
  <!-- start class org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionStrategy -->
  <class name="ZlibCompressor.CompressionStrategy" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionStrategy[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionStrategy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <field name="FILTERED" type="org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionStrategy"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Compression strategy best used for data consisting mostly of small
 values with a somewhat random distribution. Forces more Huffman coding
 and less string matching.]]>
      </doc>
    </field>
    <field name="HUFFMAN_ONLY" type="org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionStrategy"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Compression strategy for Huffman coding only.]]>
      </doc>
    </field>
    <field name="RLE" type="org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionStrategy"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Compression strategy to limit match distances to one
 (run-length encoding).]]>
      </doc>
    </field>
    <field name="FIXED" type="org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionStrategy"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Compression strategy to prevent the use of dynamic Huffman codes, 
 allowing for a simpler decoder for special applications.]]>
      </doc>
    </field>
    <field name="DEFAULT_STRATEGY" type="org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionStrategy"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default compression strategy.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[The compression level for zlib library.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.zlib.ZlibCompressor.CompressionStrategy -->
  <!-- start class org.apache.hadoop.io.compress.zlib.ZlibDecompressor -->
  <class name="ZlibDecompressor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.compress.Decompressor"/>
    <constructor name="ZlibDecompressor" type="org.apache.hadoop.io.compress.zlib.ZlibDecompressor.CompressionHeader, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new decompressor.]]>
      </doc>
    </constructor>
    <constructor name="ZlibDecompressor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setInput"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="setDictionary"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="needsInput" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="needsDictionary" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="finished" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="decompress" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getBytesWritten" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the total number of compressed bytes output so far.

 @return the total (non-negative) number of compressed bytes output so far]]>
      </doc>
    </method>
    <method name="getBytesRead" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the total number of uncompressed bytes input so far.</p>

 @return the total (non-negative) number of uncompressed bytes input so far]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="end"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="finalize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A {@link Decompressor} based on the popular 
 zlib compression algorithm.
 http://www.zlib.net/]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.zlib.ZlibDecompressor -->
  <!-- start class org.apache.hadoop.io.compress.zlib.ZlibDecompressor.CompressionHeader -->
  <class name="ZlibDecompressor.CompressionHeader" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.io.compress.zlib.ZlibDecompressor.CompressionHeader[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.io.compress.zlib.ZlibDecompressor.CompressionHeader"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="windowBits" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="NO_HEADER" type="org.apache.hadoop.io.compress.zlib.ZlibDecompressor.CompressionHeader"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[No headers/trailers/checksums.]]>
      </doc>
    </field>
    <field name="DEFAULT_HEADER" type="org.apache.hadoop.io.compress.zlib.ZlibDecompressor.CompressionHeader"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default headers/trailers/checksums.]]>
      </doc>
    </field>
    <field name="GZIP_FORMAT" type="org.apache.hadoop.io.compress.zlib.ZlibDecompressor.CompressionHeader"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Simple gzip headers/trailers.]]>
      </doc>
    </field>
    <field name="AUTODETECT_GZIP_ZLIB" type="org.apache.hadoop.io.compress.zlib.ZlibDecompressor.CompressionHeader"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Autodetect gzip/zlib headers/trailers.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[The headers to detect from compressed data.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.zlib.ZlibDecompressor.CompressionHeader -->
  <!-- start class org.apache.hadoop.io.compress.zlib.ZlibFactory -->
  <class name="ZlibFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ZlibFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isNativeZlibLoaded" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Check if native-zlib code is loaded & initialized correctly and 
 can be loaded for this job.
 
 @param conf configuration
 @return <code>true</code> if native-zlib is loaded & initialized 
         and can be loaded for this job, else <code>false</code>]]>
      </doc>
    </method>
    <method name="getZlibCompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Return the appropriate type of the zlib compressor. 
 
 @param conf configuration
 @return the appropriate type of the zlib compressor.]]>
      </doc>
    </method>
    <method name="getZlibCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Return the appropriate implementation of the zlib compressor. 
 
 @param conf configuration
 @return the appropriate implementation of the zlib compressor.]]>
      </doc>
    </method>
    <method name="getZlibDecompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Return the appropriate type of the zlib decompressor. 
 
 @param conf configuration
 @return the appropriate type of the zlib decompressor.]]>
      </doc>
    </method>
    <method name="getZlibDecompressor" return="org.apache.hadoop.io.compress.Decompressor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Return the appropriate implementation of the zlib decompressor. 
 
 @param conf configuration
 @return the appropriate implementation of the zlib decompressor.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A collection of factories to create the right 
 zlib/gzip compressor/decompressor instances.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.zlib.ZlibFactory -->
</package>
<package name="org.apache.hadoop.io.retry">
  <!-- start class org.apache.hadoop.io.retry.RetryPolicies -->
  <class name="RetryPolicies" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RetryPolicies"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="retryUpToMaximumCountWithFixedSleep" return="org.apache.hadoop.io.retry.RetryPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="maxRetries" type="int"/>
      <param name="sleepTime" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[<p>
 Keep trying a limited number of times, waiting a fixed time between attempts,
 and then fail by re-throwing the exception.
 </p>]]>
      </doc>
    </method>
    <method name="retryUpToMaximumTimeWithFixedSleep" return="org.apache.hadoop.io.retry.RetryPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="maxTime" type="long"/>
      <param name="sleepTime" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[<p>
 Keep trying for a maximum time, waiting a fixed time between attempts,
 and then fail by re-throwing the exception.
 </p>]]>
      </doc>
    </method>
    <method name="retryUpToMaximumCountWithProportionalSleep" return="org.apache.hadoop.io.retry.RetryPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="maxRetries" type="int"/>
      <param name="sleepTime" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[<p>
 Keep trying a limited number of times, waiting a growing amount of time between attempts,
 and then fail by re-throwing the exception.
 The time between attempts is <code>sleepTime</code> mutliplied by the number of tries so far.
 </p>]]>
      </doc>
    </method>
    <method name="exponentialBackoffRetry" return="org.apache.hadoop.io.retry.RetryPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="maxRetries" type="int"/>
      <param name="sleepTime" type="long"/>
      <param name="timeUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[<p>
 Keep trying a limited number of times, waiting a growing amount of time between attempts,
 and then fail by re-throwing the exception.
 The time between attempts is <code>sleepTime</code> mutliplied by a random
 number in the range of [0, 2 to the number of retries)
 </p>]]>
      </doc>
    </method>
    <method name="retryByException" return="org.apache.hadoop.io.retry.RetryPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="defaultPolicy" type="org.apache.hadoop.io.retry.RetryPolicy"/>
      <param name="exceptionToPolicyMap" type="java.util.Map"/>
      <doc>
      <![CDATA[<p>
 Set a default policy with some explicit handlers for specific exceptions.
 </p>]]>
      </doc>
    </method>
    <method name="retryByRemoteException" return="org.apache.hadoop.io.retry.RetryPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="defaultPolicy" type="org.apache.hadoop.io.retry.RetryPolicy"/>
      <param name="exceptionToPolicyMap" type="java.util.Map"/>
      <doc>
      <![CDATA[<p>
 A retry policy for RemoteException
 Set a default policy with some explicit handlers for specific exceptions.
 </p>]]>
      </doc>
    </method>
    <field name="TRY_ONCE_THEN_FAIL" type="org.apache.hadoop.io.retry.RetryPolicy"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Try once, and fail by re-throwing the exception.
 This corresponds to having no retry mechanism in place.
 </p>]]>
      </doc>
    </field>
    <field name="TRY_ONCE_DONT_FAIL" type="org.apache.hadoop.io.retry.RetryPolicy"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Try once, and fail silently for <code>void</code> methods, or by
 re-throwing the exception for non-<code>void</code> methods.
 </p>]]>
      </doc>
    </field>
    <field name="RETRY_FOREVER" type="org.apache.hadoop.io.retry.RetryPolicy"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Keep trying forever.
 </p>]]>
      </doc>
    </field>
    <doc>
    <![CDATA[<p>
 A collection of useful implementations of {@link RetryPolicy}.
 </p>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.retry.RetryPolicies -->
  <!-- start interface org.apache.hadoop.io.retry.RetryPolicy -->
  <interface name="RetryPolicy"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="shouldRetry" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Exception"/>
      <param name="retries" type="int"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[<p>
 Determines whether the framework should retry a
 method for the given exception, and the number
 of retries that have been made for that operation
 so far.
 </p>
 @param e The exception that caused the method to fail.
 @param retries The number of times the method has been retried.
 @return <code>true</code> if the method should be retried,
   <code>false</code> if the method should not be retried
   but shouldn't fail with an exception (only for void methods).
 @throws Exception The re-thrown exception <code>e</code> indicating
   that the method failed and should not be retried further.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 Specifies a policy for retrying method failures.
 Implementations of this interface should be immutable.
 </p>]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.retry.RetryPolicy -->
  <!-- start class org.apache.hadoop.io.retry.RetryProxy -->
  <class name="RetryProxy" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RetryProxy"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="create" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iface" type="java.lang.Class"/>
      <param name="implementation" type="java.lang.Object"/>
      <param name="retryPolicy" type="org.apache.hadoop.io.retry.RetryPolicy"/>
      <doc>
      <![CDATA[<p>
 Create a proxy for an interface of an implementation class
 using the same retry policy for each method in the interface. 
 </p>
 @param iface the interface that the retry will implement
 @param implementation the instance whose methods should be retried
 @param retryPolicy the policy for retirying method call failures
 @return the retry proxy]]>
      </doc>
    </method>
    <method name="create" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iface" type="java.lang.Class"/>
      <param name="implementation" type="java.lang.Object"/>
      <param name="methodNameToPolicyMap" type="java.util.Map"/>
      <doc>
      <![CDATA[<p>
 Create a proxy for an interface of an implementation class
 using the a set of retry policies specified by method name.
 If no retry policy is defined for a method then a default of
 {@link RetryPolicies#TRY_ONCE_THEN_FAIL} is used.
 </p>
 @param iface the interface that the retry will implement
 @param implementation the instance whose methods should be retried
 @param methodNameToPolicyMap a map of method names to retry policies
 @return the retry proxy]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 A factory for creating retry proxies.
 </p>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.retry.RetryProxy -->
  <doc>
  <![CDATA[<p>
A mechanism for selectively retrying methods that throw exceptions under certain circumstances.
</p>

<p>
Typical usage is
</p>

<pre>
UnreliableImplementation unreliableImpl = new UnreliableImplementation();
UnreliableInterface unreliable = (UnreliableInterface)
  RetryProxy.create(UnreliableInterface.class, unreliableImpl,
    RetryPolicies.retryUpToMaximumCountWithFixedSleep(4, 10, TimeUnit.SECONDS));
unreliable.call();
</pre>

<p>
This will retry any method called on <code>unreliable</code> four times - in this case the <code>call()</code>
method - sleeping 10 seconds between
each retry. There are a number of {@link org.apache.hadoop.io.retry.RetryPolicies retry policies}
available, or you can implement a custom one by implementing {@link org.apache.hadoop.io.retry.RetryPolicy}.
It is also possible to specify retry policies on a 
{@link org.apache.hadoop.io.retry.RetryProxy#create(Class, Object, Map) per-method basis}.
</p>]]>
  </doc>
</package>
<package name="org.apache.hadoop.io.serializer">
  <!-- start interface org.apache.hadoop.io.serializer.Deserializer -->
  <interface name="Deserializer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="open"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Prepare the deserializer for reading.</p>]]>
      </doc>
    </method>
    <method name="deserialize" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>
 Deserialize the next object from the underlying input stream.
 If the object <code>t</code> is non-null then this deserializer
 <i>may</i> set its internal state to the next object read from the input
 stream. Otherwise, if the object <code>t</code> is null a new
 deserialized object will be created.
 </p>
 @return the deserialized object]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Close the underlying input stream and clear up any resources.</p>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 Provides a facility for deserializing objects of type <T> from an
 {@link InputStream}.
 </p>
 
 <p>
 Deserializers are stateful, but must not buffer the input since
 other producers may read from the input between calls to
 {@link #deserialize(Object)}.
 </p>
 @param <T>]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.serializer.Deserializer -->
  <!-- start class org.apache.hadoop.io.serializer.DeserializerComparator -->
  <class name="DeserializerComparator" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.RawComparator"/>
    <constructor name="DeserializerComparator" type="org.apache.hadoop.io.serializer.Deserializer"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[<p>
 A {@link RawComparator} that uses a {@link Deserializer} to deserialize
 the objects to be compared so that the standard {@link Comparator} can
 be used to compare them.
 </p>
 <p>
 One may optimize compare-intensive operations by using a custom
 implementation of {@link RawComparator} that operates directly
 on byte representations.
 </p>
 @param <T>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.serializer.DeserializerComparator -->
  <!-- start class org.apache.hadoop.io.serializer.JavaSerialization -->
  <class name="JavaSerialization" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.serializer.Serialization"/>
    <constructor name="JavaSerialization"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="accept" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
    </method>
    <method name="getDeserializer" return="org.apache.hadoop.io.serializer.Deserializer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
    </method>
    <method name="getSerializer" return="org.apache.hadoop.io.serializer.Serializer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
    </method>
    <doc>
    <![CDATA[<p>
 An experimental {@link Serialization} for Java {@link Serializable} classes.
 </p>
 @see JavaSerializationComparator]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.serializer.JavaSerialization -->
  <!-- start class org.apache.hadoop.io.serializer.JavaSerializationComparator -->
  <class name="JavaSerializationComparator" extends="org.apache.hadoop.io.serializer.DeserializerComparator"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JavaSerializationComparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o1" type="java.io.Serializable"/>
      <param name="o2" type="java.io.Serializable"/>
    </method>
    <doc>
    <![CDATA[<p>
 A {@link RawComparator} that uses a {@link JavaSerialization}
 {@link Deserializer} to deserialize objects that are then compared via
 their {@link Comparable} interfaces.
 </p>
 @param <T>
 @see JavaSerialization]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.serializer.JavaSerializationComparator -->
  <!-- start interface org.apache.hadoop.io.serializer.Serialization -->
  <interface name="Serialization"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="accept" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <doc>
      <![CDATA[Allows clients to test whether this {@link Serialization}
 supports the given class.]]>
      </doc>
    </method>
    <method name="getSerializer" return="org.apache.hadoop.io.serializer.Serializer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <doc>
      <![CDATA[@return a {@link Serializer} for the given class.]]>
      </doc>
    </method>
    <method name="getDeserializer" return="org.apache.hadoop.io.serializer.Deserializer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <doc>
      <![CDATA[@return a {@link Deserializer} for the given class.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 Encapsulates a {@link Serializer}/{@link Deserializer} pair.
 </p>
 @param <T>]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.serializer.Serialization -->
  <!-- start class org.apache.hadoop.io.serializer.SerializationFactory -->
  <class name="SerializationFactory" extends="org.apache.hadoop.conf.Configured"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SerializationFactory" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Serializations are found by reading the <code>io.serializations</code>
 property from <code>conf</code>, which is a comma-delimited list of
 classnames. 
 </p>]]>
      </doc>
    </constructor>
    <method name="getSerializer" return="org.apache.hadoop.io.serializer.Serializer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
    </method>
    <method name="getDeserializer" return="org.apache.hadoop.io.serializer.Deserializer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
    </method>
    <method name="getSerialization" return="org.apache.hadoop.io.serializer.Serialization"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
    </method>
    <doc>
    <![CDATA[<p>
 A factory for {@link Serialization}s.
 </p>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.serializer.SerializationFactory -->
  <!-- start interface org.apache.hadoop.io.serializer.Serializer -->
  <interface name="Serializer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="open"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Prepare the serializer for writing.</p>]]>
      </doc>
    </method>
    <method name="serialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Serialize <code>t</code> to the underlying output stream.</p>]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Close the underlying output stream and clear up any resources.</p>]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 Provides a facility for serializing objects of type <T> to an
 {@link OutputStream}.
 </p>
 
 <p>
 Serializers are stateful, but must not buffer the output since
 other producers may write to the output between calls to
 {@link #serialize(Object)}.
 </p>
 @param <T>]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.serializer.Serializer -->
  <!-- start class org.apache.hadoop.io.serializer.WritableSerialization -->
  <class name="WritableSerialization" extends="org.apache.hadoop.conf.Configured"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.serializer.Serialization"/>
    <constructor name="WritableSerialization"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="accept" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
    </method>
    <method name="getDeserializer" return="org.apache.hadoop.io.serializer.Deserializer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
    </method>
    <method name="getSerializer" return="org.apache.hadoop.io.serializer.Serializer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
    </method>
    <doc>
    <![CDATA[A {@link Serialization} for {@link Writable}s that delegates to
 {@link Writable#write(java.io.DataOutput)} and
 {@link Writable#readFields(java.io.DataInput)}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.serializer.WritableSerialization -->
  <doc>
  <![CDATA[<p>
This package provides a mechanism for using different serialization frameworks
in Hadoop. The property "io.serializations" defines a list of
{@link org.apache.hadoop.io.serializer.Serialization}s that know how to create
{@link org.apache.hadoop.io.serializer.Serializer}s and
{@link org.apache.hadoop.io.serializer.Deserializer}s.
</p>

<p>
To add a new serialization framework write an implementation of
{@link org.apache.hadoop.io.serializer.Serialization} and add its name to the
"io.serializations" property.
</p>]]>
  </doc>
</package>
<package name="org.apache.hadoop.ipc">
  <!-- start class org.apache.hadoop.ipc.Client -->
  <class name="Client" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Client" type="java.lang.Class, org.apache.hadoop.conf.Configuration, javax.net.SocketFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct an IPC client whose values are of the given {@link Writable}
 class.]]>
      </doc>
    </constructor>
    <constructor name="Client" type="java.lang.Class, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct an IPC client with the default SocketFactory
 @param valueClass
 @param conf]]>
      </doc>
    </constructor>
    <method name="setPingInterval"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="pingInterval" type="int"/>
      <doc>
      <![CDATA[set the ping interval value in configuration
 
 @param conf Configuration
 @param pingInterval the ping interval]]>
      </doc>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stop all threads related to this client.  No further calls may be made
 using this client.]]>
      </doc>
    </method>
    <method name="call" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #call(Writable, InetSocketAddress, Class, UserGroupInformation)} instead">
      <param name="param" type="org.apache.hadoop.io.Writable"/>
      <param name="address" type="java.net.InetSocketAddress"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Make a call, passing <code>param</code>, to the IPC server running at
 <code>address</code>, returning the value.  Throws exceptions if there are
 network problems or if the remote code threw an exception.
 @deprecated Use {@link #call(Writable, InetSocketAddress, Class, UserGroupInformation)} instead]]>
      </doc>
    </method>
    <method name="call" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #call(Writable, InetSocketAddress, Class, UserGroupInformation)} instead">
      <param name="param" type="org.apache.hadoop.io.Writable"/>
      <param name="addr" type="java.net.InetSocketAddress"/>
      <param name="ticket" type="org.apache.hadoop.security.UserGroupInformation"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Make a call, passing <code>param</code>, to the IPC server running at
 <code>address</code> with the <code>ticket</code> credentials, returning 
 the value.  
 Throws exceptions if there are network problems or if the remote code 
 threw an exception.
 @deprecated Use {@link #call(Writable, InetSocketAddress, Class, UserGroupInformation)} instead]]>
      </doc>
    </method>
    <method name="call" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="param" type="org.apache.hadoop.io.Writable"/>
      <param name="addr" type="java.net.InetSocketAddress"/>
      <param name="protocol" type="java.lang.Class"/>
      <param name="ticket" type="org.apache.hadoop.security.UserGroupInformation"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Make a call, passing <code>param</code>, to the IPC server running at
 <code>address</code> which is servicing the <code>protocol</code> protocol, 
 with the <code>ticket</code> credentials, returning the value.  
 Throws exceptions if there are network problems or if the remote code 
 threw an exception.]]>
      </doc>
    </method>
    <method name="call" return="org.apache.hadoop.io.Writable[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #call(Writable[], InetSocketAddress[], Class, UserGroupInformation)} instead">
      <param name="params" type="org.apache.hadoop.io.Writable[]"/>
      <param name="addresses" type="java.net.InetSocketAddress[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Makes a set of calls in parallel.  Each parameter is sent to the
 corresponding address.  When all values are available, or have timed out
 or errored, the collected results are returned in an array.  The array
 contains nulls for calls that timed out or errored.
 @deprecated Use {@link #call(Writable[], InetSocketAddress[], Class, UserGroupInformation)} instead]]>
      </doc>
    </method>
    <method name="call" return="org.apache.hadoop.io.Writable[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="params" type="org.apache.hadoop.io.Writable[]"/>
      <param name="addresses" type="java.net.InetSocketAddress[]"/>
      <param name="protocol" type="java.lang.Class"/>
      <param name="ticket" type="org.apache.hadoop.security.UserGroupInformation"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Makes a set of calls in parallel.  Each parameter is sent to the
 corresponding address.  When all values are available, or have timed out
 or errored, the collected results are returned in an array.  The array
 contains nulls for calls that timed out or errored.]]>
      </doc>
    </method>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A client for an IPC service.  IPC calls take a single {@link Writable} as a
 parameter, and return a {@link Writable} as their value.  A service runs on
 a port and is defined by a parameter class and a value class.
 
 @see Server]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ipc.Client -->
  <!-- start class org.apache.hadoop.ipc.RemoteException -->
  <class name="RemoteException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RemoteException" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getClassName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="unwrapRemoteException" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lookupTypes" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[If this remote exception wraps up one of the lookupTypes
 then return this exception.
 <p>
 Unwraps any IOException.
 
 @param lookupTypes the desired exception class.
 @return IOException, which is either the lookupClass exception or this.]]>
      </doc>
    </method>
    <method name="unwrapRemoteException" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instantiate and return the exception wrapped up by this remote exception.
 
 <p> This unwraps any <code>Throwable</code> that has a constructor taking
 a <code>String</code> as a parameter.
 Otherwise it returns this.
 
 @return <code>Throwable]]>
      </doc>
    </method>
    <method name="writeXml"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="doc" type="org.znerd.xmlenc.XMLOutputter"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write the object to XML format]]>
      </doc>
    </method>
    <method name="valueOf" return="org.apache.hadoop.ipc.RemoteException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attrs" type="org.xml.sax.Attributes"/>
      <doc>
      <![CDATA[Create RemoteException from attributes]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.ipc.RemoteException -->
  <!-- start class org.apache.hadoop.ipc.RPC -->
  <class name="RPC" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="waitForProxy" return="org.apache.hadoop.ipc.VersionedProtocol"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="clientVersion" type="long"/>
      <param name="addr" type="java.net.InetSocketAddress"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getProxy" return="org.apache.hadoop.ipc.VersionedProtocol"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="clientVersion" type="long"/>
      <param name="addr" type="java.net.InetSocketAddress"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="factory" type="javax.net.SocketFactory"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a client-side proxy object that implements the named protocol,
 talking to a server at the named address.]]>
      </doc>
    </method>
    <method name="getProxy" return="org.apache.hadoop.ipc.VersionedProtocol"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="clientVersion" type="long"/>
      <param name="addr" type="java.net.InetSocketAddress"/>
      <param name="ticket" type="org.apache.hadoop.security.UserGroupInformation"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="factory" type="javax.net.SocketFactory"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a client-side proxy object that implements the named protocol,
 talking to a server at the named address.]]>
      </doc>
    </method>
    <method name="getProxy" return="org.apache.hadoop.ipc.VersionedProtocol"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="clientVersion" type="long"/>
      <param name="addr" type="java.net.InetSocketAddress"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a client-side proxy object with the default SocketFactory
 
 @param protocol
 @param clientVersion
 @param addr
 @param conf
 @return a proxy instance
 @throws IOException]]>
      </doc>
    </method>
    <method name="stopProxy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="proxy" type="org.apache.hadoop.ipc.VersionedProtocol"/>
      <doc>
      <![CDATA[Stop this proxy and release its invoker's resource
 @param proxy the proxy to be stopped]]>
      </doc>
    </method>
    <method name="call" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #call(Method, Object[][], InetSocketAddress[], UserGroupInformation, Configuration)} instead">
      <param name="method" type="java.lang.reflect.Method"/>
      <param name="params" type="java.lang.Object[][]"/>
      <param name="addrs" type="java.net.InetSocketAddress[]"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Expert: Make multiple, parallel calls to a set of servers.
 @deprecated Use {@link #call(Method, Object[][], InetSocketAddress[], UserGroupInformation, Configuration)} instead]]>
      </doc>
    </method>
    <method name="call" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="method" type="java.lang.reflect.Method"/>
      <param name="params" type="java.lang.Object[][]"/>
      <param name="addrs" type="java.net.InetSocketAddress[]"/>
      <param name="ticket" type="org.apache.hadoop.security.UserGroupInformation"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Expert: Make multiple, parallel calls to a set of servers.]]>
      </doc>
    </method>
    <method name="getServer" return="org.apache.hadoop.ipc.RPC.Server"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <param name="bindAddress" type="java.lang.String"/>
      <param name="port" type="int"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a server for a protocol implementation instance listening on a
 port and address.]]>
      </doc>
    </method>
    <method name="getServer" return="org.apache.hadoop.ipc.RPC.Server"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <param name="bindAddress" type="java.lang.String"/>
      <param name="port" type="int"/>
      <param name="numHandlers" type="int"/>
      <param name="verbose" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a server for a protocol implementation instance listening on a
 port and address.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A simple RPC mechanism.

 A <i>protocol</i> is a Java interface.  All parameters and return types must
 be one of:

 <ul> <li>a primitive type, <code>boolean</code>, <code>byte</code>,
 <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>,
 <code>float</code>, <code>double</code>, or <code>void</code>; or</li>

 <li>a {@link String}; or</li>

 <li>a {@link Writable}; or</li>

 <li>an array of the above types</li> </ul>

 All methods in the protocol should throw only IOException.  No field data of
 the protocol instance is transmitted.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ipc.RPC -->
  <!-- start class org.apache.hadoop.ipc.RPC.Server -->
  <class name="RPC.Server" extends="org.apache.hadoop.ipc.Server"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RPC.Server" type="java.lang.Object, org.apache.hadoop.conf.Configuration, java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct an RPC server.
 @param instance the instance whose methods will be called
 @param conf the configuration to use
 @param bindAddress the address to bind on to listen for connection
 @param port the port to listen for connections on]]>
      </doc>
    </constructor>
    <constructor name="RPC.Server" type="java.lang.Object, org.apache.hadoop.conf.Configuration, java.lang.String, int, int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct an RPC server.
 @param instance the instance whose methods will be called
 @param conf the configuration to use
 @param bindAddress the address to bind on to listen for connection
 @param port the port to listen for connections on
 @param numHandlers the number of method handler threads to run
 @param verbose whether each call should be logged]]>
      </doc>
    </constructor>
    <method name="call" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="param" type="org.apache.hadoop.io.Writable"/>
      <param name="receivedTime" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="authorize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="javax.security.auth.Subject"/>
      <param name="connection" type="org.apache.hadoop.ipc.ConnectionHeader"/>
      <exception name="AuthorizationException" type="org.apache.hadoop.security.authorize.AuthorizationException"/>
    </method>
    <doc>
    <![CDATA[An RPC Server.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ipc.RPC.Server -->
  <!-- start class org.apache.hadoop.ipc.RPC.VersionMismatch -->
  <class name="RPC.VersionMismatch" extends="java.io.IOException"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RPC.VersionMismatch" type="java.lang.String, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a version mismatch exception
 @param interfaceName the name of the protocol mismatch
 @param clientVersion the client's version of the protocol
 @param serverVersion the server's version of the protocol]]>
      </doc>
    </constructor>
    <method name="getInterfaceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the interface name
 @return the java class name 
          (eg. org.apache.hadoop.mapred.InterTrackerProtocol)]]>
      </doc>
    </method>
    <method name="getClientVersion" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the client's preferred version]]>
      </doc>
    </method>
    <method name="getServerVersion" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the server's agreed to version.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A version mismatch for the RPC protocol.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ipc.RPC.VersionMismatch -->
  <!-- start class org.apache.hadoop.ipc.Server -->
  <class name="Server" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Server" type="java.lang.String, int, java.lang.Class, int, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="Server" type="java.lang.String, int, java.lang.Class, int, org.apache.hadoop.conf.Configuration, java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Constructs a server listening on the named port and address.  Parameters passed must
 be of the named class.  The <code>handlerCount</handlerCount> determines
 the number of handler threads that will be used to process calls.]]>
      </doc>
    </constructor>
    <method name="get" return="org.apache.hadoop.ipc.Server"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the server instance called under or null.  May be called under
 {@link #call(Writable, long)} implementations, and under {@link Writable}
 methods of paramters and return values.  Permits applications to access
 the server context.]]>
      </doc>
    </method>
    <method name="getRemoteIp" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the remote side ip address when invoked inside an RPC 
  Returns null incase of an error.]]>
      </doc>
    </method>
    <method name="getRemoteAddress" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns remote address as a string when invoked inside an RPC.
  Returns null in case of an error.]]>
      </doc>
    </method>
    <method name="bind"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="socket" type="java.net.ServerSocket"/>
      <param name="address" type="java.net.InetSocketAddress"/>
      <param name="backlog" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A convenience method to bind to a given address and report 
 better exceptions if the address is not a valid host.
 @param socket the socket to bind
 @param address the address to bind to
 @param backlog the number of connections allowed in the queue
 @throws BindException if the address can't be bound
 @throws UnknownHostException if the address isn't a valid host name
 @throws IOException other random errors from bind]]>
      </doc>
    </method>
    <method name="setSocketSendBufSize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Sets the socket buffer size used for responding to RPCs]]>
      </doc>
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Starts the service.  Must be called before any calls will be handled.]]>
      </doc>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stops the service.  No new calls will be handled after this is called.]]>
      </doc>
    </method>
    <method name="join"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Wait for the server to be stopped.
 Does not wait for all subthreads to finish.
  See {@link #stop()}.]]>
      </doc>
    </method>
    <method name="getListenerAddress" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the socket (ip+port) on which the RPC server is listening to.
 @return the socket (ip+port) on which the RPC server is listening to.]]>
      </doc>
    </method>
    <method name="call" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #call(Class, Writable, long)} instead">
      <param name="param" type="org.apache.hadoop.io.Writable"/>
      <param name="receiveTime" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Called for each call. 
 @deprecated Use {@link #call(Class, Writable, long)} instead]]>
      </doc>
    </method>
    <method name="call" return="org.apache.hadoop.io.Writable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="param" type="org.apache.hadoop.io.Writable"/>
      <param name="receiveTime" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Called for each call.]]>
      </doc>
    </method>
    <method name="authorize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="javax.security.auth.Subject"/>
      <param name="connection" type="org.apache.hadoop.ipc.ConnectionHeader"/>
      <exception name="AuthorizationException" type="org.apache.hadoop.security.authorize.AuthorizationException"/>
      <doc>
      <![CDATA[Authorize the incoming client connection.
 
 @param user client user
 @param connection incoming connection
 @throws AuthorizationException when the client isn't authorized to talk the protocol]]>
      </doc>
    </method>
    <method name="getNumOpenConnections" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of open RPC conections
 @return the number of open rpc connections]]>
      </doc>
    </method>
    <method name="getCallQueueLen" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of rpc calls in the queue.
 @return The number of rpc calls in the queue.]]>
      </doc>
    </method>
    <field name="HEADER" type="java.nio.ByteBuffer"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The first four bytes of Hadoop RPC connections]]>
      </doc>
    </field>
    <field name="CURRENT_VERSION" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="rpcMetrics" type="org.apache.hadoop.ipc.metrics.RpcMetrics"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[An abstract IPC service.  IPC calls take a single {@link Writable} as a
 parameter, and return a {@link Writable} as their value.  A service runs on
 a port and is defined by a parameter class and a value class.
 
 @see Client]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ipc.Server -->
  <!-- start interface org.apache.hadoop.ipc.VersionedProtocol -->
  <interface name="VersionedProtocol"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getProtocolVersion" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.String"/>
      <param name="clientVersion" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return protocol version corresponding to protocol interface.
 @param protocol The classname of the protocol interface
 @param clientVersion The version of the protocol that the client speaks
 @return the version that the server will speak]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Superclass of all protocols that use Hadoop RPC.
 Subclasses of this interface are also supposed to have
 a static final long versionID field.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.ipc.VersionedProtocol -->
  <doc>
  <![CDATA[Tools to help define network clients and servers.]]>
  </doc>
</package>
<package name="org.apache.hadoop.ipc.metrics">
  <!-- start class org.apache.hadoop.ipc.metrics.RpcActivityMBean -->
  <class name="RpcActivityMBean" extends="org.apache.hadoop.metrics.util.MetricsDynamicMBeanBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RpcActivityMBean" type="org.apache.hadoop.metrics.util.MetricsRegistry, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param mr - the metrics registry that has all the metrics
 @param serviceName - the service name for the rpc service 
 @param port - the rpc port.]]>
      </doc>
    </constructor>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This is the JMX MBean for reporting the RPC layer Activity.
 The MBean is register using the name
        "hadoop:service=<RpcServiceName>,name=RpcActivityForPort<port>"
 
 Many of the activity metrics are sampled and averaged on an interval 
 which can be specified in the metrics config file.
 <p>
 For the metrics that are sampled and averaged, one must specify 
 a metrics context that does periodic update calls. Most metrics contexts do.
 The default Null metrics context however does NOT. So if you aren't
 using any other metrics context then you can turn on the viewing and averaging
 of sampled metrics by  specifying the following two lines
  in the hadoop-meterics.properties file:
  <pre>
        rpc.class=org.apache.hadoop.metrics.spi.NullContextWithUpdateThread
        rpc.period=10
  </pre>
<p>
 Note that the metrics are collected regardless of the context used.
 The context with the update thread is used to average the data periodically



 Impl details: We use a dynamic mbean that gets the list of the metrics
 from the metrics registry passed as an argument to the constructor]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ipc.metrics.RpcActivityMBean -->
  <!-- start class org.apache.hadoop.ipc.metrics.RpcMetrics -->
  <class name="RpcMetrics" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics.Updater"/>
    <constructor name="RpcMetrics" type="java.lang.String, java.lang.String, org.apache.hadoop.ipc.Server"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="doUpdates"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.apache.hadoop.metrics.MetricsContext"/>
      <doc>
      <![CDATA[Push the metrics to the monitoring subsystem on doUpdate() call.]]>
      </doc>
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="registry" type="org.apache.hadoop.metrics.util.MetricsRegistry"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="rpcQueueTime" type="org.apache.hadoop.metrics.util.MetricsTimeVaryingRate"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The metrics variables are public:
  - they can be set directly by calling their set/inc methods
  -they can also be read directly - e.g. JMX does this.]]>
      </doc>
    </field>
    <field name="rpcProcessingTime" type="org.apache.hadoop.metrics.util.MetricsTimeVaryingRate"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="numOpenConnections" type="org.apache.hadoop.metrics.util.MetricsIntValue"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="callQueueLen" type="org.apache.hadoop.metrics.util.MetricsIntValue"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This class is for maintaining  the various RPC statistics
 and publishing them through the metrics interfaces.
 This also registers the JMX MBean for RPC.
 <p>
 This class has a number of metrics variables that are publicly accessible;
 these variables (objects) have methods to update their values;
 for example:
  <p> {@link #rpcQueueTime}.inc(time)]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ipc.metrics.RpcMetrics -->
  <!-- start interface org.apache.hadoop.ipc.metrics.RpcMgtMBean -->
  <interface name="RpcMgtMBean"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getRpcOpsNumber" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Number of RPC Operations in the last interval
 @return number of operations]]>
      </doc>
    </method>
    <method name="getRpcOpsAvgProcessingTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Average time for RPC Operations in last interval
 @return time in msec]]>
      </doc>
    </method>
    <method name="getRpcOpsAvgProcessingTimeMin" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The Minimum RPC Operation Processing Time since reset was called
 @return time in msec]]>
      </doc>
    </method>
    <method name="getRpcOpsAvgProcessingTimeMax" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The Maximum RPC Operation Processing Time since reset was called
 @return time in msec]]>
      </doc>
    </method>
    <method name="getRpcOpsAvgQueueTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The Average RPC Operation Queued Time in the last interval
 @return time in msec]]>
      </doc>
    </method>
    <method name="getRpcOpsAvgQueueTimeMin" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The Minimum RPC Operation Queued Time since reset was called
 @return time in msec]]>
      </doc>
    </method>
    <method name="getRpcOpsAvgQueueTimeMax" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The Maximum RPC Operation Queued Time since reset was called
 @return time in msec]]>
      </doc>
    </method>
    <method name="resetAllMinMax"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reset all min max times]]>
      </doc>
    </method>
    <method name="getNumOpenConnections" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of open RPC conections
 @return the number of open rpc connections]]>
      </doc>
    </method>
    <method name="getCallQueueLen" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of rpc calls in the queue.
 @return The number of rpc calls in the queue.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This is the JMX management interface for the RPC layer.
 Many of the statistics are sampled and averaged on an interval 
 which can be specified in the metrics config file.
 <p>
 For the statistics that are sampled and averaged, one must specify 
 a metrics context that does periodic update calls. Most do.
 The default Null metrics context however does NOT. So if you aren't
 using any other metrics context then you can turn on the viewing and averaging
 of sampled metrics by  specifying the following two lines
  in the hadoop-meterics.properties file:
  <pre>
        rpc.class=org.apache.hadoop.metrics.spi.NullContextWithUpdateThread
        rpc.period=10
  </pre>
<p>
 Note that the metrics are collected regardless of the context used.
 The context with the update thread is used to average the data periodically]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.ipc.metrics.RpcMgtMBean -->
</package>
<package name="org.apache.hadoop.log">
  <!-- start class org.apache.hadoop.log.LogLevel -->
  <class name="LogLevel" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LogLevel"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <doc>
      <![CDATA[A command line implementation]]>
      </doc>
    </method>
    <field name="USAGES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Change log level in runtime.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.log.LogLevel -->
  <!-- start class org.apache.hadoop.log.LogLevel.Servlet -->
  <class name="LogLevel.Servlet" extends="javax.servlet.http.HttpServlet"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LogLevel.Servlet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="doGet"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="javax.servlet.http.HttpServletRequest"/>
      <param name="response" type="javax.servlet.http.HttpServletResponse"/>
      <exception name="ServletException" type="javax.servlet.ServletException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A servlet implementation]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.log.LogLevel.Servlet -->
</package>
<package name="org.apache.hadoop.metrics">
  <!-- start class org.apache.hadoop.metrics.ContextFactory -->
  <class name="ContextFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ContextFactory"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of ContextFactory]]>
      </doc>
    </constructor>
    <method name="getAttribute" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attributeName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the value of the named attribute, or null if there is no 
 attribute of that name.

 @param attributeName the attribute name
 @return the attribute value]]>
      </doc>
    </method>
    <method name="getAttributeNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the names of all the factory's attributes.
 
 @return the attribute names]]>
      </doc>
    </method>
    <method name="setAttribute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attributeName" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Sets the named factory attribute to the specified value, creating it
 if it did not already exist.  If the value is null, this is the same as
 calling removeAttribute.

 @param attributeName the attribute name
 @param value the new attribute value]]>
      </doc>
    </method>
    <method name="removeAttribute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attributeName" type="java.lang.String"/>
      <doc>
      <![CDATA[Removes the named attribute if it exists.

 @param attributeName the attribute name]]>
      </doc>
    </method>
    <method name="getContext" return="org.apache.hadoop.metrics.MetricsContext"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="refName" type="java.lang.String"/>
      <param name="contextName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
      <exception name="InstantiationException" type="java.lang.InstantiationException"/>
      <exception name="IllegalAccessException" type="java.lang.IllegalAccessException"/>
      <doc>
      <![CDATA[Returns the named MetricsContext instance, constructing it if necessary 
 using the factory's current configuration attributes. <p/>
 
 When constructing the instance, if the factory property 
 <i>contextName</i>.class</code> exists, 
 its value is taken to be the name of the class to instantiate.  Otherwise,
 the default is to create an instance of 
 <code>org.apache.hadoop.metrics.spi.NullContext</code>, which is a 
 dummy "no-op" context which will cause all metric data to be discarded.
 
 @param contextName the name of the context
 @return the named MetricsContext]]>
      </doc>
    </method>
    <method name="getContext" return="org.apache.hadoop.metrics.MetricsContext"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
      <exception name="InstantiationException" type="java.lang.InstantiationException"/>
      <exception name="IllegalAccessException" type="java.lang.IllegalAccessException"/>
    </method>
    <method name="getNullContext" return="org.apache.hadoop.metrics.MetricsContext"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a "null" context - one which does nothing.]]>
      </doc>
    </method>
    <method name="getFactory" return="org.apache.hadoop.metrics.ContextFactory"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the singleton ContextFactory instance, constructing it if 
 necessary. <p/>
 
 When the instance is constructed, this method checks if the file 
 <code>hadoop-metrics.properties</code> exists on the class path.  If it 
 exists, it must be in the format defined by java.util.Properties, and all 
 the properties in the file are set as attributes on the newly created
 ContextFactory instance.

 @return the singleton ContextFactory instance]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factory class for creating MetricsContext objects.  To obtain an instance
 of this class, use the static <code>getFactory()</code> method.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.ContextFactory -->
  <!-- start interface org.apache.hadoop.metrics.MetricsContext -->
  <interface name="MetricsContext"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="factory" type="org.apache.hadoop.metrics.ContextFactory"/>
      <doc>
      <![CDATA[Initialize this context.
 @param contextName The given name for this context
 @param factory The creator of this context]]>
      </doc>
    </method>
    <method name="getContextName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the context name.

 @return the context name]]>
      </doc>
    </method>
    <method name="startMonitoring"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Starts or restarts monitoring, the emitting of metrics records as they are 
 updated.]]>
      </doc>
    </method>
    <method name="stopMonitoring"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stops monitoring.  This does not free any data that the implementation
 may have buffered for sending at the next timer event. It
 is OK to call <code>startMonitoring()</code> again after calling 
 this.
 @see #close()]]>
      </doc>
    </method>
    <method name="isMonitoring" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if monitoring is currently in progress.]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stops monitoring and also frees any buffered data, returning this 
 object to its initial state.]]>
      </doc>
    </method>
    <method name="createRecord" return="org.apache.hadoop.metrics.MetricsRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recordName" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a new MetricsRecord instance with the given <code>recordName</code>.
 Throws an exception if the metrics implementation is configured with a fixed
 set of record names and <code>recordName</code> is not in that set.

 @param recordName the name of the record
 @throws MetricsException if recordName conflicts with configuration data]]>
      </doc>
    </method>
    <method name="registerUpdater"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="updater" type="org.apache.hadoop.metrics.Updater"/>
      <doc>
      <![CDATA[Registers a callback to be called at regular time intervals, as 
 determined by the implementation-class specific configuration.

 @param updater object to be run periodically; it should updated
 some metrics records and then return]]>
      </doc>
    </method>
    <method name="unregisterUpdater"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="updater" type="org.apache.hadoop.metrics.Updater"/>
      <doc>
      <![CDATA[Removes a callback, if it exists.
 
 @param updater object to be removed from the callback list]]>
      </doc>
    </method>
    <method name="getPeriod" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the timer period.]]>
      </doc>
    </method>
    <field name="DEFAULT_PERIOD" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default period in seconds at which data is sent to the metrics system.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[The main interface to the metrics package.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.metrics.MetricsContext -->
  <!-- start class org.apache.hadoop.metrics.MetricsException -->
  <class name="MetricsException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricsException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of MetricsException]]>
      </doc>
    </constructor>
    <constructor name="MetricsException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of MetricsException 

 @param message an error message]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[General-purpose, unchecked metrics exception.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.MetricsException -->
  <!-- start interface org.apache.hadoop.metrics.MetricsRecord -->
  <interface name="MetricsRecord"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getRecordName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the record name. 

 @return the record name]]>
      </doc>
    </method>
    <method name="setTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagName" type="java.lang.String"/>
      <param name="tagValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the named tag to the specified value.  The tagValue may be null, 
 which is treated the same as an empty String.

 @param tagName name of the tag
 @param tagValue new value of the tag
 @throws MetricsException if the tagName conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagName" type="java.lang.String"/>
      <param name="tagValue" type="int"/>
      <doc>
      <![CDATA[Sets the named tag to the specified value.

 @param tagName name of the tag
 @param tagValue new value of the tag
 @throws MetricsException if the tagName conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagName" type="java.lang.String"/>
      <param name="tagValue" type="long"/>
      <doc>
      <![CDATA[Sets the named tag to the specified value.

 @param tagName name of the tag
 @param tagValue new value of the tag
 @throws MetricsException if the tagName conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagName" type="java.lang.String"/>
      <param name="tagValue" type="short"/>
      <doc>
      <![CDATA[Sets the named tag to the specified value.

 @param tagName name of the tag
 @param tagValue new value of the tag
 @throws MetricsException if the tagName conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagName" type="java.lang.String"/>
      <param name="tagValue" type="byte"/>
      <doc>
      <![CDATA[Sets the named tag to the specified value.

 @param tagName name of the tag
 @param tagValue new value of the tag
 @throws MetricsException if the tagName conflicts with the configuration]]>
      </doc>
    </method>
    <method name="removeTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagName" type="java.lang.String"/>
      <doc>
      <![CDATA[Removes any tag of the specified name.

 @param tagName name of a tag]]>
      </doc>
    </method>
    <method name="setMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="int"/>
      <doc>
      <![CDATA[Sets the named metric to the specified value.

 @param metricName name of the metric
 @param metricValue new value of the metric
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="long"/>
      <doc>
      <![CDATA[Sets the named metric to the specified value.

 @param metricName name of the metric
 @param metricValue new value of the metric
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="short"/>
      <doc>
      <![CDATA[Sets the named metric to the specified value.

 @param metricName name of the metric
 @param metricValue new value of the metric
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="byte"/>
      <doc>
      <![CDATA[Sets the named metric to the specified value.

 @param metricName name of the metric
 @param metricValue new value of the metric
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="float"/>
      <doc>
      <![CDATA[Sets the named metric to the specified value.

 @param metricName name of the metric
 @param metricValue new value of the metric
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="incrMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="int"/>
      <doc>
      <![CDATA[Increments the named metric by the specified value.

 @param metricName name of the metric
 @param metricValue incremental value
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="incrMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="long"/>
      <doc>
      <![CDATA[Increments the named metric by the specified value.

 @param metricName name of the metric
 @param metricValue incremental value
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="incrMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="short"/>
      <doc>
      <![CDATA[Increments the named metric by the specified value.

 @param metricName name of the metric
 @param metricValue incremental value
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="incrMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="byte"/>
      <doc>
      <![CDATA[Increments the named metric by the specified value.

 @param metricName name of the metric
 @param metricValue incremental value
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="incrMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="float"/>
      <doc>
      <![CDATA[Increments the named metric by the specified value.

 @param metricName name of the metric
 @param metricValue incremental value
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Updates the table of buffered data which is to be sent periodically.
 If the tag values match an existing row, that row is updated; 
 otherwise, a new row is added.]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes, from the buffered data table, all rows having tags 
 that equal the tags that have been set on this record. For example,
 if there are no tags on this record, all rows for this record name
 would be removed.  Or, if there is a single tag on this record, then
 just rows containing a tag with the same name and value would be removed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A named and optionally tagged set of records to be sent to the metrics
 system. <p/>

 A record name identifies the kind of data to be reported. For example, a
 program reporting statistics relating to the disks on a computer might use
 a record name "diskStats".<p/>

 A record has zero or more <i>tags</i>. A tag has a name and a value. To
 continue the example, the "diskStats" record might use a tag named
 "diskName" to identify a particular disk.  Sometimes it is useful to have
 more than one tag, so there might also be a "diskType" with value "ide" or
 "scsi" or whatever.<p/>

 A record also has zero or more <i>metrics</i>.  These are the named
 values that are to be reported to the metrics system.  In the "diskStats"
 example, possible metric names would be "diskPercentFull", "diskPercentBusy", 
 "kbReadPerSecond", etc.<p/>
 
 The general procedure for using a MetricsRecord is to fill in its tag and
 metric values, and then call <code>update()</code> to pass the record to the
 client library.
 Metric data is not immediately sent to the metrics system
 each time that <code>update()</code> is called. 
 An internal table is maintained, identified by the record name. This
 table has columns 
 corresponding to the tag and the metric names, and rows 
 corresponding to each unique set of tag values. An update
 either modifies an existing row in the table, or adds a new row with a set of
 tag values that are different from all the other rows.  Note that if there
 are no tags, then there can be at most one row in the table. <p/>
 
 Once a row is added to the table, its data will be sent to the metrics system 
 on every timer period, whether or not it has been updated since the previous
 timer period.  If this is inappropriate, for example if metrics were being
 reported by some transient object in an application, the <code>remove()</code>
 method can be used to remove the row and thus stop the data from being
 sent.<p/>

 Note that the <code>update()</code> method is atomic.  This means that it is
 safe for different threads to be updating the same metric.  More precisely,
 it is OK for different threads to call <code>update()</code> on MetricsRecord instances 
 with the same set of tag names and tag values.  Different threads should 
 <b>not</b> use the same MetricsRecord instance at the same time.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.metrics.MetricsRecord -->
  <!-- start class org.apache.hadoop.metrics.MetricsUtil -->
  <class name="MetricsUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getContext" return="org.apache.hadoop.metrics.MetricsContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
    </method>
    <method name="getContext" return="org.apache.hadoop.metrics.MetricsContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="refName" type="java.lang.String"/>
      <param name="contextName" type="java.lang.String"/>
      <doc>
      <![CDATA[Utility method to return the named context.
 If the desired context cannot be created for any reason, the exception
 is logged, and a null context is returned.]]>
      </doc>
    </method>
    <method name="createRecord" return="org.apache.hadoop.metrics.MetricsRecord"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.apache.hadoop.metrics.MetricsContext"/>
      <param name="recordName" type="java.lang.String"/>
      <doc>
      <![CDATA[Utility method to create and return new metrics record instance within the
 given context. This record is tagged with the host name.

 @param context the context
 @param recordName name of the record
 @return newly created metrics record]]>
      </doc>
    </method>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Utility class to simplify creation and reporting of hadoop metrics.

 For examples of usage, see NameNodeMetrics.
 @see org.apache.hadoop.metrics.MetricsRecord
 @see org.apache.hadoop.metrics.MetricsContext
 @see org.apache.hadoop.metrics.ContextFactory]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.MetricsUtil -->
  <!-- start interface org.apache.hadoop.metrics.Updater -->
  <interface name="Updater"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="doUpdates"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.apache.hadoop.metrics.MetricsContext"/>
      <doc>
      <![CDATA[Timer-based call-back from the metric library.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Call-back interface.  See <code>MetricsContext.registerUpdater()</code>.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.metrics.Updater -->
  <doc>
  <![CDATA[This package defines an API for reporting performance metric information.
<p/>
The API is abstract so that it can be implemented on top of
a variety of metrics client libraries.  The choice of 
client library is a configuration option, and different 
modules within the same application can use
different metrics implementation libraries.
<p/>
Sub-packages:
<dl>
    <dt><code>org.apache.hadoop.metrics.spi</code></dt>
    <dd>The abstract Server Provider Interface package. Those wishing to
    integrate the metrics API with a particular metrics client library should 
    extend this package.</dd>
    
    <dt><code>org.apache.hadoop.metrics.file</code></dt>
    <dd>An implementation package which writes the metric data to 
    a file, or sends it to the standard output stream.</dd>
 
    <dt> <code>org.apache.hadoop.metrics.ganglia</code></dt>
    <dd>An implementation package which sends metric data to 
    <a href="http://ganglia.sourceforge.net/">Ganglia</a>.</dd>
</dl>

<h3>Introduction to the Metrics API</h3>

Here is a simple example of how to use this package to report a single
metric value:
<pre>
    private ContextFactory contextFactory = ContextFactory.getFactory();
    
    void reportMyMetric(float myMetric) {
        MetricsContext myContext = contextFactory.getContext("myContext");
        MetricsRecord myRecord = myContext.getRecord("myRecord");
        myRecord.setMetric("myMetric", myMetric);
        myRecord.update();
    }
</pre>
  
In this example there are three names:
<dl>
  <dt><i>myContext</i></dt>
  <dd>The context name will typically identify either the application, or else a
  module within an application or library.</dd>
  
  <dt><i>myRecord</i></dt>
  <dd>The record name generally identifies some entity for which a set of
  metrics are to be reported.  For example, you could have a record named 
  "cacheStats" for reporting a number of statistics relating to the usage of
  some cache in your application.</dd>
  
  <dt><i>myMetric</i></dt>
  <dd>This identifies a particular metric.  For example, you might have metrics
  named "cache_hits" and "cache_misses".
  </dd>
</dl>

<h3>Tags</h3>

In some cases it is useful to have multiple records with the same name. For 
example, suppose that you want to report statistics about each disk on a computer. 
In this case, the record name would be something like "diskStats", but you also
need to identify the disk which is done by adding a <i>tag</i> to the record.
The code could look something like this:
<pre>
    private MetricsRecord diskStats =
            contextFactory.getContext("myContext").getRecord("diskStats");
            
    void reportDiskMetrics(String diskName, float diskBusy, float diskUsed) {
        diskStats.setTag("diskName", diskName);
        diskStats.setMetric("diskBusy", diskBusy);
        diskStats.setMetric("diskUsed", diskUsed);
        diskStats.update();
    }
</pre>

<h3>Buffering and Callbacks</h3>

Data is not sent immediately to the metrics system when 
<code>MetricsRecord.update()</code> is called. Instead it is stored in an
internal table, and the contents of the table are sent periodically.
This can be important for two reasons:
<ol>
    <li>It means that a programmer is free to put calls to this API in an 
    inner loop, since updates can be very frequent without slowing down
    the application significantly.</li>
    <li>Some implementations can gain efficiency by combining many metrics 
    into a single UDP message.</li>
</ol>

The API provides a timer-based callback via the 
<code>registerUpdater()</code> method.  The benefit of this
versus using <code>java.util.Timer</code> is that the callbacks will be done 
immediately before sending the data, making the data as current as possible.

<h3>Configuration</h3>

It is possible to programmatically examine and modify configuration data
before creating a context, like this:
<pre>
    ContextFactory factory = ContextFactory.getFactory();
    ... examine and/or modify factory attributes ...
    MetricsContext context = factory.getContext("myContext");
</pre>
The factory attributes can be examined and modified using the following
<code>ContextFactory</code>methods:
<ul>
    <li><code>Object getAttribute(String attributeName)</code></li>
    <li><code>String[] getAttributeNames()</code></li>
    <li><code>void setAttribute(String name, Object value)</code></li>
    <li><code>void removeAttribute(attributeName)</code></li>
</ul>

<p/>
<code>ContextFactory.getFactory()</code> initializes the factory attributes by
reading the properties file <code>hadoop-metrics.properties</code> if it exists 
on the class path.

<p/>
A factory attribute named:
<pre>
<i>contextName</i>.class
</pre>
should have as its value the fully qualified name of the class to be 
instantiated by a call of the <code>CodeFactory</code> method
<code>getContext(<i>contextName</i>)</code>.  If this factory attribute is not 
specified, the default is to instantiate 
<code>org.apache.hadoop.metrics.file.FileContext</code>.

<p/>
Other factory attributes are specific to a particular implementation of this 
API and are documented elsewhere.  For example, configuration attributes for
the file and Ganglia implementations can be found in the javadoc for 
their respective packages.]]>
  </doc>
</package>
<package name="org.apache.hadoop.metrics.file">
  <!-- start class org.apache.hadoop.metrics.file.FileContext -->
  <class name="FileContext" extends="org.apache.hadoop.metrics.spi.AbstractMetricsContext"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FileContext"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of FileContext]]>
      </doc>
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="factory" type="org.apache.hadoop.metrics.ContextFactory"/>
    </method>
    <method name="getFileName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the configured file name, or null.]]>
      </doc>
    </method>
    <method name="startMonitoring"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Starts or restarts monitoring, by opening in append-mode, the
 file specified by the <code>fileName</code> attribute,
 if specified. Otherwise the data will be written to standard
 output.]]>
      </doc>
    </method>
    <method name="stopMonitoring"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stops monitoring, closing the file.
 @see #close()]]>
      </doc>
    </method>
    <method name="emitRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="recordName" type="java.lang.String"/>
      <param name="outRec" type="org.apache.hadoop.metrics.spi.OutputRecord"/>
      <doc>
      <![CDATA[Emits a metrics record to a file.]]>
      </doc>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Flushes the output writer, forcing updates to disk.]]>
      </doc>
    </method>
    <field name="FILE_NAME_PROPERTY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="PERIOD_PROPERTY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Metrics context for writing metrics to a file.<p/>

 This class is configured by setting ContextFactory attributes which in turn
 are usually configured through a properties file.  All the attributes are
 prefixed by the contextName. For example, the properties file might contain:
 <pre>
 myContextName.fileName=/tmp/metrics.log
 myContextName.period=5
 </pre>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.file.FileContext -->
  <doc>
  <![CDATA[Implementation of the metrics package that writes the metrics to a file.
Programmers should not normally need to use this package directly. Instead
they should use org.hadoop.metrics.

<p/>
These are the implementation specific factory attributes 
(See ContextFactory.getFactory()):

<dl>
    <dt><i>contextName</i>.fileName</dt>
    <dd>The path of the file to which metrics in context <i>contextName</i>
    are to be appended.  If this attribute is not specified, the metrics
    are written to standard output by default.</dd>
    
    <dt><i>contextName</i>.period</dt>
    <dd>The period in seconds on which the metric data is written to the
    file.</dd>
    
</dl>]]>
  </doc>
</package>
<package name="org.apache.hadoop.metrics.ganglia">
  <!-- start class org.apache.hadoop.metrics.ganglia.GangliaContext -->
  <class name="GangliaContext" extends="org.apache.hadoop.metrics.spi.AbstractMetricsContext"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GangliaContext"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of GangliaContext]]>
      </doc>
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="factory" type="org.apache.hadoop.metrics.ContextFactory"/>
    </method>
    <method name="emitRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="recordName" type="java.lang.String"/>
      <param name="outRec" type="org.apache.hadoop.metrics.spi.OutputRecord"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Context for sending metrics to Ganglia.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.ganglia.GangliaContext -->
  <doc>
  <![CDATA[<!--
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->

Implementation of the metrics package that sends metric data to 
<a href="http://ganglia.sourceforge.net/">Ganglia</a>.
Programmers should not normally need to use this package directly. Instead
they should use org.hadoop.metrics.

<p/>
These are the implementation specific factory attributes 
(See ContextFactory.getFactory()):

<dl>
    <dt><i>contextName</i>.servers</dt>
    <dd>Space and/or comma separated sequence of servers to which UDP
    messages should be sent.</dd>
    
    <dt><i>contextName</i>.period</dt>
    <dd>The period in seconds on which the metric data is sent to the
    server(s).</dd>
    
    <dt><i>contextName</i>.units.<i>recordName</i>.<i>metricName</i></dt>
    <dd>The units for the specified metric in the specified record.</dd>
    
    <dt><i>contextName</i>.slope.<i>recordName</i>.<i>metricName</i></dt>
    <dd>The slope for the specified metric in the specified record.</dd>
    
    <dt><i>contextName</i>.tmax.<i>recordName</i>.<i>metricName</i></dt>
    <dd>The tmax for the specified metric in the specified record.</dd>
    
    <dt><i>contextName</i>.dmax.<i>recordName</i>.<i>metricName</i></dt>
    <dd>The dmax for the specified metric in the specified record.</dd>
    
</dl>]]>
  </doc>
</package>
<package name="org.apache.hadoop.metrics.jvm">
  <!-- start class org.apache.hadoop.metrics.jvm.EventCounter -->
  <class name="EventCounter" extends="org.apache.log4j.AppenderSkeleton"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EventCounter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getFatal" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getError" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getWarn" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInfo" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="org.apache.log4j.spi.LoggingEvent"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="requiresLayout" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A log4J Appender that simply counts logging events in three levels:
 fatal, error and warn.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.jvm.EventCounter -->
  <!-- start class org.apache.hadoop.metrics.jvm.JvmMetrics -->
  <class name="JvmMetrics" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics.Updater"/>
    <method name="init" return="org.apache.hadoop.metrics.jvm.JvmMetrics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="processName" type="java.lang.String"/>
      <param name="sessionId" type="java.lang.String"/>
    </method>
    <method name="init" return="org.apache.hadoop.metrics.jvm.JvmMetrics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="processName" type="java.lang.String"/>
      <param name="sessionId" type="java.lang.String"/>
      <param name="recordName" type="java.lang.String"/>
    </method>
    <method name="doUpdates"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.apache.hadoop.metrics.MetricsContext"/>
      <doc>
      <![CDATA[This will be called periodically (with the period being configuration
 dependent).]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Singleton class which reports Java Virtual Machine metrics to the metrics API.  
 Any application can create an instance of this class in order to emit
 Java VM metrics.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.jvm.JvmMetrics -->
</package>
<package name="org.apache.hadoop.metrics.spi">
  <!-- start class org.apache.hadoop.metrics.spi.AbstractMetricsContext -->
  <class name="AbstractMetricsContext" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics.MetricsContext"/>
    <constructor name="AbstractMetricsContext"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of AbstractMetricsContext]]>
      </doc>
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="factory" type="org.apache.hadoop.metrics.ContextFactory"/>
      <doc>
      <![CDATA[Initializes the context.]]>
      </doc>
    </method>
    <method name="getAttribute" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="attributeName" type="java.lang.String"/>
      <doc>
      <![CDATA[Convenience method for subclasses to access factory attributes.]]>
      </doc>
    </method>
    <method name="getAttributeTable" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns an attribute-value map derived from the factory attributes
 by finding all factory attributes that begin with 
 <i>contextName</i>.<i>tableName</i>.  The returned map consists of
 those attributes with the contextName and tableName stripped off.]]>
      </doc>
    </method>
    <method name="getContextName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the context name.]]>
      </doc>
    </method>
    <method name="getContextFactory" return="org.apache.hadoop.metrics.ContextFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the factory by which this context was created.]]>
      </doc>
    </method>
    <method name="startMonitoring"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Starts or restarts monitoring, the emitting of metrics records.]]>
      </doc>
    </method>
    <method name="stopMonitoring"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stops monitoring.  This does not free buffered data. 
 @see #close()]]>
      </doc>
    </method>
    <method name="isMonitoring" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if monitoring is currently in progress.]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stops monitoring and frees buffered data, returning this
 object to its initial state.]]>
      </doc>
    </method>
    <method name="createRecord" return="org.apache.hadoop.metrics.MetricsRecord"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="recordName" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a new AbstractMetricsRecord instance with the given <code>recordName</code>.
 Throws an exception if the metrics implementation is configured with a fixed
 set of record names and <code>recordName</code> is not in that set.
 
 @param recordName the name of the record
 @throws MetricsException if recordName conflicts with configuration data]]>
      </doc>
    </method>
    <method name="newRecord" return="org.apache.hadoop.metrics.MetricsRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="recordName" type="java.lang.String"/>
      <doc>
      <![CDATA[Subclasses should override this if they subclass MetricsRecordImpl.
 @param recordName the name of the record
 @return newly created instance of MetricsRecordImpl or subclass]]>
      </doc>
    </method>
    <method name="registerUpdater"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="updater" type="org.apache.hadoop.metrics.Updater"/>
      <doc>
      <![CDATA[Registers a callback to be called at time intervals determined by
 the configuration.

 @param updater object to be run periodically; it should update
 some metrics records]]>
      </doc>
    </method>
    <method name="unregisterUpdater"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="updater" type="org.apache.hadoop.metrics.Updater"/>
      <doc>
      <![CDATA[Removes a callback, if it exists.

 @param updater object to be removed from the callback list]]>
      </doc>
    </method>
    <method name="emitRecord"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="recordName" type="java.lang.String"/>
      <param name="outRec" type="org.apache.hadoop.metrics.spi.OutputRecord"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Sends a record to the metrics system.]]>
      </doc>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Called each period after all records have been emitted, this method does nothing.
 Subclasses may override it in order to perform some kind of flush.]]>
      </doc>
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics.spi.MetricsRecordImpl"/>
      <doc>
      <![CDATA[Called by MetricsRecordImpl.update().  Creates or updates a row in
 the internal table of metric data.]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics.spi.MetricsRecordImpl"/>
      <doc>
      <![CDATA[Called by MetricsRecordImpl.remove().  Removes all matching rows in
 the internal table of metric data.  A row matches if it has the same
 tag names and values as record, but it may also have additional
 tags.]]>
      </doc>
    </method>
    <method name="getPeriod" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the timer period.]]>
      </doc>
    </method>
    <method name="setPeriod"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="period" type="int"/>
      <doc>
      <![CDATA[Sets the timer period]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The main class of the Service Provider Interface.  This class should be
 extended in order to integrate the Metrics API with a specific metrics
 client library. <p/>

 This class implements the internal table of metric data, and the timer
 on which data is to be sent to the metrics system.  Subclasses must
 override the abstract <code>emitRecord</code> method in order to transmit
 the data. <p/>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.spi.AbstractMetricsContext -->
  <!-- start class org.apache.hadoop.metrics.spi.CompositeContext -->
  <class name="CompositeContext" extends="org.apache.hadoop.metrics.spi.AbstractMetricsContext"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CompositeContext"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="factory" type="org.apache.hadoop.metrics.ContextFactory"/>
    </method>
    <method name="newRecord" return="org.apache.hadoop.metrics.MetricsRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recordName" type="java.lang.String"/>
    </method>
    <method name="emitRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="recordName" type="java.lang.String"/>
      <param name="outRec" type="org.apache.hadoop.metrics.spi.OutputRecord"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startMonitoring"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="stopMonitoring"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isMonitoring" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return true if all subcontexts are monitoring.]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="registerUpdater"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="updater" type="org.apache.hadoop.metrics.Updater"/>
    </method>
    <method name="unregisterUpdater"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="updater" type="org.apache.hadoop.metrics.Updater"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.metrics.spi.CompositeContext -->
  <!-- start class org.apache.hadoop.metrics.spi.MetricsRecordImpl -->
  <class name="MetricsRecordImpl" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics.MetricsRecord"/>
    <constructor name="MetricsRecordImpl" type="java.lang.String, org.apache.hadoop.metrics.spi.AbstractMetricsContext"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of FileRecord]]>
      </doc>
    </constructor>
    <method name="getRecordName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the record name. 

 @return the record name]]>
      </doc>
    </method>
    <method name="setTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagName" type="java.lang.String"/>
      <param name="tagValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the named tag to the specified value.

 @param tagName name of the tag
 @param tagValue new value of the tag
 @throws MetricsException if the tagName conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagName" type="java.lang.String"/>
      <param name="tagValue" type="int"/>
      <doc>
      <![CDATA[Sets the named tag to the specified value.

 @param tagName name of the tag
 @param tagValue new value of the tag
 @throws MetricsException if the tagName conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagName" type="java.lang.String"/>
      <param name="tagValue" type="long"/>
      <doc>
      <![CDATA[Sets the named tag to the specified value.

 @param tagName name of the tag
 @param tagValue new value of the tag
 @throws MetricsException if the tagName conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagName" type="java.lang.String"/>
      <param name="tagValue" type="short"/>
      <doc>
      <![CDATA[Sets the named tag to the specified value.

 @param tagName name of the tag
 @param tagValue new value of the tag
 @throws MetricsException if the tagName conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagName" type="java.lang.String"/>
      <param name="tagValue" type="byte"/>
      <doc>
      <![CDATA[Sets the named tag to the specified value.

 @param tagName name of the tag
 @param tagValue new value of the tag
 @throws MetricsException if the tagName conflicts with the configuration]]>
      </doc>
    </method>
    <method name="removeTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagName" type="java.lang.String"/>
      <doc>
      <![CDATA[Removes any tag of the specified name.]]>
      </doc>
    </method>
    <method name="setMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="int"/>
      <doc>
      <![CDATA[Sets the named metric to the specified value.

 @param metricName name of the metric
 @param metricValue new value of the metric
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="long"/>
      <doc>
      <![CDATA[Sets the named metric to the specified value.

 @param metricName name of the metric
 @param metricValue new value of the metric
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="short"/>
      <doc>
      <![CDATA[Sets the named metric to the specified value.

 @param metricName name of the metric
 @param metricValue new value of the metric
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="byte"/>
      <doc>
      <![CDATA[Sets the named metric to the specified value.

 @param metricName name of the metric
 @param metricValue new value of the metric
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="float"/>
      <doc>
      <![CDATA[Sets the named metric to the specified value.

 @param metricName name of the metric
 @param metricValue new value of the metric
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="incrMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="int"/>
      <doc>
      <![CDATA[Increments the named metric by the specified value.

 @param metricName name of the metric
 @param metricValue incremental value
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="incrMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="long"/>
      <doc>
      <![CDATA[Increments the named metric by the specified value.

 @param metricName name of the metric
 @param metricValue incremental value
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="incrMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="short"/>
      <doc>
      <![CDATA[Increments the named metric by the specified value.

 @param metricName name of the metric
 @param metricValue incremental value
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="incrMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="byte"/>
      <doc>
      <![CDATA[Increments the named metric by the specified value.

 @param metricName name of the metric
 @param metricValue incremental value
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="incrMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="float"/>
      <doc>
      <![CDATA[Increments the named metric by the specified value.

 @param metricName name of the metric
 @param metricValue incremental value
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Updates the table of buffered data which is to be sent periodically.
 If the tag values match an existing row, that row is updated; 
 otherwise, a new row is added.]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes the row, if it exists, in the buffered data table having tags 
 that equal the tags that have been set on this record.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An implementation of MetricsRecord.  Keeps a back-pointer to the context
 from which it was created, and delegates back to it on <code>update</code>
 and <code>remove()</code>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.spi.MetricsRecordImpl -->
  <!-- start class org.apache.hadoop.metrics.spi.MetricValue -->
  <class name="MetricValue" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricValue" type="java.lang.Number, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of MetricValue]]>
      </doc>
    </constructor>
    <method name="isIncrement" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isAbsolute" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNumber" return="java.lang.Number"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="ABSOLUTE" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INCREMENT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A Number that is either an absolute or an incremental amount.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.spi.MetricValue -->
  <!-- start class org.apache.hadoop.metrics.spi.NullContext -->
  <class name="NullContext" extends="org.apache.hadoop.metrics.spi.AbstractMetricsContext"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NullContext"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of NullContext]]>
      </doc>
    </constructor>
    <method name="startMonitoring"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Do-nothing version of startMonitoring]]>
      </doc>
    </method>
    <method name="emitRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="recordName" type="java.lang.String"/>
      <param name="outRec" type="org.apache.hadoop.metrics.spi.OutputRecord"/>
      <doc>
      <![CDATA[Do-nothing version of emitRecord]]>
      </doc>
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics.spi.MetricsRecordImpl"/>
      <doc>
      <![CDATA[Do-nothing version of update]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics.spi.MetricsRecordImpl"/>
      <doc>
      <![CDATA[Do-nothing version of remove]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Null metrics context: a metrics context which does nothing.  Used as the
 default context, so that no performance data is emitted if no configuration
 data is found.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.spi.NullContext -->
  <!-- start class org.apache.hadoop.metrics.spi.NullContextWithUpdateThread -->
  <class name="NullContextWithUpdateThread" extends="org.apache.hadoop.metrics.spi.AbstractMetricsContext"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NullContextWithUpdateThread"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of NullContextWithUpdateThread]]>
      </doc>
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="factory" type="org.apache.hadoop.metrics.ContextFactory"/>
    </method>
    <method name="emitRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="recordName" type="java.lang.String"/>
      <param name="outRec" type="org.apache.hadoop.metrics.spi.OutputRecord"/>
      <doc>
      <![CDATA[Do-nothing version of emitRecord]]>
      </doc>
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics.spi.MetricsRecordImpl"/>
      <doc>
      <![CDATA[Do-nothing version of update]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics.spi.MetricsRecordImpl"/>
      <doc>
      <![CDATA[Do-nothing version of remove]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A null context which has a thread calling 
 periodically when monitoring is started. This keeps the data sampled 
 correctly.
 In all other respects, this is like the NULL context: No data is emitted.
 This is suitable for Monitoring systems like JMX which reads the metrics
  when someone reads the data from JMX.
 
 The default impl of start and stop monitoring:
  is the AbstractMetricsContext is good enough.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.spi.NullContextWithUpdateThread -->
  <!-- start class org.apache.hadoop.metrics.spi.OutputRecord -->
  <class name="OutputRecord" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getTagNames" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the set of tag names]]>
      </doc>
    </method>
    <method name="getTag" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a tag object which is can be a String, Integer, Short or Byte.

 @return the tag value, or null if there is no such tag]]>
      </doc>
    </method>
    <method name="getMetricNames" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the set of metric names.]]>
      </doc>
    </method>
    <method name="getMetric" return="java.lang.Number"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the metric object which can be a Float, Integer, Short or Byte.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a record of metric data to be sent to a metrics system.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.spi.OutputRecord -->
  <!-- start class org.apache.hadoop.metrics.spi.Util -->
  <class name="Util" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="parse" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="specs" type="java.lang.String"/>
      <param name="defaultPort" type="int"/>
      <doc>
      <![CDATA[Parses a space and/or comma separated sequence of server specifications
 of the form <i>hostname</i> or <i>hostname:port</i>.  If 
 the specs string is null, defaults to localhost:defaultPort.
 
 @return a list of InetSocketAddress objects.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.spi.Util -->
  <doc>
  <![CDATA[The Service Provider Interface for the Metrics API.  This package provides
an interface allowing a variety of metrics reporting implementations to be
plugged in to the Metrics API.  Examples of such implementations can be found 
in the packages <code>org.apache.hadoop.metrics.file</code> and
<code>org.apache.hadoop.metrics.ganglia</code>.<p/>

Plugging in an implementation involves writing a concrete subclass of 
<code>AbstractMetricsContext</code>.  The subclass should get its
 configuration information using the <code>getAttribute(<i>attributeName</i>)</code>
 method.]]>
  </doc>
</package>
<package name="org.apache.hadoop.metrics.util">
  <!-- start class org.apache.hadoop.metrics.util.MBeanUtil -->
  <class name="MBeanUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MBeanUtil"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="registerMBean" return="javax.management.ObjectName"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serviceName" type="java.lang.String"/>
      <param name="nameName" type="java.lang.String"/>
      <param name="theMbean" type="java.lang.Object"/>
      <doc>
      <![CDATA[Register the MBean using our standard MBeanName format
 "hadoop:service=<serviceName>,name=<nameName>"
 Where the <serviceName> and <nameName> are the supplied parameters
    
 @param serviceName
 @param nameName
 @param theMbean - the MBean to register
 @return the named used to register the MBean]]>
      </doc>
    </method>
    <method name="unregisterMBean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mbeanName" type="javax.management.ObjectName"/>
    </method>
    <doc>
    <![CDATA[This util class provides a method to register an MBean using
 our standard naming convention as described in the doc
  for {link {@link #registerMBean(String, String, Object)}]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.util.MBeanUtil -->
  <!-- start class org.apache.hadoop.metrics.util.MetricsBase -->
  <class name="MetricsBase" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricsBase" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MetricsBase" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="pushMetric"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mr" type="org.apache.hadoop.metrics.MetricsRecord"/>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="NO_DESCRIPTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This is base class for all metrics]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.util.MetricsBase -->
  <!-- start class org.apache.hadoop.metrics.util.MetricsDynamicMBeanBase -->
  <class name="MetricsDynamicMBeanBase" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.management.DynamicMBean"/>
    <constructor name="MetricsDynamicMBeanBase" type="org.apache.hadoop.metrics.util.MetricsRegistry, java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getAttribute" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attributeName" type="java.lang.String"/>
      <exception name="AttributeNotFoundException" type="javax.management.AttributeNotFoundException"/>
      <exception name="MBeanException" type="javax.management.MBeanException"/>
      <exception name="ReflectionException" type="javax.management.ReflectionException"/>
    </method>
    <method name="getAttributes" return="javax.management.AttributeList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attributeNames" type="java.lang.String[]"/>
    </method>
    <method name="getMBeanInfo" return="javax.management.MBeanInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="invoke" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="actionName" type="java.lang.String"/>
      <param name="parms" type="java.lang.Object[]"/>
      <param name="signature" type="java.lang.String[]"/>
      <exception name="MBeanException" type="javax.management.MBeanException"/>
      <exception name="ReflectionException" type="javax.management.ReflectionException"/>
    </method>
    <method name="setAttribute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attribute" type="javax.management.Attribute"/>
      <exception name="AttributeNotFoundException" type="javax.management.AttributeNotFoundException"/>
      <exception name="InvalidAttributeValueException" type="javax.management.InvalidAttributeValueException"/>
      <exception name="MBeanException" type="javax.management.MBeanException"/>
      <exception name="ReflectionException" type="javax.management.ReflectionException"/>
    </method>
    <method name="setAttributes" return="javax.management.AttributeList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attributes" type="javax.management.AttributeList"/>
    </method>
    <doc>
    <![CDATA[This abstract base class facilitates creating dynamic mbeans automatically from
 metrics. 
 The metrics constructors registers metrics in a registry. 
 Different categories of metrics should be in differnt classes with their own
 registry (as in NameNodeMetrics and DataNodeMetrics).
 Then the MBean can be created passing the registry to the constructor.
 The MBean should be then registered using a mbean name (example):
  MetricsHolder myMetrics = new MetricsHolder(); // has metrics and registry
  MetricsTestMBean theMBean = new MetricsTestMBean(myMetrics.mregistry);
  ObjectName mbeanName = MBeanUtil.registerMBean("ServiceFoo",
                "TestStatistics", theMBean);]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.util.MetricsDynamicMBeanBase -->
  <!-- start class org.apache.hadoop.metrics.util.MetricsIntValue -->
  <class name="MetricsIntValue" extends="org.apache.hadoop.metrics.util.MetricsBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricsIntValue" type="java.lang.String, org.apache.hadoop.metrics.util.MetricsRegistry, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor - create a new metric
 @param nam the name of the metrics to be used to publish the metric
 @param registry - where the metrics object will be registered]]>
      </doc>
    </constructor>
    <constructor name="MetricsIntValue" type="java.lang.String, org.apache.hadoop.metrics.util.MetricsRegistry"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor - create a new metric
 @param nam the name of the metrics to be used to publish the metric
 @param registry - where the metrics object will be registered
 A description of {@link #NO_DESCRIPTION} is used]]>
      </doc>
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newValue" type="int"/>
      <doc>
      <![CDATA[Set the value
 @param newValue]]>
      </doc>
    </method>
    <method name="get" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get value
 @return the value last set]]>
      </doc>
    </method>
    <method name="pushMetric"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mr" type="org.apache.hadoop.metrics.MetricsRecord"/>
      <doc>
      <![CDATA[Push the metric to the mr.
 The metric is pushed only if it was updated since last push
 
 Note this does NOT push to JMX
 (JMX gets the info via {@link #get()}

 @param mr]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The MetricsIntValue class is for a metric that is not time varied
 but changes only when it is set. 
 Each time its value is set, it is published only *once* at the next update
 call.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.util.MetricsIntValue -->
  <!-- start class org.apache.hadoop.metrics.util.MetricsLongValue -->
  <class name="MetricsLongValue" extends="org.apache.hadoop.metrics.util.MetricsBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricsLongValue" type="java.lang.String, org.apache.hadoop.metrics.util.MetricsRegistry, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor - create a new metric
 @param nam the name of the metrics to be used to publish the metric
 @param registry - where the metrics object will be registered]]>
      </doc>
    </constructor>
    <constructor name="MetricsLongValue" type="java.lang.String, org.apache.hadoop.metrics.util.MetricsRegistry"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor - create a new metric
 @param nam the name of the metrics to be used to publish the metric
 @param registry - where the metrics object will be registered
 A description of {@link #NO_DESCRIPTION} is used]]>
      </doc>
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newValue" type="long"/>
      <doc>
      <![CDATA[Set the value
 @param newValue]]>
      </doc>
    </method>
    <method name="get" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get value
 @return the value last set]]>
      </doc>
    </method>
    <method name="pushMetric"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mr" type="org.apache.hadoop.metrics.MetricsRecord"/>
      <doc>
      <![CDATA[Push the metric to the mr.
 The metric is pushed only if it was updated since last push
 
 Note this does NOT push to JMX
 (JMX gets the info via {@link #get()}

 @param mr]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The MetricsLongValue class is for a metric that is not time varied
 but changes only when it is set. 
 Each time its value is set, it is published only *once* at the next update
 call.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.util.MetricsLongValue -->
  <!-- start class org.apache.hadoop.metrics.util.MetricsRegistry -->
  <class name="MetricsRegistry" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricsRegistry"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return number of metrics in the registry]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricsName" type="java.lang.String"/>
      <param name="theMetricsObj" type="org.apache.hadoop.metrics.util.MetricsBase"/>
      <doc>
      <![CDATA[Add a new metrics to the registry
 @param metricsName - the name
 @param theMetricsObj - the metrics
 @throws IllegalArgumentException if a name is already registered]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.metrics.util.MetricsBase"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricsName" type="java.lang.String"/>
      <doc>
      <![CDATA[@param metricsName
 @return the metrics if there is one registered by the supplied name.
         Returns null if none is registered]]>
      </doc>
    </method>
    <method name="getKeyList" return="java.util.Collection"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the list of metrics names]]>
      </doc>
    </method>
    <method name="getMetricsList" return="java.util.Collection"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the list of metrics]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This is the registry for metrics.
 Related set of metrics should be declared in a holding class and registered
 in a registry for those metrics which is also stored in the the holding class.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.util.MetricsRegistry -->
  <!-- start class org.apache.hadoop.metrics.util.MetricsTimeVaryingInt -->
  <class name="MetricsTimeVaryingInt" extends="org.apache.hadoop.metrics.util.MetricsBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricsTimeVaryingInt" type="java.lang.String, org.apache.hadoop.metrics.util.MetricsRegistry, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor - create a new metric
 @param nam the name of the metrics to be used to publish the metric
 @param registry - where the metrics object will be registered
 @param description - the description]]>
      </doc>
    </constructor>
    <constructor name="MetricsTimeVaryingInt" type="java.lang.String, org.apache.hadoop.metrics.util.MetricsRegistry"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor - create a new metric
 @param nam the name of the metrics to be used to publish the metric
 @param registry - where the metrics object will be registered
 A description of {@link #NO_DESCRIPTION} is used]]>
      </doc>
    </constructor>
    <method name="inc"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="incr" type="int"/>
      <doc>
      <![CDATA[Inc metrics for incr vlaue
 @param incr - number of operations]]>
      </doc>
    </method>
    <method name="inc"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Inc metrics by one]]>
      </doc>
    </method>
    <method name="pushMetric"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mr" type="org.apache.hadoop.metrics.MetricsRecord"/>
      <doc>
      <![CDATA[Push the delta  metrics to the mr.
 The delta is since the last push/interval.
 
 Note this does NOT push to JMX
 (JMX gets the info via {@link #previousIntervalValue}

 @param mr]]>
      </doc>
    </method>
    <method name="getPreviousIntervalValue" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The Value at the Previous interval
 @return prev interval value]]>
      </doc>
    </method>
    <method name="getCurrentIntervalValue" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The Value at the current interval
 @return prev interval value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The MetricsTimeVaryingInt class is for a metric that naturally
 varies over time (e.g. number of files created). The metrics is accumulated
 over an interval (set in the metrics config file); the metrics is
  published at the end of each interval and then 
 reset to zero. Hence the counter has the value in the current interval. 
 
 Note if one wants a time associated with the metric then use
 @see org.apache.hadoop.metrics.util.MetricsTimeVaryingRate]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.util.MetricsTimeVaryingInt -->
  <!-- start class org.apache.hadoop.metrics.util.MetricsTimeVaryingLong -->
  <class name="MetricsTimeVaryingLong" extends="org.apache.hadoop.metrics.util.MetricsBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricsTimeVaryingLong" type="java.lang.String, org.apache.hadoop.metrics.util.MetricsRegistry, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor - create a new metric
 @param nam the name of the metrics to be used to publish the metric
 @param registry - where the metrics object will be registered]]>
      </doc>
    </constructor>
    <constructor name="MetricsTimeVaryingLong" type="java.lang.String, org.apache.hadoop.metrics.util.MetricsRegistry"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor - create a new metric
 @param nam the name of the metrics to be used to publish the metric
 @param registry - where the metrics object will be registered
 A description of {@link #NO_DESCRIPTION} is used]]>
      </doc>
    </constructor>
    <method name="inc"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="incr" type="long"/>
      <doc>
      <![CDATA[Inc metrics for incr vlaue
 @param incr - number of operations]]>
      </doc>
    </method>
    <method name="inc"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Inc metrics by one]]>
      </doc>
    </method>
    <method name="pushMetric"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mr" type="org.apache.hadoop.metrics.MetricsRecord"/>
      <doc>
      <![CDATA[Push the delta  metrics to the mr.
 The delta is since the last push/interval.
 
 Note this does NOT push to JMX
 (JMX gets the info via {@link #previousIntervalValue}

 @param mr]]>
      </doc>
    </method>
    <method name="getPreviousIntervalValue" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The Value at the Previous interval
 @return prev interval value]]>
      </doc>
    </method>
    <method name="getCurrentIntervalValue" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The Value at the current interval
 @return prev interval value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The MetricsTimeVaryingLong class is for a metric that naturally
 varies over time (e.g. number of files created). The metrics is accumulated
 over an interval (set in the metrics config file); the metrics is
  published at the end of each interval and then 
 reset to zero. Hence the counter has the value in the current interval. 
 
 Note if one wants a time associated with the metric then use
 @see org.apache.hadoop.metrics.util.MetricsTimeVaryingRate]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.util.MetricsTimeVaryingLong -->
  <!-- start class org.apache.hadoop.metrics.util.MetricsTimeVaryingRate -->
  <class name="MetricsTimeVaryingRate" extends="org.apache.hadoop.metrics.util.MetricsBase"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricsTimeVaryingRate" type="java.lang.String, org.apache.hadoop.metrics.util.MetricsRegistry, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor - create a new metric
 @param nam the name of the metrics to be used to publish the metric
 @param registry - where the metrics object will be registered]]>
      </doc>
    </constructor>
    <constructor name="MetricsTimeVaryingRate" type="java.lang.String, org.apache.hadoop.metrics.util.MetricsRegistry"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor - create a new metric
 @param nam the name of the metrics to be used to publish the metric
 @param registry - where the metrics object will be registered
 A description of {@link #NO_DESCRIPTION} is used]]>
      </doc>
    </constructor>
    <method name="inc"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="numOps" type="int"/>
      <param name="time" type="long"/>
      <doc>
      <![CDATA[Increment the metrics for numOps operations
 @param numOps - number of operations
 @param time - time for numOps operations]]>
      </doc>
    </method>
    <method name="inc"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <doc>
      <![CDATA[Increment the metrics for one operation
 @param time for one operation]]>
      </doc>
    </method>
    <method name="pushMetric"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mr" type="org.apache.hadoop.metrics.MetricsRecord"/>
      <doc>
      <![CDATA[Push the delta  metrics to the mr.
 The delta is since the last push/interval.
 
 Note this does NOT push to JMX
 (JMX gets the info via {@link #getPreviousIntervalAverageTime()} and
 {@link #getPreviousIntervalNumOps()}

 @param mr]]>
      </doc>
    </method>
    <method name="getPreviousIntervalNumOps" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of operations in the previous interval
 @return - ops in prev interval]]>
      </doc>
    </method>
    <method name="getPreviousIntervalAverageTime" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The average rate of an operation in the previous interval
 @return - the average rate.]]>
      </doc>
    </method>
    <method name="getMinTime" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The min time for a single operation since the last reset
  {@link #resetMinMax()}
 @return min time for an operation]]>
      </doc>
    </method>
    <method name="getMaxTime" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The max time for a single operation since the last reset
  {@link #resetMinMax()}
 @return max time for an operation]]>
      </doc>
    </method>
    <method name="resetMinMax"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reset the min max values]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The MetricsTimeVaryingRate class is for a rate based metric that
 naturally varies over time (e.g. time taken to create a file).
 The rate is averaged at each interval heart beat (the interval
 is set in the metrics config file).
 This class also keeps track of the min and max rates along with 
 a method to reset the min-max.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.util.MetricsTimeVaryingRate -->
</package>
<package name="org.apache.hadoop.net">
  <!-- start class org.apache.hadoop.net.CachedDNSToSwitchMapping -->
  <class name="CachedDNSToSwitchMapping" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.net.DNSToSwitchMapping"/>
    <constructor name="CachedDNSToSwitchMapping" type="org.apache.hadoop.net.DNSToSwitchMapping"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="resolve" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.util.List"/>
    </method>
    <field name="rawMapping" type="org.apache.hadoop.net.DNSToSwitchMapping"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A cached implementation of DNSToSwitchMapping that takes an
 raw DNSToSwitchMapping and stores the resolved network location in 
 a cache. The following calls to a resolved network location
 will get its location from the cache.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.CachedDNSToSwitchMapping -->
  <!-- start class org.apache.hadoop.net.DNS -->
  <class name="DNS" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DNS"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="reverseDns" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hostIp" type="java.net.InetAddress"/>
      <param name="ns" type="java.lang.String"/>
      <exception name="NamingException" type="javax.naming.NamingException"/>
      <doc>
      <![CDATA[Returns the hostname associated with the specified IP address by the
 provided nameserver.
 
 @param hostIp
            The address to reverse lookup
 @param ns
            The host name of a reachable DNS server
 @return The host name associated with the provided IP
 @throws NamingException
             If a NamingException is encountered]]>
      </doc>
    </method>
    <method name="getIPs" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="strInterface" type="java.lang.String"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
      <doc>
      <![CDATA[Returns all the IPs associated with the provided interface, if any, in
 textual form.
 
 @param strInterface
            The name of the network interface to query (e.g. eth0)
 @return A string vector of all the IPs associated with the provided
         interface
 @throws UnknownHostException
             If an UnknownHostException is encountered in querying the
             default interface]]>
      </doc>
    </method>
    <method name="getDefaultIP" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="strInterface" type="java.lang.String"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
      <doc>
      <![CDATA[Returns the first available IP address associated with the provided
 network interface
 
 @param strInterface
            The name of the network interface to query (e.g. eth0)
 @return The IP address in text form
 @throws UnknownHostException
             If one is encountered in querying the default interface]]>
      </doc>
    </method>
    <method name="getHosts" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="strInterface" type="java.lang.String"/>
      <param name="nameserver" type="java.lang.String"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
      <doc>
      <![CDATA[Returns all the host names associated by the provided nameserver with the
 address bound to the specified network interface
 
 @param strInterface
            The name of the network interface to query (e.g. eth0)
 @param nameserver
            The DNS host name
 @return A string vector of all host names associated with the IPs tied to
         the specified interface
 @throws UnknownHostException]]>
      </doc>
    </method>
    <method name="getHosts" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="strInterface" type="java.lang.String"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
      <doc>
      <![CDATA[Returns all the host names associated by the default nameserver with the
 address bound to the specified network interface
 
 @param strInterface
            The name of the network interface to query (e.g. eth0)
 @return The list of host names associated with IPs bound to the network
         interface
 @throws UnknownHostException
             If one is encountered while querying the deault interface]]>
      </doc>
    </method>
    <method name="getDefaultHost" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="strInterface" type="java.lang.String"/>
      <param name="nameserver" type="java.lang.String"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
      <doc>
      <![CDATA[Returns the default (first) host name associated by the provided
 nameserver with the address bound to the specified network interface
 
 @param strInterface
            The name of the network interface to query (e.g. eth0)
 @param nameserver
            The DNS host name
 @return The default host names associated with IPs bound to the network
         interface
 @throws UnknownHostException
             If one is encountered while querying the deault interface]]>
      </doc>
    </method>
    <method name="getDefaultHost" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="strInterface" type="java.lang.String"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
      <doc>
      <![CDATA[Returns the default (first) host name associated by the default
 nameserver with the address bound to the specified network interface
 
 @param strInterface
            The name of the network interface to query (e.g. eth0)
 @return The default host name associated with IPs bound to the network
         interface
 @throws UnknownHostException
             If one is encountered while querying the deault interface]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class that provides direct and reverse lookup functionalities, allowing
 the querying of specific network interfaces or nameservers.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.DNS -->
  <!-- start interface org.apache.hadoop.net.DNSToSwitchMapping -->
  <interface name="DNSToSwitchMapping"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="resolve" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.util.List"/>
      <doc>
      <![CDATA[Resolves a list of DNS-names/IP-addresses and returns back a list of
 switch information (network paths). One-to-one correspondence must be 
 maintained between the elements in the lists. 
 Consider an element in the argument list - x.y.com. The switch information
 that is returned must be a network path of the form /foo/rack, 
 where / is the root, and 'foo' is the switch where 'rack' is connected.
 Note the hostname/ip-address is not part of the returned path.
 The network topology of the cluster would determine the number of
 components in the network path.
 @param names
 @return list of resolved network paths]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An interface that should be implemented to allow pluggable 
 DNS-name/IP-address to RackID resolvers.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.net.DNSToSwitchMapping -->
  <!-- start class org.apache.hadoop.net.NetUtils -->
  <class name="NetUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NetUtils"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSocketFactory" return="javax.net.SocketFactory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="clazz" type="java.lang.Class"/>
      <doc>
      <![CDATA[Get the socket factory for the given class according to its
 configuration parameter
 <tt>hadoop.rpc.socket.factory.class.&lt;ClassName&gt;</tt>. When no
 such parameter exists then fall back on the default socket factory as
 configured by <tt>hadoop.rpc.socket.factory.class.default</tt>. If
 this default socket factory is not configured, then fall back on the JVM
 default socket factory.
 
 @param conf the configuration
 @param clazz the class (usually a {@link VersionedProtocol})
 @return a socket factory]]>
      </doc>
    </method>
    <method name="getDefaultSocketFactory" return="javax.net.SocketFactory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the default socket factory as specified by the configuration
 parameter <tt>hadoop.rpc.socket.factory.default</tt>
 
 @param conf the configuration
 @return the default socket factory as specified in the configuration or
         the JVM default socket factory if the configuration does not
         contain a default socket factory property.]]>
      </doc>
    </method>
    <method name="getSocketFactoryFromProperty" return="javax.net.SocketFactory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="propValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the socket factory corresponding to the given proxy URI. If the
 given proxy URI corresponds to an absence of configuration parameter,
 returns null. If the URI is malformed raises an exception.
 
 @param propValue the property which is the class name of the
        SocketFactory to instantiate; assumed non null and non empty.
 @return a socket factory as defined in the property value.]]>
      </doc>
    </method>
    <method name="createSocketAddr" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="java.lang.String"/>
      <doc>
      <![CDATA[Util method to build socket addr from either:
   <host>:<post>
   <fs>://<host>:<port>/<path>]]>
      </doc>
    </method>
    <method name="createSocketAddr" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="java.lang.String"/>
      <param name="defaultPort" type="int"/>
      <doc>
      <![CDATA[Util method to build socket addr from either:
   <host>
   <host>:<post>
   <fs>://<host>:<port>/<path>]]>
      </doc>
    </method>
    <method name="getServerAddress" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="oldBindAddressName" type="java.lang.String"/>
      <param name="oldPortName" type="java.lang.String"/>
      <param name="newBindAddressName" type="java.lang.String"/>
      <doc>
      <![CDATA[Handle the transition from pairs of attributes specifying a host and port
 to a single colon separated one.
 @param conf the configuration to check
 @param oldBindAddressName the old address attribute name
 @param oldPortName the old port attribute name
 @param newBindAddressName the new combined name
 @return the complete address from the configuration]]>
      </doc>
    </method>
    <method name="addStaticResolution"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="resolvedName" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds a static resolution for host. This can be used for setting up
 hostnames with names that are fake to point to a well known host. For e.g.
 in some testcases we require to have daemons with different hostnames
 running on the same machine. In order to create connections to these
 daemons, one can set up mappings from those hostnames to "localhost".
 {@link NetUtils#getStaticResolution(String)} can be used to query for
 the actual hostname. 
 @param host
 @param resolvedName]]>
      </doc>
    </method>
    <method name="getStaticResolution" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <doc>
      <![CDATA[Retrieves the resolved name for the passed host. The resolved name must
 have been set earlier using 
 {@link NetUtils#addStaticResolution(String, String)}
 @param host
 @return the resolution]]>
      </doc>
    </method>
    <method name="getAllStaticResolutions" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This is used to get all the resolutions that were added using
 {@link NetUtils#addStaticResolution(String, String)}. The return
 value is a List each element of which contains an array of String 
 of the form String[0]=hostname, String[1]=resolved-hostname
 @return the list of resolutions]]>
      </doc>
    </method>
    <method name="getConnectAddress" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="server" type="org.apache.hadoop.ipc.Server"/>
      <doc>
      <![CDATA[Returns InetSocketAddress that a client can use to 
 connect to the server. Server.getListenerAddress() is not correct when
 the server binds to "0.0.0.0". This returns "127.0.0.1:port" when
 the getListenerAddress() returns "0.0.0.0:port".
 
 @param server
 @return socket address that a client can use to connect to the server.]]>
      </doc>
    </method>
    <method name="getInputStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="socket" type="java.net.Socket"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Same as getInputStream(socket, socket.getSoTimeout()).<br><br>
 
 From documentation for {@link #getInputStream(Socket, long)}:<br>
 Returns InputStream for the socket. If the socket has an associated
 SocketChannel then it returns a 
 {@link SocketInputStream} with the given timeout. If the socket does not
 have a channel, {@link Socket#getInputStream()} is returned. In the later
 case, the timeout argument is ignored and the timeout set with 
 {@link Socket#setSoTimeout(int)} applies for reads.<br><br>

 Any socket created using socket factories returned by {@link #NetUtils},
 must use this interface instead of {@link Socket#getInputStream()}.
     
 @see #getInputStream(Socket, long)
 
 @param socket
 @return InputStream for reading from the socket.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getInputStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="socket" type="java.net.Socket"/>
      <param name="timeout" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns InputStream for the socket. If the socket has an associated
 SocketChannel then it returns a 
 {@link SocketInputStream} with the given timeout. If the socket does not
 have a channel, {@link Socket#getInputStream()} is returned. In the later
 case, the timeout argument is ignored and the timeout set with 
 {@link Socket#setSoTimeout(int)} applies for reads.<br><br>
 
 Any socket created using socket factories returned by {@link #NetUtils},
 must use this interface instead of {@link Socket#getInputStream()}.
     
 @see Socket#getChannel()
 
 @param socket
 @param timeout timeout in milliseconds. This may not always apply. zero
        for waiting as long as necessary.
 @return InputStream for reading from the socket.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getOutputStream" return="java.io.OutputStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="socket" type="java.net.Socket"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Same as getOutputStream(socket, 0). Timeout of zero implies write will
 wait until data is available.<br><br>
 
 From documentation for {@link #getOutputStream(Socket, long)} : <br>
 Returns OutputStream for the socket. If the socket has an associated
 SocketChannel then it returns a 
 {@link SocketOutputStream} with the given timeout. If the socket does not
 have a channel, {@link Socket#getOutputStream()} is returned. In the later
 case, the timeout argument is ignored and the write will wait until 
 data is available.<br><br>
 
 Any socket created using socket factories returned by {@link #NetUtils},
 must use this interface instead of {@link Socket#getOutputStream()}.
 
 @see #getOutputStream(Socket, long)
 
 @param socket
 @return OutputStream for writing to the socket.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getOutputStream" return="java.io.OutputStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="socket" type="java.net.Socket"/>
      <param name="timeout" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns OutputStream for the socket. If the socket has an associated
 SocketChannel then it returns a 
 {@link SocketOutputStream} with the given timeout. If the socket does not
 have a channel, {@link Socket#getOutputStream()} is returned. In the later
 case, the timeout argument is ignored and the write will wait until 
 data is available.<br><br>
 
 Any socket created using socket factories returned by {@link #NetUtils},
 must use this interface instead of {@link Socket#getOutputStream()}.
 
 @see Socket#getChannel()
 
 @param socket
 @param timeout timeout in milliseconds. This may not always apply. zero
        for waiting as long as necessary.
 @return OutputStream for writing to the socket.
 @throws IOException]]>
      </doc>
    </method>
    <method name="connect"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="socket" type="java.net.Socket"/>
      <param name="endpoint" type="java.net.SocketAddress"/>
      <param name="timeout" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This is a drop-in replacement for 
 {@link Socket#connect(SocketAddress, int)}.
 In the case of normal sockets that don't have associated channels, this 
 just invokes <code>socket.connect(endpoint, timeout)</code>. If 
 <code>socket.getChannel()</code> returns a non-null channel,
 connect is implemented using Hadoop's selectors. This is done mainly
 to avoid Sun's connect implementation from creating thread-local 
 selectors, since Hadoop does not have control on when these are closed
 and could end up taking all the available file descriptors.
 
 @see java.net.Socket#connect(java.net.SocketAddress, int)
 
 @param socket
 @param endpoint 
 @param timeout - timeout in milliseconds]]>
      </doc>
    </method>
    <method name="normalizeHostName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Given a string representation of a host, return its ip address
 in textual presentation.
 
 @param name a string representation of a host:
             either a textual representation its IP address or its host name
 @return its IP address in the string format]]>
      </doc>
    </method>
    <method name="normalizeHostNames" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.util.Collection"/>
      <doc>
      <![CDATA[Given a collection of string representation of hosts, return a list of
 corresponding IP addresses in the textual representation.
 
 @param names a collection of string representations of hosts
 @return a list of corresponding IP addresses in the string format
 @see #normalizeHostName(String)]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.net.NetUtils -->
  <!-- start class org.apache.hadoop.net.NetworkTopology -->
  <class name="NetworkTopology" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NetworkTopology"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="org.apache.hadoop.net.Node"/>
      <doc>
      <![CDATA[Add a leaf node
 Update node counter & rack counter if neccessary
 @param node
          node to be added
 @exception IllegalArgumentException if add a node to a leave 
                                         or node to be added is not a leaf]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="org.apache.hadoop.net.Node"/>
      <doc>
      <![CDATA[Remove a node
 Update node counter & rack counter if neccessary
 @param node
          node to be removed]]>
      </doc>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="org.apache.hadoop.net.Node"/>
      <doc>
      <![CDATA[Check if the tree contains node <i>node</i>
 
 @param node
          a node
 @return true if <i>node</i> is already in the tree; false otherwise]]>
      </doc>
    </method>
    <method name="getNode" return="org.apache.hadoop.net.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loc" type="java.lang.String"/>
      <doc>
      <![CDATA[Given a string representation of a node, return its reference
 
 @param loc
          a path-like string representation of a node
 @return a reference to the node; null if the node is not in the tree]]>
      </doc>
    </method>
    <method name="getNumOfRacks" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the total number of racks]]>
      </doc>
    </method>
    <method name="getNumOfLeaves" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the total number of nodes]]>
      </doc>
    </method>
    <method name="getDistance" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node1" type="org.apache.hadoop.net.Node"/>
      <param name="node2" type="org.apache.hadoop.net.Node"/>
      <doc>
      <![CDATA[Return the distance between two nodes
 It is assumed that the distance from one node to its parent is 1
 The distance between two nodes is calculated by summing up their distances
 to their closest common  ancestor.
 @param node1 one node
 @param node2 another node
 @return the distance between node1 and node2
 node1 or node2 do not belong to the cluster]]>
      </doc>
    </method>
    <method name="isOnSameRack" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node1" type="org.apache.hadoop.net.Node"/>
      <param name="node2" type="org.apache.hadoop.net.Node"/>
      <doc>
      <![CDATA[Check if two nodes are on the same rack
 @param node1 one node
 @param node2 another node
 @return true if node1 and node2 are pm the same rack; false otherwise
 @exception IllegalArgumentException when either node1 or node2 is null, or
 node1 or node2 do not belong to the cluster]]>
      </doc>
    </method>
    <method name="chooseRandom" return="org.apache.hadoop.net.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scope" type="java.lang.String"/>
      <doc>
      <![CDATA[randomly choose one node from <i>scope</i>
 if scope starts with ~, choose one from the all nodes except for the
 ones in <i>scope</i>; otherwise, choose one from <i>scope</i>
 @param scope range of nodes from which a node will be choosen
 @return the choosen node]]>
      </doc>
    </method>
    <method name="countNumOfAvailableNodes" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scope" type="java.lang.String"/>
      <param name="excludedNodes" type="java.util.List"/>
      <doc>
      <![CDATA[return the number of leaves in <i>scope</i> but not in <i>excludedNodes</i>
 if scope starts with ~, return the number of nodes that are not
 in <i>scope</i> and <i>excludedNodes</i>; 
 @param scope a path string that may start with ~
 @param excludedNodes a list of nodes
 @return number of available nodes]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[convert a network tree to a string]]>
      </doc>
    </method>
    <method name="pseudoSortByDistance"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="org.apache.hadoop.net.Node"/>
      <param name="nodes" type="org.apache.hadoop.net.Node[]"/>
      <doc>
      <![CDATA[Sort nodes array by their distances to <i>reader</i>
 It linearly scans the array, if a local node is found, swap it with
 the first element of the array.
 If a local rack node is found, swap it with the first element following
 the local node.
 If neither local node or local rack node is found, put a random replica
 location at postion 0.
 It leaves the rest nodes untouched.]]>
      </doc>
    </method>
    <field name="DEFAULT_RACK" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_HOST_LEVEL" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[The class represents a cluster of computer with a tree hierarchical
 network topology.
 For example, a cluster may be consists of many data centers filled 
 with racks of computers.
 In a network topology, leaves represent data nodes (computers) and inner
 nodes represent switches/routers that manage traffic in/out of data centers
 or racks.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.NetworkTopology -->
  <!-- start interface org.apache.hadoop.net.Node -->
  <interface name="Node"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getNetworkLocation" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the string representation of this node's network location]]>
      </doc>
    </method>
    <method name="setNetworkLocation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the node's network location]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return this node's name]]>
      </doc>
    </method>
    <method name="getParent" return="org.apache.hadoop.net.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return this node's parent]]>
      </doc>
    </method>
    <method name="setParent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parent" type="org.apache.hadoop.net.Node"/>
      <doc>
      <![CDATA[Set this node's parent]]>
      </doc>
    </method>
    <method name="getLevel" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return this node's level in the tree.
 E.g. the root of a tree returns 0 and its children return 1]]>
      </doc>
    </method>
    <method name="setLevel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <doc>
      <![CDATA[Set this node's level in the tree.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The interface defines a node in a network topology.
 A node may be a leave representing a data node or an inner
 node representing a datacenter or rack.
 Each data has a name and its location in the network is
 decided by a string with syntax similar to a file name. 
 For example, a data node's name is hostname:port# and if it's located at
 rack "orange" in datacenter "dog", the string representation of its
 network location is /dog/orange]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.net.Node -->
  <!-- start class org.apache.hadoop.net.NodeBase -->
  <class name="NodeBase" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.net.Node"/>
    <constructor name="NodeBase"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor]]>
      </doc>
    </constructor>
    <constructor name="NodeBase" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a node from its path
 @param path 
   a concatenation of this node's location, the path seperator, and its name]]>
      </doc>
    </constructor>
    <constructor name="NodeBase" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a node from its name and its location
 @param name this node's name 
 @param location this node's location]]>
      </doc>
    </constructor>
    <constructor name="NodeBase" type="java.lang.String, java.lang.String, org.apache.hadoop.net.Node, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a node from its name and its location
 @param name this node's name 
 @param location this node's location 
 @param parent this node's parent node
 @param level this node's level in the tree]]>
      </doc>
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return this node's name]]>
      </doc>
    </method>
    <method name="getNetworkLocation" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return this node's network location]]>
      </doc>
    </method>
    <method name="setNetworkLocation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="location" type="java.lang.String"/>
      <doc>
      <![CDATA[Set this node's network location]]>
      </doc>
    </method>
    <method name="getPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="node" type="org.apache.hadoop.net.Node"/>
      <doc>
      <![CDATA[Return this node's path]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return this node's string representation]]>
      </doc>
    </method>
    <method name="normalize" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Normalize a path]]>
      </doc>
    </method>
    <method name="getParent" return="org.apache.hadoop.net.Node"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return this node's parent]]>
      </doc>
    </method>
    <method name="setParent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parent" type="org.apache.hadoop.net.Node"/>
      <doc>
      <![CDATA[Set this node's parent]]>
      </doc>
    </method>
    <method name="getLevel" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return this node's level in the tree.
 E.g. the root of a tree returns 0 and its children return 1]]>
      </doc>
    </method>
    <method name="setLevel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="level" type="int"/>
      <doc>
      <![CDATA[Set this node's level in the tree]]>
      </doc>
    </method>
    <field name="PATH_SEPARATOR" type="char"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PATH_SEPARATOR_STR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ROOT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="name" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="location" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="level" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="parent" type="org.apache.hadoop.net.Node"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A base class that implements interface Node]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.NodeBase -->
  <!-- start class org.apache.hadoop.net.ScriptBasedMapping -->
  <class name="ScriptBasedMapping" extends="org.apache.hadoop.net.CachedDNSToSwitchMapping"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="ScriptBasedMapping"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ScriptBasedMapping" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <doc>
    <![CDATA[This class implements the {@link DNSToSwitchMapping} interface using a 
 script configured via topology.script.file.name .]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.ScriptBasedMapping -->
  <!-- start class org.apache.hadoop.net.SocketInputStream -->
  <class name="SocketInputStream" extends="java.io.InputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.nio.channels.ReadableByteChannel"/>
    <constructor name="SocketInputStream" type="java.nio.channels.ReadableByteChannel, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a new input stream with the given timeout. If the timeout
 is zero, it will be treated as infinite timeout. The socket's
 channel will be configured to be non-blocking.
 
 @param channel 
        Channel for reading, should also be a {@link SelectableChannel}.
        The channel will be configured to be non-blocking.
 @param timeout timeout in milliseconds. must not be negative.
 @throws IOException]]>
      </doc>
    </constructor>
    <constructor name="SocketInputStream" type="java.net.Socket, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Same as SocketInputStream(socket.getChannel(), timeout): <br><br>
 
 Create a new input stream with the given timeout. If the timeout
 is zero, it will be treated as infinite timeout. The socket's
 channel will be configured to be non-blocking.
 
 @see SocketInputStream#SocketInputStream(ReadableByteChannel, long)
  
 @param socket should have a channel associated with it.
 @param timeout timeout timeout in milliseconds. must not be negative.
 @throws IOException]]>
      </doc>
    </constructor>
    <constructor name="SocketInputStream" type="java.net.Socket"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Same as SocketInputStream(socket.getChannel(), socket.getSoTimeout())
 :<br><br>
 
 Create a new input stream with the given timeout. If the timeout
 is zero, it will be treated as infinite timeout. The socket's
 channel will be configured to be non-blocking.
 @see SocketInputStream#SocketInputStream(ReadableByteChannel, long)
  
 @param socket should have a channel associated with it.
 @throws IOException]]>
      </doc>
    </constructor>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getChannel" return="java.nio.channels.ReadableByteChannel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns underlying channel used by inputstream.
 This is useful in certain cases like channel for 
 {@link FileChannel#transferFrom(ReadableByteChannel, long, long)}.]]>
      </doc>
    </method>
    <method name="isOpen" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dst" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="waitForReadable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[waits for the underlying channel to be ready for reading.
 The timeout specified for this stream applies to this wait.
 
 @throws SocketTimeoutException 
         if select on the channel times out.
 @throws IOException
         if any other I/O error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This implements an input stream that can have a timeout while reading.
 This sets non-blocking flag on the socket channel.
 So after create this object, read() on 
 {@link Socket#getInputStream()} and write() on 
 {@link Socket#getOutputStream()} for the associated socket will throw 
 IllegalBlockingModeException. 
 Please use {@link SocketOutputStream} for writing.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.SocketInputStream -->
  <!-- start class org.apache.hadoop.net.SocketOutputStream -->
  <class name="SocketOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.nio.channels.WritableByteChannel"/>
    <constructor name="SocketOutputStream" type="java.nio.channels.WritableByteChannel, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a new ouput stream with the given timeout. If the timeout
 is zero, it will be treated as infinite timeout. The socket's
 channel will be configured to be non-blocking.
 
 @param channel 
        Channel for writing, should also be a {@link SelectableChannel}.  
        The channel will be configured to be non-blocking.
 @param timeout timeout in milliseconds. must not be negative.
 @throws IOException]]>
      </doc>
    </constructor>
    <constructor name="SocketOutputStream" type="java.net.Socket, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Same as SocketOutputStream(socket.getChannel(), timeout):<br><br>
 
 Create a new ouput stream with the given timeout. If the timeout
 is zero, it will be treated as infinite timeout. The socket's
 channel will be configured to be non-blocking.
 
 @see SocketOutputStream#SocketOutputStream(WritableByteChannel, long)
  
 @param socket should have a channel associated with it.
 @param timeout timeout timeout in milliseconds. must not be negative.
 @throws IOException]]>
      </doc>
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getChannel" return="java.nio.channels.WritableByteChannel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns underlying channel used by this stream.
 This is useful in certain cases like channel for 
 {@link FileChannel#transferTo(long, long, WritableByteChannel)}]]>
      </doc>
    </method>
    <method name="isOpen" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="waitForWritable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[waits for the underlying channel to be ready for writing.
 The timeout specified for this stream applies to this wait.

 @throws SocketTimeoutException 
         if select on the channel times out.
 @throws IOException
         if any other I/O error occurs.]]>
      </doc>
    </method>
    <method name="transferToFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileCh" type="java.nio.channels.FileChannel"/>
      <param name="position" type="long"/>
      <param name="count" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Transfers data from FileChannel using 
 {@link FileChannel#transferTo(long, long, WritableByteChannel)}. 
 
 Similar to readFully(), this waits till requested amount of 
 data is transfered.
 
 @param fileCh FileChannel to transfer data from.
 @param position position within the channel where the transfer begins
 @param count number of bytes to transfer.
 
 @throws EOFException 
         If end of input file is reached before requested number of 
         bytes are transfered.

 @throws SocketTimeoutException 
         If this channel blocks transfer longer than timeout for 
         this stream.
          
 @throws IOException Includes any exception thrown by 
         {@link FileChannel#transferTo(long, long, WritableByteChannel)}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This implements an output stream that can have a timeout while writing.
 This sets non-blocking flag on the socket channel.
 So after creating this object , read() on 
 {@link Socket#getInputStream()} and write() on 
 {@link Socket#getOutputStream()} on the associated socket will throw 
 llegalBlockingModeException.
 Please use {@link SocketInputStream} for reading.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.SocketOutputStream -->
  <!-- start class org.apache.hadoop.net.SocksSocketFactory -->
  <class name="SocksSocketFactory" extends="javax.net.SocketFactory"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="SocksSocketFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default empty constructor (for use with the reflection API).]]>
      </doc>
    </constructor>
    <constructor name="SocksSocketFactory" type="java.net.Proxy"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with a supplied Proxy
 
 @param proxy the proxy to use to create sockets]]>
      </doc>
    </constructor>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addr" type="java.net.InetAddress"/>
      <param name="port" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addr" type="java.net.InetAddress"/>
      <param name="port" type="int"/>
      <param name="localHostAddr" type="java.net.InetAddress"/>
      <param name="localPort" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="port" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="port" type="int"/>
      <param name="localHostAddr" type="java.net.InetAddress"/>
      <param name="localPort" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <doc>
    <![CDATA[Specialized SocketFactory to create sockets with a SOCKS proxy]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.SocksSocketFactory -->
  <!-- start class org.apache.hadoop.net.StandardSocketFactory -->
  <class name="StandardSocketFactory" extends="javax.net.SocketFactory"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="StandardSocketFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default empty constructor (for use with the reflection API).]]>
      </doc>
    </constructor>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addr" type="java.net.InetAddress"/>
      <param name="port" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addr" type="java.net.InetAddress"/>
      <param name="port" type="int"/>
      <param name="localHostAddr" type="java.net.InetAddress"/>
      <param name="localPort" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="port" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="port" type="int"/>
      <param name="localHostAddr" type="java.net.InetAddress"/>
      <param name="localPort" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Specialized SocketFactory to create sockets with a SOCKS proxy]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.StandardSocketFactory -->
  <doc>
  <![CDATA[Network-related classes.]]>
  </doc>
</package>
<package name="org.apache.hadoop.record">
  <!-- start class org.apache.hadoop.record.BinaryRecordInput -->
  <class name="BinaryRecordInput" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.record.RecordInput"/>
    <constructor name="BinaryRecordInput" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of BinaryRecordInput]]>
      </doc>
    </constructor>
    <constructor name="BinaryRecordInput" type="java.io.DataInput"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of BinaryRecordInput]]>
      </doc>
    </constructor>
    <method name="get" return="org.apache.hadoop.record.BinaryRecordInput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inp" type="java.io.DataInput"/>
      <doc>
      <![CDATA[Get a thread-local record input for the supplied DataInput.
 @param inp data input stream
 @return binary record input corresponding to the supplied DataInput.]]>
      </doc>
    </method>
    <method name="readByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readBool" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readBuffer" return="org.apache.hadoop.record.Buffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startVector" return="org.apache.hadoop.record.Index"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startMap" return="org.apache.hadoop.record.Index"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.record.BinaryRecordInput -->
  <!-- start class org.apache.hadoop.record.BinaryRecordOutput -->
  <class name="BinaryRecordOutput" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.record.RecordOutput"/>
    <constructor name="BinaryRecordOutput" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of BinaryRecordOutput]]>
      </doc>
    </constructor>
    <constructor name="BinaryRecordOutput" type="java.io.DataOutput"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of BinaryRecordOutput]]>
      </doc>
    </constructor>
    <method name="get" return="org.apache.hadoop.record.BinaryRecordOutput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <doc>
      <![CDATA[Get a thread-local record output for the supplied DataOutput.
 @param out data output stream
 @return binary record output corresponding to the supplied DataOutput.]]>
      </doc>
    </method>
    <method name="writeByte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeBool"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="boolean"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="long"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="float"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeDouble"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="d" type="double"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeString"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="org.apache.hadoop.record.Buffer"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="org.apache.hadoop.record.Record"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="org.apache.hadoop.record.Record"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.ArrayList"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.ArrayList"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.TreeMap"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.TreeMap"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.record.BinaryRecordOutput -->
  <!-- start class org.apache.hadoop.record.Buffer -->
  <class name="Buffer" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <implements name="java.lang.Cloneable"/>
    <constructor name="Buffer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a zero-count sequence.]]>
      </doc>
    </constructor>
    <constructor name="Buffer" type="byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a Buffer using the byte array as the initial value.

 @param bytes This array becomes the backing storage for the object.]]>
      </doc>
    </constructor>
    <constructor name="Buffer" type="byte[], int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a Buffer using the byte range as the initial value.

 @param bytes Copy of this array becomes the backing storage for the object.
 @param offset offset into byte array
 @param length length of data]]>
      </doc>
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Use the specified bytes array as underlying sequence.

 @param bytes byte sequence]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Copy the specified byte array to the Buffer. Replaces the current buffer.

 @param bytes byte array to be assigned
 @param offset offset into byte array
 @param length length of data]]>
      </doc>
    </method>
    <method name="get" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the data from the Buffer.
 
 @return The data is only valid between 0 and getCount() - 1.]]>
      </doc>
    </method>
    <method name="getCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current count of the buffer.]]>
      </doc>
    </method>
    <method name="getCapacity" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the capacity, which is the maximum count that could handled without
 resizing the backing storage.
 
 @return The number of bytes]]>
      </doc>
    </method>
    <method name="setCapacity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newCapacity" type="int"/>
      <doc>
      <![CDATA[Change the capacity of the backing storage.
 The data is preserved if newCapacity >= getCount().
 @param newCapacity The new capacity in bytes.]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reset the buffer to 0 size]]>
      </doc>
    </method>
    <method name="truncate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Change the capacity of the backing store to be the same as the current 
 count of buffer.]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Append specified bytes to the buffer.

 @param bytes byte array to be appended
 @param offset offset into byte array
 @param length length of data]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Append specified bytes to the buffer

 @param bytes byte array to be appended]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
      <doc>
      <![CDATA[Define the sort order of the Buffer.
 
 @param other The other buffer
 @return Positive if this is bigger than other, 0 if they are equal, and
         negative if this is smaller than other.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charsetName" type="java.lang.String"/>
      <exception name="UnsupportedEncodingException" type="java.io.UnsupportedEncodingException"/>
      <doc>
      <![CDATA[Convert the byte buffer to a string an specific character encoding

 @param charsetName Valid Java Character Set Name]]>
      </doc>
    </method>
    <method name="clone" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="CloneNotSupportedException" type="java.lang.CloneNotSupportedException"/>
    </method>
    <doc>
    <![CDATA[A byte sequence that is used as a Java native type for buffer.
 It is resizable and distinguishes between the count of the seqeunce and
 the current capacity.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.Buffer -->
  <!-- start class org.apache.hadoop.record.CsvRecordInput -->
  <class name="CsvRecordInput" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.record.RecordInput"/>
    <constructor name="CsvRecordInput" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of CsvRecordInput]]>
      </doc>
    </constructor>
    <method name="readByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readBool" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readBuffer" return="org.apache.hadoop.record.Buffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startVector" return="org.apache.hadoop.record.Index"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startMap" return="org.apache.hadoop.record.Index"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.record.CsvRecordInput -->
  <!-- start class org.apache.hadoop.record.CsvRecordOutput -->
  <class name="CsvRecordOutput" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.record.RecordOutput"/>
    <constructor name="CsvRecordOutput" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of CsvRecordOutput]]>
      </doc>
    </constructor>
    <method name="writeByte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeBool"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="boolean"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="long"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="float"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeDouble"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="d" type="double"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeString"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="org.apache.hadoop.record.Buffer"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="org.apache.hadoop.record.Record"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="org.apache.hadoop.record.Record"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.ArrayList"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.ArrayList"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.TreeMap"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.TreeMap"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.record.CsvRecordOutput -->
  <!-- start interface org.apache.hadoop.record.Index -->
  <interface name="Index"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="done" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="incr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Interface that acts as an iterator for deserializing maps.
 The deserializer returns an instance that the record uses to
 read vectors and maps. An example of usage is as follows:

 <code>
 Index idx = startVector(...);
 while (!idx.done()) {
   .... // read element of a vector
   idx.incr();
 }
 </code>]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.record.Index -->
  <!-- start class org.apache.hadoop.record.Record -->
  <class name="Record" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <implements name="java.lang.Cloneable"/>
    <constructor name="Record"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="serialize"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rout" type="org.apache.hadoop.record.RecordOutput"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serialize a record with tag (ususally field name)
 @param rout Record output destination
 @param tag record tag (Used only in tagged serialization e.g. XML)]]>
      </doc>
    </method>
    <method name="deserialize"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rin" type="org.apache.hadoop.record.RecordInput"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deserialize a record with a tag (usually field name)
 @param rin Record input source
 @param tag Record tag (Used only in tagged serialization e.g. XML)]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="peer" type="java.lang.Object"/>
      <exception name="ClassCastException" type="java.lang.ClassCastException"/>
    </method>
    <method name="serialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rout" type="org.apache.hadoop.record.RecordOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serialize a record without a tag
 @param rout Record output destination]]>
      </doc>
    </method>
    <method name="deserialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rin" type="org.apache.hadoop.record.RecordInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deserialize a record without a tag
 @param rin Record input source]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="din" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Abstract class that is extended by generated classes.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.Record -->
  <!-- start class org.apache.hadoop.record.RecordComparator -->
  <class name="RecordComparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RecordComparator" type="java.lang.Class"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a raw {@link Record} comparison implementation.]]>
      </doc>
    </constructor>
    <method name="compare" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <method name="define"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="comparator" type="org.apache.hadoop.record.RecordComparator"/>
      <doc>
      <![CDATA[Register an optimized comparator for a {@link Record} implementation.

 @param c record classs for which a raw comparator is provided
 @param comparator Raw comparator instance for class c]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A raw record comparator base class]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.RecordComparator -->
  <!-- start interface org.apache.hadoop.record.RecordInput -->
  <interface name="RecordInput"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="readByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a byte from serialized record.
 @param tag Used by tagged serialization formats (such as XML)
 @return value read from serialized record.]]>
      </doc>
    </method>
    <method name="readBool" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a boolean from serialized record.
 @param tag Used by tagged serialization formats (such as XML)
 @return value read from serialized record.]]>
      </doc>
    </method>
    <method name="readInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read an integer from serialized record.
 @param tag Used by tagged serialization formats (such as XML)
 @return value read from serialized record.]]>
      </doc>
    </method>
    <method name="readLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a long integer from serialized record.
 @param tag Used by tagged serialization formats (such as XML)
 @return value read from serialized record.]]>
      </doc>
    </method>
    <method name="readFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a single-precision float from serialized record.
 @param tag Used by tagged serialization formats (such as XML)
 @return value read from serialized record.]]>
      </doc>
    </method>
    <method name="readDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a double-precision number from serialized record.
 @param tag Used by tagged serialization formats (such as XML)
 @return value read from serialized record.]]>
      </doc>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a UTF-8 encoded string from serialized record.
 @param tag Used by tagged serialization formats (such as XML)
 @return value read from serialized record.]]>
      </doc>
    </method>
    <method name="readBuffer" return="org.apache.hadoop.record.Buffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read byte array from serialized record.
 @param tag Used by tagged serialization formats (such as XML)
 @return value read from serialized record.]]>
      </doc>
    </method>
    <method name="startRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Check the mark for start of the serialized record.
 @param tag Used by tagged serialization formats (such as XML)]]>
      </doc>
    </method>
    <method name="endRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Check the mark for end of the serialized record.
 @param tag Used by tagged serialization formats (such as XML)]]>
      </doc>
    </method>
    <method name="startVector" return="org.apache.hadoop.record.Index"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Check the mark for start of the serialized vector.
 @param tag Used by tagged serialization formats (such as XML)
 @return Index that is used to count the number of elements.]]>
      </doc>
    </method>
    <method name="endVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Check the mark for end of the serialized vector.
 @param tag Used by tagged serialization formats (such as XML)]]>
      </doc>
    </method>
    <method name="startMap" return="org.apache.hadoop.record.Index"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Check the mark for start of the serialized map.
 @param tag Used by tagged serialization formats (such as XML)
 @return Index that is used to count the number of map entries.]]>
      </doc>
    </method>
    <method name="endMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Check the mark for end of the serialized map.
 @param tag Used by tagged serialization formats (such as XML)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface that all the Deserializers have to implement.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.record.RecordInput -->
  <!-- start interface org.apache.hadoop.record.RecordOutput -->
  <interface name="RecordOutput"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="writeByte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a byte to serialized record.
 @param b Byte to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="writeBool"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="boolean"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a boolean to serialized record.
 @param b Boolean to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="writeInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write an integer to serialized record.
 @param i Integer to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="writeLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="long"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a long integer to serialized record.
 @param l Long to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="writeFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="float"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a single-precision float to serialized record.
 @param f Float to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="writeDouble"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="d" type="double"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a double precision floating point number to serialized record.
 @param d Double to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="writeString"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a unicode string to serialized record.
 @param s String to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="writeBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="org.apache.hadoop.record.Buffer"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a buffer to serialized record.
 @param buf Buffer to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="startRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="org.apache.hadoop.record.Record"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Mark the start of a record to be serialized.
 @param r Record to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="endRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="org.apache.hadoop.record.Record"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Mark the end of a serialized record.
 @param r Record to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="startVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.ArrayList"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Mark the start of a vector to be serialized.
 @param v Vector to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="endVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.ArrayList"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Mark the end of a serialized vector.
 @param v Vector to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="startMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.TreeMap"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Mark the start of a map to be serialized.
 @param m Map to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="endMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.TreeMap"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Mark the end of a serialized map.
 @param m Map to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface that alll the serializers have to implement.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.record.RecordOutput -->
  <!-- start class org.apache.hadoop.record.Utils -->
  <class name="Utils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="readFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Parse a float from a byte array.]]>
      </doc>
    </method>
    <method name="readDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Parse a double from a byte array.]]>
      </doc>
    </method>
    <method name="readVLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a zero-compressed encoded long from a byte array and returns it.
 @param bytes byte array with decode long
 @param start starting index
 @throws java.io.IOException
 @return deserialized long]]>
      </doc>
    </method>
    <method name="readVInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a zero-compressed encoded integer from a byte array and returns it.
 @param bytes byte array with the encoded integer
 @param start start index
 @throws java.io.IOException
 @return deserialized integer]]>
      </doc>
    </method>
    <method name="readVLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a zero-compressed encoded long from a stream and return it.
 @param in input stream
 @throws java.io.IOException
 @return deserialized long]]>
      </doc>
    </method>
    <method name="readVInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a zero-compressed encoded integer from a stream and returns it.
 @param in input stream
 @throws java.io.IOException
 @return deserialized integer]]>
      </doc>
    </method>
    <method name="getVIntSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="long"/>
      <doc>
      <![CDATA[Get the encoded length if an integer is stored in a variable-length format
 @return the encoded length]]>
      </doc>
    </method>
    <method name="writeVLong"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.DataOutput"/>
      <param name="i" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serializes a long to a binary stream with zero-compressed encoding.
 For -112 <= i <= 127, only one byte is used with the actual value.
 For other values of i, the first byte value indicates whether the
 long is positive or negative, and the number of bytes that follow.
 If the first byte value v is between -113 and -120, the following long
 is positive, with number of bytes that follow are -(v+112).
 If the first byte value v is between -121 and -128, the following long
 is negative, with number of bytes that follow are -(v+120). Bytes are
 stored in the high-non-zero-byte-first order.

 @param stream Binary output stream
 @param i Long to be serialized
 @throws java.io.IOException]]>
      </doc>
    </method>
    <method name="writeVInt"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.DataOutput"/>
      <param name="i" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serializes an int to a binary stream with zero-compressed encoding.

 @param stream Binary output stream
 @param i int to be serialized
 @throws java.io.IOException]]>
      </doc>
    </method>
    <method name="compareBytes" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
      <doc>
      <![CDATA[Lexicographic order of binary data.]]>
      </doc>
    </method>
    <field name="hexchars" type="char[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Various utility functions for Hadooop record I/O runtime.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.Utils -->
  <!-- start class org.apache.hadoop.record.XmlRecordInput -->
  <class name="XmlRecordInput" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.record.RecordInput"/>
    <constructor name="XmlRecordInput" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of XmlRecordInput]]>
      </doc>
    </constructor>
    <method name="readByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readBool" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readBuffer" return="org.apache.hadoop.record.Buffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startVector" return="org.apache.hadoop.record.Index"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startMap" return="org.apache.hadoop.record.Index"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[XML Deserializer.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.XmlRecordInput -->
  <!-- start class org.apache.hadoop.record.XmlRecordOutput -->
  <class name="XmlRecordOutput" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.record.RecordOutput"/>
    <constructor name="XmlRecordOutput" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of XmlRecordOutput]]>
      </doc>
    </constructor>
    <method name="writeByte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeBool"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="boolean"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="long"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="float"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeDouble"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="d" type="double"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeString"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="org.apache.hadoop.record.Buffer"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="org.apache.hadoop.record.Record"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="org.apache.hadoop.record.Record"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.ArrayList"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.ArrayList"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.TreeMap"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.TreeMap"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[XML Serializer.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.XmlRecordOutput -->
  <doc>
  <![CDATA[Hadoop record I/O contains classes and a record description language
  translator for simplifying serialization and deserialization of records in a
  language-neutral manner.
  
  <h2>Introduction</h2>
  
  Software systems of any significant complexity require mechanisms for data 
interchange with the outside world. These interchanges typically involve the
marshaling and unmarshaling of logical units of data to and from data streams
(files, network connections, memory buffers etc.). Applications usually have
some code for serializing and deserializing the data types that they manipulate
embedded in them. The work of serialization has several features that make
automatic code generation for it worthwhile. Given a particular output encoding
(binary, XML, etc.), serialization of primitive types and simple compositions
of primitives (structs, vectors etc.) is a very mechanical task. Manually
written serialization code can be susceptible to bugs especially when records
have a large number of fields or a record definition changes between software
versions. Lastly, it can be very useful for applications written in different
programming languages to be able to share and interchange data. This can be 
made a lot easier by describing the data records manipulated by these
applications in a language agnostic manner and using the descriptions to derive
implementations of serialization in multiple target languages. 

This document describes Hadoop Record I/O, a mechanism that is aimed 
at
<ul> 
<li> enabling the specification of simple serializable data types (records) 
<li> enabling the generation of code in multiple target languages for
marshaling and unmarshaling such types
<li> providing target language specific support that will enable application 
programmers to incorporate generated code into their applications
</ul>

The goals of Hadoop Record I/O are similar to those of mechanisms such as XDR,
ASN.1, PADS and ICE. While these systems all include a DDL that enables
the specification of most record types, they differ widely in what else they
focus on. The focus in Hadoop Record I/O is on data marshaling and
multi-lingual support.  We take a translator-based approach to serialization.
Hadoop users have to describe their data in a simple data description
language. The Hadoop DDL translator rcc generates code that users
can invoke in order to read/write their data from/to simple stream 
abstractions. Next we list explicitly some of the goals and non-goals of
Hadoop Record I/O.


<h3>Goals</h3>

<ul>
<li> Support for commonly used primitive types. Hadoop should include as
primitives commonly used builtin types from programming languages we intend to
support.

<li> Support for common data compositions (including recursive compositions).
Hadoop should support widely used composite types such as structs and
vectors.

<li> Code generation in multiple target languages. Hadoop should be capable of
generating serialization code in multiple target languages and should be
easily extensible to new target languages. The initial target languages are
C++ and Java.

<li> Support for generated target languages. Hadooop should include support
in the form of headers, libraries, packages for supported target languages 
that enable easy inclusion and use of generated code in applications.

<li> Support for multiple output encodings. Candidates include
packed binary, comma-separated text, XML etc.

<li> Support for specifying record types in a backwards/forwards compatible
manner. This will probably be in the form of support for optional fields in
records. This version of the document does not include a description of the
planned mechanism, we intend to include it in the next iteration.

</ul>

<h3>Non-Goals</h3>

<ul>
  <li> Serializing existing arbitrary C++ classes.
  <li> Serializing complex data structures such as trees, linked lists etc.
  <li> Built-in indexing schemes, compression, or check-sums.
  <li> Dynamic construction of objects from an XML schema.
</ul>

The remainder of this document describes the features of Hadoop record I/O
in more detail. Section 2 describes the data types supported by the system.
Section 3 lays out the DDL syntax with some examples of simple records. 
Section 4 describes the process of code generation with rcc. Section 5
describes target language mappings and support for Hadoop types. We include a
fairly complete description of C++ mappings with intent to include Java and
others in upcoming iterations of this document. The last section talks about
supported output encodings.


<h2>Data Types and Streams</h2>

This section describes the primitive and composite types supported by Hadoop.
We aim to support a set of types that can be used to simply and efficiently
express a wide range of record types in different programming languages.

<h3>Primitive Types</h3>

For the most part, the primitive types of Hadoop map directly to primitive
types in high level programming languages. Special cases are the
ustring (a Unicode string) and buffer types, which we believe
find wide use and which are usually implemented in library code and not
available as language built-ins. Hadoop also supplies these via library code
when a target language built-in is not present and there is no widely
adopted "standard" implementation. The complete list of primitive types is:

<ul>
  <li> byte: An 8-bit unsigned integer.
  <li> boolean: A boolean value.
  <li> int: A 32-bit signed integer.
  <li> long: A 64-bit signed integer.
  <li> float: A single precision floating point number as described by
    IEEE-754.
  <li> double: A double precision floating point number as described by
    IEEE-754.
  <li> ustring: A string consisting of Unicode characters.
  <li> buffer: An arbitrary sequence of bytes. 
</ul>


<h3>Composite Types</h3>
Hadoop supports a small set of composite types that enable the description
of simple aggregate types and containers. A composite type is serialized
by sequentially serializing it constituent elements. The supported
composite types are:

<ul>

  <li> record: An aggregate type like a C-struct. This is a list of
typed fields that are together considered a single unit of data. A record
is serialized by sequentially serializing its constituent fields. In addition
to serialization a record has comparison operations (equality and less-than)
implemented for it, these are defined as memberwise comparisons.

  <li>vector: A sequence of entries of the same data type, primitive
or composite.

  <li> map: An associative container mapping instances of a key type to
instances of a value type. The key and value types may themselves be primitive
or composite types. 

</ul>

<h3>Streams</h3>

Hadoop generates code for serializing and deserializing record types to
abstract streams. For each target language Hadoop defines very simple input
and output stream interfaces. Application writers can usually develop
concrete implementations of these by putting a one method wrapper around
an existing stream implementation.


<h2>DDL Syntax and Examples</h2>

We now describe the syntax of the Hadoop data description language. This is
followed by a few examples of DDL usage.
 
<h3>Hadoop DDL Syntax</h3>

<pre><code>
recfile = *include module *record
include = "include" path
path = (relative-path / absolute-path)
module = "module" module-name
module-name = name *("." name)
record := "class" name "{" 1*(field) "}"
field := type name ";"
name :=  ALPHA (ALPHA / DIGIT / "_" )*
type := (ptype / ctype)
ptype := ("byte" / "boolean" / "int" |
          "long" / "float" / "double"
          "ustring" / "buffer")
ctype := (("vector" "<" type ">") /
          ("map" "<" type "," type ">" ) ) / name)
</code></pre>

A DDL file describes one or more record types. It begins with zero or
more include declarations, a single mandatory module declaration
followed by zero or more class declarations. The semantics of each of
these declarations are described below:

<ul>

<li>include: An include declaration specifies a DDL file to be
referenced when generating code for types in the current DDL file. Record types
in the current compilation unit may refer to types in all included files.
File inclusion is recursive. An include does not trigger code
generation for the referenced file.

<li> module: Every Hadoop DDL file must have a single module
declaration that follows the list of includes and precedes all record
declarations. A module declaration identifies a scope within which
the names of all types in the current file are visible. Module names are
mapped to C++ namespaces, Java packages etc. in generated code.

<li> class: Records types are specified through class
declarations. A class declaration is like a Java class declaration.
It specifies a named record type and a list of fields that constitute records
of the type. Usage is illustrated in the following examples.

</ul>

<h3>Examples</h3>

<ul>
<li>A simple DDL file links.jr with just one record declaration. 
<pre><code>
module links {
    class Link {
        ustring URL;
        boolean isRelative;
        ustring anchorText;
    };
}
</code></pre>

<li> A DDL file outlinks.jr which includes another
<pre><code>
include "links.jr"

module outlinks {
    class OutLinks {
        ustring baseURL;
        vector<links.Link> outLinks;
    };
}
</code></pre>
</ul>

<h2>Code Generation</h2>

The Hadoop translator is written in Java. Invocation is done by executing a 
wrapper shell script named named rcc. It takes a list of
record description files as a mandatory argument and an
optional language argument (the default is Java) --language or
-l. Thus a typical invocation would look like:
<pre><code>
$ rcc -l C++ <filename> ...
</code></pre>


<h2>Target Language Mappings and Support</h2>

For all target languages, the unit of code generation is a record type. 
For each record type, Hadoop generates code for serialization and
deserialization, record comparison and access to record members.

<h3>C++</h3>

Support for including Hadoop generated C++ code in applications comes in the
form of a header file recordio.hh which needs to be included in source
that uses Hadoop types and a library librecordio.a which applications need
to be linked with. The header declares the Hadoop C++ namespace which defines
appropriate types for the various primitives, the basic interfaces for
records and streams and enumerates the supported serialization encodings.
Declarations of these interfaces and a description of their semantics follow:

<pre><code>
namespace hadoop {

  enum RecFormat { kBinary, kXML, kCSV };

  class InStream {
  public:
    virtual ssize_t read(void *buf, size_t n) = 0;
  };

  class OutStream {
  public:
    virtual ssize_t write(const void *buf, size_t n) = 0;
  };

  class IOError : public runtime_error {
  public:
    explicit IOError(const std::string& msg);
  };

  class IArchive;
  class OArchive;

  class RecordReader {
  public:
    RecordReader(InStream& in, RecFormat fmt);
    virtual ~RecordReader(void);

    virtual void read(Record& rec);
  };

  class RecordWriter {
  public:
    RecordWriter(OutStream& out, RecFormat fmt);
    virtual ~RecordWriter(void);

    virtual void write(Record& rec);
  };


  class Record {
  public:
    virtual std::string type(void) const = 0;
    virtual std::string signature(void) const = 0;
  protected:
    virtual bool validate(void) const = 0;

    virtual void
    serialize(OArchive& oa, const std::string& tag) const = 0;

    virtual void
    deserialize(IArchive& ia, const std::string& tag) = 0;
  };
}
</code></pre>

<ul>

<li> RecFormat: An enumeration of the serialization encodings supported
by this implementation of Hadoop.

<li> InStream: A simple abstraction for an input stream. This has a 
single public read method that reads n bytes from the stream into
the buffer buf. Has the same semantics as a blocking read system
call. Returns the number of bytes read or -1 if an error occurs.

<li> OutStream: A simple abstraction for an output stream. This has a 
single write method that writes n bytes to the stream from the
buffer buf. Has the same semantics as a blocking write system
call. Returns the number of bytes written or -1 if an error occurs.

<li> RecordReader: A RecordReader reads records one at a time from
an underlying stream in a specified record format. The reader is instantiated
with a stream and a serialization format. It has a read method that
takes an instance of a record and deserializes the record from the stream.

<li> RecordWriter: A RecordWriter writes records one at a
time to an underlying stream in a specified record format. The writer is
instantiated with a stream and a serialization format. It has a
write method that takes an instance of a record and serializes the
record to the stream.

<li> Record: The base class for all generated record types. This has two
public methods type and signature that return the typename and the
type signature of the record.

</ul>

Two files are generated for each record file (note: not for each record). If a
record file is named "name.jr", the generated files are 
"name.jr.cc" and "name.jr.hh" containing serialization 
implementations and record type declarations respectively.

For each record in the DDL file, the generated header file will contain a
class definition corresponding to the record type, method definitions for the
generated type will be present in the '.cc' file.  The generated class will
inherit from the abstract class hadoop::Record. The DDL files
module declaration determines the namespace the record belongs to.
Each '.' delimited token in the module declaration results in the
creation of a namespace. For instance, the declaration module docs.links
results in the creation of a docs namespace and a nested 
docs::links namespace. In the preceding examples, the Link class
is placed in the links namespace. The header file corresponding to
the links.jr file will contain:

<pre><code>
namespace links {
  class Link : public hadoop::Record {
    // ....
  };
};
</code></pre>

Each field within the record will cause the generation of a private member
declaration of the appropriate type in the class declaration, and one or more
acccessor methods. The generated class will implement the serialize and
deserialize methods defined in hadoop::Record+. It will also 
implement the inspection methods type and signature from
hadoop::Record. A default constructor and virtual destructor will also
be generated. Serialization code will read/write records into streams that
implement the hadoop::InStream and the hadoop::OutStream interfaces.

For each member of a record an accessor method is generated that returns 
either the member or a reference to the member. For members that are returned 
by value, a setter method is also generated. This is true for primitive 
data members of the types byte, int, long, boolean, float and 
double. For example, for a int field called MyField the folowing
code is generated.

<pre><code>
...
private:
  int32_t mMyField;
  ...
public:
  int32_t getMyField(void) const {
    return mMyField;
  };

  void setMyField(int32_t m) {
    mMyField = m;
  };
  ...
</code></pre>

For a ustring or buffer or composite field. The generated code
only contains accessors that return a reference to the field. A const
and a non-const accessor are generated. For example:

<pre><code>
...
private:
  std::string mMyBuf;
  ...
public:

  std::string& getMyBuf() {
    return mMyBuf;
  };

  const std::string& getMyBuf() const {
    return mMyBuf;
  };
  ...
</code></pre>

<h4>Examples</h4>

Suppose the inclrec.jr file contains:
<pre><code>
module inclrec {
    class RI {
        int      I32;
        double   D;
        ustring  S;
    };
}
</code></pre>

and the testrec.jr file contains:

<pre><code>
include "inclrec.jr"
module testrec {
    class R {
        vector<float> VF;
        RI            Rec;
        buffer        Buf;
    };
}
</code></pre>

Then the invocation of rcc such as:
<pre><code>
$ rcc -l c++ inclrec.jr testrec.jr
</code></pre>
will result in generation of four files:
inclrec.jr.{cc,hh} and testrec.jr.{cc,hh}.

The inclrec.jr.hh will contain:

<pre><code>
#ifndef _INCLREC_JR_HH_
#define _INCLREC_JR_HH_

#include "recordio.hh"

namespace inclrec {
  
  class RI : public hadoop::Record {

  private:

    int32_t      I32;
    double       D;
    std::string  S;

  public:

    RI(void);
    virtual ~RI(void);

    virtual bool operator==(const RI& peer) const;
    virtual bool operator<(const RI& peer) const;

    virtual int32_t getI32(void) const { return I32; }
    virtual void setI32(int32_t v) { I32 = v; }

    virtual double getD(void) const { return D; }
    virtual void setD(double v) { D = v; }

    virtual std::string& getS(void) const { return S; }
    virtual const std::string& getS(void) const { return S; }

    virtual std::string type(void) const;
    virtual std::string signature(void) const;

  protected:

    virtual void serialize(hadoop::OArchive& a) const;
    virtual void deserialize(hadoop::IArchive& a);
  };
} // end namespace inclrec

#endif /* _INCLREC_JR_HH_ */

</code></pre>

The testrec.jr.hh file will contain:


<pre><code>

#ifndef _TESTREC_JR_HH_
#define _TESTREC_JR_HH_

#include "inclrec.jr.hh"

namespace testrec {
  class R : public hadoop::Record {

  private:

    std::vector<float> VF;
    inclrec::RI        Rec;
    std::string        Buf;

  public:

    R(void);
    virtual ~R(void);

    virtual bool operator==(const R& peer) const;
    virtual bool operator<(const R& peer) const;

    virtual std::vector<float>& getVF(void) const;
    virtual const std::vector<float>& getVF(void) const;

    virtual std::string& getBuf(void) const ;
    virtual const std::string& getBuf(void) const;

    virtual inclrec::RI& getRec(void) const;
    virtual const inclrec::RI& getRec(void) const;
    
    virtual bool serialize(hadoop::OutArchive& a) const;
    virtual bool deserialize(hadoop::InArchive& a);
    
    virtual std::string type(void) const;
    virtual std::string signature(void) const;
  };
}; // end namespace testrec
#endif /* _TESTREC_JR_HH_ */

</code></pre>

<h3>Java</h3>

Code generation for Java is similar to that for C++. A Java class is generated
for each record type with private members corresponding to the fields. Getters
and setters for fields are also generated. Some differences arise in the
way comparison is expressed and in the mapping of modules to packages and
classes to files. For equality testing, an equals method is generated
for each record type. As per Java requirements a hashCode method is also
generated. For comparison a compareTo method is generated for each
record type. This has the semantics as defined by the Java Comparable
interface, that is, the method returns a negative integer, zero, or a positive
integer as the invoked object is less than, equal to, or greater than the
comparison parameter.

A .java file is generated per record type as opposed to per DDL
file as in C++. The module declaration translates to a Java
package declaration. The module name maps to an identical Java package
name. In addition to this mapping, the DDL compiler creates the appropriate
directory hierarchy for the package and places the generated .java
files in the correct directories.

<h2>Mapping Summary</h2>

<pre><code>
DDL Type        C++ Type            Java Type 

boolean         bool                boolean
byte            int8_t              byte
int             int32_t             int
long            int64_t             long
float           float               float
double          double              double
ustring         std::string         java.lang.String
buffer          std::string         org.apache.hadoop.record.Buffer
class type      class type          class type
vector<type>    std::vector<type>   java.util.ArrayList<type>
map<type,type>  std::map<type,type> java.util.TreeMap<type,type>
</code></pre>

<h2>Data encodings</h2>

This section describes the format of the data encodings supported by Hadoop.
Currently, three data encodings are supported, namely binary, CSV and XML.

<h3>Binary Serialization Format</h3>

The binary data encoding format is fairly dense. Serialization of composite
types is simply defined as a concatenation of serializations of the constituent
elements (lengths are included in vectors and maps).

Composite types are serialized as follows:
<ul>
<li> class: Sequence of serialized members.
<li> vector: The number of elements serialized as an int. Followed by a
sequence of serialized elements.
<li> map: The number of key value pairs serialized as an int. Followed
by a sequence of serialized (key,value) pairs.
</ul>

Serialization of primitives is more interesting, with a zero compression
optimization for integral types and normalization to UTF-8 for strings. 
Primitive types are serialized as follows:

<ul>
<li> byte: Represented by 1 byte, as is.
<li> boolean: Represented by 1-byte (0 or 1)
<li> int/long: Integers and longs are serialized zero compressed.
Represented as 1-byte if -120 <= value < 128. Otherwise, serialized as a
sequence of 2-5 bytes for ints, 2-9 bytes for longs. The first byte represents
the number of trailing bytes, N, as the negative number (-120-N). For example,
the number 1024 (0x400) is represented by the byte sequence 'x86 x04 x00'.
This doesn't help much for 4-byte integers but does a reasonably good job with
longs without bit twiddling.
<li> float/double: Serialized in IEEE 754 single and double precision
format in network byte order. This is the format used by Java.
<li> ustring: Serialized as 4-byte zero compressed length followed by
data encoded as UTF-8. Strings are normalized to UTF-8 regardless of native
language representation.
<li> buffer: Serialized as a 4-byte zero compressed length followed by the
raw bytes in the buffer.
</ul>


<h3>CSV Serialization Format</h3>

The CSV serialization format has a lot more structure than the "standard"
Excel CSV format, but we believe the additional structure is useful because

<ul>
<li> it makes parsing a lot easier without detracting too much from legibility
<li> the delimiters around composites make it obvious when one is reading a
sequence of Hadoop records
</ul>

Serialization formats for the various types are detailed in the grammar that
follows. The notable feature of the formats is the use of delimiters for 
indicating the certain field types.

<ul>
<li> A string field begins with a single quote (').
<li> A buffer field begins with a sharp (#).
<li> A class, vector or map begins with 's{', 'v{' or 'm{' respectively and
ends with '}'.
</ul>

The CSV format can be described by the following grammar:

<pre><code>
record = primitive / struct / vector / map
primitive = boolean / int / long / float / double / ustring / buffer

boolean = "T" / "F"
int = ["-"] 1*DIGIT
long = ";" ["-"] 1*DIGIT
float = ["-"] 1*DIGIT "." 1*DIGIT ["E" / "e" ["-"] 1*DIGIT]
double = ";" ["-"] 1*DIGIT "." 1*DIGIT ["E" / "e" ["-"] 1*DIGIT]

ustring = "'" *(UTF8 char except NULL, LF, % and , / "%00" / "%0a" / "%25" / "%2c" )

buffer = "#" *(BYTE except NULL, LF, % and , / "%00" / "%0a" / "%25" / "%2c" )

struct = "s{" record *("," record) "}"
vector = "v{" [record *("," record)] "}"
map = "m{" [*(record "," record)] "}"
</code></pre>

<h3>XML Serialization Format</h3>

The XML serialization format is the same used by Apache XML-RPC
(http://ws.apache.org/xmlrpc/types.html). This is an extension of the original
XML-RPC format and adds some additional data types. All record I/O types are
not directly expressible in this format, and access to a DDL is required in
order to convert these to valid types. All types primitive or composite are
represented by &lt;value&gt; elements. The particular XML-RPC type is
indicated by a nested element in the &lt;value&gt; element. The encoding for
records is always UTF-8. Primitive types are serialized as follows:

<ul>
<li> byte: XML tag &lt;ex:i1&gt;. Values: 1-byte unsigned 
integers represented in US-ASCII
<li> boolean: XML tag &lt;boolean&gt;. Values: "0" or "1"
<li> int: XML tags &lt;i4&gt; or &lt;int&gt;. Values: 4-byte
signed integers represented in US-ASCII.
<li> long: XML tag &lt;ex:i8&gt;. Values: 8-byte signed integers
represented in US-ASCII.
<li> float: XML tag &lt;ex:float&gt;. Values: Single precision
floating point numbers represented in US-ASCII.
<li> double: XML tag &lt;double&gt;. Values: Double precision
floating point numbers represented in US-ASCII.
<li> ustring: XML tag &lt;;string&gt;. Values: String values
represented as UTF-8. XML does not permit all Unicode characters in literal
data. In particular, NULLs and control chars are not allowed. Additionally,
XML processors are required to replace carriage returns with line feeds and to
replace CRLF sequences with line feeds. Programming languages that we work
with do not impose these restrictions on string types. To work around these
restrictions, disallowed characters and CRs are percent escaped in strings.
The '%' character is also percent escaped.
<li> buffer: XML tag &lt;string&&gt;. Values: Arbitrary binary
data. Represented as hexBinary, each byte is replaced by its 2-byte
hexadecimal representation.
</ul>

Composite types are serialized as follows:

<ul>
<li> class: XML tag &lt;struct&gt;. A struct is a sequence of
&lt;member&gt; elements. Each &lt;member&gt; element has a &lt;name&gt;
element and a &lt;value&gt; element. The &lt;name&gt; is a string that must
match /[a-zA-Z][a-zA-Z0-9_]*/. The value of the member is represented
by a &lt;value&gt; element.

<li> vector: XML tag &lt;array&lt;. An &lt;array&gt; contains a
single &lt;data&gt; element. The &lt;data&gt; element is a sequence of
&lt;value&gt; elements each of which represents an element of the vector.

<li> map: XML tag &lt;array&gt;. Same as vector.

</ul>

For example:

<pre><code>
class {
  int           MY_INT;            // value 5
  vector<float> MY_VEC;            // values 0.1, -0.89, 2.45e4
  buffer        MY_BUF;            // value '\00\n\tabc%'
}
</code></pre>

is serialized as

<pre><code class="XML">
&lt;value&gt;
  &lt;struct&gt;
    &lt;member&gt;
      &lt;name&gt;MY_INT&lt;/name&gt;
      &lt;value&gt;&lt;i4&gt;5&lt;/i4&gt;&lt;/value&gt;
    &lt;/member&gt;
    &lt;member&gt;
      &lt;name&gt;MY_VEC&lt;/name&gt;
      &lt;value&gt;
        &lt;array&gt;
          &lt;data&gt;
            &lt;value&gt;&lt;ex:float&gt;0.1&lt;/ex:float&gt;&lt;/value&gt;
            &lt;value&gt;&lt;ex:float&gt;-0.89&lt;/ex:float&gt;&lt;/value&gt;
            &lt;value&gt;&lt;ex:float&gt;2.45e4&lt;/ex:float&gt;&lt;/value&gt;
          &lt;/data&gt;
        &lt;/array&gt;
      &lt;/value&gt;
    &lt;/member&gt;
    &lt;member&gt;
      &lt;name&gt;MY_BUF&lt;/name&gt;
      &lt;value&gt;&lt;string&gt;%00\n\tabc%25&lt;/string&gt;&lt;/value&gt;
    &lt;/member&gt;
  &lt;/struct&gt;
&lt;/value&gt; 
</code></pre>]]>
  </doc>
</package>
<package name="org.apache.hadoop.record.compiler">
  <!-- start class org.apache.hadoop.record.compiler.CodeBuffer -->
  <class name="CodeBuffer" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A wrapper around StringBuffer that automatically does indentation]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.CodeBuffer -->
  <!-- start class org.apache.hadoop.record.compiler.Consts -->
  <class name="Consts" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="RIO_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RTI_VAR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RTI_FILTER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RTI_FILTER_FIELDS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RECORD_OUTPUT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RECORD_INPUT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TAG" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[const definitions for Record I/O compiler]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.Consts -->
  <!-- start class org.apache.hadoop.record.compiler.JBoolean -->
  <class name="JBoolean" extends="org.apache.hadoop.record.compiler.JType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JBoolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JBoolean]]>
      </doc>
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JBoolean -->
  <!-- start class org.apache.hadoop.record.compiler.JBuffer -->
  <class name="JBuffer" extends="org.apache.hadoop.record.compiler.JCompType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JBuffer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JBuffer]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Code generator for "buffer" type.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JBuffer -->
  <!-- start class org.apache.hadoop.record.compiler.JByte -->
  <class name="JByte" extends="org.apache.hadoop.record.compiler.JType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JByte"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Code generator for "byte" type.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JByte -->
  <!-- start class org.apache.hadoop.record.compiler.JDouble -->
  <class name="JDouble" extends="org.apache.hadoop.record.compiler.JType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JDouble"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JDouble]]>
      </doc>
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JDouble -->
  <!-- start class org.apache.hadoop.record.compiler.JField -->
  <class name="JField" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JField" type="java.lang.String, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JField]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A thin wrappper around record field.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JField -->
  <!-- start class org.apache.hadoop.record.compiler.JFile -->
  <class name="JFile" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JFile" type="java.lang.String, java.util.ArrayList, java.util.ArrayList"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JFile

 @param name possibly full pathname to the file
 @param inclFiles included files (as JFile)
 @param recList List of records defined within this file]]>
      </doc>
    </constructor>
    <method name="genCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="language" type="java.lang.String"/>
      <param name="destDir" type="java.lang.String"/>
      <param name="options" type="java.util.ArrayList"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Generate record code in given language. Language should be all
  lowercase.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Container for the Hadoop Record DDL.
 The main components of the file are filename, list of included files,
 and records defined in that file.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JFile -->
  <!-- start class org.apache.hadoop.record.compiler.JFloat -->
  <class name="JFloat" extends="org.apache.hadoop.record.compiler.JType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JFloat"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JFloat]]>
      </doc>
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JFloat -->
  <!-- start class org.apache.hadoop.record.compiler.JInt -->
  <class name="JInt" extends="org.apache.hadoop.record.compiler.JType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JInt"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JInt]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Code generator for "int" type]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JInt -->
  <!-- start class org.apache.hadoop.record.compiler.JLong -->
  <class name="JLong" extends="org.apache.hadoop.record.compiler.JType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JLong"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JLong]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Code generator for "long" type]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JLong -->
  <!-- start class org.apache.hadoop.record.compiler.JMap -->
  <class name="JMap" extends="org.apache.hadoop.record.compiler.JCompType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JMap" type="org.apache.hadoop.record.compiler.JType, org.apache.hadoop.record.compiler.JType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JMap]]>
      </doc>
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JMap -->
  <!-- start class org.apache.hadoop.record.compiler.JRecord -->
  <class name="JRecord" extends="org.apache.hadoop.record.compiler.JCompType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JRecord" type="java.lang.String, java.util.ArrayList"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JRecord]]>
      </doc>
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JRecord -->
  <!-- start class org.apache.hadoop.record.compiler.JString -->
  <class name="JString" extends="org.apache.hadoop.record.compiler.JCompType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JString"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JString]]>
      </doc>
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JString -->
  <!-- start class org.apache.hadoop.record.compiler.JType -->
  <class name="JType" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Abstract Base class for all types supported by Hadoop Record I/O.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JType -->
  <!-- start class org.apache.hadoop.record.compiler.JVector -->
  <class name="JVector" extends="org.apache.hadoop.record.compiler.JCompType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JVector" type="org.apache.hadoop.record.compiler.JType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JVector]]>
      </doc>
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JVector -->
  <doc>
  <![CDATA[This package contains classes needed for code generation
  from the hadoop record compiler. CppGenerator and JavaGenerator
  are the main entry points from the parser. There are classes
  corrsponding to every primitive type and compound type
  included in Hadoop record I/O syntax.]]>
  </doc>
</package>
<package name="org.apache.hadoop.record.compiler.ant">
  <!-- start class org.apache.hadoop.record.compiler.ant.RccTask -->
  <class name="RccTask" extends="org.apache.tools.ant.Task"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RccTask"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of RccTask]]>
      </doc>
    </constructor>
    <method name="setLanguage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="language" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the output language option
 @param language "java"/"c++"]]>
      </doc>
    </method>
    <method name="setFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <doc>
      <![CDATA[Sets the record definition file attribute
 @param file record definition file]]>
      </doc>
    </method>
    <method name="setFailonerror"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="boolean"/>
      <doc>
      <![CDATA[Given multiple files (via fileset), set the error handling behavior
 @param flag true will throw build exception in case of failure (default)]]>
      </doc>
    </method>
    <method name="setDestdir"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <doc>
      <![CDATA[Sets directory where output files will be generated
 @param dir output directory]]>
      </doc>
    </method>
    <method name="addFileset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set" type="org.apache.tools.ant.types.FileSet"/>
      <doc>
      <![CDATA[Adds a fileset that can consist of one or more files
 @param set Set of record definition files]]>
      </doc>
    </method>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="BuildException" type="org.apache.tools.ant.BuildException"/>
      <doc>
      <![CDATA[Invoke the Hadoop record compiler on each record definition file]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Hadoop record compiler ant Task
<p> This task takes the given record definition files and compiles them into
 java or c++
 files. It is then up to the user to compile the generated files.

 <p> The task requires the <code>file</code> or the nested fileset element to be
 specified. Optional attributes are <code>language</code> (set the output
 language, default is "java"),
 <code>destdir</code> (name of the destination directory for generated java/c++
 code, default is ".") and <code>failonerror</code> (specifies error handling
 behavior. default is true).
 <p><h4>Usage</h4>
 <pre>
 &lt;recordcc
       destdir="${basedir}/gensrc"
       language="java"&gt;
   &lt;fileset include="**\/*.jr" /&gt;
 &lt;/recordcc&gt;
 </pre>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.ant.RccTask -->
</package>
<package name="org.apache.hadoop.record.compiler.generated">
  <!-- start class org.apache.hadoop.record.compiler.generated.ParseException -->
  <class name="ParseException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ParseException" type="org.apache.hadoop.record.compiler.generated.Token, int[][], java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This constructor is used by the method "generateParseException"
 in the generated parser.  Calling this constructor generates
 a new object of this type with the fields "currentToken",
 "expectedTokenSequences", and "tokenImage" set.  The boolean
 flag "specialConstructor" is also set to true to indicate that
 this constructor was used to create this object.
 This constructor calls its super class with the empty string
 to force the "toString" method of parent class "Throwable" to
 print the error message in the form:
     ParseException: <result of getMessage>]]>
      </doc>
    </constructor>
    <constructor name="ParseException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The following constructors are for use by you for whatever
 purpose you can think of.  Constructing the exception in this
 manner makes the exception behave in the normal way - i.e., as
 documented in the class "Throwable".  The fields "errorToken",
 "expectedTokenSequences", and "tokenImage" do not contain
 relevant information.  The JavaCC generated code does not use
 these constructors.]]>
      </doc>
    </constructor>
    <constructor name="ParseException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This method has the standard behavior when this object has been
 created using the standard constructors.  Otherwise, it uses
 "currentToken" and "expectedTokenSequences" to generate a parse
 error message and returns it.  If this object has been created
 due to a parse error, and you do not catch it (it gets thrown
 from the parser), then this method is called during the printing
 of the final stack trace, and hence the correct error message
 gets displayed.]]>
      </doc>
    </method>
    <method name="add_escapes" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <doc>
      <![CDATA[Used to convert raw characters to their escaped version
 when these raw version cannot be used as part of an ASCII
 string literal.]]>
      </doc>
    </method>
    <field name="specialConstructor" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This variable determines which constructor was used to create
 this object and thereby affects the semantics of the
 "getMessage" method (see below).]]>
      </doc>
    </field>
    <field name="currentToken" type="org.apache.hadoop.record.compiler.generated.Token"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This is the last token that has been consumed successfully.  If
 this object has been created due to a parse error, the token
 followng this token will (therefore) be the first error token.]]>
      </doc>
    </field>
    <field name="expectedTokenSequences" type="int[][]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Each entry in this array is an array of integers.  Each array
 of integers represents a sequence of tokens (by their ordinal
 values) that is expected at this point of the parse.]]>
      </doc>
    </field>
    <field name="tokenImage" type="java.lang.String[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This is a reference to the "tokenImage" array of the generated
 parser within which the parse error occurred.  This array is
 defined in the generated ...Constants interface.]]>
      </doc>
    </field>
    <field name="eol" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The end of line string for this machine.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This exception is thrown when parse errors are encountered.
 You can explicitly create objects of this exception type by
 calling the method generateParseException in the generated
 parser.

 You can modify this class to customize your error reporting
 mechanisms so long as you retain the public fields.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.generated.ParseException -->
  <!-- start class org.apache.hadoop.record.compiler.generated.Rcc -->
  <class name="Rcc" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.record.compiler.generated.RccConstants"/>
    <constructor name="Rcc" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Rcc" type="java.io.InputStream, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Rcc" type="java.io.Reader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Rcc" type="org.apache.hadoop.record.compiler.generated.RccTokenManager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
    </method>
    <method name="usage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="driver" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
    </method>
    <method name="Input" return="org.apache.hadoop.record.compiler.JFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="ParseException" type="org.apache.hadoop.record.compiler.generated.ParseException"/>
    </method>
    <method name="Include" return="org.apache.hadoop.record.compiler.JFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="ParseException" type="org.apache.hadoop.record.compiler.generated.ParseException"/>
    </method>
    <method name="Module" return="java.util.ArrayList"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="ParseException" type="org.apache.hadoop.record.compiler.generated.ParseException"/>
    </method>
    <method name="ModuleName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="ParseException" type="org.apache.hadoop.record.compiler.generated.ParseException"/>
    </method>
    <method name="RecordList" return="java.util.ArrayList"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="ParseException" type="org.apache.hadoop.record.compiler.generated.ParseException"/>
    </method>
    <method name="Record" return="org.apache.hadoop.record.compiler.JRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="ParseException" type="org.apache.hadoop.record.compiler.generated.ParseException"/>
    </method>
    <method name="Field" return="org.apache.hadoop.record.compiler.JField"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="ParseException" type="org.apache.hadoop.record.compiler.generated.ParseException"/>
    </method>
    <method name="Type" return="org.apache.hadoop.record.compiler.JType"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="ParseException" type="org.apache.hadoop.record.compiler.generated.ParseException"/>
    </method>
    <method name="Map" return="org.apache.hadoop.record.compiler.JMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="ParseException" type="org.apache.hadoop.record.compiler.generated.ParseException"/>
    </method>
    <method name="Vector" return="org.apache.hadoop.record.compiler.JVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="ParseException" type="org.apache.hadoop.record.compiler.generated.ParseException"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.InputStream"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.InputStream"/>
      <param name="encoding" type="java.lang.String"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.Reader"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tm" type="org.apache.hadoop.record.compiler.generated.RccTokenManager"/>
    </method>
    <method name="getNextToken" return="org.apache.hadoop.record.compiler.generated.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getToken" return="org.apache.hadoop.record.compiler.generated.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="generateParseException" return="org.apache.hadoop.record.compiler.generated.ParseException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="enable_tracing"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="disable_tracing"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="token_source" type="org.apache.hadoop.record.compiler.generated.RccTokenManager"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="token" type="org.apache.hadoop.record.compiler.generated.Token"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="jj_nt" type="org.apache.hadoop.record.compiler.generated.Token"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.generated.Rcc -->
  <!-- start interface org.apache.hadoop.record.compiler.generated.RccConstants -->
  <interface name="RccConstants"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="EOF" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MODULE_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RECORD_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INCLUDE_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BYTE_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BOOLEAN_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INT_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LONG_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FLOAT_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DOUBLE_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="USTRING_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BUFFER_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="VECTOR_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MAP_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LBRACE_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RBRACE_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LT_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="GT_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SEMICOLON_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="COMMA_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DOT_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CSTRING_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="IDENT_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WithinOneLineComment" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WithinMultiLineComment" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="tokenImage" type="java.lang.String[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </interface>
  <!-- end interface org.apache.hadoop.record.compiler.generated.RccConstants -->
  <!-- start class org.apache.hadoop.record.compiler.generated.RccTokenManager -->
  <class name="RccTokenManager" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.record.compiler.generated.RccConstants"/>
    <constructor name="RccTokenManager" type="org.apache.hadoop.record.compiler.generated.SimpleCharStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="RccTokenManager" type="org.apache.hadoop.record.compiler.generated.SimpleCharStream, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setDebugStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ds" type="java.io.PrintStream"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="org.apache.hadoop.record.compiler.generated.SimpleCharStream"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="org.apache.hadoop.record.compiler.generated.SimpleCharStream"/>
      <param name="lexState" type="int"/>
    </method>
    <method name="SwitchTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lexState" type="int"/>
    </method>
    <method name="jjFillToken" return="org.apache.hadoop.record.compiler.generated.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getNextToken" return="org.apache.hadoop.record.compiler.generated.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="debugStream" type="java.io.PrintStream"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="jjstrLiteralImages" type="java.lang.String[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="lexStateNames" type="java.lang.String[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="jjnewLexState" type="int[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="input_stream" type="org.apache.hadoop.record.compiler.generated.SimpleCharStream"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="curChar" type="char"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.generated.RccTokenManager -->
  <!-- start class org.apache.hadoop.record.compiler.generated.SimpleCharStream -->
  <class name="SimpleCharStream" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SimpleCharStream" type="java.io.Reader, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SimpleCharStream" type="java.io.Reader, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SimpleCharStream" type="java.io.Reader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SimpleCharStream" type="java.io.InputStream, java.lang.String, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedEncodingException" type="java.io.UnsupportedEncodingException"/>
    </constructor>
    <constructor name="SimpleCharStream" type="java.io.InputStream, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SimpleCharStream" type="java.io.InputStream, java.lang.String, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedEncodingException" type="java.io.UnsupportedEncodingException"/>
    </constructor>
    <constructor name="SimpleCharStream" type="java.io.InputStream, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SimpleCharStream" type="java.io.InputStream, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedEncodingException" type="java.io.UnsupportedEncodingException"/>
    </constructor>
    <constructor name="SimpleCharStream" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setTabSize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="i" type="int"/>
    </method>
    <method name="getTabSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="i" type="int"/>
    </method>
    <method name="ExpandBuff"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="wrapAround" type="boolean"/>
    </method>
    <method name="FillBuff"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="BeginToken" return="char"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="UpdateLineColumn"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="c" type="char"/>
    </method>
    <method name="readChar" return="char"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getEndColumn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEndLine" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBeginColumn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBeginLine" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="backup"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amount" type="int"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dstream" type="java.io.Reader"/>
      <param name="startline" type="int"/>
      <param name="startcolumn" type="int"/>
      <param name="buffersize" type="int"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dstream" type="java.io.Reader"/>
      <param name="startline" type="int"/>
      <param name="startcolumn" type="int"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dstream" type="java.io.Reader"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dstream" type="java.io.InputStream"/>
      <param name="encoding" type="java.lang.String"/>
      <param name="startline" type="int"/>
      <param name="startcolumn" type="int"/>
      <param name="buffersize" type="int"/>
      <exception name="UnsupportedEncodingException" type="java.io.UnsupportedEncodingException"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dstream" type="java.io.InputStream"/>
      <param name="startline" type="int"/>
      <param name="startcolumn" type="int"/>
      <param name="buffersize" type="int"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dstream" type="java.io.InputStream"/>
      <param name="encoding" type="java.lang.String"/>
      <exception name="UnsupportedEncodingException" type="java.io.UnsupportedEncodingException"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dstream" type="java.io.InputStream"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dstream" type="java.io.InputStream"/>
      <param name="encoding" type="java.lang.String"/>
      <param name="startline" type="int"/>
      <param name="startcolumn" type="int"/>
      <exception name="UnsupportedEncodingException" type="java.io.UnsupportedEncodingException"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dstream" type="java.io.InputStream"/>
      <param name="startline" type="int"/>
      <param name="startcolumn" type="int"/>
    </method>
    <method name="GetImage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="GetSuffix" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="len" type="int"/>
    </method>
    <method name="Done"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="adjustBeginLineColumn"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newLine" type="int"/>
      <param name="newCol" type="int"/>
      <doc>
      <![CDATA[Method to adjust line and column numbers for the start of a token.]]>
      </doc>
    </method>
    <field name="staticFlag" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="bufpos" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="bufline" type="int[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="bufcolumn" type="int[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="column" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="line" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="prevCharIsCR" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="prevCharIsLF" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="inputStream" type="java.io.Reader"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="buffer" type="char[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="maxNextCharInd" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="inBuf" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="tabSize" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[An implementation of interface CharStream, where the stream is assumed to
 contain only ASCII characters (without unicode processing).]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.generated.SimpleCharStream -->
  <!-- start class org.apache.hadoop.record.compiler.generated.Token -->
  <class name="Token" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Token"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the image.]]>
      </doc>
    </method>
    <method name="newToken" return="org.apache.hadoop.record.compiler.generated.Token"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="ofKind" type="int"/>
      <doc>
      <![CDATA[Returns a new Token object, by default. However, if you want, you
 can create and return subclass objects based on the value of ofKind.
 Simply add the cases to the switch for all those special cases.
 For example, if you have a subclass of Token called IDToken that
 you want to create if ofKind is ID, simlpy add something like :

    case MyParserConstants.ID : return new IDToken();

 to the following switch statement. Then you can cast matchedToken
 variable to the appropriate type and use it in your lexical actions.]]>
      </doc>
    </method>
    <field name="kind" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An integer that describes the kind of this token.  This numbering
 system is determined by JavaCCParser, and a table of these numbers is
 stored in the file ...Constants.java.]]>
      </doc>
    </field>
    <field name="beginLine" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[beginLine and beginColumn describe the position of the first character
 of this token; endLine and endColumn describe the position of the
 last character of this token.]]>
      </doc>
    </field>
    <field name="beginColumn" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[beginLine and beginColumn describe the position of the first character
 of this token; endLine and endColumn describe the position of the
 last character of this token.]]>
      </doc>
    </field>
    <field name="endLine" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[beginLine and beginColumn describe the position of the first character
 of this token; endLine and endColumn describe the position of the
 last character of this token.]]>
      </doc>
    </field>
    <field name="endColumn" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[beginLine and beginColumn describe the position of the first character
 of this token; endLine and endColumn describe the position of the
 last character of this token.]]>
      </doc>
    </field>
    <field name="image" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The string image of the token.]]>
      </doc>
    </field>
    <field name="next" type="org.apache.hadoop.record.compiler.generated.Token"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A reference to the next regular (non-special) token from the input
 stream.  If this is the last token from the input stream, or if the
 token manager has not read tokens beyond this one, this field is
 set to null.  This is true only if this token is also a regular
 token.  Otherwise, see below for a description of the contents of
 this field.]]>
      </doc>
    </field>
    <field name="specialToken" type="org.apache.hadoop.record.compiler.generated.Token"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This field is used to access special tokens that occur prior to this
 token, but after the immediately preceding regular (non-special) token.
 If there are no such special tokens, this field is set to null.
 When there are more than one such special token, this field refers
 to the last of these special tokens, which in turn refers to the next
 previous special token through its specialToken field, and so on
 until the first special token (whose specialToken field is null).
 The next fields of special tokens refer to other special tokens that
 immediately follow it (without an intervening regular token).  If there
 is no such token, this field is null.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Describes the input token stream.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.generated.Token -->
  <!-- start class org.apache.hadoop.record.compiler.generated.TokenMgrError -->
  <class name="TokenMgrError" extends="java.lang.Error"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TokenMgrError"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TokenMgrError" type="java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TokenMgrError" type="boolean, int, int, int, java.lang.String, char, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="addEscapes" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <doc>
      <![CDATA[Replaces unprintable characters by their espaced (or unicode escaped)
 equivalents in the given string]]>
      </doc>
    </method>
    <method name="LexicalError" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="EOFSeen" type="boolean"/>
      <param name="lexState" type="int"/>
      <param name="errorLine" type="int"/>
      <param name="errorColumn" type="int"/>
      <param name="errorAfter" type="java.lang.String"/>
      <param name="curChar" type="char"/>
      <doc>
      <![CDATA[Returns a detailed message for the Error when it is thrown by the
 token manager to indicate a lexical error.
 Parameters : 
    EOFSeen     : indicates if EOF caused the lexicl error
    curLexState : lexical state in which this error occured
    errorLine   : line number when the error occured
    errorColumn : column number when the error occured
    errorAfter  : prefix that was seen before this error occured
    curchar     : the offending character
 Note: You can customize the lexical error message by modifying this method.]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[You can also modify the body of this method to customize your error messages.
 For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
 of end-users concern, so you can return something like : 

     "Internal Error : Please file a bug report .... "

 from this method for such cases in the release version of your parser.]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.generated.TokenMgrError -->
  <doc>
  <![CDATA[This package contains code generated by JavaCC from the
  Hadoop record syntax file rcc.jj. For details about the
  record file syntax please @see org.apache.hadoop.record.]]>
  </doc>
</package>
<package name="org.apache.hadoop.record.meta">
  <!-- start class org.apache.hadoop.record.meta.FieldTypeInfo -->
  <class name="FieldTypeInfo" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getTypeID" return="org.apache.hadoop.record.meta.TypeID"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the field's TypeID object]]>
      </doc>
    </method>
    <method name="getFieldID" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the field's id (name)]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Two FieldTypeInfos are equal if ach of their fields matches]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[We use a basic hashcode implementation, since this class will likely not
 be used as a hashmap key]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ti" type="org.apache.hadoop.record.meta.FieldTypeInfo"/>
    </method>
    <doc>
    <![CDATA[Represents a type information for a field, which is made up of its 
 ID (name) and its type (a TypeID object).]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.meta.FieldTypeInfo -->
  <!-- start class org.apache.hadoop.record.meta.MapTypeID -->
  <class name="MapTypeID" extends="org.apache.hadoop.record.meta.TypeID"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MapTypeID" type="org.apache.hadoop.record.meta.TypeID, org.apache.hadoop.record.meta.TypeID"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKeyTypeID" return="org.apache.hadoop.record.meta.TypeID"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the TypeID of the map's key element]]>
      </doc>
    </method>
    <method name="getValueTypeID" return="org.apache.hadoop.record.meta.TypeID"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the TypeID of the map's value element]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Two map  typeIDs are equal if their constituent elements have the 
 same type]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[We use a basic hashcode implementation, since this class will likely not
 be used as a hashmap key]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents typeID for a Map]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.meta.MapTypeID -->
  <!-- start class org.apache.hadoop.record.meta.RecordTypeInfo -->
  <class name="RecordTypeInfo" extends="org.apache.hadoop.record.Record"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RecordTypeInfo"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an empty RecordTypeInfo object.]]>
      </doc>
    </constructor>
    <constructor name="RecordTypeInfo" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a RecordTypeInfo object representing a record with the given name
 @param name Name of the record]]>
      </doc>
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[return the name of the record]]>
      </doc>
    </method>
    <method name="setName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[set the name of the record]]>
      </doc>
    </method>
    <method name="addField"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldName" type="java.lang.String"/>
      <param name="tid" type="org.apache.hadoop.record.meta.TypeID"/>
      <doc>
      <![CDATA[Add a field. 
 @param fieldName Name of the field
 @param tid Type ID of the field]]>
      </doc>
    </method>
    <method name="getFieldTypeInfos" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a collection of field type infos]]>
      </doc>
    </method>
    <method name="getNestedStructTypeInfo" return="org.apache.hadoop.record.meta.RecordTypeInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Return the type info of a nested record. We only consider nesting 
 to one level. 
 @param name Name of the nested record]]>
      </doc>
    </method>
    <method name="serialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rout" type="org.apache.hadoop.record.RecordOutput"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serialize the type information for a record]]>
      </doc>
    </method>
    <method name="deserialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rin" type="org.apache.hadoop.record.RecordInput"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deserialize the type information for a record]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="peer_" type="java.lang.Object"/>
      <exception name="ClassCastException" type="java.lang.ClassCastException"/>
      <doc>
      <![CDATA[This class doesn't implement Comparable as it's not meant to be used 
 for anything besides de/serializing.
 So we always throw an exception.
 Not implemented. Always returns 0 if another RecordTypeInfo is passed in.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A record's Type Information object which can read/write itself. 
 
 Type information for a record comprises metadata about the record, 
 as well as a collection of type information for each field in the record.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.meta.RecordTypeInfo -->
  <!-- start class org.apache.hadoop.record.meta.StructTypeID -->
  <class name="StructTypeID" extends="org.apache.hadoop.record.meta.TypeID"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="StructTypeID" type="org.apache.hadoop.record.meta.RecordTypeInfo"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a StructTypeID based on the RecordTypeInfo of some record]]>
      </doc>
    </constructor>
    <method name="getFieldTypeInfos" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents typeID for a struct]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.meta.StructTypeID -->
  <!-- start class org.apache.hadoop.record.meta.TypeID -->
  <class name="TypeID" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getTypeVal" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type value. One of the constants in RIOType.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Two base typeIDs are equal if they refer to the same type]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[We use a basic hashcode implementation, since this class will likely not
 be used as a hashmap key]]>
      </doc>
    </method>
    <field name="BoolTypeID" type="org.apache.hadoop.record.meta.TypeID"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constant classes for the basic types, so we can share them.]]>
      </doc>
    </field>
    <field name="BufferTypeID" type="org.apache.hadoop.record.meta.TypeID"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ByteTypeID" type="org.apache.hadoop.record.meta.TypeID"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DoubleTypeID" type="org.apache.hadoop.record.meta.TypeID"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FloatTypeID" type="org.apache.hadoop.record.meta.TypeID"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="IntTypeID" type="org.apache.hadoop.record.meta.TypeID"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LongTypeID" type="org.apache.hadoop.record.meta.TypeID"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="StringTypeID" type="org.apache.hadoop.record.meta.TypeID"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="typeVal" type="byte"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents typeID for basic types.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.meta.TypeID -->
  <!-- start class org.apache.hadoop.record.meta.TypeID.RIOType -->
  <class name="TypeID.RIOType" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="TypeID.RIOType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="BOOL" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BUFFER" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BYTE" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DOUBLE" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FLOAT" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INT" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LONG" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MAP" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="STRING" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="STRUCT" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="VECTOR" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[constants representing the IDL types we support]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.meta.TypeID.RIOType -->
  <!-- start class org.apache.hadoop.record.meta.Utils -->
  <class name="Utils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="skip"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rin" type="org.apache.hadoop.record.RecordInput"/>
      <param name="tag" type="java.lang.String"/>
      <param name="typeID" type="org.apache.hadoop.record.meta.TypeID"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[read/skip bytes from stream based on a type]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Various utility functions for Hadooop record I/O platform.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.meta.Utils -->
  <!-- start class org.apache.hadoop.record.meta.VectorTypeID -->
  <class name="VectorTypeID" extends="org.apache.hadoop.record.meta.TypeID"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="VectorTypeID" type="org.apache.hadoop.record.meta.TypeID"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getElementTypeID" return="org.apache.hadoop.record.meta.TypeID"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Two vector typeIDs are equal if their constituent elements have the 
 same type]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[We use a basic hashcode implementation, since this class will likely not
 be used as a hashmap key]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents typeID for vector.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.meta.VectorTypeID -->
</package>
<package name="org.apache.hadoop.security">
  <!-- start class org.apache.hadoop.security.AccessControlException -->
  <class name="AccessControlException" extends="org.apache.hadoop.fs.permission.AccessControlException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessControlException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor is needed for unwrapping from 
 {@link org.apache.hadoop.ipc.RemoteException}.]]>
      </doc>
    </constructor>
    <constructor name="AccessControlException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an {@link AccessControlException}
 with the specified detail message.
 @param s the detail message.]]>
      </doc>
    </constructor>
    <constructor name="AccessControlException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new exception with the specified cause and a detail
 message of <tt>(cause==null ? null : cause.toString())</tt> (which
 typically contains the class and detail message of <tt>cause</tt>).
 @param  cause the cause (which is saved for later retrieval by the
         {@link #getCause()} method).  (A <tt>null</tt> value is
         permitted, and indicates that the cause is nonexistent or
         unknown.)]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[An exception class for access control related issues.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.AccessControlException -->
  <!-- start class org.apache.hadoop.security.Group -->
  <class name="Group" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.security.Principal"/>
    <constructor name="Group" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new <code>Group</code> with the given groupname.
 @param group group name]]>
      </doc>
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[A group to which a user belongs to.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.Group -->
  <!-- start class org.apache.hadoop.security.SecurityUtil -->
  <class name="SecurityUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SecurityUtil"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="policy" type="java.security.Policy"/>
      <doc>
      <![CDATA[Set the global security policy for Hadoop.
 
 @param policy {@link Policy} used for authorization.]]>
      </doc>
    </method>
    <method name="getPolicy" return="java.security.Policy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current global security policy for Hadoop.
 @return the current {@link Policy}]]>
      </doc>
    </method>
    <method name="getSubject" return="javax.security.auth.Subject"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ugi" type="org.apache.hadoop.security.UserGroupInformation"/>
      <doc>
      <![CDATA[Get the {@link Subject} for the user identified by <code>ugi</code>.
 @param ugi user
 @return the {@link Subject} for the user identified by <code>ugi</code>]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.security.SecurityUtil -->
  <!-- start class org.apache.hadoop.security.SecurityUtil.AccessControlList -->
  <class name="SecurityUtil.AccessControlList" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SecurityUtil.AccessControlList" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a new ACL from a String representation of the same.
 
 The String is a a comma separated list of users and groups.
 The user list comes first and is separated by a space followed 
 by the group list. For e.g. "user1,user2 group1,group2"
 
 @param aclString String representation of the ACL]]>
      </doc>
    </constructor>
    <method name="allAllowed" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUsers" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getGroups" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="WILDCARD_ACL_VALUE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Class representing a configured access control list.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.SecurityUtil.AccessControlList -->
  <!-- start class org.apache.hadoop.security.UnixUserGroupInformation -->
  <class name="UnixUserGroupInformation" extends="org.apache.hadoop.security.UserGroupInformation"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UnixUserGroupInformation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor]]>
      </doc>
    </constructor>
    <constructor name="UnixUserGroupInformation" type="java.lang.String, java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with parameters user name and its group names.
 The first entry in the groups list is the default  group.
 
 @param userName a user's name
 @param groupNames groups list, first of which is the default group
 @exception IllegalArgumentException if any argument is null]]>
      </doc>
    </constructor>
    <constructor name="UnixUserGroupInformation" type="java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with parameter user/group names
 
 @param ugi an array containing user/group names, the first
                     element of which is the user name, the second of
                     which is the default group name.
 @exception IllegalArgumentException if the array size is less than 2 
                                     or any element is null.]]>
      </doc>
    </constructor>
    <method name="createImmutable" return="org.apache.hadoop.security.UnixUserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ugi" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Create an immutable {@link UnixUserGroupInformation} object.]]>
      </doc>
    </method>
    <method name="getGroupNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return an array of group names]]>
      </doc>
    </method>
    <method name="getUserName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the user's name]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deserialize this object
 First check if this is a UGI in the string format.
 If no, throw an IOException; otherwise
 set this object's fields by reading them from the given data input
  
  @param in input stream
  @exception IOException is thrown if encounter any error when reading]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serialize this object
 First write a string marking that this is a UGI in the string format,
 then write this object's serialized form to the given data output
 
 @param out output stream
 @exception IOException if encounter any error during writing]]>
      </doc>
    </method>
    <method name="saveToConf"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="attr" type="java.lang.String"/>
      <param name="ugi" type="org.apache.hadoop.security.UnixUserGroupInformation"/>
      <doc>
      <![CDATA[Store the given <code>ugi</code> as a comma separated string in
 <code>conf</code> as a property <code>attr</code>
 
 The String starts with the user name followed by the default group names,
 and other group names.
 
 @param conf configuration
 @param attr property name
 @param ugi a UnixUserGroupInformation]]>
      </doc>
    </method>
    <method name="readFromConf" return="org.apache.hadoop.security.UnixUserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="attr" type="java.lang.String"/>
      <exception name="LoginException" type="javax.security.auth.login.LoginException"/>
      <doc>
      <![CDATA[Read a UGI from the given <code>conf</code>
 
 The object is expected to store with the property name <code>attr</code>
 as a comma separated string that starts
 with the user name followed by group names.
 If the property name is not defined, return null.
 It's assumed that there is only one UGI per user. If this user already
 has a UGI in the ugi map, return the ugi in the map.
 Otherwise, construct a UGI from the configuration, store it in the
 ugi map and return it.
 
 @param conf configuration
 @param attr property name
 @return a UnixUGI
 @throws LoginException if the stored string is ill-formatted.]]>
      </doc>
    </method>
    <method name="login" return="org.apache.hadoop.security.UnixUserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="LoginException" type="javax.security.auth.login.LoginException"/>
      <doc>
      <![CDATA[Get current user's name and the names of all its groups from Unix.
 It's assumed that there is only one UGI per user. If this user already
 has a UGI in the ugi map, return the ugi in the map.
 Otherwise get the current user's information from Unix, store it
 in the map, and return it.

 If the current user's UNIX username or groups are configured in such a way
 to throw an Exception, for example if the user uses LDAP, then this method
 will use a the {@link #DEFAULT_USERNAME} and {@link #DEFAULT_GROUP}
 constants.]]>
      </doc>
    </method>
    <method name="login" return="org.apache.hadoop.security.UnixUserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="LoginException" type="javax.security.auth.login.LoginException"/>
      <doc>
      <![CDATA[Equivalent to login(conf, false).]]>
      </doc>
    </method>
    <method name="login" return="org.apache.hadoop.security.UnixUserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="save" type="boolean"/>
      <exception name="LoginException" type="javax.security.auth.login.LoginException"/>
      <doc>
      <![CDATA[Get a user's name & its group names from the given configuration; 
 If it is not defined in the configuration, get the current user's
 information from Unix.
 If the user has a UGI in the ugi map, return the one in
 the UGI map.
 
  @param conf either a job configuration or client's configuration
  @param save saving it to conf?
  @return UnixUserGroupInformation a user/group information
  @exception LoginException if not able to get the user/group information]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
      <doc>
      <![CDATA[Decide if two UGIs are the same

 @param other other object
 @return true if they are the same; false otherwise.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash code for this UGI. 
 The hash code for a UGI is the hash code of its user name string.
 
 @return  a hash code value for this UGI.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Convert this object to a string
 
 @return a comma separated string containing the user name and group names]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="DEFAULT_USERNAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_GROUP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="UGI_PROPERTY_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[An implementation of UserGroupInformation in the Unix system]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.UnixUserGroupInformation -->
  <!-- start class org.apache.hadoop.security.User -->
  <class name="User" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.security.Principal"/>
    <constructor name="User" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new <code>User</code> with the given username.
 @param user user name]]>
      </doc>
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[The username of a user.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.User -->
  <!-- start class org.apache.hadoop.security.UserGroupInformation -->
  <class name="UserGroupInformation" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <implements name="java.security.Principal"/>
    <constructor name="UserGroupInformation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCurrentUGI" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the {@link UserGroupInformation} for the current thread]]>
      </doc>
    </method>
    <method name="setCurrentUGI"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #setCurrentUser(UserGroupInformation)}">
      <param name="ugi" type="org.apache.hadoop.security.UserGroupInformation"/>
      <doc>
      <![CDATA[Set the {@link UserGroupInformation} for the current thread
 @deprecated Use {@link #setCurrentUser(UserGroupInformation)}]]>
      </doc>
    </method>
    <method name="setCurrentUser"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ugi" type="org.apache.hadoop.security.UserGroupInformation"/>
      <doc>
      <![CDATA[Set the {@link UserGroupInformation} for the current thread
 WARNING - This method should be used only in test cases and other exceptional
 cases!
 @param ugi {@link UserGroupInformation} for the current thread]]>
      </doc>
    </method>
    <method name="getUserName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get username
 
 @return the user's name]]>
      </doc>
    </method>
    <method name="getGroupNames" return="java.lang.String[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the name of the groups that the user belong to
 
 @return an array of group names]]>
      </doc>
    </method>
    <method name="login" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="LoginException" type="javax.security.auth.login.LoginException"/>
      <doc>
      <![CDATA[Login and return a UserGroupInformation object.]]>
      </doc>
    </method>
    <method name="readFrom" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a {@link UserGroupInformation} from conf]]>
      </doc>
    </method>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A {@link Writable} abstract class for storing user and groups information.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.UserGroupInformation -->
</package>
<package name="org.apache.hadoop.security.authorize">
  <!-- start class org.apache.hadoop.security.authorize.AuthorizationException -->
  <class name="AuthorizationException" extends="org.apache.hadoop.security.AccessControlException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AuthorizationException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AuthorizationException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AuthorizationException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new exception with the specified cause and a detail
 message of <tt>(cause==null ? null : cause.toString())</tt> (which
 typically contains the class and detail message of <tt>cause</tt>).
 @param  cause the cause (which is saved for later retrieval by the
         {@link #getCause()} method).  (A <tt>null</tt> value is
         permitted, and indicates that the cause is nonexistent or
         unknown.)]]>
      </doc>
    </constructor>
    <method name="getStackTrace" return="java.lang.StackTraceElement[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="printStackTrace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="printStackTrace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.io.PrintStream"/>
    </method>
    <method name="printStackTrace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.io.PrintWriter"/>
    </method>
    <doc>
    <![CDATA[An exception class for authorization-related issues.
 
 This class <em>does not</em> provide the stack trace for security purposes.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.authorize.AuthorizationException -->
  <!-- start class org.apache.hadoop.security.authorize.ConfiguredPolicy -->
  <class name="ConfiguredPolicy" extends="java.security.Policy"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="ConfiguredPolicy" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.security.authorize.PolicyProvider"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="implies" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="domain" type="java.security.ProtectionDomain"/>
      <param name="permission" type="java.security.Permission"/>
    </method>
    <method name="getPermissions" return="java.security.PermissionCollection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="domain" type="java.security.ProtectionDomain"/>
    </method>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="HADOOP_POLICY_FILE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A {@link Configuration} based security {@link Policy} for Hadoop.

 {@link ConfiguredPolicy} works in conjunction with a {@link PolicyProvider}
 for providing service-level authorization for Hadoop.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.authorize.ConfiguredPolicy -->
  <!-- start class org.apache.hadoop.security.authorize.ConnectionPermission -->
  <class name="ConnectionPermission" extends="java.security.Permission"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConnectionPermission" type="java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@link ConnectionPermission} for a given service.
 @param protocol service to be accessed]]>
      </doc>
    </constructor>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="getActions" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="implies" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permission" type="java.security.Permission"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[{@link Permission} to initiate a connection to a given service.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.authorize.ConnectionPermission -->
  <!-- start class org.apache.hadoop.security.authorize.PolicyProvider -->
  <class name="PolicyProvider" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PolicyProvider"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getServices" return="org.apache.hadoop.security.authorize.Service[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link Service} definitions from the {@link PolicyProvider}.
 @return the {@link Service} definitions]]>
      </doc>
    </method>
    <field name="POLICY_PROVIDER_CONFIG" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Configuration key for the {@link PolicyProvider} implementation.]]>
      </doc>
    </field>
    <field name="DEFAULT_POLICY_PROVIDER" type="org.apache.hadoop.security.authorize.PolicyProvider"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A default {@link PolicyProvider} without any defined services.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[{@link PolicyProvider} provides the {@link Service} definitions to the
 security {@link Policy} in effect for Hadoop.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.authorize.PolicyProvider -->
  <!-- start interface org.apache.hadoop.security.authorize.RefreshAuthorizationPolicyProtocol -->
  <interface name="RefreshAuthorizationPolicyProtocol"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.ipc.VersionedProtocol"/>
    <method name="refreshServiceAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Refresh the service-level authorization policy in-effect.
 @throws IOException]]>
      </doc>
    </method>
    <field name="versionID" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Version 1: Initial version]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Protocol which is used to refresh the authorization policy in use currently.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.security.authorize.RefreshAuthorizationPolicyProtocol -->
  <!-- start class org.apache.hadoop.security.authorize.Service -->
  <class name="Service" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Service" type="java.lang.String, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getServiceKey" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the configuration key for the service.
 @return the configuration key for the service]]>
      </doc>
    </method>
    <method name="getPermission" return="java.security.Permission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link Permission} required to access the service.
 @return the {@link Permission} required to access the service]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An abstract definition of <em>service</em> as related to 
 Service Level Authorization for Hadoop.
 
 Each service defines it's configuration key and also the necessary
 {@link Permission} required to access the service.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.authorize.Service -->
  <!-- start class org.apache.hadoop.security.authorize.ServiceAuthorizationManager -->
  <class name="ServiceAuthorizationManager" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServiceAuthorizationManager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="authorize"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="javax.security.auth.Subject"/>
      <param name="protocol" type="java.lang.Class"/>
      <exception name="AuthorizationException" type="org.apache.hadoop.security.authorize.AuthorizationException"/>
      <doc>
      <![CDATA[Authorize the user to access the protocol being used.
 
 @param user user accessing the service 
 @param protocol service being accessed
 @throws AuthorizationException on authorization failure]]>
      </doc>
    </method>
    <field name="SERVICE_AUTHORIZATION_CONFIG" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Configuration key for controlling service-level authorization for Hadoop.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[An authorization manager which handles service-level authorization
 for incoming service requests.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.authorize.ServiceAuthorizationManager -->
</package>
<package name="org.apache.hadoop.util">
  <!-- start class org.apache.hadoop.util.CyclicIteration -->
  <class name="CyclicIteration" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Iterable"/>
    <constructor name="CyclicIteration" type="java.util.NavigableMap, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct an {@link Iterable} object,
 so that an {@link Iterator} can be created  
 for iterating the given {@link NavigableMap}.
 The iteration begins from the starting key exclusively.]]>
      </doc>
    </constructor>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provide an cyclic {@link Iterator} for a {@link NavigableMap}.
 The {@link Iterator} navigates the entries of the map
 according to the map's ordering.
 If the {@link Iterator} hits the last entry of the map,
 it will then continue from the first entry.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.CyclicIteration -->
  <!-- start class org.apache.hadoop.util.Daemon -->
  <class name="Daemon" extends="java.lang.Thread"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Daemon"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a daemon thread.]]>
      </doc>
    </constructor>
    <constructor name="Daemon" type="java.lang.Runnable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a daemon thread.]]>
      </doc>
    </constructor>
    <constructor name="Daemon" type="java.lang.ThreadGroup, java.lang.Runnable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a daemon thread to be part of a specified thread group.]]>
      </doc>
    </constructor>
    <method name="getRunnable" return="java.lang.Runnable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A thread that has called {@link Thread#setDaemon(boolean) } with true.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.Daemon -->
  <!-- start class org.apache.hadoop.util.DataChecksum -->
  <class name="DataChecksum" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.zip.Checksum"/>
    <method name="newDataChecksum" return="org.apache.hadoop.util.DataChecksum"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="int"/>
      <param name="bytesPerChecksum" type="int"/>
    </method>
    <method name="newDataChecksum" return="org.apache.hadoop.util.DataChecksum"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="offset" type="int"/>
      <doc>
      <![CDATA[Creates a DataChecksum from HEADER_LEN bytes from arr[offset].
 @return DataChecksum of the type in the array or null in case of an error.]]>
      </doc>
    </method>
    <method name="newDataChecksum" return="org.apache.hadoop.util.DataChecksum"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This constructucts a DataChecksum by reading HEADER_LEN bytes from
 input stream <i>in</i>]]>
      </doc>
    </method>
    <method name="writeHeader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the checksum header to the output stream <i>out</i>.]]>
      </doc>
    </method>
    <method name="getHeader" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="writeValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutputStream"/>
      <param name="reset" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the current checksum to the stream.
 If <i>reset</i> is true, then resets the checksum.
 @return number of bytes written. Will be equal to getChecksumSize();]]>
      </doc>
    </method>
    <method name="writeValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="reset" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the current checksum to a buffer.
 If <i>reset</i> is true, then resets the checksum.
 @return number of bytes written. Will be equal to getChecksumSize();]]>
      </doc>
    </method>
    <method name="compare" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="byte[]"/>
      <param name="offset" type="int"/>
      <doc>
      <![CDATA[Compares the checksum located at buf[offset] with the current checksum.
 @return true if the checksum matches and false otherwise.]]>
      </doc>
    </method>
    <method name="getChecksumType" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getChecksumSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBytesPerChecksum" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNumBytesInSum" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getChecksumHeaderSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
    </method>
    <field name="HEADER_LEN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CHECKSUM_NULL" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CHECKSUM_CRC32" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SIZE_OF_INTEGER" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This class provides inteface and utilities for processing checksums for
 DFS data transfers.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.DataChecksum -->
  <!-- start class org.apache.hadoop.util.DiskChecker -->
  <class name="DiskChecker" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DiskChecker"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="mkdirsWithExistsCheck" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <doc>
      <![CDATA[The semantics of mkdirsWithExistsCheck method is different from the mkdirs
 method provided in the Sun's java.io.File class in the following way:
 While creating the non-existent parent directories, this method checks for
 the existence of those directories if the mkdir fails at any point (since
 that directory might have just been created by some other process).
 If both mkdir() and the exists() check fails for any seemingly 
 non-existent directory, then we signal an error; Sun's mkdir would signal
 an error (return false) if a directory it is attempting to create already
 exists or the mkdir fails.
 @param dir
 @return true on success, false on failure]]>
      </doc>
    </method>
    <method name="checkDir"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <exception name="DiskChecker.DiskErrorException" type="org.apache.hadoop.util.DiskChecker.DiskErrorException"/>
    </method>
    <doc>
    <![CDATA[Class that provides utility functions for checking disk problem]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.DiskChecker -->
  <!-- start class org.apache.hadoop.util.DiskChecker.DiskErrorException -->
  <class name="DiskChecker.DiskErrorException" extends="java.io.IOException"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DiskChecker.DiskErrorException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.util.DiskChecker.DiskErrorException -->
  <!-- start class org.apache.hadoop.util.DiskChecker.DiskOutOfSpaceException -->
  <class name="DiskChecker.DiskOutOfSpaceException" extends="java.io.IOException"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DiskChecker.DiskOutOfSpaceException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.util.DiskChecker.DiskOutOfSpaceException -->
  <!-- start class org.apache.hadoop.util.GenericOptionsParser -->
  <class name="GenericOptionsParser" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GenericOptionsParser" type="org.apache.commons.cli.Options, java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an options parser with the given options to parse the args.
 @param opts the options
 @param args the command line arguments]]>
      </doc>
    </constructor>
    <constructor name="GenericOptionsParser" type="java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an options parser to parse the args.
 @param args the command line arguments]]>
      </doc>
    </constructor>
    <constructor name="GenericOptionsParser" type="org.apache.hadoop.conf.Configuration, java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a <code>GenericOptionsParser<code> to parse only the generic Hadoop  
 arguments. 
 
 The array of string arguments other than the generic arguments can be 
 obtained by {@link #getRemainingArgs()}.
 
 @param conf the <code>Configuration</code> to modify.
 @param args command-line arguments.]]>
      </doc>
    </constructor>
    <constructor name="GenericOptionsParser" type="org.apache.hadoop.conf.Configuration, org.apache.commons.cli.Options, java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a <code>GenericOptionsParser</code> to parse given options as well 
 as generic Hadoop options. 
 
 The resulting <code>CommandLine</code> object can be obtained by 
 {@link #getCommandLine()}.
 
 @param conf the configuration to modify  
 @param options options built by the caller 
 @param args User-specified arguments]]>
      </doc>
    </constructor>
    <method name="getRemainingArgs" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an array of Strings containing only application-specific arguments.
 
 @return array of <code>String</code>s containing the un-parsed arguments
 or <strong>empty array</strong> if commandLine was not defined.]]>
      </doc>
    </method>
    <method name="getConfiguration" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the modified configuration
 @return the configuration that has the modified parameters.]]>
      </doc>
    </method>
    <method name="getCommandLine" return="org.apache.commons.cli.CommandLine"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the commons-cli <code>CommandLine</code> object 
 to process the parsed arguments. 
 
 Note: If the object is created with 
 {@link #GenericOptionsParser(Configuration, String[])}, then returned 
 object will only contain parsed generic options.
 
 @return <code>CommandLine</code> representing list of arguments 
         parsed against Options descriptor.]]>
      </doc>
    </method>
    <method name="getLibJars" return="java.net.URL[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[If libjars are set in the conf, parse the libjars.
 @param conf
 @return libjar urls
 @throws IOException]]>
      </doc>
    </method>
    <method name="printGenericCommandUsage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.PrintStream"/>
      <doc>
      <![CDATA[Print the usage message for generic command-line options supported.
 
 @param out stream to print the usage message to.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<code>GenericOptionsParser</code> is a utility to parse command line
 arguments generic to the Hadoop framework. 
 
 <code>GenericOptionsParser</code> recognizes several standarad command 
 line arguments, enabling applications to easily specify a namenode, a 
 jobtracker, additional configuration resources etc.
 
 <h4 id="GenericOptions">Generic Options</h4>
 
 <p>The supported generic options are:</p>
 <p><blockquote><pre>
     -conf &lt;configuration file&gt;     specify a configuration file
     -D &lt;property=value&gt;            use value for given property
     -fs &lt;local|namenode:port&gt;      specify a namenode
     -jt &lt;local|jobtracker:port&gt;    specify a job tracker
     -files &lt;comma separated list of files&gt;    specify comma separated
                            files to be copied to the map reduce cluster
     -libjars &lt;comma separated list of jars&gt;   specify comma separated
                            jar files to include in the classpath.
     -archives &lt;comma separated list of archives&gt;    specify comma
             separated archives to be unarchived on the compute machines.

 </pre></blockquote></p>
 
 <p>The general command line syntax is:</p>
 <p><tt><pre>
 bin/hadoop command [genericOptions] [commandOptions]
 </pre></tt></p>
 
 <p>Generic command line arguments <strong>might</strong> modify 
 <code>Configuration </code> objects, given to constructors.</p>
 
 <p>The functionality is implemented using Commons CLI.</p>

 <p>Examples:</p>
 <p><blockquote><pre>
 $ bin/hadoop dfs -fs darwin:8020 -ls /data
 list /data directory in dfs with namenode darwin:8020
 
 $ bin/hadoop dfs -D fs.default.name=darwin:8020 -ls /data
 list /data directory in dfs with namenode darwin:8020
     
 $ bin/hadoop dfs -conf hadoop-site.xml -ls /data
 list /data directory in dfs with conf specified in hadoop-site.xml
     
 $ bin/hadoop job -D mapred.job.tracker=darwin:50020 -submit job.xml
 submit a job to job tracker darwin:50020
     
 $ bin/hadoop job -jt darwin:50020 -submit job.xml
 submit a job to job tracker darwin:50020
     
 $ bin/hadoop job -jt local -submit job.xml
 submit a job to local runner
 
 $ bin/hadoop jar -libjars testlib.jar 
 -archives test.tgz -files file.txt inputjar args
 job submission with libjars, files and archives
 </pre></blockquote></p>

 @see Tool
 @see ToolRunner]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.GenericOptionsParser -->
  <!-- start class org.apache.hadoop.util.GenericsUtil -->
  <class name="GenericsUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GenericsUtil"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns the Class object (of type <code>Class&lt;T&gt;</code>) of the  
 argument of type <code>T</code>. 
 @param <T> The type of the argument
 @param t the object to get it class
 @return <code>Class&lt;T&gt;</code>]]>
      </doc>
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="list" type="java.util.List"/>
      <doc>
      <![CDATA[Converts the given <code>List&lt;T&gt;</code> to a an array of 
 <code>T[]</code>.
 @param c the Class object of the items in the list
 @param list the list to convert]]>
      </doc>
    </method>
    <method name="toArray" return="java.lang.Object[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="list" type="java.util.List"/>
      <doc>
      <![CDATA[Converts the given <code>List&lt;T&gt;</code> to a an array of 
 <code>T[]</code>. 
 @param list the list to convert
 @throws ArrayIndexOutOfBoundsException if the list is empty. 
 Use {@link #toArray(Class, List)} if the list may be empty.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Contains utility methods for dealing with Java Generics.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.GenericsUtil -->
  <!-- start class org.apache.hadoop.util.HeapSort -->
  <class name="HeapSort" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.IndexedSorter"/>
    <constructor name="HeapSort"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="sort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="org.apache.hadoop.util.IndexedSortable"/>
      <param name="p" type="int"/>
      <param name="r" type="int"/>
      <doc>
      <![CDATA[Sort the given range of items using heap sort.
 {@inheritDoc}]]>
      </doc>
    </method>
    <method name="sort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="org.apache.hadoop.util.IndexedSortable"/>
      <param name="p" type="int"/>
      <param name="r" type="int"/>
      <param name="rep" type="org.apache.hadoop.util.Progressable"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An implementation of the core algorithm of HeapSort.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.HeapSort -->
  <!-- start class org.apache.hadoop.util.HostsFileReader -->
  <class name="HostsFileReader" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HostsFileReader" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="refresh"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getHosts" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getExcludedHosts" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setIncludesFile"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="includesFile" type="java.lang.String"/>
    </method>
    <method name="setExcludesFile"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="excludesFile" type="java.lang.String"/>
    </method>
    <method name="updateFileNames"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="includesFile" type="java.lang.String"/>
      <param name="excludesFile" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.util.HostsFileReader -->
  <!-- start interface org.apache.hadoop.util.IndexedSortable -->
  <interface name="IndexedSortable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="j" type="int"/>
      <doc>
      <![CDATA[Compare items at the given addresses consistent with the semantics of
 {@link java.util.Comparator#compare(Object, Object)}.]]>
      </doc>
    </method>
    <method name="swap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="j" type="int"/>
      <doc>
      <![CDATA[Swap items at the given addresses.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface for collections capable of being sorted by {@link IndexedSorter}
 algorithms.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.util.IndexedSortable -->
  <!-- start interface org.apache.hadoop.util.IndexedSorter -->
  <interface name="IndexedSorter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="sort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="org.apache.hadoop.util.IndexedSortable"/>
      <param name="l" type="int"/>
      <param name="r" type="int"/>
      <doc>
      <![CDATA[Sort the items accessed through the given IndexedSortable over the given
 range of logical indices. From the perspective of the sort algorithm,
 each index between l (inclusive) and r (exclusive) is an addressable
 entry.
 @see IndexedSortable#compare
 @see IndexedSortable#swap]]>
      </doc>
    </method>
    <method name="sort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="org.apache.hadoop.util.IndexedSortable"/>
      <param name="l" type="int"/>
      <param name="r" type="int"/>
      <param name="rep" type="org.apache.hadoop.util.Progressable"/>
      <doc>
      <![CDATA[Same as {@link #sort(IndexedSortable,int,int)}, but indicate progress
 periodically.
 @see #sort(IndexedSortable,int,int)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface for sort algorithms accepting {@link IndexedSortable} items.

 A sort algorithm implementing this interface may only
 {@link IndexedSortable#compare} and {@link IndexedSortable#swap} items
 for a range of indices to effect a sort across that range.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.util.IndexedSorter -->
  <!-- start class org.apache.hadoop.util.LineReader -->
  <class name="LineReader" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LineReader" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a line reader that reads from the given stream using the
 default buffer-size (64k).
 @param in The input stream
 @throws IOException]]>
      </doc>
    </constructor>
    <constructor name="LineReader" type="java.io.InputStream, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a line reader that reads from the given stream using the 
 given buffer-size.
 @param in The input stream
 @param bufferSize Size of the read buffer
 @throws IOException]]>
      </doc>
    </constructor>
    <constructor name="LineReader" type="java.io.InputStream, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a line reader that reads from the given stream using the
 <code>io.file.buffer.size</code> specified in the given
 <code>Configuration</code>.
 @param in input stream
 @param conf configuration
 @throws IOException]]>
      </doc>
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close the underlying stream.
 @throws IOException]]>
      </doc>
    </method>
    <method name="readLine" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="org.apache.hadoop.io.Text"/>
      <param name="maxLineLength" type="int"/>
      <param name="maxBytesToConsume" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read one line from the InputStream into the given Text.  A line
 can be terminated by one of the following: '\n' (LF) , '\r' (CR),
 or '\r\n' (CR+LF).  EOF also terminates an otherwise unterminated
 line.

 @param str the object to store the given line (without newline)
 @param maxLineLength the maximum number of bytes to store into str;
  the rest of the line is silently discarded.
 @param maxBytesToConsume the maximum number of bytes to consume
  in this call.  This is only a hint, because if the line cross
  this threshold, we allow it to happen.  It can overshoot
  potentially by as much as one buffer length.

 @return the number of bytes read including the (longest) newline
 found.

 @throws IOException if the underlying stream throws]]>
      </doc>
    </method>
    <method name="readLine" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="org.apache.hadoop.io.Text"/>
      <param name="maxLineLength" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read from the InputStream into the given Text.
 @param str the object to store the given line
 @param maxLineLength the maximum number of bytes to store into str.
 @return the number of bytes read including the newline
 @throws IOException if the underlying stream throws]]>
      </doc>
    </method>
    <method name="readLine" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="org.apache.hadoop.io.Text"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read from the InputStream into the given Text.
 @param str the object to store the given line
 @return the number of bytes read including the newline
 @throws IOException if the underlying stream throws]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class that provides a line reader from an input stream.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.LineReader -->
  <!-- start class org.apache.hadoop.util.LinuxMemoryCalculatorPlugin -->
  <class name="LinuxMemoryCalculatorPlugin" extends="org.apache.hadoop.util.MemoryCalculatorPlugin"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LinuxMemoryCalculatorPlugin"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPhysicalMemorySize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="getVirtualMemorySize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Test the {@link LinuxMemoryCalculatorPlugin}
 
 @param args]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Plugin to calculate virtual and physical memories on Linux systems.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.LinuxMemoryCalculatorPlugin -->
  <!-- start class org.apache.hadoop.util.MemoryCalculatorPlugin -->
  <class name="MemoryCalculatorPlugin" extends="org.apache.hadoop.conf.Configured"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MemoryCalculatorPlugin"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getVirtualMemorySize" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain the total size of the virtual memory present in the system.
 
 @return virtual memory size in bytes.]]>
      </doc>
    </method>
    <method name="getPhysicalMemorySize" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain the total size of the physical memory present in the system.
 
 @return physical memory size bytes.]]>
      </doc>
    </method>
    <method name="getMemoryCalculatorPlugin" return="org.apache.hadoop.util.MemoryCalculatorPlugin"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the MemoryCalculatorPlugin from the class name and configure it. If
 class name is null, this method will try and return a memory calculator
 plugin available for this system.
 
 @param clazz class-name
 @param conf configure the plugin with this.
 @return MemoryCalculatorPlugin]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Plugin to calculate virtual and physical memories on the system.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.MemoryCalculatorPlugin -->
  <!-- start class org.apache.hadoop.util.MergeSort -->
  <class name="MergeSort" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MergeSort" type="java.util.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="mergeSort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="int[]"/>
      <param name="dest" type="int[]"/>
      <param name="low" type="int"/>
      <param name="high" type="int"/>
    </method>
    <doc>
    <![CDATA[An implementation of the core algorithm of MergeSort.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.MergeSort -->
  <!-- start class org.apache.hadoop.util.NativeCodeLoader -->
  <class name="NativeCodeLoader" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NativeCodeLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isNativeCodeLoaded" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if native-hadoop code is loaded for this platform.
 
 @return <code>true</code> if native-hadoop is loaded, 
         else <code>false</code>]]>
      </doc>
    </method>
    <method name="getLoadNativeLibraries" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Return if native hadoop libraries, if present, can be used for this job.
 @param conf configuration
 
 @return <code>true</code> if native hadoop libraries, if present, can be 
         used for this job; <code>false</code> otherwise.]]>
      </doc>
    </method>
    <method name="setLoadNativeLibraries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="loadNativeLibraries" type="boolean"/>
      <doc>
      <![CDATA[Set if native hadoop libraries, if present, can be used for this job.
 
 @param conf configuration
 @param loadNativeLibraries can native hadoop libraries be loaded]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A helper to load the native hadoop code i.e. libhadoop.so.
 This handles the fallback to either the bundled libhadoop-Linux-i386-32.so
 or the default java implementations where appropriate.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.NativeCodeLoader -->
  <!-- start class org.apache.hadoop.util.PlatformName -->
  <class name="PlatformName" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PlatformName"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPlatformName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the complete platform as per the java-vm.
 @return returns the complete platform as per the java-vm.]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
    </method>
    <doc>
    <![CDATA[A helper class for getting build-info of the java-vm.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.PlatformName -->
  <!-- start class org.apache.hadoop.util.PrintJarMainClass -->
  <class name="PrintJarMainClass" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PrintJarMainClass"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param args]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A micro-application that prints the main class name out of a jar file.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.PrintJarMainClass -->
  <!-- start class org.apache.hadoop.util.PriorityQueue -->
  <class name="PriorityQueue" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PriorityQueue"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="lessThan" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Object"/>
      <param name="b" type="java.lang.Object"/>
      <doc>
      <![CDATA[Determines the ordering of objects in this priority queue.  Subclasses
      must define this one method.]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="maxSize" type="int"/>
      <doc>
      <![CDATA[Subclass constructors must call this.]]>
      </doc>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Adds an Object to a PriorityQueue in log(size) time.
 If one tries to add more objects than maxSize from initialize
 a RuntimeException (ArrayIndexOutOfBound) is thrown.]]>
      </doc>
    </method>
    <method name="insert" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="java.lang.Object"/>
      <doc>
      <![CDATA[Adds element to the PriorityQueue in log(size) time if either
 the PriorityQueue is not full, or not lessThan(element, top()).
 @param element
 @return true if element is added, false otherwise.]]>
      </doc>
    </method>
    <method name="top" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the least element of the PriorityQueue in constant time.]]>
      </doc>
    </method>
    <method name="pop" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes and returns the least element of the PriorityQueue in log(size)
      time.]]>
      </doc>
    </method>
    <method name="adjustTop"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Should be called when the Object at top changes values.  Still log(n)
 worst case, but it's at least twice as fast to <pre>
  { pq.top().change(); pq.adjustTop(); }
 </pre> instead of <pre>
  { o = pq.pop(); o.change(); pq.push(o); }
 </pre>]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of elements currently stored in the PriorityQueue.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes all entries from the PriorityQueue.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A PriorityQueue maintains a partial ordering of its elements such that the
  least element can always be found in constant time.  Put()'s and pop()'s
  require log(size) time.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.PriorityQueue -->
  <!-- start class org.apache.hadoop.util.ProcfsBasedProcessTree -->
  <class name="ProcfsBasedProcessTree" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ProcfsBasedProcessTree" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setSigKillInterval"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interval" type="long"/>
    </method>
    <method name="isAvailable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Checks if the ProcfsBasedProcessTree is available on this system.
 
 @return true if ProcfsBasedProcessTree is available. False otherwise.]]>
      </doc>
    </method>
    <method name="getProcessTree" return="org.apache.hadoop.util.ProcfsBasedProcessTree"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the process-tree with latest state. If the root-process is not alive,
 an empty tree will be returned.
 
 @return the process-tree with latest state.]]>
      </doc>
    </method>
    <method name="isAlive" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Is the process-tree alive? Currently we care only about the status of the
 root-process.
 
 @return true if the process-true is alive, false otherwise.]]>
      </doc>
    </method>
    <method name="destroy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Destroy the process-tree. Currently we only make sure the root process is
 gone. It is the responsibility of the root process to make sure that all
 its descendants are cleaned up.]]>
      </doc>
    </method>
    <method name="getCumulativeVmem" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the cumulative virtual memory used by all the processes in the
 process-tree.
 
 @return cumulative virtual memory used by the process-tree in bytes.]]>
      </doc>
    </method>
    <method name="getPidFromPidFile" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pidFileName" type="java.lang.String"/>
      <doc>
      <![CDATA[Get PID from a pid-file.
 
 @param pidFileName
          Name of the pid-file.
 @return the PID string read from the pid-file. Returns null if the
         pidFileName points to a non-existing file or if read fails from the
         file.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string printing PIDs of process present in the
 ProcfsBasedProcessTree. Output format : [pid pid ..]]]>
      </doc>
    </method>
    <field name="DEFAULT_SLEEPTIME_BEFORE_SIGKILL" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A Proc file-system based ProcessTree. Works only on Linux.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.ProcfsBasedProcessTree -->
  <!-- start class org.apache.hadoop.util.ProgramDriver -->
  <class name="ProgramDriver" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ProgramDriver"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="addClass"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="mainClass" type="java.lang.Class"/>
      <param name="description" type="java.lang.String"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[This is the method that adds the classed to the repository
 @param name The name of the string you want the class instance to be called with
 @param mainClass The class that you want to add to the repository
 @param description The description of the class
 @throws NoSuchMethodException 
 @throws SecurityException]]>
      </doc>
    </method>
    <method name="driver"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[This is a driver for the example programs.
 It looks at the first command line argument and tries to find an
 example program with that name.
 If it is found, it calls the main method in that class with the rest 
 of the command line arguments.
 @param args The argument from the user. args[0] is the command to run.
 @throws NoSuchMethodException 
 @throws SecurityException 
 @throws IllegalAccessException 
 @throws IllegalArgumentException 
 @throws Throwable Anything thrown by the example program's main]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A driver that is used to run programs added to it]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.ProgramDriver -->
  <!-- start class org.apache.hadoop.util.Progress -->
  <class name="Progress" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Progress"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new root node.]]>
      </doc>
    </constructor>
    <method name="addPhase" return="org.apache.hadoop.util.Progress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="status" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds a named node to the tree.]]>
      </doc>
    </method>
    <method name="addPhase" return="org.apache.hadoop.util.Progress"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Adds a node to the tree.]]>
      </doc>
    </method>
    <method name="startNextPhase"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Called during execution to move to the next phase at this level in the
 tree.]]>
      </doc>
    </method>
    <method name="phase" return="org.apache.hadoop.util.Progress"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the current sub-node executing.]]>
      </doc>
    </method>
    <method name="complete"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Completes this node, moving the parent node to its next child.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="progress" type="float"/>
      <doc>
      <![CDATA[Called during execution on a leaf node to set its progress.]]>
      </doc>
    </method>
    <method name="get" return="float"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the overall progress of the root.]]>
      </doc>
    </method>
    <method name="setStatus"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="status" type="java.lang.String"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Utility to assist with generation of progress reports.  Applications build
 a hierarchy of {@link Progress} instances, each modelling a phase of
 execution.  The root is constructed with {@link #Progress()}.  Nodes for
 sub-phases are created by calling {@link #addPhase()}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.Progress -->
  <!-- start interface org.apache.hadoop.util.Progressable -->
  <interface name="Progressable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="progress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Report progress to the Hadoop framework.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A facility for reporting progress.
 
 <p>Clients and/or applications can use the provided <code>Progressable</code>
 to explicitly report progress to the Hadoop framework. This is especially
 important for operations which take an insignificant amount of time since,
 in-lieu of the reported progress, the framework has to assume that an error
 has occured and time-out the operation.</p>]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.util.Progressable -->
  <!-- start class org.apache.hadoop.util.QuickSort -->
  <class name="QuickSort" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.IndexedSorter"/>
    <constructor name="QuickSort"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getMaxDepth" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="x" type="int"/>
      <doc>
      <![CDATA[Deepest recursion before giving up and doing a heapsort.
 Returns 2 * ceil(log(n)).]]>
      </doc>
    </method>
    <method name="sort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="org.apache.hadoop.util.IndexedSortable"/>
      <param name="p" type="int"/>
      <param name="r" type="int"/>
      <doc>
      <![CDATA[Sort the given range of items using quick sort.
 {@inheritDoc} If the recursion depth falls below {@link #getMaxDepth},
 then switch to {@link HeapSort}.]]>
      </doc>
    </method>
    <method name="sort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="org.apache.hadoop.util.IndexedSortable"/>
      <param name="p" type="int"/>
      <param name="r" type="int"/>
      <param name="rep" type="org.apache.hadoop.util.Progressable"/>
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An implementation of the core algorithm of QuickSort.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.QuickSort -->
  <!-- start class org.apache.hadoop.util.ReflectionUtils -->
  <class name="ReflectionUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ReflectionUtils"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="theObject" type="java.lang.Object"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Check and set 'configuration' if necessary.
 
 @param theObject object for which to set configuration
 @param conf Configuration]]>
      </doc>
    </method>
    <method name="newInstance" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="theClass" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Create an object for the given class and initialize it from conf
 
 @param theClass class of which an object is created
 @param conf Configuration
 @return a new object]]>
      </doc>
    </method>
    <method name="setContentionTracing"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="boolean"/>
    </method>
    <method name="printThreadInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.PrintWriter"/>
      <param name="title" type="java.lang.String"/>
      <doc>
      <![CDATA[Print all of the thread's information and stack traces.
 
 @param stream the stream to
 @param title a string title for the stack trace]]>
      </doc>
    </method>
    <method name="logThreadInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="log" type="org.apache.commons.logging.Log"/>
      <param name="title" type="java.lang.String"/>
      <param name="minInterval" type="long"/>
      <doc>
      <![CDATA[Log the current thread stacks at INFO level.
 @param log the logger that logs the stack trace
 @param title a descriptive title for the call stacks
 @param minInterval the minimum time from the last]]>
      </doc>
    </method>
    <method name="getClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Return the correctly-typed {@link Class} of the given object.
  
 @param o object whose correctly-typed <code>Class</code> is to be obtained
 @return the correctly typed <code>Class</code> of the given object.]]>
      </doc>
    </method>
    <method name="copy" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="src" type="java.lang.Object"/>
      <param name="dst" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Make a copy of the writable object using serialization to a buffer
 @param dst the object to copy from
 @param src the object to copy into, which is destroyed
 @throws IOException]]>
      </doc>
    </method>
    <method name="cloneWritableInto"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dst" type="org.apache.hadoop.io.Writable"/>
      <param name="src" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[General reflection utils]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.ReflectionUtils -->
  <!-- start class org.apache.hadoop.util.RunJar -->
  <class name="RunJar" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RunJar"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="unJar"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="jarFile" type="java.io.File"/>
      <param name="toDir" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Unpack a jar file into a directory.]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Throwable" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Run a Hadoop job jar.  If the main class is not in the jar's manifest,
 then it must be provided on the command line.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Run a Hadoop job jar.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.RunJar -->
  <!-- start class org.apache.hadoop.util.ServletUtil -->
  <class name="ServletUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServletUtil"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="initHTML" return="java.io.PrintWriter"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="response" type="javax.servlet.ServletResponse"/>
      <param name="title" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Initial HTML header]]>
      </doc>
    </method>
    <method name="getParameter" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="javax.servlet.ServletRequest"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a parameter from a ServletRequest.
 Return null if the parameter contains only white spaces.]]>
      </doc>
    </method>
    <method name="htmlFooter" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[HTML footer to be added in the jsps.
 @return the HTML footer.]]>
      </doc>
    </method>
    <method name="percentageGraph" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perc" type="int"/>
      <param name="width" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Generate the percentage graph and returns HTML representation string
 of the same.
 
 @param perc The percentage value for which graph is to be generated
 @param width The width of the display table
 @return HTML String representation of the percentage graph
 @throws IOException]]>
      </doc>
    </method>
    <method name="percentageGraph" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perc" type="float"/>
      <param name="width" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Generate the percentage graph and returns HTML representation string
 of the same.
 @param perc The percentage value for which graph is to be generated
 @param width The width of the display table
 @return HTML String representation of the percentage graph
 @throws IOException]]>
      </doc>
    </method>
    <field name="HTML_TAIL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.util.ServletUtil -->
  <!-- start class org.apache.hadoop.util.Shell -->
  <class name="Shell" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Shell"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Shell" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param interval the minimum duration to wait before re-executing the 
        command.]]>
      </doc>
    </constructor>
    <method name="getGROUPS_COMMAND" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[a Unix command to get the current user's groups list]]>
      </doc>
    </method>
    <method name="getGET_PERMISSION_COMMAND" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a Unix command to get permission information.]]>
      </doc>
    </method>
    <method name="getUlimitMemoryCommand" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the Unix command for setting the maximum virtual memory available
 to a given child process. This is only relevant when we are forking a
 process from within the {@link org.apache.hadoop.mapred.Mapper} or the 
 {@link org.apache.hadoop.mapred.Reducer} implementations 
 e.g. <a href="{@docRoot}/org/apache/hadoop/mapred/pipes/package-summary.html">Hadoop Pipes</a> 
 or <a href="{@docRoot}/org/apache/hadoop/streaming/package-summary.html">Hadoop Streaming</a>.
 
 It also checks to ensure that we are running on a *nix platform else 
 (e.g. in Cygwin/Windows) it returns <code>null</code>.
 @param conf configuration
 @return a <code>String[]</code> with the ulimit command arguments or 
         <code>null</code> if we are running on a non *nix platform or
         if the limit is unspecified.]]>
      </doc>
    </method>
    <method name="setEnvironment"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="env" type="java.util.Map"/>
      <doc>
      <![CDATA[set the environment for the command 
 @param env Mapping of environment variables]]>
      </doc>
    </method>
    <method name="setWorkingDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <doc>
      <![CDATA[set the working directory 
 @param dir The directory where the command would be executed]]>
      </doc>
    </method>
    <method name="run"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[check to see if a command needs to be executed and execute if needed]]>
      </doc>
    </method>
    <method name="getExecString" return="java.lang.String[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[return an array containing the command name & its parameters]]>
      </doc>
    </method>
    <method name="parseExecResult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="lines" type="java.io.BufferedReader"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse the execution result]]>
      </doc>
    </method>
    <method name="getProcess" return="java.lang.Process"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the current sub-process executing the given command 
 @return process executing the command]]>
      </doc>
    </method>
    <method name="getExitCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the exit code 
 @return the exit code of the process]]>
      </doc>
    </method>
    <method name="execCommand" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cmd" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Static method to execute a shell command. 
 Covers most of the simple cases without requiring the user to implement  
 the <code>Shell</code> interface.
 @param cmd shell command to execute.
 @return the output of the executed command.]]>
      </doc>
    </method>
    <method name="execCommand" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="env" type="java.util.Map"/>
      <param name="cmd" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Static method to execute a shell command. 
 Covers most of the simple cases without requiring the user to implement  
 the <code>Shell</code> interface.
 @param env the map of environment key=value
 @param cmd shell command to execute.
 @return the output of the executed command.]]>
      </doc>
    </method>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="USER_NAME_COMMAND" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[a Unix command to get the current user's name]]>
      </doc>
    </field>
    <field name="SET_PERMISSION_COMMAND" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[a Unix command to set permission]]>
      </doc>
    </field>
    <field name="SET_OWNER_COMMAND" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[a Unix command to set owner]]>
      </doc>
    </field>
    <field name="SET_GROUP_COMMAND" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WINDOWS" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Set to true on Windows platforms]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A base class for running a Unix command.
 
 <code>Shell</code> can be used to run unix commands like <code>du</code> or
 <code>df</code>. It also offers facilities to gate commands by 
 time-intervals.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.Shell -->
  <!-- start class org.apache.hadoop.util.Shell.ExitCodeException -->
  <class name="Shell.ExitCodeException" extends="java.io.IOException"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Shell.ExitCodeException" type="int, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getExitCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This is an IOException with exit code added.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.Shell.ExitCodeException -->
  <!-- start class org.apache.hadoop.util.Shell.ShellCommandExecutor -->
  <class name="Shell.ShellCommandExecutor" extends="org.apache.hadoop.util.Shell"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Shell.ShellCommandExecutor" type="java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Shell.ShellCommandExecutor" type="java.lang.String[], java.io.File"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Shell.ShellCommandExecutor" type="java.lang.String[], java.io.File, java.util.Map"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Execute the shell command.]]>
      </doc>
    </method>
    <method name="getExecString" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="parseExecResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="lines" type="java.io.BufferedReader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getOutput" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the output of the shell command.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the commands of this instance.
 Arguments with spaces in are presented with quotes round; other
 arguments are presented raw

 @return a string representation of the object.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A simple shell command executor.
 
 <code>ShellCommandExecutor</code>should be used in cases where the output 
 of the command needs no explicit parsing and where the command, working 
 directory and the environment remains unchanged. The output of the command 
 is stored as-is and is expected to be small.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.Shell.ShellCommandExecutor -->
  <!-- start class org.apache.hadoop.util.StringUtils -->
  <class name="StringUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="StringUtils"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="stringifyException" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Make a string representation of the exception.
 @param e The exception to stringify
 @return A string with exception name and call stack.]]>
      </doc>
    </method>
    <method name="simpleHostname" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fullHostname" type="java.lang.String"/>
      <doc>
      <![CDATA[Given a full hostname, return the word upto the first dot.
 @param fullHostname the full hostname
 @return the hostname to the first dot]]>
      </doc>
    </method>
    <method name="humanReadableInt" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="number" type="long"/>
      <doc>
      <![CDATA[Given an integer, return a string that is in an approximate, but human 
 readable format. 
 It uses the bases 'k', 'm', and 'g' for 1024, 1024**2, and 1024**3.
 @param number the number to format
 @return a human readable form of the integer]]>
      </doc>
    </method>
    <method name="formatPercent" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="done" type="double"/>
      <param name="digits" type="int"/>
      <doc>
      <![CDATA[Format a percentage for presentation to the user.
 @param done the percentage to format (0.0 to 1.0)
 @param digits the number of digits past the decimal point
 @return a string representation of the percentage]]>
      </doc>
    </method>
    <method name="arrayToString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="strs" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Given an array of strings, return a comma-separated list of its elements.
 @param strs Array of strings
 @return Empty string if strs.length is 0, comma separated list of strings
 otherwise]]>
      </doc>
    </method>
    <method name="byteToHexString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="end" type="int"/>
      <doc>
      <![CDATA[Given an array of bytes it will convert the bytes to a hex string
 representation of the bytes
 @param bytes
 @param start start index, inclusively
 @param end end index, exclusively
 @return hex string representation of the byte array]]>
      </doc>
    </method>
    <method name="byteToHexString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Same as byteToHexString(bytes, 0, bytes.length).]]>
      </doc>
    </method>
    <method name="hexStringToByte" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hex" type="java.lang.String"/>
      <doc>
      <![CDATA[Given a hexstring this will return the byte array corresponding to the
 string
 @param hex the hex String array
 @return a byte array that is a hex string representation of the given
         string. The size of the byte array is therefore hex.length/2]]>
      </doc>
    </method>
    <method name="uriToString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uris" type="java.net.URI[]"/>
      <doc>
      <![CDATA[@param uris]]>
      </doc>
    </method>
    <method name="stringToURI" return="java.net.URI[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param str]]>
      </doc>
    </method>
    <method name="stringToPath" return="org.apache.hadoop.fs.Path[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String[]"/>
      <doc>
      <![CDATA[@param str]]>
      </doc>
    </method>
    <method name="formatTimeDiff" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="finishTime" type="long"/>
      <param name="startTime" type="long"/>
      <doc>
      <![CDATA[Given a finish and start time in long milliseconds, returns a 
 String in the format Xhrs, Ymins, Z sec, for the time difference between two times. 
 If finish time comes before start time then negative valeus of X, Y and Z wil return. 
 
 @param finishTime finish time
 @param startTime start time]]>
      </doc>
    </method>
    <method name="formatTime" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeDiff" type="long"/>
      <doc>
      <![CDATA[Given the time in long milliseconds, returns a 
 String in the format Xhrs, Ymins, Z sec. 
 
 @param timeDiff The time difference to format]]>
      </doc>
    </method>
    <method name="getFormattedTimeWithDiff" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dateFormat" type="java.text.DateFormat"/>
      <param name="finishTime" type="long"/>
      <param name="startTime" type="long"/>
      <doc>
      <![CDATA[Formats time in ms and appends difference (finishTime - startTime) 
 as returned by formatTimeDiff().
 If finish time is 0, empty string is returned, if start time is 0 
 then difference is not appended to return value. 
 @param dateFormat date format to use
 @param finishTime fnish time
 @param startTime start time
 @return formatted value.]]>
      </doc>
    </method>
    <method name="getStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns an arraylist of strings.
 @param str the comma seperated string values
 @return the arraylist of the comma seperated string values]]>
      </doc>
    </method>
    <method name="getStringCollection" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a collection of strings.
 @param str comma seperated string values
 @return an <code>ArrayList</code> of string values]]>
      </doc>
    </method>
    <method name="split" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <doc>
      <![CDATA[Split a string using the default separator
 @param str a string that may have escaped separator
 @return an array of strings]]>
      </doc>
    </method>
    <method name="split" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <param name="escapeChar" type="char"/>
      <param name="separator" type="char"/>
      <doc>
      <![CDATA[Split a string using the given separator
 @param str a string that may have escaped separator
 @param escapeChar a char that be used to escape the separator
 @param separator a separator char
 @return an array of strings]]>
      </doc>
    </method>
    <method name="findNext" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <param name="separator" type="char"/>
      <param name="escapeChar" type="char"/>
      <param name="start" type="int"/>
      <param name="split" type="java.lang.StringBuilder"/>
      <doc>
      <![CDATA[Finds the first occurrence of the separator character ignoring the escaped
 separators starting from the index. Note the substring between the index
 and the position of the separator is passed.
 @param str the source string
 @param separator the character to find
 @param escapeChar character used to escape
 @param start from where to search
 @param split used to pass back the extracted string]]>
      </doc>
    </method>
    <method name="escapeString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <doc>
      <![CDATA[Escape commas in the string using the default escape char
 @param str a string
 @return an escaped string]]>
      </doc>
    </method>
    <method name="escapeString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <param name="escapeChar" type="char"/>
      <param name="charToEscape" type="char"/>
      <doc>
      <![CDATA[Escape <code>charToEscape</code> in the string 
 with the escape char <code>escapeChar</code>
 
 @param str string
 @param escapeChar escape char
 @param charToEscape the char to be escaped
 @return an escaped string]]>
      </doc>
    </method>
    <method name="escapeString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <param name="escapeChar" type="char"/>
      <param name="charsToEscape" type="char[]"/>
      <doc>
      <![CDATA[@param charsToEscape array of characters to be escaped]]>
      </doc>
    </method>
    <method name="unEscapeString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <doc>
      <![CDATA[Unescape commas in the string using the default escape char
 @param str a string
 @return an unescaped string]]>
      </doc>
    </method>
    <method name="unEscapeString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <param name="escapeChar" type="char"/>
      <param name="charToEscape" type="char"/>
      <doc>
      <![CDATA[Unescape <code>charToEscape</code> in the string 
 with the escape char <code>escapeChar</code>
 
 @param str string
 @param escapeChar escape char
 @param charToEscape the escaped char
 @return an unescaped string]]>
      </doc>
    </method>
    <method name="unEscapeString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <param name="escapeChar" type="char"/>
      <param name="charsToEscape" type="char[]"/>
      <doc>
      <![CDATA[@param charsToEscape array of characters to unescape]]>
      </doc>
    </method>
    <method name="getHostname" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return hostname without throwing exception.
 @return hostname]]>
      </doc>
    </method>
    <method name="startupShutdownMessage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <param name="args" type="java.lang.String[]"/>
      <param name="LOG" type="org.apache.commons.logging.Log"/>
      <doc>
      <![CDATA[Print a log message for starting up and shutting down
 @param clazz the class of the server
 @param args arguments
 @param LOG the target log object]]>
      </doc>
    </method>
    <method name="escapeHTML" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Escapes HTML Special characters present in the string.
 @param string
 @return HTML Escaped String representation]]>
      </doc>
    </method>
    <method name="byteDesc" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="len" type="long"/>
      <doc>
      <![CDATA[Return an abbreviated English-language desc of the byte length]]>
      </doc>
    </method>
    <method name="limitDecimalTo2" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="d" type="double"/>
    </method>
    <field name="COMMA" type="char"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="COMMA_STR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ESCAPE_CHAR" type="char"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[General string utils]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.StringUtils -->
  <!-- start class org.apache.hadoop.util.StringUtils.TraditionalBinaryPrefix -->
  <class name="StringUtils.TraditionalBinaryPrefix" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.util.StringUtils.TraditionalBinaryPrefix[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.util.StringUtils.TraditionalBinaryPrefix"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="valueOf" return="org.apache.hadoop.util.StringUtils.TraditionalBinaryPrefix"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="symbol" type="char"/>
      <doc>
      <![CDATA[@return The TraditionalBinaryPrefix object corresponding to the symbol.]]>
      </doc>
    </method>
    <method name="string2long" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <doc>
      <![CDATA[Convert a string to long.
 The input string is first be trimmed
 and then it is parsed with traditional binary prefix.

 For example,
 "-1230k" will be converted to -1230 * 1024 = -1259520;
 "891g" will be converted to 891 * 1024^3 = 956703965184;

 @param s input string
 @return a long value represented by the input string.]]>
      </doc>
    </method>
    <field name="KILO" type="org.apache.hadoop.util.StringUtils.TraditionalBinaryPrefix"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MEGA" type="org.apache.hadoop.util.StringUtils.TraditionalBinaryPrefix"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="GIGA" type="org.apache.hadoop.util.StringUtils.TraditionalBinaryPrefix"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TERA" type="org.apache.hadoop.util.StringUtils.TraditionalBinaryPrefix"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PETA" type="org.apache.hadoop.util.StringUtils.TraditionalBinaryPrefix"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EXA" type="org.apache.hadoop.util.StringUtils.TraditionalBinaryPrefix"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="value" type="long"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="symbol" type="char"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[The traditional binary prefixes, kilo, mega, ..., exa,
 which can be represented by a 64-bit integer.
 TraditionalBinaryPrefix symbol are case insensitive.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.StringUtils.TraditionalBinaryPrefix -->
  <!-- start interface org.apache.hadoop.util.Tool -->
  <interface name="Tool"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Execute the command with the given arguments.
 
 @param args command specific arguments.
 @return exit code.
 @throws Exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A tool interface that supports handling of generic command-line options.
 
 <p><code>Tool</code>, is the standard for any Map-Reduce tool/application. 
 The tool/application should delegate the handling of 
 <a href="{@docRoot}/org/apache/hadoop/util/GenericOptionsParser.html#GenericOptions">
 standard command-line options</a> to {@link ToolRunner#run(Tool, String[])} 
 and only handle its custom arguments.</p>
 
 <p>Here is how a typical <code>Tool</code> is implemented:</p>
 <p><blockquote><pre>
     public class MyApp extends Configured implements Tool {
     
       public int run(String[] args) throws Exception {
         // <code>Configuration</code> processed by <code>ToolRunner</code>
         Configuration conf = getConf();
         
         // Create a JobConf using the processed <code>conf</code>
         JobConf job = new JobConf(conf, MyApp.class);
         
         // Process custom command-line options
         Path in = new Path(args[1]);
         Path out = new Path(args[2]);
         
         // Specify various job-specific parameters     
         job.setJobName("my-app");
         job.setInputPath(in);
         job.setOutputPath(out);
         job.setMapperClass(MyApp.MyMapper.class);
         job.setReducerClass(MyApp.MyReducer.class);

         // Submit the job, then poll for progress until the job is complete
         JobClient.runJob(job);
       }
       
       public static void main(String[] args) throws Exception {
         // Let <code>ToolRunner</code> handle generic command-line options 
         int res = ToolRunner.run(new Configuration(), new Sort(), args);
         
         System.exit(res);
       }
     }
 </pre></blockquote></p>
 
 @see GenericOptionsParser
 @see ToolRunner]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.util.Tool -->
  <!-- start class org.apache.hadoop.util.ToolRunner -->
  <class name="ToolRunner" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ToolRunner"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="tool" type="org.apache.hadoop.util.Tool"/>
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Runs the given <code>Tool</code> by {@link Tool#run(String[])}, after 
 parsing with the given generic arguments. Uses the given 
 <code>Configuration</code>, or builds one if null.
 
 Sets the <code>Tool</code>'s configuration with the possibly modified 
 version of the <code>conf</code>.  
 
 @param conf <code>Configuration</code> for the <code>Tool</code>.
 @param tool <code>Tool</code> to run.
 @param args command-line arguments to the tool.
 @return exit code of the {@link Tool#run(String[])} method.]]>
      </doc>
    </method>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tool" type="org.apache.hadoop.util.Tool"/>
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Runs the <code>Tool</code> with its <code>Configuration</code>.
 
 Equivalent to <code>run(tool.getConf(), tool, args)</code>.
 
 @param tool <code>Tool</code> to run.
 @param args command-line arguments to the tool.
 @return exit code of the {@link Tool#run(String[])} method.]]>
      </doc>
    </method>
    <method name="printGenericCommandUsage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.PrintStream"/>
      <doc>
      <![CDATA[Prints generic command-line argurments and usage information.
 
  @param out stream to write usage information to.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A utility to help run {@link Tool}s.
 
 <p><code>ToolRunner</code> can be used to run classes implementing 
 <code>Tool</code> interface. It works in conjunction with 
 {@link GenericOptionsParser} to parse the 
 <a href="{@docRoot}/org/apache/hadoop/util/GenericOptionsParser.html#GenericOptions">
 generic hadoop command line arguments</a> and modifies the 
 <code>Configuration</code> of the <code>Tool</code>. The 
 application-specific options are passed along without being modified.
 </p>
 
 @see Tool
 @see GenericOptionsParser]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.ToolRunner -->
  <!-- start class org.apache.hadoop.util.UTF8ByteArrayUtils -->
  <class name="UTF8ByteArrayUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UTF8ByteArrayUtils"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="findByte" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="end" type="int"/>
      <param name="b" type="byte"/>
      <doc>
      <![CDATA[Find the first occurrence of the given byte b in a UTF-8 encoded string
 @param utf a byte array containing a UTF-8 encoded string
 @param start starting offset
 @param end ending position
 @param b the byte to find
 @return position that first byte occures otherwise -1]]>
      </doc>
    </method>
    <method name="findBytes" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="end" type="int"/>
      <param name="b" type="byte[]"/>
      <doc>
      <![CDATA[Find the first occurrence of the given bytes b in a UTF-8 encoded string
 @param utf a byte array containing a UTF-8 encoded string
 @param start starting offset
 @param end ending position
 @param b the bytes to find
 @return position that first byte occures otherwise -1]]>
      </doc>
    </method>
    <method name="findNthByte" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="length" type="int"/>
      <param name="b" type="byte"/>
      <param name="n" type="int"/>
      <doc>
      <![CDATA[Find the nth occurrence of the given byte b in a UTF-8 encoded string
 @param utf a byte array containing a UTF-8 encoded string
 @param start starting offset
 @param length the length of byte array
 @param b the byte to find
 @param n the desired occurrence of the given byte
 @return position that nth occurrence of the given byte if exists; otherwise -1]]>
      </doc>
    </method>
    <method name="findNthByte" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf" type="byte[]"/>
      <param name="b" type="byte"/>
      <param name="n" type="int"/>
      <doc>
      <![CDATA[Find the nth occurrence of the given byte b in a UTF-8 encoded string
 @param utf a byte array containing a UTF-8 encoded string
 @param b the byte to find
 @param n the desired occurrence of the given byte
 @return position that nth occurrence of the given byte if exists; otherwise -1]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.util.UTF8ByteArrayUtils -->
  <!-- start class org.apache.hadoop.util.VersionInfo -->
  <class name="VersionInfo" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="VersionInfo"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the Hadoop version.
 @return the Hadoop version string, eg. "0.6.3-dev"]]>
      </doc>
    </method>
    <method name="getRevision" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the subversion revision number for the root directory
 @return the revision number, eg. "451451"]]>
      </doc>
    </method>
    <method name="getDate" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The date that Hadoop was compiled.
 @return the compilation date in unix date format]]>
      </doc>
    </method>
    <method name="getUser" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The user that compiled Hadoop.
 @return the username of the user]]>
      </doc>
    </method>
    <method name="getUrl" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the subversion URL for the root Hadoop directory.]]>
      </doc>
    </method>
    <method name="getBuildVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the buildVersion which includes version, 
 revision, user and date.]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
    </method>
    <doc>
    <![CDATA[This class finds the package info for Hadoop and the HadoopVersionAnnotation
 information.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.VersionInfo -->
  <!-- start class org.apache.hadoop.util.XMLUtils -->
  <class name="XMLUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="XMLUtils"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="transform"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="styleSheet" type="java.io.InputStream"/>
      <param name="xml" type="java.io.InputStream"/>
      <param name="out" type="java.io.Writer"/>
      <exception name="TransformerConfigurationException" type="javax.xml.transform.TransformerConfigurationException"/>
      <exception name="TransformerException" type="javax.xml.transform.TransformerException"/>
      <doc>
      <![CDATA[Transform input xml given a stylesheet.
 
 @param styleSheet the style-sheet
 @param xml input xml data
 @param out output
 @throws TransformerConfigurationException
 @throws TransformerException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[General xml utilities.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.XMLUtils -->
  <doc>
  <![CDATA[Common utilities.]]>
  </doc>
</package>
<package name="org.apache.hadoop.util.bloom">
  <!-- start class org.apache.hadoop.util.bloom.BloomFilter -->
  <class name="BloomFilter" extends="org.apache.hadoop.util.bloom.Filter"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BloomFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor - use with readFields]]>
      </doc>
    </constructor>
    <constructor name="BloomFilter" type="int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor
 @param vectorSize The vector size of <i>this</i> filter.
 @param nbHash The number of hash function to consider.
 @param hashType type of the hashing function (see
 {@link org.apache.hadoop.util.hash.Hash}).]]>
      </doc>
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="and"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="membershipTest" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="not"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="or"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="xor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getVectorSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return size of the the bloomfilter]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Implements a <i>Bloom filter</i>, as defined by Bloom in 1970.
 <p>
 The Bloom filter is a data structure that was introduced in 1970 and that has been adopted by 
 the networking research community in the past decade thanks to the bandwidth efficiencies that it
 offers for the transmission of set membership information between networked hosts.  A sender encodes 
 the information into a bit vector, the Bloom filter, that is more compact than a conventional 
 representation. Computation and space costs for construction are linear in the number of elements.  
 The receiver uses the filter to test whether various elements are members of the set. Though the 
 filter will occasionally return a false positive, it will never return a false negative. When creating 
 the filter, the sender can choose its desired point in a trade-off between the false positive rate and the size. 
 
 <p>
 Originally created by
 <a href="http://www.one-lab.org">European Commission One-Lab Project 034819</a>.
 
 @see Filter The general behavior of a filter
 
 @see <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/Time Trade-Offs in Hash Coding with Allowable Errors</a>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.bloom.BloomFilter -->
  <!-- start class org.apache.hadoop.util.bloom.CountingBloomFilter -->
  <class name="CountingBloomFilter" extends="org.apache.hadoop.util.bloom.Filter"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="CountingBloomFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor - use with readFields]]>
      </doc>
    </constructor>
    <constructor name="CountingBloomFilter" type="int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor
 @param vectorSize The vector size of <i>this</i> filter.
 @param nbHash The number of hash function to consider.
 @param hashType type of the hashing function (see
 {@link org.apache.hadoop.util.hash.Hash}).]]>
      </doc>
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="delete"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
      <doc>
      <![CDATA[Removes a specified key from <i>this</i> counting Bloom filter.
 <p>
 <b>Invariant</b>: nothing happens if the specified key does not belong to <i>this</i> counter Bloom filter.
 @param key The key to remove.]]>
      </doc>
    </method>
    <method name="and"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="membershipTest" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="approximateCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
      <doc>
      <![CDATA[This method calculates an approximate count of the key, i.e. how many
 times the key was added to the filter. This allows the filter to be
 used as an approximate <code>key -&gt; count</code> map.
 <p>NOTE: due to the bucket size of this filter, inserting the same
 key more than 15 times will cause an overflow at all filter positions
 associated with this key, and it will significantly increase the error
 rate for this and other keys. For this reason the filter can only be
 used to store small count values <code>0 &lt;= N &lt;&lt; 15</code>.
 @param key key to be tested
 @return 0 if the key is not present. Otherwise, a positive value v will
 be returned such that <code>v == count</code> with probability equal to the
 error rate of this filter, and <code>v &gt; count</code> otherwise.
 Additionally, if the filter experienced an underflow as a result of
 {@link #delete(Key)} operation, the return value may be lower than the
 <code>count</code> with the probability of the false negative rate of such
 filter.]]>
      </doc>
    </method>
    <method name="not"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="or"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="xor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Implements a <i>counting Bloom filter</i>, as defined by Fan et al. in a ToN
 2000 paper.
 <p>
 A counting Bloom filter is an improvement to standard a Bloom filter as it
 allows dynamic additions and deletions of set membership information.  This 
 is achieved through the use of a counting vector instead of a bit vector.
 <p>
 Originally created by
 <a href="http://www.one-lab.org">European Commission One-Lab Project 034819</a>.

 @see Filter The general behavior of a filter
 
 @see <a href="http://portal.acm.org/citation.cfm?id=343571.343572">Summary cache: a scalable wide-area web cache sharing protocol</a>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.bloom.CountingBloomFilter -->
  <!-- start class org.apache.hadoop.util.bloom.DynamicBloomFilter -->
  <class name="DynamicBloomFilter" extends="org.apache.hadoop.util.bloom.Filter"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DynamicBloomFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Zero-args constructor for the serialization.]]>
      </doc>
    </constructor>
    <constructor name="DynamicBloomFilter" type="int, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor.
 <p>
 Builds an empty Dynamic Bloom filter.
 @param vectorSize The number of bits in the vector.
 @param nbHash The number of hash function to consider.
 @param hashType type of the hashing function (see
 {@link org.apache.hadoop.util.hash.Hash}).
 @param nr The threshold for the maximum number of keys to record in a
 dynamic Bloom filter row.]]>
      </doc>
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="and"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="membershipTest" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="not"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="or"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="xor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Implements a <i>dynamic Bloom filter</i>, as defined in the INFOCOM 2006 paper.
 <p>
 A dynamic Bloom filter (DBF) makes use of a <code>s * m</code> bit matrix but
 each of the <code>s</code> rows is a standard Bloom filter. The creation 
 process of a DBF is iterative. At the start, the DBF is a <code>1 * m</code>
 bit matrix, i.e., it is composed of a single standard Bloom filter.
 It assumes that <code>n<sub>r</sub></code> elements are recorded in the 
 initial bit vector, where <code>n<sub>r</sub> <= n</code> (<code>n</code> is
 the cardinality of the set <code>A</code> to record in the filter).  
 <p>
 As the size of <code>A</code> grows during the execution of the application,
 several keys must be inserted in the DBF.  When inserting a key into the DBF,
 one must first get an active Bloom filter in the matrix.  A Bloom filter is
 active when the number of recorded keys, <code>n<sub>r</sub></code>, is 
 strictly less than the current cardinality of <code>A</code>, <code>n</code>.
 If an active Bloom filter is found, the key is inserted and 
 <code>n<sub>r</sub></code> is incremented by one. On the other hand, if there
 is no active Bloom filter, a new one is created (i.e., a new row is added to
 the matrix) according to the current size of <code>A</code> and the element
 is added in this new Bloom filter and the <code>n<sub>r</sub></code> value of
 this new Bloom filter is set to one.  A given key is said to belong to the
 DBF if the <code>k</code> positions are set to one in one of the matrix rows.
 <p>
 Originally created by
 <a href="http://www.one-lab.org">European Commission One-Lab Project 034819</a>.

 @see Filter The general behavior of a filter
 @see BloomFilter A Bloom filter
 
 @see <a href="http://www.cse.fau.edu/~jie/research/publications/Publication_files/infocom2006.pdf">Theory and Network Applications of Dynamic Bloom Filters</a>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.bloom.DynamicBloomFilter -->
  <!-- start class org.apache.hadoop.util.bloom.Filter -->
  <class name="Filter" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="Filter"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Filter" type="int, int, int"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor.
 @param vectorSize The vector size of <i>this</i> filter.
 @param nbHash The number of hash functions to consider.
 @param hashType type of the hashing function (see {@link Hash}).]]>
      </doc>
    </constructor>
    <method name="add"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
      <doc>
      <![CDATA[Adds a key to <i>this</i> filter.
 @param key The key to add.]]>
      </doc>
    </method>
    <method name="membershipTest" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
      <doc>
      <![CDATA[Determines wether a specified key belongs to <i>this</i> filter.
 @param key The key to test.
 @return boolean True if the specified key belongs to <i>this</i> filter.
 		     False otherwise.]]>
      </doc>
    </method>
    <method name="and"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
      <doc>
      <![CDATA[Peforms a logical AND between <i>this</i> filter and a specified filter.
 <p>
 <b>Invariant</b>: The result is assigned to <i>this</i> filter.
 @param filter The filter to AND with.]]>
      </doc>
    </method>
    <method name="or"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
      <doc>
      <![CDATA[Peforms a logical OR between <i>this</i> filter and a specified filter.
 <p>
 <b>Invariant</b>: The result is assigned to <i>this</i> filter.
 @param filter The filter to OR with.]]>
      </doc>
    </method>
    <method name="xor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
      <doc>
      <![CDATA[Peforms a logical XOR between <i>this</i> filter and a specified filter.
 <p>
 <b>Invariant</b>: The result is assigned to <i>this</i> filter.
 @param filter The filter to XOR with.]]>
      </doc>
    </method>
    <method name="not"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Performs a logical NOT on <i>this</i> filter.
 <p>
 The result is assigned to <i>this</i> filter.]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.util.List"/>
      <doc>
      <![CDATA[Adds a list of keys to <i>this</i> filter.
 @param keys The list of keys.]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.util.Collection"/>
      <doc>
      <![CDATA[Adds a collection of keys to <i>this</i> filter.
 @param keys The collection of keys.]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="org.apache.hadoop.util.bloom.Key[]"/>
      <doc>
      <![CDATA[Adds an array of keys to <i>this</i> filter.
 @param keys The array of keys.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="vectorSize" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The vector size of <i>this</i> filter.]]>
      </doc>
    </field>
    <field name="hash" type="org.apache.hadoop.util.bloom.HashFunction"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The hash function used to map a key to several positions in the vector.]]>
      </doc>
    </field>
    <field name="nbHash" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of hash function to consider.]]>
      </doc>
    </field>
    <field name="hashType" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Type of hashing function to use.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Defines the general behavior of a filter.
 <p>
 A filter is a data structure which aims at offering a lossy summary of a set <code>A</code>.  The
 key idea is to map entries of <code>A</code> (also called <i>keys</i>) into several positions 
 in a vector through the use of several hash functions.
 <p>
 Typically, a filter will be implemented as a Bloom filter (or a Bloom filter extension).
 <p>
 It must be extended in order to define the real behavior.
 
 @see Key The general behavior of a key
 @see HashFunction A hash function]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.bloom.Filter -->
  <!-- start class org.apache.hadoop.util.bloom.HashFunction -->
  <class name="HashFunction" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="HashFunction" type="int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor.
 <p>
 Builds a hash function that must obey to a given maximum number of returned values and a highest value.
 @param maxValue The maximum highest returned value.
 @param nbHash The number of resulting hashed values.
 @param hashType type of the hashing function (see {@link Hash}).]]>
      </doc>
    </constructor>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears <i>this</i> hash function. A NOOP]]>
      </doc>
    </method>
    <method name="hash" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k" type="org.apache.hadoop.util.bloom.Key"/>
      <doc>
      <![CDATA[Hashes a specified key into several integers.
 @param k The specified key.
 @return The array of hashed values.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implements a hash object that returns a certain number of hashed values.
 
 @see Key The general behavior of a key being stored in a filter
 @see Filter The general behavior of a filter]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.bloom.HashFunction -->
  <!-- start class org.apache.hadoop.util.bloom.Key -->
  <class name="Key" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="Key"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[default constructor - use with readFields]]>
      </doc>
    </constructor>
    <constructor name="Key" type="byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor.
 <p>
 Builds a key with a default weight.
 @param value The byte value of <i>this</i> key.]]>
      </doc>
    </constructor>
    <constructor name="Key" type="byte[], double"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor.
 <p>
 Builds a key with a specified weight.
 @param value The value of <i>this</i> key.
 @param weight The weight associated to <i>this</i> key.]]>
      </doc>
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte[]"/>
      <param name="weight" type="double"/>
      <doc>
      <![CDATA[@param value
 @param weight]]>
      </doc>
    </method>
    <method name="getBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return byte[] The value of <i>this</i> key.]]>
      </doc>
    </method>
    <method name="getWeight" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Returns the weight associated to <i>this</i> key.]]>
      </doc>
    </method>
    <method name="incrementWeight"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="weight" type="double"/>
      <doc>
      <![CDATA[Increments the weight of <i>this</i> key with a specified value. 
 @param weight The increment.]]>
      </doc>
    </method>
    <method name="incrementWeight"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increments the weight of <i>this</i> key by one.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <doc>
    <![CDATA[The general behavior of a key that must be stored in a filter.
 
 @see Filter The general behavior of a filter]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.bloom.Key -->
  <!-- start interface org.apache.hadoop.util.bloom.RemoveScheme -->
  <interface name="RemoveScheme"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="RANDOM" type="short"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Random selection.
 <p>
 The idea is to randomly select a bit to reset.]]>
      </doc>
    </field>
    <field name="MINIMUM_FN" type="short"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[MinimumFN Selection.
 <p>
 The idea is to select the bit to reset that will generate the minimum
 number of false negative.]]>
      </doc>
    </field>
    <field name="MAXIMUM_FP" type="short"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[MaximumFP Selection.
 <p>
 The idea is to select the bit to reset that will remove the maximum number
 of false positive.]]>
      </doc>
    </field>
    <field name="RATIO" type="short"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Ratio Selection.
 <p>
 The idea is to select the bit to reset that will, at the same time, remove
 the maximum number of false positve while minimizing the amount of false
 negative generated.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Defines the different remove scheme for retouched Bloom filters.
 <p>
 Originally created by
 <a href="http://www.one-lab.org">European Commission One-Lab Project 034819</a>.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.util.bloom.RemoveScheme -->
  <!-- start class org.apache.hadoop.util.bloom.RetouchedBloomFilter -->
  <class name="RetouchedBloomFilter" extends="org.apache.hadoop.util.bloom.BloomFilter"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.bloom.RemoveScheme"/>
    <constructor name="RetouchedBloomFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor - use with readFields]]>
      </doc>
    </constructor>
    <constructor name="RetouchedBloomFilter" type="int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor
 @param vectorSize The vector size of <i>this</i> filter.
 @param nbHash The number of hash function to consider.
 @param hashType type of the hashing function (see
 {@link org.apache.hadoop.util.hash.Hash}).]]>
      </doc>
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="addFalsePositive"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
      <doc>
      <![CDATA[Adds a false positive information to <i>this</i> retouched Bloom filter.
 <p>
 <b>Invariant</b>: if the false positive is <code>null</code>, nothing happens.
 @param key The false positive key to add.]]>
      </doc>
    </method>
    <method name="addFalsePositive"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="coll" type="java.util.Collection"/>
      <doc>
      <![CDATA[Adds a collection of false positive information to <i>this</i> retouched Bloom filter.
 @param coll The collection of false positive.]]>
      </doc>
    </method>
    <method name="addFalsePositive"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.util.List"/>
      <doc>
      <![CDATA[Adds a list of false positive information to <i>this</i> retouched Bloom filter.
 @param keys The list of false positive.]]>
      </doc>
    </method>
    <method name="addFalsePositive"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="org.apache.hadoop.util.bloom.Key[]"/>
      <doc>
      <![CDATA[Adds an array of false positive information to <i>this</i> retouched Bloom filter.
 @param keys The array of false positive.]]>
      </doc>
    </method>
    <method name="selectiveClearing"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k" type="org.apache.hadoop.util.bloom.Key"/>
      <param name="scheme" type="short"/>
      <doc>
      <![CDATA[Performs the selective clearing for a given key.
 @param k The false positive key to remove from <i>this</i> retouched Bloom filter.
 @param scheme The selective clearing scheme to apply.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Implements a <i>retouched Bloom filter</i>, as defined in the CoNEXT 2006 paper.
 <p>
 It allows the removal of selected false positives at the cost of introducing
 random false negatives, and with the benefit of eliminating some random false
 positives at the same time.
 
 <p>
 Originally created by
 <a href="http://www.one-lab.org">European Commission One-Lab Project 034819</a>.
 
 @see Filter The general behavior of a filter
 @see BloomFilter A Bloom filter
 @see RemoveScheme The different selective clearing algorithms
 
 @see <a href="http://www-rp.lip6.fr/site_npa/site_rp/_publications/740-rbf_cameraready.pdf">Retouched Bloom Filters: Allowing Networked Applications to Trade Off Selected False Positives Against False Negatives</a>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.bloom.RetouchedBloomFilter -->
</package>
<package name="org.apache.hadoop.util.hash">
  <!-- start class org.apache.hadoop.util.hash.Hash -->
  <class name="Hash" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Hash"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="parseHashType" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[This utility method converts String representation of hash function name
 to a symbolic constant. Currently two function types are supported,
 "jenkins" and "murmur".
 @param name hash function name
 @return one of the predefined constants]]>
      </doc>
    </method>
    <method name="getHashType" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[This utility method converts the name of the configured
 hash type to a symbolic constant.
 @param conf configuration
 @return one of the predefined constants]]>
      </doc>
    </method>
    <method name="getInstance" return="org.apache.hadoop.util.hash.Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="int"/>
      <doc>
      <![CDATA[Get a singleton instance of hash function of a given type.
 @param type predefined hash type
 @return hash function instance, or null if type is invalid]]>
      </doc>
    </method>
    <method name="getInstance" return="org.apache.hadoop.util.hash.Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get a singleton instance of hash function of a type
 defined in the configuration.
 @param conf current configuration
 @return defined hash type, or null if type is invalid]]>
      </doc>
    </method>
    <method name="hash" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Calculate a hash using all bytes from the input argument, and
 a seed of -1.
 @param bytes input bytes
 @return hash value]]>
      </doc>
    </method>
    <method name="hash" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="initval" type="int"/>
      <doc>
      <![CDATA[Calculate a hash using all bytes from the input argument,
 and a provided seed value.
 @param bytes input bytes
 @param initval seed value
 @return hash value]]>
      </doc>
    </method>
    <method name="hash" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="length" type="int"/>
      <param name="initval" type="int"/>
      <doc>
      <![CDATA[Calculate a hash using bytes from 0 to <code>length</code>, and
 the provided seed value
 @param bytes input bytes
 @param length length of the valid bytes to consider
 @param initval seed value
 @return hash value]]>
      </doc>
    </method>
    <field name="INVALID_HASH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constant to denote invalid hash type.]]>
      </doc>
    </field>
    <field name="JENKINS_HASH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constant to denote {@link JenkinsHash}.]]>
      </doc>
    </field>
    <field name="MURMUR_HASH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constant to denote {@link MurmurHash}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This class represents a common API for hashing functions.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.hash.Hash -->
  <!-- start class org.apache.hadoop.util.hash.JenkinsHash -->
  <class name="JenkinsHash" extends="org.apache.hadoop.util.hash.Hash"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JenkinsHash"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getInstance" return="org.apache.hadoop.util.hash.Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hash" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="byte[]"/>
      <param name="nbytes" type="int"/>
      <param name="initval" type="int"/>
      <doc>
      <![CDATA[taken from  hashlittle() -- hash a variable-length key into a 32-bit value
 
 @param key the key (the unaligned variable-length array of bytes)
 @param nbytes number of bytes to include in hash
 @param initval can be any integer value
 @return a 32-bit value.  Every bit of the key affects every bit of the
 return value.  Two keys differing by one or two bits will have totally
 different hash values.
 
 <p>The best hash table sizes are powers of 2.  There is no need to do mod
 a prime (mod is sooo slow!).  If you need less than 32 bits, use a bitmask.
 For example, if you need only 10 bits, do
 <code>h = (h & hashmask(10));</code>
 In which case, the hash table should have hashsize(10) elements.
 
 <p>If you are hashing n strings byte[][] k, do it like this:
 for (int i = 0, h = 0; i < n; ++i) h = hash( k[i], h);
 
 <p>By Bob Jenkins, 2006.  bob_jenkins@burtleburtle.net.  You may use this
 code any way you wish, private, educational, or commercial.  It's free.
 
 <p>Use for hash table lookup, or anything where one collision in 2^^32 is
 acceptable.  Do NOT use for cryptographic purposes.]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Compute the hash of the specified file
 @param args name of file to compute hash of.
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Produces 32-bit hash for hash table lookup.
 
 <pre>lookup3.c, by Bob Jenkins, May 2006, Public Domain.

 You can use this free for any purpose.  It's in the public domain.
 It has no warranty.
 </pre>
 
 @see <a href="http://burtleburtle.net/bob/c/lookup3.c">lookup3.c</a>
 @see <a href="http://www.ddj.com/184410284">Hash Functions (and how this
 function compares to others such as CRC, MD?, etc</a>
 @see <a href="http://burtleburtle.net/bob/hash/doobs.html">Has update on the
 Dr. Dobbs Article</a>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.hash.JenkinsHash -->
  <!-- start class org.apache.hadoop.util.hash.MurmurHash -->
  <class name="MurmurHash" extends="org.apache.hadoop.util.hash.Hash"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MurmurHash"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getInstance" return="org.apache.hadoop.util.hash.Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hash" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="byte[]"/>
      <param name="length" type="int"/>
      <param name="seed" type="int"/>
    </method>
    <doc>
    <![CDATA[This is a very fast, non-cryptographic hash suitable for general hash-based
 lookup.  See http://murmurhash.googlepages.com/ for more details.
 
 <p>The C version of MurmurHash 2.0 found at that site was ported
 to Java by Andrzej Bialecki (ab at getopt org).</p>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.hash.MurmurHash -->
</package>

</api>
