<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Tue Mar 14 18:48:02 UTC 2023 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="Apache Hadoop YARN Common 3.3.5"
  jdversion="1.0.9">

<!--  Command line arguments =  -doclet org.apache.hadoop.classification.tools.IncludePublicAnnotationsJDiffDoclet -docletpath /build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/target/hadoop-annotations.jar:/build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/target/jdiff.jar -verbose -classpath /build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/target/classes:/build/source/hadoop-common-project/hadoop-common/target/hadoop-common-3.3.5.jar:/maven/org/apache/hadoop/thirdparty/hadoop-shaded-protobuf_3_7/1.1.1/hadoop-shaded-protobuf_3_7-1.1.1.jar:/maven/com/google/guava/guava/27.0-jre/guava-27.0-jre.jar:/maven/com/google/guava/failureaccess/1.0/failureaccess-1.0.jar:/maven/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/maven/org/checkerframework/checker-qual/2.5.2/checker-qual-2.5.2.jar:/maven/com/google/j2objc/j2objc-annotations/1.1/j2objc-annotations-1.1.jar:/maven/org/codehaus/mojo/animal-sniffer-annotations/1.17/animal-sniffer-annotations-1.17.jar:/maven/org/apache/commons/commons-math3/3.1.1/commons-math3-3.1.1.jar:/maven/org/apache/httpcomponents/httpclient/4.5.13/httpclient-4.5.13.jar:/maven/org/apache/httpcomponents/httpcore/4.4.13/httpcore-4.4.13.jar:/maven/commons-net/commons-net/3.9.0/commons-net-3.9.0.jar:/maven/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/maven/jakarta/activation/jakarta.activation-api/1.2.1/jakarta.activation-api-1.2.1.jar:/maven/org/eclipse/jetty/jetty-server/9.4.48.v20220622/jetty-server-9.4.48.v20220622.jar:/maven/org/eclipse/jetty/jetty-http/9.4.48.v20220622/jetty-http-9.4.48.v20220622.jar:/maven/org/eclipse/jetty/jetty-io/9.4.48.v20220622/jetty-io-9.4.48.v20220622.jar:/maven/org/eclipse/jetty/jetty-servlet/9.4.48.v20220622/jetty-servlet-9.4.48.v20220622.jar:/maven/org/eclipse/jetty/jetty-security/9.4.48.v20220622/jetty-security-9.4.48.v20220622.jar:/maven/org/eclipse/jetty/jetty-util-ajax/9.4.48.v20220622/jetty-util-ajax-9.4.48.v20220622.jar:/maven/org/eclipse/jetty/jetty-webapp/9.4.48.v20220622/jetty-webapp-9.4.48.v20220622.jar:/maven/org/eclipse/jetty/jetty-xml/9.4.48.v20220622/jetty-xml-9.4.48.v20220622.jar:/maven/javax/servlet/jsp/jsp-api/2.1/jsp-api-2.1.jar:/maven/com/sun/jersey/jersey-servlet/1.19.4/jersey-servlet-1.19.4.jar:/maven/commons-logging/commons-logging/1.1.3/commons-logging-1.1.3.jar:/maven/commons-beanutils/commons-beanutils/1.9.4/commons-beanutils-1.9.4.jar:/maven/org/apache/commons/commons-configuration2/2.8.0/commons-configuration2-2.8.0.jar:/maven/org/apache/commons/commons-lang3/3.12.0/commons-lang3-3.12.0.jar:/maven/org/apache/commons/commons-text/1.10.0/commons-text-1.10.0.jar:/maven/org/apache/avro/avro/1.7.7/avro-1.7.7.jar:/maven/org/codehaus/jackson/jackson-core-asl/1.9.13/jackson-core-asl-1.9.13.jar:/maven/org/codehaus/jackson/jackson-mapper-asl/1.9.13/jackson-mapper-asl-1.9.13.jar:/maven/com/thoughtworks/paranamer/paranamer/2.3/paranamer-2.3.jar:/maven/com/google/re2j/re2j/1.1/re2j-1.1.jar:/maven/com/google/code/gson/gson/2.9.0/gson-2.9.0.jar:/maven/com/jcraft/jsch/0.1.55/jsch-0.1.55.jar:/maven/org/apache/curator/curator-client/4.2.0/curator-client-4.2.0.jar:/maven/org/apache/curator/curator-recipes/4.2.0/curator-recipes-4.2.0.jar:/maven/com/google/code/findbugs/jsr305/3.0.2/jsr305-3.0.2.jar:/maven/org/apache/zookeeper/zookeeper/3.5.6/zookeeper-3.5.6.jar:/maven/org/apache/zookeeper/zookeeper-jute/3.5.6/zookeeper-jute-3.5.6.jar:/maven/org/apache/yetus/audience-annotations/0.5.0/audience-annotations-0.5.0.jar:/maven/org/apache/kerby/kerb-core/1.0.1/kerb-core-1.0.1.jar:/maven/org/apache/kerby/kerby-pkix/1.0.1/kerby-pkix-1.0.1.jar:/maven/org/apache/kerby/kerby-asn1/1.0.1/kerby-asn1-1.0.1.jar:/maven/org/apache/kerby/kerby-util/1.0.1/kerby-util-1.0.1.jar:/maven/org/codehaus/woodstox/stax2-api/4.2.1/stax2-api-4.2.1.jar:/maven/com/fasterxml/woodstox/woodstox-core/5.4.0/woodstox-core-5.4.0.jar:/maven/dnsjava/dnsjava/2.1.7/dnsjava-2.1.7.jar:/maven/org/xerial/snappy/snappy-java/1.1.8.2/snappy-java-1.1.8.2.jar:/build/source/hadoop-hdfs-project/hadoop-hdfs-client/target/hadoop-hdfs-client-3.3.5.jar:/maven/com/squareup/okhttp3/okhttp/4.9.3/okhttp-4.9.3.jar:/maven/com/squareup/okio/okio/2.8.0/okio-2.8.0.jar:/maven/org/jetbrains/kotlin/kotlin-stdlib/1.4.10/kotlin-stdlib-1.4.10.jar:/maven/org/jetbrains/kotlin/kotlin-stdlib-common/1.4.10/kotlin-stdlib-common-1.4.10.jar:/maven/com/fasterxml/jackson/core/jackson-annotations/2.12.7/jackson-annotations-2.12.7.jar:/build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-api/target/hadoop-yarn-api-3.3.5.jar:/build/source/hadoop-common-project/hadoop-auth/target/hadoop-auth-3.3.5.jar:/maven/com/nimbusds/nimbus-jose-jwt/9.8.1/nimbus-jose-jwt-9.8.1.jar:/maven/com/github/stephenc/jcip/jcip-annotations/1.0-1/jcip-annotations-1.0-1.jar:/maven/net/minidev/json-smart/2.4.7/json-smart-2.4.7.jar:/maven/net/minidev/accessors-smart/2.4.7/accessors-smart-2.4.7.jar:/maven/org/ow2/asm/asm/5.0.4/asm-5.0.4.jar:/maven/org/apache/curator/curator-framework/4.2.0/curator-framework-4.2.0.jar:/maven/org/apache/kerby/kerb-simplekdc/1.0.1/kerb-simplekdc-1.0.1.jar:/maven/org/apache/kerby/kerb-client/1.0.1/kerb-client-1.0.1.jar:/maven/org/apache/kerby/kerby-config/1.0.1/kerby-config-1.0.1.jar:/maven/org/apache/kerby/kerb-common/1.0.1/kerb-common-1.0.1.jar:/maven/org/apache/kerby/kerb-crypto/1.0.1/kerb-crypto-1.0.1.jar:/maven/org/apache/kerby/kerb-util/1.0.1/kerb-util-1.0.1.jar:/maven/org/apache/kerby/token-provider/1.0.1/token-provider-1.0.1.jar:/maven/org/apache/kerby/kerb-admin/1.0.1/kerb-admin-1.0.1.jar:/maven/org/apache/kerby/kerb-server/1.0.1/kerb-server-1.0.1.jar:/maven/org/apache/kerby/kerb-identity/1.0.1/kerb-identity-1.0.1.jar:/maven/org/apache/kerby/kerby-xdr/1.0.1/kerby-xdr-1.0.1.jar:/maven/javax/xml/bind/jaxb-api/2.2.11/jaxb-api-2.2.11.jar:/maven/org/apache/commons/commons-compress/1.21/commons-compress-1.21.jar:/maven/javax/servlet/javax.servlet-api/3.1.0/javax.servlet-api-3.1.0.jar:/maven/commons-codec/commons-codec/1.15/commons-codec-1.15.jar:/maven/org/eclipse/jetty/jetty-util/9.4.48.v20220622/jetty-util-9.4.48.v20220622.jar:/maven/com/sun/jersey/jersey-core/1.19.4/jersey-core-1.19.4.jar:/maven/javax/ws/rs/jsr311-api/1.1.1/jsr311-api-1.1.1.jar:/maven/com/sun/jersey/jersey-client/1.19.4/jersey-client-1.19.4.jar:/maven/org/apache/hadoop/thirdparty/hadoop-shaded-guava/1.1.1/hadoop-shaded-guava-1.1.1.jar:/maven/commons-cli/commons-cli/1.2/commons-cli-1.2.jar:/maven/org/slf4j/slf4j-api/1.7.36/slf4j-api-1.7.36.jar:/build/source/hadoop-common-project/hadoop-annotations/target/hadoop-annotations-3.3.5.jar:/usr/lib/jvm/java-8-openjdk-arm64/lib/tools.jar:/maven/com/google/inject/extensions/guice-servlet/4.0/guice-servlet-4.0.jar:/maven/com/google/protobuf/protobuf-java/2.5.0/protobuf-java-2.5.0.jar:/maven/commons-io/commons-io/2.8.0/commons-io-2.8.0.jar:/maven/com/google/inject/guice/4.0/guice-4.0.jar:/maven/javax/inject/javax.inject/1/javax.inject-1.jar:/maven/aopalliance/aopalliance/1.0/aopalliance-1.0.jar:/maven/com/sun/jersey/jersey-server/1.19.4/jersey-server-1.19.4.jar:/maven/com/github/pjfanning/jersey-json/1.20/jersey-json-1.20.jar:/maven/org/codehaus/jettison/jettison/1.5.3/jettison-1.5.3.jar:/maven/com/sun/xml/bind/jaxb-impl/2.2.3-1/jaxb-impl-2.2.3-1.jar:/maven/com/sun/jersey/contribs/jersey-guice/1.19.4/jersey-guice-1.19.4.jar:/maven/ch/qos/reload4j/reload4j/1.2.22/reload4j-1.2.22.jar:/maven/com/fasterxml/jackson/core/jackson-core/2.12.7/jackson-core-2.12.7.jar:/maven/com/fasterxml/jackson/core/jackson-databind/2.12.7.1/jackson-databind-2.12.7.1.jar:/maven/com/fasterxml/jackson/module/jackson-module-jaxb-annotations/2.12.7/jackson-module-jaxb-annotations-2.12.7.jar:/maven/jakarta/xml/bind/jakarta.xml.bind-api/2.3.2/jakarta.xml.bind-api-2.3.2.jar:/maven/com/fasterxml/jackson/jaxrs/jackson-jaxrs-json-provider/2.12.7/jackson-jaxrs-json-provider-2.12.7.jar:/maven/com/fasterxml/jackson/jaxrs/jackson-jaxrs-base/2.12.7/jackson-jaxrs-base-2.12.7.jar:/maven/xerces/xercesImpl/2.12.2/xercesImpl-2.12.2.jar:/maven/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar -sourcepath /build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java -doclet org.apache.hadoop.classification.tools.IncludePublicAnnotationsJDiffDoclet -docletpath /build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/target/hadoop-annotations.jar:/build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/target/jdiff.jar -apidir /build/source/hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/target/site/jdiff/xml -apiname Apache Hadoop YARN Common 3.3.5 -->
<package name="org.apache.hadoop.yarn">
  <!-- start class org.apache.hadoop.yarn.ContainerLogAppender -->
  <class name="ContainerLogAppender" extends="org.apache.log4j.FileAppender"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Flushable"/>
    <constructor name="ContainerLogAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="activateOptions"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="org.apache.log4j.spi.LoggingEvent"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getContainerLogDir" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Getter/Setter methods for log4j.]]>
      </doc>
    </method>
    <method name="setContainerLogDir"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerLogDir" type="java.lang.String"/>
    </method>
    <method name="getContainerLogFile" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setContainerLogFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerLogFile" type="java.lang.String"/>
    </method>
    <method name="getTotalLogFileSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setTotalLogFileSize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="logSize" type="long"/>
      <doc>
      <![CDATA[Setter so that log4j can configure it from the
  configuration(log4j.properties).]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A simple log4j-appender for container's logs.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.ContainerLogAppender -->
  <!-- start class org.apache.hadoop.yarn.ContainerRollingLogAppender -->
  <class name="ContainerRollingLogAppender" extends="org.apache.log4j.RollingFileAppender"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Flushable"/>
    <constructor name="ContainerRollingLogAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="activateOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getContainerLogDir" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Getter/Setter methods for log4j.]]>
      </doc>
    </method>
    <method name="setContainerLogDir"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerLogDir" type="java.lang.String"/>
    </method>
    <method name="getContainerLogFile" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setContainerLogFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerLogFile" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[A simple log4j-appender for container's logs.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.ContainerRollingLogAppender -->
  <!-- start class org.apache.hadoop.yarn.YarnUncaughtExceptionHandler -->
  <class name="YarnUncaughtExceptionHandler" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Thread.UncaughtExceptionHandler"/>
    <constructor name="YarnUncaughtExceptionHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="uncaughtException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Thread"/>
      <param name="e" type="java.lang.Throwable"/>
    </method>
    <doc>
    <![CDATA[This class is intended to be installed by calling 
 {@link Thread#setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler)}
 In the main entry point.  It is intended to try and cleanly shut down
 programs using the YARN Event framework.
 
 Note: Right now it only will shut down the program if a Error is caught, but
 not any other exception.  Anything else is just logged.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.YarnUncaughtExceptionHandler -->
</package>
<package name="org.apache.hadoop.yarn.api">
</package>
<package name="org.apache.hadoop.yarn.client">
  <!-- start class org.apache.hadoop.yarn.client.AHSProxy -->
  <class name="AHSProxy" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AHSProxy"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createAHSProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="protocol" type="java.lang.Class"/>
      <param name="ahsAddress" type="java.net.InetSocketAddress"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="protocol" type="java.lang.Class"/>
      <param name="rmAddress" type="java.net.InetSocketAddress"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.AHSProxy -->
  <!-- start class org.apache.hadoop.yarn.client.ClientRMProxy -->
  <class name="ClientRMProxy" extends="org.apache.hadoop.yarn.client.RMProxy"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="createRMProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="configuration" type="org.apache.hadoop.conf.Configuration"/>
      <param name="protocol" type="java.lang.Class"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a proxy to the ResourceManager for the specified protocol.
 @param configuration Configuration with all the required information.
 @param protocol Client protocol for which proxy is being requested.
 @param <T> Type of proxy.
 @return Proxy to the ResourceManager for the specified client protocol.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getRMDelegationTokenService" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the token service name to be used for RMDelegationToken. Depending
 on whether HA is enabled or not, this method generates the appropriate
 service name as a comma-separated list of service addresses.

 @param conf Configuration corresponding to the cluster we need the
             RMDelegationToken for
 @return - Service name for RMDelegationToken]]>
      </doc>
    </method>
    <method name="getAMRMTokenService" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getTokenService" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="address" type="java.lang.String"/>
      <param name="defaultAddr" type="java.lang.String"/>
      <param name="defaultPort" type="int"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.ClientRMProxy -->
  <!-- start class org.apache.hadoop.yarn.client.NMProxy -->
  <class name="NMProxy" extends="org.apache.hadoop.yarn.client.ServerProxy"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NMProxy"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createNMProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="protocol" type="java.lang.Class"/>
      <param name="ugi" type="org.apache.hadoop.security.UserGroupInformation"/>
      <param name="rpc" type="org.apache.hadoop.yarn.ipc.YarnRPC"/>
      <param name="serverAddress" type="java.net.InetSocketAddress"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.NMProxy -->
  <!-- start class org.apache.hadoop.yarn.client.RMProxy -->
  <class name="RMProxy" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RMProxy"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="createRetryPolicy" return="org.apache.hadoop.io.retry.RetryPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="retryTime" type="long"/>
      <param name="retryInterval" type="long"/>
      <param name="isHAEnabled" type="boolean"/>
      <doc>
      <![CDATA[Fetch retry policy from Configuration and create the
 retry policy with specified retryTime and retry interval.]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.RMProxy -->
  <!-- start class org.apache.hadoop.yarn.client.ServerProxy -->
  <class name="ServerProxy" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServerProxy"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createRetryPolicy" return="org.apache.hadoop.io.retry.RetryPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="maxWaitTimeStr" type="java.lang.String"/>
      <param name="defMaxWaitTime" type="long"/>
      <param name="connectRetryIntervalStr" type="java.lang.String"/>
      <param name="defRetryInterval" type="long"/>
    </method>
    <method name="createRetriableProxy" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="protocol" type="java.lang.Class"/>
      <param name="user" type="org.apache.hadoop.security.UserGroupInformation"/>
      <param name="rpc" type="org.apache.hadoop.yarn.ipc.YarnRPC"/>
      <param name="serverAddress" type="java.net.InetSocketAddress"/>
      <param name="retryPolicy" type="org.apache.hadoop.io.retry.RetryPolicy"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.ServerProxy -->
</package>
<package name="org.apache.hadoop.yarn.client.api">
  <!-- start class org.apache.hadoop.yarn.client.api.AppAdminClient -->
  <class name="AppAdminClient" extends="org.apache.hadoop.service.CompositeService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AppAdminClient"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="createAppAdminClient" return="org.apache.hadoop.yarn.client.api.AppAdminClient"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appType" type="java.lang.String"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[<p>
 Create a new instance of AppAdminClient.
 </p>

 @param appType application type
 @param conf configuration
 @return app admin client]]>
      </doc>
    </method>
    <method name="actionLaunch" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileName" type="java.lang.String"/>
      <param name="appName" type="java.lang.String"/>
      <param name="lifetime" type="java.lang.Long"/>
      <param name="queue" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Launch a new YARN application.
 </p>

 @param fileName specification of application
 @param appName name of the application
 @param lifetime lifetime of the application
 @param queue queue of the application
 @return exit code
 @throws IOException IOException
 @throws YarnException exception in client or server]]>
      </doc>
    </method>
    <method name="actionStop" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Stop a YARN application (attempt to stop gracefully before killing the
 application). In the case of a long-running service, the service may be
 restarted later.
 </p>

 @param appName the name of the application
 @return exit code
 @throws IOException IOException
 @throws YarnException exception in client or server]]>
      </doc>
    </method>
    <method name="actionStart" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Start a YARN application from a previously saved specification. In the
 case of a long-running service, the service must have been previously
 launched/started and then stopped, or previously saved but not started.
 </p>

 @param appName the name of the application
 @return exit code
 @throws IOException IOException
 @throws YarnException exception in client or server]]>
      </doc>
    </method>
    <method name="actionSave" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileName" type="java.lang.String"/>
      <param name="appName" type="java.lang.String"/>
      <param name="lifetime" type="java.lang.Long"/>
      <param name="queue" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Save the specification for a YARN application / long-running service.
 The application may be started later.
 </p>

 @param fileName specification of application to save
 @param appName name of the application
 @param lifetime lifetime of the application
 @param queue queue of the application
 @return exit code
 @throws IOException IOException
 @throws YarnException exception in client or server]]>
      </doc>
    </method>
    <method name="actionDestroy" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Remove the specification and all application data for a YARN application.
 The application cannot be running.
 </p>

 @param appName the name of the application
 @return exit code
 @throws IOException IOException
 @throws YarnException exception in client or server]]>
      </doc>
    </method>
    <method name="actionFlex" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appName" type="java.lang.String"/>
      <param name="componentCounts" type="java.util.Map"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Change the number of running containers for a component of a YARN
 application / long-running service.
 </p>

 @param appName the name of the application
 @param componentCounts map of component name to new component count or
                        amount to change existing component count (e.g.
                        5, +5, -5)
 @return exit code
 @throws IOException IOException
 @throws YarnException exception in client or server]]>
      </doc>
    </method>
    <method name="enableFastLaunch" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="destinationFolder" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Upload AM dependencies to HDFS. This makes future application launches
 faster since the dependencies do not have to be uploaded on each launch.
 </p>

 @param destinationFolder
          an optional HDFS folder where dependency tarball will be uploaded
 @return exit code
 @throws IOException
           IOException
 @throws YarnException
           exception in client or server]]>
      </doc>
    </method>
    <method name="getStatusString" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appIdOrName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Get detailed app specific status string for a YARN application.
 </p>

 @param appIdOrName appId or appName
 @return status string
 @throws IOException IOException
 @throws YarnException exception in client or server]]>
      </doc>
    </method>
    <method name="initiateUpgrade" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appName" type="java.lang.String"/>
      <param name="fileName" type="java.lang.String"/>
      <param name="autoFinalize" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[Initiate upgrade of a long running service.

 @param appName      the name of the application.
 @param fileName     specification of application upgrade to save.
 @param autoFinalize when true, finalization of upgrade will be done
                     automatically.
 @return exit code
 @throws IOException   IOException
 @throws YarnException exception in client or server]]>
      </doc>
    </method>
    <method name="actionUpgradeInstances" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appName" type="java.lang.String"/>
      <param name="componentInstances" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[Upgrade component instances of a long running service.

 @param appName            the name of the application.
 @param componentInstances the name of the component instances.]]>
      </doc>
    </method>
    <method name="actionUpgradeComponents" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appName" type="java.lang.String"/>
      <param name="components" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[Upgrade components of a long running service.

 @param appName    the name of the application.
 @param components the name of the components.]]>
      </doc>
    </method>
    <method name="actionCleanUp" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appName" type="java.lang.String"/>
      <param name="userName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Operation to be performed by the RM after an application has completed.

 @param appName  the name of the application.
 @param userName the name of the user.
 @return exit code]]>
      </doc>
    </method>
    <method name="getInstances" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appName" type="java.lang.String"/>
      <param name="components" type="java.util.List"/>
      <param name="version" type="java.lang.String"/>
      <param name="containerStates" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
    </method>
    <method name="actionUpgradeExpress" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appName" type="java.lang.String"/>
      <param name="fileName" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[Express upgrade a long running service.

 @param appName  the name of the application
 @param fileName specification of application upgrade to save.
 @return exit code]]>
      </doc>
    </method>
    <method name="actionCancelUpgrade" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[Cancels the upgrade of the service.

 @param appName the name of the application
 @return exit code
 @throws IOException
 @throws YarnException]]>
      </doc>
    </method>
    <method name="actionDecommissionInstances" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appName" type="java.lang.String"/>
      <param name="componentInstances" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[Decommission component instances of a long running service.

 @param appName            the name of the application.
 @param componentInstances the name of the component instances.]]>
      </doc>
    </method>
    <field name="YARN_APP_ADMIN_CLIENT_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_CLASS_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="UNIT_TEST_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="UNIT_TEST_CLASS_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Client for managing applications.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.AppAdminClient -->
  <!-- start class org.apache.hadoop.yarn.client.api.TimelineClient -->
  <class name="TimelineClient" extends="org.apache.hadoop.service.CompositeService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Flushable"/>
    <constructor name="TimelineClient" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="createTimelineClient" return="org.apache.hadoop.yarn.client.api.TimelineClient"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an instance of the timeline v.1.x client.
 The current UGI when the user initialize the client will be used to do the
 put and the delegation token operations. The current user may use
 {@link UserGroupInformation#doAs} another user to construct and initialize
 a timeline client if the following operations are supposed to be conducted
 by that user.

 @return the created timeline client instance]]>
      </doc>
    </method>
    <method name="putEntities" return="org.apache.hadoop.yarn.api.records.timeline.TimelinePutResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entities" type="org.apache.hadoop.yarn.api.records.timeline.TimelineEntity[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Send the information of a number of conceptual entities to the timeline
 server. It is a blocking API. The method will not return until it gets the
 response from the timeline server.
 </p>
 
 @param entities
          the collection of {@link TimelineEntity}
 @return the error information if the sent entities are not correctly stored
 @throws IOException if there are I/O errors
 @throws YarnException if entities are incomplete/invalid]]>
      </doc>
    </method>
    <method name="putEntities" return="org.apache.hadoop.yarn.api.records.timeline.TimelinePutResponse"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appAttemptId" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"/>
      <param name="groupId" type="org.apache.hadoop.yarn.api.records.timeline.TimelineEntityGroupId"/>
      <param name="entities" type="org.apache.hadoop.yarn.api.records.timeline.TimelineEntity[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Send the information of a number of conceptual entities to the timeline
 server. It is a blocking API. The method will not return until it gets the
 response from the timeline server.

 This API is only for timeline service v1.5
 </p>

 @param appAttemptId {@link ApplicationAttemptId}
 @param groupId {@link TimelineEntityGroupId}
 @param entities
          the collection of {@link TimelineEntity}
 @return the error information if the sent entities are not correctly stored
 @throws IOException if there are I/O errors
 @throws YarnException if entities are incomplete/invalid]]>
      </doc>
    </method>
    <method name="putDomain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="domain" type="org.apache.hadoop.yarn.api.records.timeline.TimelineDomain"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Send the information of a domain to the timeline server. It is a
 blocking API. The method will not return until it gets the response from
 the timeline server.
 </p>
 
 @param domain
          an {@link TimelineDomain} object
 @throws IOException
 @throws YarnException]]>
      </doc>
    </method>
    <method name="putDomain"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appAttemptId" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"/>
      <param name="domain" type="org.apache.hadoop.yarn.api.records.timeline.TimelineDomain"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Send the information of a domain to the timeline server. It is a
 blocking API. The method will not return until it gets the response from
 the timeline server.

 This API is only for timeline service v1.5
 </p>

 @param domain
          an {@link TimelineDomain} object
 @param appAttemptId {@link ApplicationAttemptId}
 @throws IOException
 @throws YarnException]]>
      </doc>
    </method>
    <method name="getDelegationToken" return="org.apache.hadoop.security.token.Token"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="renewer" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Get a delegation token so as to be able to talk to the timeline server in a
 secure way.
 </p>
 
 @param renewer
          Address of the renewer who can renew these tokens when needed by
          securely talking to the timeline server
 @return a delegation token ({@link Token}) that can be used to talk to the
         timeline server
 @throws IOException
 @throws YarnException]]>
      </doc>
    </method>
    <method name="renewDelegationToken" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timelineDT" type="org.apache.hadoop.security.token.Token"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Renew a timeline delegation token.
 </p>
 
 @param timelineDT
          the delegation token to renew
 @return the new expiration time
 @throws IOException
 @throws YarnException]]>
      </doc>
    </method>
    <method name="cancelDelegationToken"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timelineDT" type="org.apache.hadoop.security.token.Token"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[<p>
 Cancel a timeline delegation token.
 </p>
 
 @param timelineDT
          the delegation token to cancel
 @throws IOException
 @throws YarnException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A client library that can be used to post some information in terms of a
 number of conceptual entities. This client library needs to be used along
 with Timeline V.1.x server versions.
 Refer {@link TimelineV2Client} for ATS V2 interface.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.TimelineClient -->
  <!-- start class org.apache.hadoop.yarn.client.api.TimelineReaderClient -->
  <class name="TimelineReaderClient" extends="org.apache.hadoop.service.CompositeService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TimelineReaderClient" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createTimelineReaderClient" return="org.apache.hadoop.yarn.client.api.TimelineReaderClient"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new instance of Timeline Reader Client.]]>
      </doc>
    </method>
    <method name="getApplicationEntity" return="org.apache.hadoop.yarn.api.records.timelineservice.TimelineEntity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <param name="fields" type="java.lang.String"/>
      <param name="filters" type="java.util.Map"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets application entity.
 @param appId application id
 @param fields Fields to be fetched. Defaults to INFO.
 @param filters Filters to be applied while fetching entities.
 @return entity of the application
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplicationAttemptEntity" return="org.apache.hadoop.yarn.api.records.timelineservice.TimelineEntity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appAttemptId" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"/>
      <param name="fields" type="java.lang.String"/>
      <param name="filters" type="java.util.Map"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets application attempt entity.
 @param appAttemptId application attempt id
 @param fields Fields to be fetched. Defaults to INFO.
 @param filters Filters to be applied while fetching entities.
 @return entity associated with application attempt
 @throws IOException]]>
      </doc>
    </method>
    <method name="getApplicationAttemptEntities" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <param name="fields" type="java.lang.String"/>
      <param name="filters" type="java.util.Map"/>
      <param name="limit" type="long"/>
      <param name="fromId" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets application attempt entities.
 @param appId application id
 @param fields Fields to be fetched. Defaults to INFO.
 @param filters Filters to be applied while fetching entities.
 @param limit Number of entities to return.
 @param fromId Retrieve next set of generic ids from given fromId
 @return list of application attempt entities
 @throws IOException]]>
      </doc>
    </method>
    <method name="getContainerEntity" return="org.apache.hadoop.yarn.api.records.timelineservice.TimelineEntity"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <param name="fields" type="java.lang.String"/>
      <param name="filters" type="java.util.Map"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets Timeline entity for the container.
 @param containerId container id
 @param fields Fields to be fetched. Defaults to INFO.
 @param filters Filters to be applied while fetching entities.
 @return timeline entity for container
 @throws IOException]]>
      </doc>
    </method>
    <method name="getContainerEntities" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <param name="fields" type="java.lang.String"/>
      <param name="filters" type="java.util.Map"/>
      <param name="limit" type="long"/>
      <param name="fromId" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets container entities for an application.
 @param appId application id
 @param fields Fields to be fetched. Defaults to INFO.
 @param filters Filters to be applied while fetching entities.
 @param limit Number of entities to return.
 @param fromId Retrieve next set of generic ids from given fromId
 @return list of entities
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A client library that can be used to get Timeline Entities associated with
 application, application attempt or containers. This client library needs to
 be used along with time line v.2 server version.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.TimelineReaderClient -->
</package>
<package name="org.apache.hadoop.yarn.client.api.impl">
  <!-- start class org.apache.hadoop.yarn.client.api.impl.TimelineReaderClientImpl -->
  <class name="TimelineReaderClientImpl" extends="org.apache.hadoop.yarn.client.api.TimelineReaderClient"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TimelineReaderClientImpl"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="serviceInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="getApplicationEntity" return="org.apache.hadoop.yarn.api.records.timelineservice.TimelineEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <param name="fields" type="java.lang.String"/>
      <param name="filters" type="java.util.Map"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getApplicationAttemptEntity" return="org.apache.hadoop.yarn.api.records.timelineservice.TimelineEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appAttemptId" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"/>
      <param name="fields" type="java.lang.String"/>
      <param name="filters" type="java.util.Map"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getApplicationAttemptEntities" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <param name="fields" type="java.lang.String"/>
      <param name="filters" type="java.util.Map"/>
      <param name="limit" type="long"/>
      <param name="fromId" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getContainerEntity" return="org.apache.hadoop.yarn.api.records.timelineservice.TimelineEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
      <param name="fields" type="java.lang.String"/>
      <param name="filters" type="java.util.Map"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getContainerEntities" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <param name="fields" type="java.lang.String"/>
      <param name="filters" type="java.util.Map"/>
      <param name="limit" type="long"/>
      <param name="fromId" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="encodeValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <exception name="UnsupportedEncodingException" type="java.io.UnsupportedEncodingException"/>
    </method>
    <method name="doGetUri" return="com.sun.jersey.api.client.ClientResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="base" type="java.net.URI"/>
      <param name="path" type="java.lang.String"/>
      <param name="params" type="javax.ws.rs.core.MultivaluedMap"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Implementation of TimelineReaderClient interface.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.client.api.impl.TimelineReaderClientImpl -->
</package>
<package name="org.apache.hadoop.yarn.event">
  <!-- start class org.apache.hadoop.yarn.event.AbstractEvent -->
  <class name="AbstractEvent" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.yarn.event.Event"/>
    <constructor name="AbstractEvent" type="TYPE"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AbstractEvent" type="TYPE, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTimestamp" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="TYPE"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Parent class of all the events. All events extend this class.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.event.AbstractEvent -->
  <!-- start class org.apache.hadoop.yarn.event.AsyncDispatcher -->
  <class name="AsyncDispatcher" extends="org.apache.hadoop.service.AbstractService"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.yarn.event.Dispatcher"/>
    <constructor name="AsyncDispatcher"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AsyncDispatcher" type="java.util.concurrent.BlockingQueue"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AsyncDispatcher" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Set a name for this dispatcher thread.
 @param dispatcherName name of the dispatcher thread]]>
      </doc>
    </constructor>
    <method name="disableExitOnDispatchException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="serviceInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="serviceStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="setDrainEventsOnStop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="serviceStop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="dispatch"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="event" type="org.apache.hadoop.yarn.event.Event"/>
    </method>
    <method name="register"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="eventType" type="java.lang.Class"/>
      <param name="handler" type="org.apache.hadoop.yarn.event.EventHandler"/>
    </method>
    <method name="getEventHandler" return="org.apache.hadoop.yarn.event.EventHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isEventThreadWaiting" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="isDrained" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="isStopped" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="addMetrics"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metrics" type="org.apache.hadoop.yarn.metrics.EventTypeMetrics"/>
      <param name="eventClass" type="java.lang.Class"/>
    </method>
    <field name="eventDispatchers" type="java.util.Map"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Dispatches {@link Event}s in a separate thread. Currently only single thread
 does that. Potentially there could be multiple channels for each event type
 class and a thread pool can be used to dispatch the events.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.event.AsyncDispatcher -->
  <!-- start interface org.apache.hadoop.yarn.event.Dispatcher -->
  <interface name="Dispatcher"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getEventHandler" return="org.apache.hadoop.yarn.event.EventHandler"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="register"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="eventType" type="java.lang.Class"/>
      <param name="handler" type="org.apache.hadoop.yarn.event.EventHandler"/>
    </method>
    <doc>
    <![CDATA[Event Dispatcher interface. It dispatches events to registered 
 event handlers based on event types.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.yarn.event.Dispatcher -->
  <!-- start interface org.apache.hadoop.yarn.event.Event -->
  <interface name="Event"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getType" return="TYPE"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTimestamp" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Interface defining events api.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.yarn.event.Event -->
  <!-- start interface org.apache.hadoop.yarn.event.EventHandler -->
  <interface name="EventHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handle"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="T"/>
    </method>
    <doc>
    <![CDATA[Interface for handling events of type T

 @param <T> parameterized event of type T]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.yarn.event.EventHandler -->
</package>
<package name="org.apache.hadoop.yarn.factories">
</package>
<package name="org.apache.hadoop.yarn.factory.providers">
</package>
<package name="org.apache.hadoop.yarn.logaggregation">
  <!-- start class org.apache.hadoop.yarn.logaggregation.AggregatedLogFormat -->
  <class name="AggregatedLogFormat" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AggregatedLogFormat"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.yarn.logaggregation.AggregatedLogFormat -->
  <!-- start class org.apache.hadoop.yarn.logaggregation.AggregatedLogFormat.LogKey -->
  <class name="AggregatedLogFormat.LogKey" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="LogKey"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LogKey" type="org.apache.hadoop.yarn.api.records.ContainerId"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LogKey" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.logaggregation.AggregatedLogFormat.LogKey -->
  <!-- start class org.apache.hadoop.yarn.logaggregation.AggregatedLogFormat.LogReader -->
  <class name="AggregatedLogFormat.LogReader" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LogReader" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="getApplicationOwner" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the owner of the application.

 @return the application owner.
 @throws IOException if we can not get the application owner.]]>
      </doc>
    </method>
    <method name="getApplicationAcls" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns ACLs for the application. An empty map is returned if no ACLs are
 found.

 @return a map of the Application ACLs.
 @throws IOException if we can not get the application acls.]]>
      </doc>
    </method>
    <method name="next" return="java.io.DataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.yarn.logaggregation.AggregatedLogFormat.LogKey"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read the next key and return the value-stream.
 
 @param key the log key
 @return the valueStream if there are more keys or null otherwise
 @throws IOException if we can not get the dataInputStream
 for the next key]]>
      </doc>
    </method>
    <method name="readAcontainerLogs"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueStream" type="java.io.DataInputStream"/>
      <param name="writer" type="java.io.Writer"/>
      <param name="logUploadedTime" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes all logs for a single container to the provided writer.
 @param valueStream the valueStream
 @param writer the log writer
 @param logUploadedTime the time stamp
 @throws IOException if we can not read the container logs.]]>
      </doc>
    </method>
    <method name="readAcontainerLogs"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueStream" type="java.io.DataInputStream"/>
      <param name="writer" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes all logs for a single container to the provided writer.
 @param valueStream the value stream
 @param writer the log writer
 @throws IOException if we can not read the container logs.]]>
      </doc>
    </method>
    <method name="readAContainerLogsForALogType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueStream" type="java.io.DataInputStream"/>
      <param name="out" type="java.io.PrintStream"/>
      <param name="logUploadedTime" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Keep calling this till you get a {@link EOFException} for getting logs of
 all types for a single container.
 
 @param valueStream the value stream
 @param out the print stream
 @param logUploadedTime the time stamp
 @throws IOException if we can not read the container log by specifying
 the container log type.]]>
      </doc>
    </method>
    <method name="readAContainerLogsForALogType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueStream" type="java.io.DataInputStream"/>
      <param name="out" type="java.io.PrintStream"/>
      <param name="logUploadedTime" type="long"/>
      <param name="bytes" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Keep calling this till you get a {@link EOFException} for getting logs of
 all types for a single container for the specific bytes.

 @param valueStream the value stream
 @param out the output print stream
 @param logUploadedTime the log upload time stamp
 @param bytes the output size of the log
 @throws IOException if we can not read the container log]]>
      </doc>
    </method>
    <method name="readAContainerLogsForALogType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueStream" type="java.io.DataInputStream"/>
      <param name="out" type="java.io.PrintStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Keep calling this till you get a {@link EOFException} for getting logs of
 all types for a single container.
 
 @param valueStream the value stream
 @param out the output print stream
 @throws IOException if we can not read the container log]]>
      </doc>
    </method>
    <method name="readContainerLogsForALogType" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueStream" type="java.io.DataInputStream"/>
      <param name="out" type="java.io.PrintStream"/>
      <param name="logUploadedTime" type="long"/>
      <param name="logType" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Keep calling this till you get a {@link EOFException} for getting logs of
 the specific types for a single container.
 @param valueStream the value stream
 @param out the output print stream
 @param logUploadedTime the log uploaded time stamp
 @param logType the given log type
 @throws IOException if we can not read the container logs]]>
      </doc>
    </method>
    <method name="readContainerLogsForALogType" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="valueStream" type="java.io.DataInputStream"/>
      <param name="out" type="java.io.PrintStream"/>
      <param name="logUploadedTime" type="long"/>
      <param name="logType" type="java.util.List"/>
      <param name="bytes" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Keep calling this till you get a {@link EOFException} for getting logs of
 the specific types for a single container.
 @param valueStream the value stream
 @param out the output print stream
 @param logUploadedTime the log uploaded time stamp
 @param logType the given log type
 @throws IOException if we can not read the container logs]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.logaggregation.AggregatedLogFormat.LogReader -->
</package>
<package name="org.apache.hadoop.yarn.logaggregation.filecontroller">
  <!-- start class org.apache.hadoop.yarn.logaggregation.filecontroller.LogAggregationFileController -->
  <class name="LogAggregationFileController" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LogAggregationFileController"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="controllerName" type="java.lang.String"/>
      <doc>
      <![CDATA[Initialize the log file controller.
 @param conf the Configuration
 @param controllerName the log controller class name]]>
      </doc>
    </method>
    <method name="initInternal"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Derived classes initialize themselves using this method.
 @param conf the Configuration]]>
      </doc>
    </method>
    <method name="getRemoteRootLogDir" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the remote root log directory.
 @return the remote root log directory path]]>
      </doc>
    </method>
    <method name="getRemoteRootLogDirSuffix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the log aggregation directory suffix.
 @return the log aggregation directory suffix]]>
      </doc>
    </method>
    <method name="initializeWriter"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.apache.hadoop.yarn.logaggregation.filecontroller.LogAggregationFileControllerContext"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Initialize the writer.
 @param context the {@link LogAggregationFileControllerContext}
 @throws IOException if fails to initialize the writer]]>
      </doc>
    </method>
    <method name="closeWriter"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="LogAggregationDFSException" type="org.apache.hadoop.yarn.logaggregation.filecontroller.LogAggregationDFSException"/>
      <doc>
      <![CDATA[Close the writer.
 @throws LogAggregationDFSException if the closing of the writer fails
         (for example due to HDFS quota being exceeded)]]>
      </doc>
    </method>
    <method name="write"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="logKey" type="org.apache.hadoop.yarn.logaggregation.AggregatedLogFormat.LogKey"/>
      <param name="logValue" type="org.apache.hadoop.yarn.logaggregation.AggregatedLogFormat.LogValue"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write the log content.
 @param logKey the log key
 @param logValue the log content
 @throws IOException if fails to write the logs]]>
      </doc>
    </method>
    <method name="postWrite"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.yarn.logaggregation.filecontroller.LogAggregationFileControllerContext"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Operations needed after write the log content.
 @param record the {@link LogAggregationFileControllerContext}
 @throws Exception if anything fails]]>
      </doc>
    </method>
    <method name="closePrintStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
    </method>
    <method name="readAggregatedLogs" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="logRequest" type="org.apache.hadoop.yarn.logaggregation.ContainerLogsRequest"/>
      <param name="os" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Output container log.
 @param logRequest {@link ContainerLogsRequest}
 @param os the output stream
 @return true if we can read the aggregated logs successfully
 @throws IOException if we can not access the log file.]]>
      </doc>
    </method>
    <method name="readAggregatedLogsMeta" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="logRequest" type="org.apache.hadoop.yarn.logaggregation.ContainerLogsRequest"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a list of {@link ContainerLogMeta} for an application
 from Remote FileSystem.

 @param logRequest {@link ContainerLogsRequest}
 @return a list of {@link ContainerLogMeta}
 @throws IOException if there is no available log file]]>
      </doc>
    </method>
    <method name="renderAggregatedLogsBlock"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="html" type="org.apache.hadoop.yarn.webapp.view.HtmlBlock.Block"/>
      <param name="context" type="org.apache.hadoop.yarn.webapp.View.ViewContext"/>
      <doc>
      <![CDATA[Render Aggregated Logs block.
 @param html the html
 @param context the ViewContext]]>
      </doc>
    </method>
    <method name="getApplicationOwner" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="aggregatedLogPath" type="org.apache.hadoop.fs.Path"/>
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the owner of the application.

 @param aggregatedLogPath the aggregatedLog path
 @param appId the ApplicationId
 @return the application owner
 @throws IOException if we can not get the application owner]]>
      </doc>
    </method>
    <method name="getApplicationAcls" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="aggregatedLogPath" type="org.apache.hadoop.fs.Path"/>
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns ACLs for the application. An empty map is returned if no ACLs are
 found.

 @param aggregatedLogPath the aggregatedLog path.
 @param appId the ApplicationId
 @return a map of the Application ACLs.
 @throws IOException if we can not get the application acls]]>
      </doc>
    </method>
    <method name="verifyAndCreateRemoteLogDir"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Verify and create the remote log directory.]]>
      </doc>
    </method>
    <method name="createAppDir"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <param name="userUgi" type="org.apache.hadoop.security.UserGroupInformation"/>
      <doc>
      <![CDATA[Create remote Application directory for log aggregation.
 @param user the user
 @param appId the application ID
 @param userUgi the UGI]]>
      </doc>
    </method>
    <method name="getFileSystem" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createDir"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="fsPerm" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="checkExists" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="fsPerm" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getRemoteNodeLogFileForApp" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <param name="user" type="java.lang.String"/>
      <param name="nodeId" type="org.apache.hadoop.yarn.api.records.NodeId"/>
      <doc>
      <![CDATA[Get the remote aggregated log path.
 @param appId the ApplicationId
 @param user the Application Owner
 @param nodeId the NodeManager Id
 @return the remote aggregated log path]]>
      </doc>
    </method>
    <method name="getRemoteAppLogDir" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <param name="appOwner" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the remote application directory for log aggregation.
 @param appId the Application ID
 @param appOwner the Application Owner
 @return the remote application directory
 @throws IOException if can not find the remote application directory]]>
      </doc>
    </method>
    <method name="getOlderRemoteAppLogDir" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
      <param name="appOwner" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the older remote application directory for log aggregation.
 @param appId the Application ID
 @param appOwner the Application Owner
 @return the older remote application directory
 @throws IOException if can not find the remote application directory]]>
      </doc>
    </method>
    <method name="cleanOldLogs"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="remoteNodeLogFileForApp" type="org.apache.hadoop.fs.Path"/>
      <param name="nodeId" type="org.apache.hadoop.yarn.api.records.NodeId"/>
      <param name="userUgi" type="org.apache.hadoop.security.UserGroupInformation"/>
    </method>
    <method name="aggregatedLogSuffix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fileName" type="java.lang.String"/>
      <doc>
      <![CDATA[Create the aggregated log suffix. The LogAggregationFileController
 should call this to get the suffix and append the suffix to the end
 of each log. This would keep the aggregated log format consistent.

 @param fileName the File Name
 @return the aggregated log suffix String]]>
      </doc>
    </method>
    <method name="isFsSupportsChmod" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="belongsToAppAttempt" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="appAttemptId" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"/>
      <param name="containerIdStr" type="java.lang.String"/>
    </method>
    <field name="TLDIR_PERMISSIONS" type="org.apache.hadoop.fs.permission.FsPermission"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Permissions for the top level directory under which app directories will be
 created.]]>
      </doc>
    </field>
    <field name="APP_DIR_PERMISSIONS" type="org.apache.hadoop.fs.permission.FsPermission"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Permissions for the Application directory.]]>
      </doc>
    </field>
    <field name="APP_LOG_FILE_UMASK" type="org.apache.hadoop.fs.permission.FsPermission"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Umask for the log file.]]>
      </doc>
    </field>
    <field name="conf" type="org.apache.hadoop.conf.Configuration"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="remoteRootLogDir" type="org.apache.hadoop.fs.Path"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="remoteRootLogDirSuffix" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="retentionSize" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="fileControllerName" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="fsSupportsChmod" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Base class to implement Log Aggregation File Controller.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.logaggregation.filecontroller.LogAggregationFileController -->
</package>
<package name="org.apache.hadoop.yarn.logaggregation.filecontroller.ifile">
</package>
<package name="org.apache.hadoop.yarn.logaggregation.filecontroller.tfile">
</package>
<package name="org.apache.hadoop.yarn.nodelabels">
</package>
<package name="org.apache.hadoop.yarn.nodelabels.event">
</package>
<package name="org.apache.hadoop.yarn.security">
  <!-- start class org.apache.hadoop.yarn.security.AccessRequest -->
  <class name="AccessRequest" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessRequest" type="org.apache.hadoop.yarn.security.PrivilegedEntity, org.apache.hadoop.security.UserGroupInformation, org.apache.hadoop.yarn.security.AccessType, java.lang.String, java.lang.String, java.lang.String, java.util.List"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUser" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAccessType" return="org.apache.hadoop.yarn.security.AccessType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAppId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAppName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEntity" return="org.apache.hadoop.yarn.security.PrivilegedEntity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getForwardedAddresses" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRemoteAddress" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This request object contains all the context information to determine whether
 a user has permission to access the target entity.
 user       : the user who's currently accessing
 accessType : the access type against the entity.
 entity     : the target object user is accessing.
 appId      : the associated app Id for current access. This could be null
              if no app is associated.
 appName    : the associated app name for current access. This could be null if
              no app is associated.
 remoteAddress : The caller's remote ip address.
 forwardedAddresses : In case this is an http request, this contains the
                    originating IP address of a client connecting to a web
                    server through an HTTP proxy or load balancer. This
                    parameter is null, if it's a RPC request.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.AccessRequest -->
  <!-- start class org.apache.hadoop.yarn.security.AMRMTokenIdentifier -->
  <class name="AMRMTokenIdentifier" extends="org.apache.hadoop.security.token.TokenIdentifier"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AMRMTokenIdentifier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AMRMTokenIdentifier" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getKind" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUser" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKeyId" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getProto" return="org.apache.hadoop.yarn.proto.YarnSecurityTokenProtos.AMRMTokenIdentifierProto"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="KIND_NAME" type="org.apache.hadoop.io.Text"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[AMRMTokenIdentifier is the TokenIdentifier to be used by
 ApplicationMasters to authenticate to the ResourceManager.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.AMRMTokenIdentifier -->
  <!-- start class org.apache.hadoop.yarn.security.AMRMTokenSelector -->
  <class name="AMRMTokenSelector" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.security.token.TokenSelector"/>
    <constructor name="AMRMTokenSelector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="selectToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.io.Text"/>
      <param name="tokens" type="java.util.Collection"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.AMRMTokenSelector -->
  <!-- start class org.apache.hadoop.yarn.security.ContainerManagerSecurityInfo -->
  <class name="ContainerManagerSecurityInfo" extends="org.apache.hadoop.security.SecurityInfo"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ContainerManagerSecurityInfo"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKerberosInfo" return="org.apache.hadoop.security.KerberosInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getTokenInfo" return="org.apache.hadoop.security.token.TokenInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.ContainerManagerSecurityInfo -->
  <!-- start class org.apache.hadoop.yarn.security.ContainerTokenIdentifier -->
  <class name="ContainerTokenIdentifier" extends="org.apache.hadoop.security.token.TokenIdentifier"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ContainerTokenIdentifier" type="org.apache.hadoop.yarn.api.records.ContainerId, java.lang.String, java.lang.String, org.apache.hadoop.yarn.api.records.Resource, long, int, long, org.apache.hadoop.yarn.api.records.Priority, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ContainerTokenIdentifier" type="org.apache.hadoop.yarn.api.records.ContainerId, java.lang.String, java.lang.String, org.apache.hadoop.yarn.api.records.Resource, long, int, long, org.apache.hadoop.yarn.api.records.Priority, long, org.apache.hadoop.yarn.api.records.LogAggregationContext"
      static="false" final="false" visibility="public"
      deprecated="Use one of the other constructors instead.">
      <doc>
      <![CDATA[Creates a instance.

 @param appSubmitter appSubmitter
 @param containerID container ID
 @param creationTime creation time
 @param expiryTimeStamp expiry timestamp
 @param hostName hostname
 @param logAggregationContext log aggregation context
 @param masterKeyId master key ID
 @param priority priority
 @param r resource needed by the container
 @param rmIdentifier ResourceManager identifier
 @deprecated Use one of the other constructors instead.]]>
      </doc>
    </constructor>
    <constructor name="ContainerTokenIdentifier" type="org.apache.hadoop.yarn.api.records.ContainerId, java.lang.String, java.lang.String, org.apache.hadoop.yarn.api.records.Resource, long, int, long, org.apache.hadoop.yarn.api.records.Priority, long, org.apache.hadoop.yarn.api.records.LogAggregationContext, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ContainerTokenIdentifier" type="org.apache.hadoop.yarn.api.records.ContainerId, java.lang.String, java.lang.String, org.apache.hadoop.yarn.api.records.Resource, long, int, long, org.apache.hadoop.yarn.api.records.Priority, long, org.apache.hadoop.yarn.api.records.LogAggregationContext, java.lang.String, org.apache.hadoop.yarn.server.api.ContainerType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ContainerTokenIdentifier" type="org.apache.hadoop.yarn.api.records.ContainerId, int, java.lang.String, java.lang.String, org.apache.hadoop.yarn.api.records.Resource, long, int, long, org.apache.hadoop.yarn.api.records.Priority, long, org.apache.hadoop.yarn.api.records.LogAggregationContext, java.lang.String, org.apache.hadoop.yarn.server.api.ContainerType, org.apache.hadoop.yarn.api.records.ExecutionType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ContainerTokenIdentifier" type="org.apache.hadoop.yarn.api.records.ContainerId, int, java.lang.String, java.lang.String, org.apache.hadoop.yarn.api.records.Resource, long, int, long, org.apache.hadoop.yarn.api.records.Priority, long, org.apache.hadoop.yarn.api.records.LogAggregationContext, java.lang.String, org.apache.hadoop.yarn.server.api.ContainerType, org.apache.hadoop.yarn.api.records.ExecutionType, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Convenience Constructor for existing clients.

 @param containerID containerID
 @param containerVersion containerVersion
 @param hostName hostName
 @param appSubmitter appSubmitter
 @param r resource
 @param expiryTimeStamp expiryTimeStamp
 @param masterKeyId masterKeyId
 @param rmIdentifier rmIdentifier
 @param priority priority
 @param creationTime creationTime
 @param logAggregationContext logAggregationContext
 @param nodeLabelExpression nodeLabelExpression
 @param containerType containerType
 @param executionType executionType
 @param allocationRequestId allocationRequestId]]>
      </doc>
    </constructor>
    <constructor name="ContainerTokenIdentifier" type="org.apache.hadoop.yarn.api.records.ContainerId, int, java.lang.String, java.lang.String, org.apache.hadoop.yarn.api.records.Resource, long, int, long, org.apache.hadoop.yarn.api.records.Priority, long, org.apache.hadoop.yarn.api.records.LogAggregationContext, java.lang.String, org.apache.hadoop.yarn.server.api.ContainerType, org.apache.hadoop.yarn.api.records.ExecutionType, long, java.util.Set"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a Container Token Identifier.

 @param containerID containerID
 @param containerVersion containerVersion
 @param hostName hostName
 @param appSubmitter appSubmitter
 @param r resource
 @param expiryTimeStamp expiryTimeStamp
 @param masterKeyId masterKeyId
 @param rmIdentifier rmIdentifier
 @param priority priority
 @param creationTime creationTime
 @param logAggregationContext logAggregationContext
 @param nodeLabelExpression nodeLabelExpression
 @param containerType containerType
 @param executionType executionType
 @param allocationRequestId allocationRequestId
 @param allocationTags Set of allocation Tags.]]>
      </doc>
    </constructor>
    <constructor name="ContainerTokenIdentifier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor needed by RPC layer/SecretManager.]]>
      </doc>
    </constructor>
    <method name="getContainerID" return="org.apache.hadoop.yarn.api.records.ContainerId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getApplicationSubmitter" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNmHostAddress" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getResource" return="org.apache.hadoop.yarn.api.records.Resource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getExpiryTimeStamp" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMasterKeyId" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPriority" return="org.apache.hadoop.yarn.api.records.Priority"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCreationTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getRMIdentifier" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the RMIdentifier of RM in which containers are allocated.
 @return RMIdentifier]]>
      </doc>
    </method>
    <method name="getContainerType" return="org.apache.hadoop.yarn.server.api.ContainerType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the ContainerType of container to allocate.
 @return ContainerType]]>
      </doc>
    </method>
    <method name="getExecutionType" return="org.apache.hadoop.yarn.api.records.ExecutionType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the ExecutionType of container to allocate
 @return ExecutionType]]>
      </doc>
    </method>
    <method name="getProto" return="org.apache.hadoop.yarn.proto.YarnSecurityTokenProtos.ContainerTokenIdentifierProto"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLogAggregationContext" return="org.apache.hadoop.yarn.api.records.LogAggregationContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAllocationRequestId" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getKind" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUser" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getVersion" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the Container version
 @return container version]]>
      </doc>
    </method>
    <method name="getNodeLabelExpression" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the node-label-expression in the original ResourceRequest]]>
      </doc>
    </method>
    <method name="getAllcationTags" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="KIND" type="org.apache.hadoop.io.Text"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[TokenIdentifier for a container. Encodes {@link ContainerId},
 {@link Resource} needed by the container and the target NMs host-address.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.ContainerTokenIdentifier -->
  <!-- start class org.apache.hadoop.yarn.security.ContainerTokenSelector -->
  <class name="ContainerTokenSelector" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.security.token.TokenSelector"/>
    <constructor name="ContainerTokenSelector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="selectToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.io.Text"/>
      <param name="tokens" type="java.util.Collection"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.ContainerTokenSelector -->
  <!-- start class org.apache.hadoop.yarn.security.NMTokenIdentifier -->
  <class name="NMTokenIdentifier" extends="org.apache.hadoop.security.token.TokenIdentifier"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NMTokenIdentifier" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId, org.apache.hadoop.yarn.api.records.NodeId, java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="NMTokenIdentifier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor needed by RPC/Secret manager]]>
      </doc>
    </constructor>
    <method name="getApplicationAttemptId" return="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNodeId" return="org.apache.hadoop.yarn.api.records.NodeId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getApplicationSubmitter" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKeyId" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getKind" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUser" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getProto" return="org.apache.hadoop.yarn.proto.YarnSecurityTokenProtos.NMTokenIdentifierProto"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="KIND" type="org.apache.hadoop.io.Text"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.NMTokenIdentifier -->
  <!-- start class org.apache.hadoop.yarn.security.SchedulerSecurityInfo -->
  <class name="SchedulerSecurityInfo" extends="org.apache.hadoop.security.SecurityInfo"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SchedulerSecurityInfo"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKerberosInfo" return="org.apache.hadoop.security.KerberosInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getTokenInfo" return="org.apache.hadoop.security.token.TokenInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.SchedulerSecurityInfo -->
</package>
<package name="org.apache.hadoop.yarn.security.admin">
  <!-- start class org.apache.hadoop.yarn.security.admin.AdminSecurityInfo -->
  <class name="AdminSecurityInfo" extends="org.apache.hadoop.security.SecurityInfo"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AdminSecurityInfo"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKerberosInfo" return="org.apache.hadoop.security.KerberosInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getTokenInfo" return="org.apache.hadoop.security.token.TokenInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.admin.AdminSecurityInfo -->
</package>
<package name="org.apache.hadoop.yarn.security.client">
  <!-- start class org.apache.hadoop.yarn.security.client.BaseClientToAMTokenSecretManager -->
  <class name="BaseClientToAMTokenSecretManager" extends="org.apache.hadoop.security.token.SecretManager"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BaseClientToAMTokenSecretManager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[A base {@link SecretManager} for AMs to extend and validate Client-RM tokens
 issued to clients by the RM using the underlying master-key shared by RM to
 the AMs on their launch. All the methods are called by either Hadoop RPC or
 YARN, so this class is strictly for the purpose of inherit/extend and
 register with Hadoop RPC.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.client.BaseClientToAMTokenSecretManager -->
  <!-- start class org.apache.hadoop.yarn.security.client.ClientRMSecurityInfo -->
  <class name="ClientRMSecurityInfo" extends="org.apache.hadoop.security.SecurityInfo"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ClientRMSecurityInfo"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKerberosInfo" return="org.apache.hadoop.security.KerberosInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getTokenInfo" return="org.apache.hadoop.security.token.TokenInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.client.ClientRMSecurityInfo -->
  <!-- start class org.apache.hadoop.yarn.security.client.ClientTimelineSecurityInfo -->
  <class name="ClientTimelineSecurityInfo" extends="org.apache.hadoop.security.SecurityInfo"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ClientTimelineSecurityInfo"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKerberosInfo" return="org.apache.hadoop.security.KerberosInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getTokenInfo" return="org.apache.hadoop.security.token.TokenInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.client.ClientTimelineSecurityInfo -->
  <!-- start class org.apache.hadoop.yarn.security.client.ClientToAMTokenIdentifier -->
  <class name="ClientToAMTokenIdentifier" extends="org.apache.hadoop.security.token.TokenIdentifier"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ClientToAMTokenIdentifier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ClientToAMTokenIdentifier" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getApplicationAttemptID" return="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getClientName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getProto" return="org.apache.hadoop.yarn.proto.YarnSecurityTokenProtos.ClientToAMTokenIdentifierProto"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getKind" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUser" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="KIND_NAME" type="org.apache.hadoop.io.Text"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.client.ClientToAMTokenIdentifier -->
  <!-- start class org.apache.hadoop.yarn.security.client.ClientToAMTokenSecretManager -->
  <class name="ClientToAMTokenSecretManager" extends="org.apache.hadoop.yarn.security.client.BaseClientToAMTokenSecretManager"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ClientToAMTokenSecretManager" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId, byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="retrievePassword" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="identifier" type="org.apache.hadoop.yarn.security.client.ClientToAMTokenIdentifier"/>
      <exception name="SecretManager.InvalidToken" type="org.apache.hadoop.security.token.SecretManager.InvalidToken"/>
    </method>
    <method name="getMasterKey" return="javax.crypto.SecretKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationAttemptID" type="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"/>
    </method>
    <method name="setMasterKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="byte[]"/>
    </method>
    <doc>
    <![CDATA[A simple {@link SecretManager} for AMs to validate Client-RM tokens issued to
 clients by the RM using the underlying master-key shared by RM to the AMs on
 their launch. All the methods are called by either Hadoop RPC or YARN, so
 this class is strictly for the purpose of inherit/extend and register with
 Hadoop RPC.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.client.ClientToAMTokenSecretManager -->
  <!-- start class org.apache.hadoop.yarn.security.client.RMDelegationTokenIdentifier -->
  <class name="RMDelegationTokenIdentifier" extends="org.apache.hadoop.yarn.security.client.YARNDelegationTokenIdentifier"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RMDelegationTokenIdentifier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="RMDelegationTokenIdentifier" type="org.apache.hadoop.io.Text, org.apache.hadoop.io.Text, org.apache.hadoop.io.Text"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new delegation token identifier
 @param owner the effective username of the token owner
 @param renewer the username of the renewer
 @param realUser the real username of the token owner]]>
      </doc>
    </constructor>
    <method name="getKind" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="KIND_NAME" type="org.apache.hadoop.io.Text"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Delegation Token Identifier that identifies the delegation tokens from the 
 Resource Manager.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.client.RMDelegationTokenIdentifier -->
  <!-- start class org.apache.hadoop.yarn.security.client.RMDelegationTokenSelector -->
  <class name="RMDelegationTokenSelector" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.security.token.TokenSelector"/>
    <constructor name="RMDelegationTokenSelector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="selectToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.io.Text"/>
      <param name="tokens" type="java.util.Collection"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.client.RMDelegationTokenSelector -->
  <!-- start class org.apache.hadoop.yarn.security.client.TimelineDelegationTokenIdentifier -->
  <class name="TimelineDelegationTokenIdentifier" extends="org.apache.hadoop.yarn.security.client.YARNDelegationTokenIdentifier"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TimelineDelegationTokenIdentifier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TimelineDelegationTokenIdentifier" type="org.apache.hadoop.io.Text, org.apache.hadoop.io.Text, org.apache.hadoop.io.Text"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new timeline delegation token identifier

 @param owner the effective username of the token owner
 @param renewer the username of the renewer
 @param realUser the real username of the token owner]]>
      </doc>
    </constructor>
    <method name="getKind" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="KIND_NAME" type="org.apache.hadoop.io.Text"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.client.TimelineDelegationTokenIdentifier -->
  <!-- start class org.apache.hadoop.yarn.security.client.TimelineDelegationTokenSelector -->
  <class name="TimelineDelegationTokenSelector" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.security.token.TokenSelector"/>
    <constructor name="TimelineDelegationTokenSelector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="selectToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.io.Text"/>
      <param name="tokens" type="java.util.Collection"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.security.client.TimelineDelegationTokenSelector -->
</package>
<package name="org.apache.hadoop.yarn.server.api">
</package>
<package name="org.apache.hadoop.yarn.server.api.impl.pb.client">
</package>
<package name="org.apache.hadoop.yarn.server.api.impl.pb.service">
</package>
<package name="org.apache.hadoop.yarn.sharedcache">
  <!-- start interface org.apache.hadoop.yarn.sharedcache.SharedCacheChecksum -->
  <interface name="SharedCacheChecksum"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="computeChecksum" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Calculate the checksum of the passed input stream.

 @param in <code>InputStream</code> to be checksumed
 @return the message digest of the input stream
 @throws IOException]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.yarn.sharedcache.SharedCacheChecksum -->
  <!-- start class org.apache.hadoop.yarn.sharedcache.SharedCacheChecksumFactory -->
  <class name="SharedCacheChecksumFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SharedCacheChecksumFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getChecksum" return="org.apache.hadoop.yarn.sharedcache.SharedCacheChecksum"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get a new <code>SharedCacheChecksum</code> object based on the configurable
 algorithm implementation
 (see <code>yarn.sharedcache.checksum.algo.impl</code>)

 @return <code>SharedCacheChecksum</code> object]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.yarn.sharedcache.SharedCacheChecksumFactory -->
</package>
<package name="org.apache.hadoop.yarn.state">
  <!-- start class org.apache.hadoop.yarn.state.InvalidStateTransitionException -->
  <class name="InvalidStateTransitionException" extends="org.apache.hadoop.yarn.state.InvalidStateTransitonException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvalidStateTransitionException" type="java.lang.Enum, java.lang.Enum"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[The exception that happens when you call invalid state transition.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.state.InvalidStateTransitionException -->
  <!-- start class org.apache.hadoop.yarn.state.InvalidStateTransitonException -->
  <class name="InvalidStateTransitonException" extends="org.apache.hadoop.yarn.exceptions.YarnRuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Use {@link InvalidStateTransitionException} instead.">
    <constructor name="InvalidStateTransitonException" type="java.lang.Enum, java.lang.Enum"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCurrentState" return="java.lang.Enum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEvent" return="java.lang.Enum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[@deprecated Use {@link InvalidStateTransitionException} instead.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.state.InvalidStateTransitonException -->
  <!-- start interface org.apache.hadoop.yarn.state.MultipleArcTransition -->
  <interface name="MultipleArcTransition"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="transition" return="STATE"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operand" type="OPERAND"/>
      <param name="event" type="EVENT"/>
      <doc>
      <![CDATA[Transition hook.
 @return the postState. Post state must be one of the 
                      valid post states registered in StateMachine.
 @param operand the entity attached to the FSM, whose internal 
                state may change.
 @param event causal event]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Hook for Transition. 
 Post state is decided by Transition hook. Post state must be one of the 
 valid post states registered in StateMachine.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.yarn.state.MultipleArcTransition -->
  <!-- start interface org.apache.hadoop.yarn.state.SingleArcTransition -->
  <interface name="SingleArcTransition"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="transition"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operand" type="OPERAND"/>
      <param name="event" type="EVENT"/>
      <doc>
      <![CDATA[Transition hook.
 
 @param operand the entity attached to the FSM, whose internal 
                state may change.
 @param event causal event]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Hook for Transition. This lead to state machine to move to 
 the post state as registered in the state machine.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.yarn.state.SingleArcTransition -->
  <!-- start interface org.apache.hadoop.yarn.state.StateMachine -->
  <interface name="StateMachine"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getCurrentState" return="STATE"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="doTransition" return="STATE"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="eventType" type="EVENTTYPE"/>
      <param name="event" type="EVENT"/>
      <exception name="InvalidStateTransitionException" type="org.apache.hadoop.yarn.state.InvalidStateTransitionException"/>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.yarn.state.StateMachine -->
  <!-- start class org.apache.hadoop.yarn.state.StateMachineFactory -->
  <class name="StateMachineFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="StateMachineFactory" type="STATE"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor

 This is the only constructor in the API.]]>
      </doc>
    </constructor>
    <method name="addTransition" return="org.apache.hadoop.yarn.state.StateMachineFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preState" type="STATE"/>
      <param name="postState" type="STATE"/>
      <param name="eventType" type="EVENTTYPE"/>
      <doc>
      <![CDATA[@return a NEW StateMachineFactory just like {@code this} with the current
          transition added as a new legal transition.  This overload
          has no hook object.

         Note that the returned StateMachineFactory is a distinct
         object.

         This method is part of the API.

 @param preState pre-transition state
 @param postState post-transition state
 @param eventType stimulus for the transition]]>
      </doc>
    </method>
    <method name="addTransition" return="org.apache.hadoop.yarn.state.StateMachineFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preState" type="STATE"/>
      <param name="postState" type="STATE"/>
      <param name="eventTypes" type="java.util.Set"/>
      <doc>
      <![CDATA[@return a NEW StateMachineFactory just like {@code this} with the current
          transition added as a new legal transition.  This overload
          has no hook object.


         Note that the returned StateMachineFactory is a distinct
         object.

         This method is part of the API.

 @param preState pre-transition state
 @param postState post-transition state
 @param eventTypes List of stimuli for the transitions]]>
      </doc>
    </method>
    <method name="addTransition" return="org.apache.hadoop.yarn.state.StateMachineFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preState" type="STATE"/>
      <param name="postState" type="STATE"/>
      <param name="eventTypes" type="java.util.Set"/>
      <param name="hook" type="org.apache.hadoop.yarn.state.SingleArcTransition"/>
      <doc>
      <![CDATA[@return a NEW StateMachineFactory just like {@code this} with the current
          transition added as a new legal transition

         Note that the returned StateMachineFactory is a distinct
         object.

         This method is part of the API.

 @param preState pre-transition state
 @param postState post-transition state
 @param eventTypes List of stimuli for the transitions
 @param hook transition hook]]>
      </doc>
    </method>
    <method name="addTransition" return="org.apache.hadoop.yarn.state.StateMachineFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preState" type="STATE"/>
      <param name="postState" type="STATE"/>
      <param name="eventType" type="EVENTTYPE"/>
      <param name="hook" type="org.apache.hadoop.yarn.state.SingleArcTransition"/>
      <doc>
      <![CDATA[@return a NEW StateMachineFactory just like {@code this} with the current
          transition added as a new legal transition

         Note that the returned StateMachineFactory is a distinct object.

         This method is part of the API.

 @param preState pre-transition state
 @param postState post-transition state
 @param eventType stimulus for the transition
 @param hook transition hook]]>
      </doc>
    </method>
    <method name="addTransition" return="org.apache.hadoop.yarn.state.StateMachineFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preState" type="STATE"/>
      <param name="postStates" type="java.util.Set"/>
      <param name="eventType" type="EVENTTYPE"/>
      <param name="hook" type="org.apache.hadoop.yarn.state.MultipleArcTransition"/>
      <doc>
      <![CDATA[@return a NEW StateMachineFactory just like {@code this} with the current
          transition added as a new legal transition

         Note that the returned StateMachineFactory is a distinct object.

         This method is part of the API.

 @param preState pre-transition state
 @param postStates valid post-transition states
 @param eventType stimulus for the transition
 @param hook transition hook]]>
      </doc>
    </method>
    <method name="installTopology" return="org.apache.hadoop.yarn.state.StateMachineFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return a StateMachineFactory just like {@code this}, except that if
         you won't need any synchronization to build a state machine

         Note that the returned StateMachineFactory is a distinct object.

         This method is part of the API.

         The only way you could distinguish the returned
         StateMachineFactory from {@code this} would be by
         measuring the performance of the derived 
         {@code StateMachine} you can get from it.

 Calling this is optional.  It doesn't change the semantics of the factory,
   if you call it then when you use the factory there is no synchronization.]]>
      </doc>
    </method>
    <method name="make" return="org.apache.hadoop.yarn.state.StateMachine"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operand" type="OPERAND"/>
      <param name="initialState" type="STATE"/>
      <param name="listener" type="org.apache.hadoop.yarn.state.StateTransitionListener"/>
      <doc>
      <![CDATA[A StateMachine that accepts a transition listener.
 @param operand the object upon which the returned
                {@link StateMachine} will operate.
 @param initialState the state in which the returned
                {@link StateMachine} will start.
 @param listener An implementation of a {@link StateTransitionListener}.
 @return A (@link StateMachine}.]]>
      </doc>
    </method>
    <method name="make" return="org.apache.hadoop.yarn.state.StateMachine"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operand" type="OPERAND"/>
      <param name="initialState" type="STATE"/>
    </method>
    <method name="make" return="org.apache.hadoop.yarn.state.StateMachine"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operand" type="OPERAND"/>
    </method>
    <method name="generateStateGraph" return="org.apache.hadoop.yarn.state.Graph"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Generate a graph represents the state graph of this StateMachine
 @param name graph name
 @return Graph object generated]]>
      </doc>
    </method>
    <doc>
    <![CDATA[State machine topology.
 This object is semantically immutable.  If you have a
 StateMachineFactory there's no operation in the API that changes
 its semantic properties.

 @param <OPERAND> The object type on which this state machine operates.
 @param <STATE> The state of the entity.
 @param <EVENTTYPE> The external eventType to be handled.
 @param <EVENT> The event object.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.state.StateMachineFactory -->
  <!-- start interface org.apache.hadoop.yarn.state.StateTransitionListener -->
  <interface name="StateTransitionListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="preTransition"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="op" type="OPERAND"/>
      <param name="beforeState" type="STATE"/>
      <param name="eventToBeProcessed" type="EVENT"/>
      <doc>
      <![CDATA[Pre Transition Hook. This will be called before transition.
 @param op Operand.
 @param beforeState State before transition.
 @param eventToBeProcessed Incoming Event.]]>
      </doc>
    </method>
    <method name="postTransition"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="op" type="OPERAND"/>
      <param name="beforeState" type="STATE"/>
      <param name="afterState" type="STATE"/>
      <param name="processedEvent" type="EVENT"/>
      <doc>
      <![CDATA[Post Transition Hook. This will be called after the transition.
 @param op Operand.
 @param beforeState State before transition.
 @param afterState State after transition.
 @param processedEvent Processed Event.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A State Transition Listener.
 It exposes a pre and post transition hook called before and
 after the transition.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.yarn.state.StateTransitionListener -->
</package>
<package name="org.apache.hadoop.yarn.util">
  <!-- start class org.apache.hadoop.yarn.util.AbstractLivelinessMonitor -->
  <class name="AbstractLivelinessMonitor" extends="org.apache.hadoop.service.AbstractService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractLivelinessMonitor" type="java.lang.String, org.apache.hadoop.yarn.util.Clock"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AbstractLivelinessMonitor" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="serviceStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="serviceStop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="expire"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="ob" type="O"/>
    </method>
    <method name="setExpireInterval"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="expireInterval" type="int"/>
    </method>
    <method name="getExpireInterval" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="o" type="O"/>
    </method>
    <method name="setMonitorInterval"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="monitorInterval" type="long"/>
    </method>
    <method name="receivedPing"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ob" type="O"/>
    </method>
    <method name="register"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ob" type="O"/>
    </method>
    <method name="register"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ob" type="O"/>
      <param name="expireTime" type="long"/>
    </method>
    <method name="unregister"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ob" type="O"/>
    </method>
    <method name="resetTimer"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setResetTimeOnStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="resetTimeOnStart" type="boolean"/>
    </method>
    <field name="DEFAULT_EXPIRE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A simple liveliness monitor with which clients can register, trust the
 component to monitor liveliness, get a call-back on expiry and then finally
 unregister.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.util.AbstractLivelinessMonitor -->
  <!-- start class org.apache.hadoop.yarn.util.ApplicationClassLoader -->
  <class name="ApplicationClassLoader" extends="org.apache.hadoop.util.ApplicationClassLoader"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ApplicationClassLoader" type="java.net.URL[], java.lang.ClassLoader, java.util.List"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ApplicationClassLoader" type="java.lang.String, java.lang.ClassLoader, java.util.List"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="MalformedURLException" type="java.net.MalformedURLException"/>
    </constructor>
    <doc>
    <![CDATA[This type has been deprecated in favor of
 {@link org.apache.hadoop.util.ApplicationClassLoader}. All new uses of
 ApplicationClassLoader should use that type instead.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.util.ApplicationClassLoader -->
  <!-- start class org.apache.hadoop.yarn.util.BoundedAppender -->
  <class name="BoundedAppender" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BoundedAppender" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append" return="org.apache.hadoop.yarn.util.BoundedAppender"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="csq" type="java.lang.CharSequence"/>
      <doc>
      <![CDATA[Append a {@link CharSequence} considering {@link #limit}, truncating
 from the head of {@code csq} or {@link #messages} when necessary.

 @param csq the {@link CharSequence} to append
 @return this]]>
      </doc>
    </method>
    <method name="length" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get current length of messages considering truncates
 without header and ellipses.

 @return current length]]>
      </doc>
    </method>
    <method name="getLimit" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a string representation of the actual contents, displaying also a
 header and ellipses when there was a truncate.

 @return String representation of the {@link #messages}]]>
      </doc>
    </method>
    <field name="TRUNCATED_MESSAGES_TEMPLATE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A {@link CharSequence} appender that considers its {@link #limit} as upper
 bound.
 <p>
 When {@link #limit} would be reached on append, past messages will be
 truncated from head, and a header telling the user about truncation will be
 prepended, with ellipses in between header and messages.
 <p>
 Note that header and ellipses are not counted against {@link #limit}.
 <p>
 An example:

 <pre>
 {@code
   // At the beginning it's an empty string
   final Appendable shortAppender = new BoundedAppender(80);
   // The whole message fits into limit
   shortAppender.append(
       "message1 this is a very long message but fitting into limit\n");
   // The first message is truncated, the second not
   shortAppender.append("message2 this is shorter than the previous one\n");
   // The first message is deleted, the second truncated, the third
   // preserved
   shortAppender.append("message3 this is even shorter message, maybe.\n");
   // The first two are deleted, the third one truncated, the last preserved
   shortAppender.append("message4 the shortest one, yet the greatest :)");
   // Current contents are like this:
   // Diagnostic messages truncated, showing last 80 chars out of 199:
   // ...s is even shorter message, maybe.
   // message4 the shortest one, yet the greatest :)
 }
 </pre>
 <p>
 Note that <tt>null</tt> values are {@link #append(CharSequence) append}ed
 just like in {@link StringBuilder#append(CharSequence) original
 implementation}.
 <p>
 Note that this class is not thread safe.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.util.BoundedAppender -->
  <!-- start interface org.apache.hadoop.yarn.util.Clock -->
  <interface name="Clock"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getTime" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A simple clock interface that gives you time.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.yarn.util.Clock -->
  <!-- start class org.apache.hadoop.yarn.util.ConverterUtils -->
  <class name="ConverterUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConverterUtils"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPathFromYarnURL" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="org.apache.hadoop.yarn.api.records.URL"/>
      <exception name="URISyntaxException" type="java.net.URISyntaxException"/>
      <doc>
      <![CDATA[return a hadoop path from a given url
 This method is deprecated, use {@link URL#toPath()} instead.
 
 @param url
          url to convert
 @return path from {@link URL}
 @throws URISyntaxException]]>
      </doc>
    </method>
    <method name="getYarnUrlFromPath" return="org.apache.hadoop.yarn.api.records.URL"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="getYarnUrlFromURI" return="org.apache.hadoop.yarn.api.records.URL"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
    </method>
    <method name="toApplicationId" return="org.apache.hadoop.yarn.api.records.ApplicationId"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recordFactory" type="org.apache.hadoop.yarn.factories.RecordFactory"/>
      <param name="applicationIdStr" type="java.lang.String"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cId" type="org.apache.hadoop.yarn.api.records.ContainerId"/>
    </method>
    <method name="toNodeId" return="org.apache.hadoop.yarn.api.records.NodeId"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nodeIdStr" type="java.lang.String"/>
    </method>
    <method name="toContainerId" return="org.apache.hadoop.yarn.api.records.ContainerId"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="containerIdStr" type="java.lang.String"/>
    </method>
    <method name="toApplicationAttemptId" return="org.apache.hadoop.yarn.api.records.ApplicationAttemptId"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="applicationAttemptIdStr" type="java.lang.String"/>
    </method>
    <method name="toApplicationId" return="org.apache.hadoop.yarn.api.records.ApplicationId"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appIdStr" type="java.lang.String"/>
    </method>
    <method name="convertFromYarn" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protoToken" type="org.apache.hadoop.yarn.api.records.Token"/>
      <param name="serviceAddr" type="java.net.InetSocketAddress"/>
      <doc>
      <![CDATA[Convert a protobuf token into a rpc token and set its service. Supposed
 to be used for tokens other than RMDelegationToken. For
 RMDelegationToken, use
 {@link #convertFromYarn(org.apache.hadoop.yarn.api.records.Token,
 org.apache.hadoop.io.Text)} instead.

 @param protoToken the yarn token
 @param serviceAddr the connect address for the service
 @return rpc token]]>
      </doc>
    </method>
    <method name="convertFromYarn" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protoToken" type="org.apache.hadoop.yarn.api.records.Token"/>
      <param name="service" type="org.apache.hadoop.io.Text"/>
      <doc>
      <![CDATA[Convert a protobuf token into a rpc token and set its service.

 @param protoToken the yarn token
 @param service the service for the token]]>
      </doc>
    </method>
    <field name="APPLICATION_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CONTAINER_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="APPLICATION_ATTEMPT_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This class contains a set of utilities which help converting data structures
 from/to 'serializableFormat' to/from hadoop/nativejava data structures.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.util.ConverterUtils -->
  <!-- start class org.apache.hadoop.yarn.util.MonotonicClock -->
  <class name="MonotonicClock" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.yarn.util.Clock"/>
    <constructor name="MonotonicClock"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get current time from some arbitrary time base in the past, counting in
 milliseconds, and not affected by settimeofday or similar system clock
 changes.
 @return a monotonic clock that counts in milliseconds.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A monotonic clock from some arbitrary time base in the past, counting in
 milliseconds, and not affected by settimeofday or similar system clock
 changes.
 This is appropriate to use when computing how much longer to wait for an
 interval to expire.
 This function can return a negative value and it must be handled correctly
 by callers. See the documentation of System#nanoTime for caveats.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.util.MonotonicClock -->
  <!-- start class org.apache.hadoop.yarn.util.ResourceCalculatorProcessTree -->
  <class name="ResourceCalculatorProcessTree" extends="org.apache.hadoop.conf.Configured"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ResourceCalculatorProcessTree" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create process-tree instance with specified root process.

 Subclass must override this.
 @param root process-tree root-process]]>
      </doc>
    </constructor>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="YarnException" type="org.apache.hadoop.yarn.exceptions.YarnException"/>
      <doc>
      <![CDATA[Initialize the object.
 @throws YarnException Throws an exception on error.]]>
      </doc>
    </method>
    <method name="updateProcessTree"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Update the process-tree with latest state.

 Each call to this function should increment the age of the running
 processes that already exist in the process tree. Age is used other API's
 of the interface.]]>
      </doc>
    </method>
    <method name="getProcessTreeDump" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a dump of the process-tree.

 @return a string concatenating the dump of information of all the processes
         in the process-tree]]>
      </doc>
    </method>
    <method name="getVirtualMemorySize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the virtual memory used by all the processes in the
 process-tree.

 @return virtual memory used by the process-tree in bytes,
 {@link #UNAVAILABLE} if it cannot be calculated.]]>
      </doc>
    </method>
    <method name="getRssMemorySize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the resident set size (rss) memory used by all the processes
 in the process-tree.

 @return rss memory used by the process-tree in bytes,
 {@link #UNAVAILABLE} if it cannot be calculated.]]>
      </doc>
    </method>
    <method name="getVirtualMemorySize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="olderThanAge" type="int"/>
      <doc>
      <![CDATA[Get the virtual memory used by all the processes in the
 process-tree that are older than the passed in age.

 @param olderThanAge processes above this age are included in the
                     memory addition
 @return virtual memory used by the process-tree in bytes for
 processes older than the specified age, {@link #UNAVAILABLE} if it
 cannot be calculated.]]>
      </doc>
    </method>
    <method name="getRssMemorySize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="olderThanAge" type="int"/>
      <doc>
      <![CDATA[Get the resident set size (rss) memory used by all the processes
 in the process-tree that are older than the passed in age.

 @param olderThanAge processes above this age are included in the
                     memory addition
 @return rss memory used by the process-tree in bytes for
 processes older than specified age, {@link #UNAVAILABLE} if it cannot be
 calculated.]]>
      </doc>
    </method>
    <method name="getCumulativeCpuTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the CPU time in millisecond used by all the processes in the
 process-tree since the process-tree was created

 @return cumulative CPU time in millisecond since the process-tree
 created, {@link #UNAVAILABLE} if it cannot be calculated.]]>
      </doc>
    </method>
    <method name="getCpuUsagePercent" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the CPU usage by all the processes in the process-tree based on
 average between samples as a ratio of overall CPU cycles similar to top.
 Thus, if 2 out of 4 cores are used this should return 200.0.
 Note: UNAVAILABLE will be returned in case when CPU usage is not
 available. It is NOT advised to return any other error code.

 @return percentage CPU usage since the process-tree was created,
 {@link #UNAVAILABLE} if CPU usage cannot be calculated or not available.]]>
      </doc>
    </method>
    <method name="checkPidPgrpidForMatch" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Verify that the tree process id is same as its process group id.
 @return true if the process id matches else return false.]]>
      </doc>
    </method>
    <method name="getResourceCalculatorProcessTree" return="org.apache.hadoop.yarn.util.ResourceCalculatorProcessTree"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pid" type="java.lang.String"/>
      <param name="clazz" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Create the ResourceCalculatorProcessTree rooted to specified process 
 from the class name and configure it. If class name is null, this method
 will try and return a process tree plugin available for this system.

 @param pid process pid of the root of the process tree
 @param clazz class-name
 @param conf configure the plugin with this.

 @return ResourceCalculatorProcessTree or null if ResourceCalculatorPluginTree
         is not available for this system.]]>
      </doc>
    </method>
    <field name="UNAVAILABLE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Interface class to obtain process resource usage
 NOTE: This class should not be used by external users, but only by external
 developers to extend and include their own process-tree implementation, 
 especially for platforms other than Linux and Windows.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.util.ResourceCalculatorProcessTree -->
  <!-- start class org.apache.hadoop.yarn.util.SystemClock -->
  <class name="SystemClock" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.yarn.util.Clock"/>
    <constructor name="SystemClock"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getInstance" return="org.apache.hadoop.yarn.util.SystemClock"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Implementation of {@link Clock} that gives the current time from the system
 clock in milliseconds.
 
 NOTE: Do not use this to calculate a duration of expire or interval to sleep,
 because it will be broken by settimeofday. Please use {@link MonotonicClock}
 instead.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.util.SystemClock -->
  <!-- start class org.apache.hadoop.yarn.util.UTCClock -->
  <class name="UTCClock" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.yarn.util.Clock"/>
    <constructor name="UTCClock"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Implementation of {@link Clock} that gives the current UTC time in
 milliseconds.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.util.UTCClock -->
</package>
<package name="org.apache.hadoop.yarn.util.resource">
</package>
<package name="org.apache.hadoop.yarn.util.timeline">
  <!-- start class org.apache.hadoop.yarn.util.timeline.TimelineUtils -->
  <class name="TimelineUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TimelineUtils"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="dumpTimelineRecordtoJSON" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <exception name="JsonGenerationException" type="com.fasterxml.jackson.core.JsonGenerationException"/>
      <exception name="JsonMappingException" type="com.fasterxml.jackson.databind.JsonMappingException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serialize a POJO object into a JSON string not in a pretty format
 
 @param o
          an object to serialize
 @return a JSON string
 @throws IOException
 @throws JsonMappingException
 @throws JsonGenerationException]]>
      </doc>
    </method>
    <method name="dumpTimelineRecordtoJSON" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <param name="pretty" type="boolean"/>
      <exception name="JsonGenerationException" type="com.fasterxml.jackson.core.JsonGenerationException"/>
      <exception name="JsonMappingException" type="com.fasterxml.jackson.databind.JsonMappingException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serialize a POJO object into a JSON string
 
 @param o
          an object to serialize
 @param pretty
          whether in a pretty format or not
 @return a JSON string
 @throws IOException
 @throws JsonMappingException
 @throws JsonGenerationException]]>
      </doc>
    </method>
    <method name="timelineServiceEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Returns whether the timeline service is enabled via configuration.

 @param conf the configuration
 @return whether the timeline service is enabled.]]>
      </doc>
    </method>
    <method name="getTimelineServiceVersion" return="float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Returns the timeline service version. It does not check whether the
 timeline service itself is enabled.

 @param conf the configuration
 @return the timeline service version as a float.]]>
      </doc>
    </method>
    <method name="timelineServiceV1_5Enabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Returns whether the timeline service v.1.5 is enabled by default via
 configuration.

 @param conf the configuration
 @return whether the timeline service v.1.5 is enabled. V.1.5 refers to a
 version equal to 1.5.]]>
      </doc>
    </method>
    <method name="createTimelineAbout" return="org.apache.hadoop.yarn.api.records.timeline.TimelineAbout"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="about" type="java.lang.String"/>
    </method>
    <method name="getTimelineTokenServiceAddress" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="buildTimelineTokenService" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="generateDefaultFlowName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="appName" type="java.lang.String"/>
      <param name="appId" type="org.apache.hadoop.yarn.api.records.ApplicationId"/>
    </method>
    <method name="generateFlowNameTag" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flowName" type="java.lang.String"/>
      <doc>
      <![CDATA[Generate flow name tag.

 @param flowName flow name that identifies a distinct flow application which
                 can be run repeatedly over time
 @return flow name tag.]]>
      </doc>
    </method>
    <method name="shortenFlowName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flowName" type="java.lang.String"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Shortens the flow name for the configured size by removing UUID if present.

 @param flowName which has to be shortened
 @param conf to resize the flow name
 @return shortened flowName]]>
      </doc>
    </method>
    <method name="generateFlowVersionTag" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flowVersion" type="java.lang.String"/>
      <doc>
      <![CDATA[Generate flow version tag.

 @param flowVersion flow version that keeps track of the changes made to the
                    flow
 @return flow version tag.]]>
      </doc>
    </method>
    <method name="generateFlowRunIdTag" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flowRunId" type="long"/>
      <doc>
      <![CDATA[Generate flow run ID tag.

 @param flowRunId flow run ID that identifies one instance (or specific
                  execution) of that flow
 @return flow run id tag.]]>
      </doc>
    </method>
    <field name="FLOW_NAME_TAG_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FLOW_VERSION_TAG_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FLOW_RUN_ID_TAG_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_FLOW_VERSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[The helper class for the timeline module.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.yarn.util.timeline.TimelineUtils -->
</package>
<package name="org.apache.hadoop.yarn.webapp.util">
</package>

</api>
