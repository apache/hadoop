<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Tue Mar 14 18:21:54 UTC 2023 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="Apache Hadoop Common 3.3.5"
  jdversion="1.0.9">

<!--  Command line arguments =  -doclet org.apache.hadoop.classification.tools.IncludePublicAnnotationsJDiffDoclet -docletpath /build/source/hadoop-common-project/hadoop-common/target/hadoop-annotations.jar:/build/source/hadoop-common-project/hadoop-common/target/jdiff.jar -verbose -classpath /build/source/hadoop-common-project/hadoop-common/target/classes:/maven/org/apache/hadoop/thirdparty/hadoop-shaded-protobuf_3_7/1.1.1/hadoop-shaded-protobuf_3_7-1.1.1.jar:/build/source/hadoop-common-project/hadoop-annotations/target/hadoop-annotations-3.3.5.jar:/usr/lib/jvm/java-8-openjdk-arm64/lib/tools.jar:/maven/org/apache/hadoop/thirdparty/hadoop-shaded-guava/1.1.1/hadoop-shaded-guava-1.1.1.jar:/maven/com/google/guava/guava/27.0-jre/guava-27.0-jre.jar:/maven/com/google/guava/failureaccess/1.0/failureaccess-1.0.jar:/maven/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/maven/org/checkerframework/checker-qual/2.5.2/checker-qual-2.5.2.jar:/maven/com/google/j2objc/j2objc-annotations/1.1/j2objc-annotations-1.1.jar:/maven/org/codehaus/mojo/animal-sniffer-annotations/1.17/animal-sniffer-annotations-1.17.jar:/maven/commons-cli/commons-cli/1.2/commons-cli-1.2.jar:/maven/org/apache/commons/commons-math3/3.1.1/commons-math3-3.1.1.jar:/maven/org/apache/httpcomponents/httpclient/4.5.13/httpclient-4.5.13.jar:/maven/org/apache/httpcomponents/httpcore/4.4.13/httpcore-4.4.13.jar:/maven/commons-codec/commons-codec/1.15/commons-codec-1.15.jar:/maven/commons-io/commons-io/2.8.0/commons-io-2.8.0.jar:/maven/commons-net/commons-net/3.9.0/commons-net-3.9.0.jar:/maven/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/maven/javax/servlet/javax.servlet-api/3.1.0/javax.servlet-api-3.1.0.jar:/maven/org/eclipse/jetty/jetty-server/9.4.48.v20220622/jetty-server-9.4.48.v20220622.jar:/maven/org/eclipse/jetty/jetty-http/9.4.48.v20220622/jetty-http-9.4.48.v20220622.jar:/maven/org/eclipse/jetty/jetty-io/9.4.48.v20220622/jetty-io-9.4.48.v20220622.jar:/maven/org/eclipse/jetty/jetty-util/9.4.48.v20220622/jetty-util-9.4.48.v20220622.jar:/maven/org/eclipse/jetty/jetty-servlet/9.4.48.v20220622/jetty-servlet-9.4.48.v20220622.jar:/maven/org/eclipse/jetty/jetty-security/9.4.48.v20220622/jetty-security-9.4.48.v20220622.jar:/maven/org/eclipse/jetty/jetty-webapp/9.4.48.v20220622/jetty-webapp-9.4.48.v20220622.jar:/maven/org/eclipse/jetty/jetty-xml/9.4.48.v20220622/jetty-xml-9.4.48.v20220622.jar:/maven/com/sun/jersey/jersey-core/1.19.4/jersey-core-1.19.4.jar:/maven/javax/ws/rs/jsr311-api/1.1.1/jsr311-api-1.1.1.jar:/maven/com/sun/jersey/jersey-servlet/1.19.4/jersey-servlet-1.19.4.jar:/maven/com/github/pjfanning/jersey-json/1.20/jersey-json-1.20.jar:/maven/org/codehaus/jettison/jettison/1.5.3/jettison-1.5.3.jar:/maven/com/sun/xml/bind/jaxb-impl/2.2.3-1/jaxb-impl-2.2.3-1.jar:/maven/javax/xml/bind/jaxb-api/2.2.11/jaxb-api-2.2.11.jar:/maven/com/sun/jersey/jersey-server/1.19.4/jersey-server-1.19.4.jar:/maven/commons-logging/commons-logging/1.1.3/commons-logging-1.1.3.jar:/maven/ch/qos/reload4j/reload4j/1.2.22/reload4j-1.2.22.jar:/maven/commons-beanutils/commons-beanutils/1.9.4/commons-beanutils-1.9.4.jar:/maven/org/apache/commons/commons-configuration2/2.8.0/commons-configuration2-2.8.0.jar:/maven/org/apache/commons/commons-lang3/3.12.0/commons-lang3-3.12.0.jar:/maven/org/apache/commons/commons-text/1.10.0/commons-text-1.10.0.jar:/maven/org/slf4j/slf4j-api/1.7.36/slf4j-api-1.7.36.jar:/maven/org/slf4j/slf4j-reload4j/1.7.36/slf4j-reload4j-1.7.36.jar:/maven/org/apache/avro/avro/1.7.7/avro-1.7.7.jar:/maven/org/codehaus/jackson/jackson-core-asl/1.9.13/jackson-core-asl-1.9.13.jar:/maven/org/codehaus/jackson/jackson-mapper-asl/1.9.13/jackson-mapper-asl-1.9.13.jar:/maven/com/thoughtworks/paranamer/paranamer/2.3/paranamer-2.3.jar:/maven/com/google/re2j/re2j/1.1/re2j-1.1.jar:/maven/com/google/protobuf/protobuf-java/2.5.0/protobuf-java-2.5.0.jar:/maven/com/google/code/gson/gson/2.9.0/gson-2.9.0.jar:/build/source/hadoop-common-project/hadoop-auth/target/hadoop-auth-3.3.5.jar:/maven/com/nimbusds/nimbus-jose-jwt/9.8.1/nimbus-jose-jwt-9.8.1.jar:/maven/com/github/stephenc/jcip/jcip-annotations/1.0-1/jcip-annotations-1.0-1.jar:/maven/net/minidev/json-smart/2.4.7/json-smart-2.4.7.jar:/maven/net/minidev/accessors-smart/2.4.7/accessors-smart-2.4.7.jar:/maven/org/ow2/asm/asm/5.0.4/asm-5.0.4.jar:/maven/org/apache/curator/curator-framework/4.2.0/curator-framework-4.2.0.jar:/maven/org/apache/kerby/kerb-simplekdc/1.0.1/kerb-simplekdc-1.0.1.jar:/maven/org/apache/kerby/kerb-client/1.0.1/kerb-client-1.0.1.jar:/maven/org/apache/kerby/kerby-config/1.0.1/kerby-config-1.0.1.jar:/maven/org/apache/kerby/kerb-common/1.0.1/kerb-common-1.0.1.jar:/maven/org/apache/kerby/kerb-crypto/1.0.1/kerb-crypto-1.0.1.jar:/maven/org/apache/kerby/kerb-util/1.0.1/kerb-util-1.0.1.jar:/maven/org/apache/kerby/token-provider/1.0.1/token-provider-1.0.1.jar:/maven/org/apache/kerby/kerb-admin/1.0.1/kerb-admin-1.0.1.jar:/maven/org/apache/kerby/kerb-server/1.0.1/kerb-server-1.0.1.jar:/maven/org/apache/kerby/kerb-identity/1.0.1/kerb-identity-1.0.1.jar:/maven/org/apache/kerby/kerby-xdr/1.0.1/kerby-xdr-1.0.1.jar:/maven/com/jcraft/jsch/0.1.55/jsch-0.1.55.jar:/maven/org/apache/curator/curator-client/4.2.0/curator-client-4.2.0.jar:/maven/org/apache/curator/curator-recipes/4.2.0/curator-recipes-4.2.0.jar:/maven/com/google/code/findbugs/jsr305/3.0.2/jsr305-3.0.2.jar:/maven/org/apache/zookeeper/zookeeper/3.5.6/zookeeper-3.5.6.jar:/maven/org/apache/zookeeper/zookeeper-jute/3.5.6/zookeeper-jute-3.5.6.jar:/maven/org/apache/yetus/audience-annotations/0.5.0/audience-annotations-0.5.0.jar:/maven/org/apache/commons/commons-compress/1.21/commons-compress-1.21.jar:/maven/org/apache/kerby/kerb-core/1.0.1/kerb-core-1.0.1.jar:/maven/org/apache/kerby/kerby-pkix/1.0.1/kerby-pkix-1.0.1.jar:/maven/org/apache/kerby/kerby-asn1/1.0.1/kerby-asn1-1.0.1.jar:/maven/org/apache/kerby/kerby-util/1.0.1/kerby-util-1.0.1.jar:/maven/com/fasterxml/jackson/core/jackson-databind/2.12.7.1/jackson-databind-2.12.7.1.jar:/maven/com/fasterxml/jackson/core/jackson-annotations/2.12.7/jackson-annotations-2.12.7.jar:/maven/com/fasterxml/jackson/core/jackson-core/2.12.7/jackson-core-2.12.7.jar:/maven/org/codehaus/woodstox/stax2-api/4.2.1/stax2-api-4.2.1.jar:/maven/com/fasterxml/woodstox/woodstox-core/5.4.0/woodstox-core-5.4.0.jar:/maven/dnsjava/dnsjava/2.1.7/dnsjava-2.1.7.jar:/maven/org/wildfly/openssl/wildfly-openssl-java/1.1.3.Final/wildfly-openssl-java-1.1.3.Final.jar:/maven/org/xerial/snappy/snappy-java/1.1.8.2/snappy-java-1.1.8.2.jar:/maven/org/lz4/lz4-java/1.7.1/lz4-java-1.7.1.jar:/maven/xerces/xercesImpl/2.12.2/xercesImpl-2.12.2.jar:/maven/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar -sourcepath /build/source/hadoop-common-project/hadoop-common/src/main/java -doclet org.apache.hadoop.classification.tools.IncludePublicAnnotationsJDiffDoclet -docletpath /build/source/hadoop-common-project/hadoop-common/target/hadoop-annotations.jar:/build/source/hadoop-common-project/hadoop-common/target/jdiff.jar -apidir /build/source/hadoop-common-project/hadoop-common/target/site/jdiff/xml -apiname Apache Hadoop Common 3.3.5 -->
<package name="org.apache.hadoop">
  <!-- start class org.apache.hadoop.HadoopIllegalArgumentException -->
  <class name="HadoopIllegalArgumentException" extends="java.lang.IllegalArgumentException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HadoopIllegalArgumentException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs exception with the specified detail message. 
 @param message detailed message.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Indicates that a method has been passed illegal or invalid argument. This
 exception is thrown instead of IllegalArgumentException to differentiate the
 exception thrown in Hadoop implementation from the one thrown in JDK.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.HadoopIllegalArgumentException -->
</package>
<package name="org.apache.hadoop.conf">
  <!-- start interface org.apache.hadoop.conf.Configurable -->
  <interface name="Configurable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setConf"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Set the configuration to be used by this object.
 @param conf configuration to be used]]>
      </doc>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the configuration used by this object.
 @return Configuration]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Something that may be configured with a {@link Configuration}.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.conf.Configurable -->
  <!-- start class org.apache.hadoop.conf.Configuration -->
  <class name="Configuration" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Iterable"/>
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A new configuration.]]>
      </doc>
    </constructor>
    <constructor name="Configuration" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A new configuration where the behavior of reading from the default 
 resources can be turned off.
 
 If the parameter {@code loadDefaults} is false, the new instance
 will not load resources from the default files. 
 @param loadDefaults specifies whether to load from the default files]]>
      </doc>
    </constructor>
    <constructor name="Configuration" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A new configuration with the same settings cloned from another.
 
 @param other the configuration from which to clone settings.]]>
      </doc>
    </constructor>
    <method name="addDeprecations"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deltas" type="org.apache.hadoop.conf.Configuration.DeprecationDelta[]"/>
      <doc>
      <![CDATA[Adds a set of deprecated keys to the global deprecations.

 This method is lockless.  It works by means of creating a new
 DeprecationContext based on the old one, and then atomically swapping in
 the new context.  If someone else updated the context in between us reading
 the old context and swapping in the new one, we try again until we win the
 race.

 @param deltas   The deprecations to add.]]>
      </doc>
    </method>
    <method name="addDeprecation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use {@link #addDeprecation(String key, String newKey,
      String customMessage)} instead">
      <param name="key" type="java.lang.String"/>
      <param name="newKeys" type="java.lang.String[]"/>
      <param name="customMessage" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds the deprecated key to the global deprecation map.
 It does not override any existing entries in the deprecation map.
 This is to be used only by the developers in order to add deprecation of
 keys, and attempts to call this method after loading resources once,
 would lead to <tt>UnsupportedOperationException</tt>
 
 If a key is deprecated in favor of multiple keys, they are all treated as 
 aliases of each other, and setting any one of them resets all the others 
 to the new value.

 If you have multiple deprecation entries to add, it is more efficient to
 use #addDeprecations(DeprecationDelta[] deltas) instead.
 
 @param key to be deprecated
 @param newKeys list of keys that take up the values of deprecated key
 @param customMessage depcrication message
 @deprecated use {@link #addDeprecation(String key, String newKey,
      String customMessage)} instead]]>
      </doc>
    </method>
    <method name="addDeprecation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="newKey" type="java.lang.String"/>
      <param name="customMessage" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds the deprecated key to the global deprecation map.
 It does not override any existing entries in the deprecation map.
 This is to be used only by the developers in order to add deprecation of
 keys, and attempts to call this method after loading resources once,
 would lead to <tt>UnsupportedOperationException</tt>
 
 If you have multiple deprecation entries to add, it is more efficient to
 use #addDeprecations(DeprecationDelta[] deltas) instead.

 @param key to be deprecated
 @param newKey key that take up the values of deprecated key
 @param customMessage deprecation message]]>
      </doc>
    </method>
    <method name="addDeprecation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use {@link #addDeprecation(String key, String newKey)} instead">
      <param name="key" type="java.lang.String"/>
      <param name="newKeys" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Adds the deprecated key to the global deprecation map when no custom
 message is provided.
 It does not override any existing entries in the deprecation map.
 This is to be used only by the developers in order to add deprecation of
 keys, and attempts to call this method after loading resources once,
 would lead to <tt>UnsupportedOperationException</tt>
 
 If a key is deprecated in favor of multiple keys, they are all treated as 
 aliases of each other, and setting any one of them resets all the others 
 to the new value.
 
 If you have multiple deprecation entries to add, it is more efficient to
 use #addDeprecations(DeprecationDelta[] deltas) instead.

 @param key Key that is to be deprecated
 @param newKeys list of keys that take up the values of deprecated key
 @deprecated use {@link #addDeprecation(String key, String newKey)} instead]]>
      </doc>
    </method>
    <method name="addDeprecation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="newKey" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds the deprecated key to the global deprecation map when no custom
 message is provided.
 It does not override any existing entries in the deprecation map.
 This is to be used only by the developers in order to add deprecation of
 keys, and attempts to call this method after loading resources once,
 would lead to <tt>UnsupportedOperationException</tt>
 
 If you have multiple deprecation entries to add, it is more efficient to
 use #addDeprecations(DeprecationDelta[] deltas) instead.

 @param key Key that is to be deprecated
 @param newKey key that takes up the value of deprecated key]]>
      </doc>
    </method>
    <method name="isDeprecated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[checks whether the given <code>key</code> is deprecated.
 
 @param key the parameter which is to be checked for deprecation
 @return <code>true</code> if the key is deprecated and 
         <code>false</code> otherwise.]]>
      </doc>
    </method>
    <method name="setDeprecatedProperties"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sets all deprecated properties that are not currently set but have a
 corresponding new property that is set. Useful for iterating the
 properties when all deprecated properties for currently set properties
 need to be present.]]>
      </doc>
    </method>
    <method name="reloadExistingConfigurations"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reload existing configuration instances.]]>
      </doc>
    </method>
    <method name="addDefaultResource"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a default resource. Resources are loaded in the order of the resources 
 added.
 @param name file name. File should be present in the classpath.]]>
      </doc>
    </method>
    <method name="setRestrictSystemPropertiesDefault"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="boolean"/>
    </method>
    <method name="setRestrictSystemProperties"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="boolean"/>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 @param name resource to be added, the classpath is examined for a file 
             with that name.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="restrictedParser" type="boolean"/>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 @param url url of the resource to be added, the local filesystem is 
            examined directly to find the resource, without referring to 
            the classpath.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="restrictedParser" type="boolean"/>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 @param file file-path of resource to be added, the local filesystem is
             examined directly to find the resource, without referring to 
             the classpath.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="restrictedParser" type="boolean"/>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 WARNING: The contents of the InputStream will be cached, by this method. 
 So use this sparingly because it does increase the memory consumption.
 
 @param in InputStream to deserialize the object from. In will be read from
 when a get or set is called next.  After it is read the stream will be
 closed.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="restrictedParser" type="boolean"/>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 @param in InputStream to deserialize the object from.
 @param name the name of the resource because InputStream.toString is not
 very descriptive some times.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="name" type="java.lang.String"/>
      <param name="restrictedParser" type="boolean"/>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Add a configuration resource.

 The properties of this resource will override properties of previously
 added resources, unless they were marked <a href="#Final">final</a>.

 @param conf Configuration object from which to load properties]]>
      </doc>
    </method>
    <method name="reloadConfiguration"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reload configuration from previously added resources.

 This method will clear all the configuration read from the added 
 resources, and final parameters. This will make the resources to 
 be read again before accessing the values. Values that are added
 via set methods will overlay values read from the resources.]]>
      </doc>
    </method>
    <method name="get" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property, <code>null</code> if
 no such property exists. If the key is deprecated, it returns the value of
 the first key which replaces the deprecated key and is not null.
 
 Values are processed for <a href="#VariableExpansion">variable expansion</a> 
 before being returned.

 As a side effect get loads the properties from the sources if called for
 the first time as a lazy init.
 
 @param name the property name, will be trimmed before get value.
 @return the value of the <code>name</code> or its replacing property, 
         or null if no such property exists.]]>
      </doc>
    </method>
    <method name="setAllowNullValueProperties"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="boolean"/>
      <doc>
      <![CDATA[Set Configuration to allow keys without values during setup.  Intended
 for use during testing.

 @param val If true, will allow Configuration to store keys without values]]>
      </doc>
    </method>
    <method name="setRestrictSystemProps"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="boolean"/>
    </method>
    <method name="onlyKeyExists" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Return existence of the <code>name</code> property, but only for
 names which have no valid value, usually non-existent or commented
 out in XML.

 @param name the property name
 @return true if the property <code>name</code> exists without value]]>
      </doc>
    </method>
    <method name="getTrimmed" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a trimmed <code>String</code>, 
 <code>null</code> if no such property exists. 
 If the key is deprecated, it returns the value of
 the first key which replaces the deprecated key and is not null
 
 Values are processed for <a href="#VariableExpansion">variable expansion</a> 
 before being returned. 
 
 @param name the property name.
 @return the value of the <code>name</code> or its replacing property, 
         or null if no such property exists.]]>
      </doc>
    </method>
    <method name="getTrimmed" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a trimmed <code>String</code>, 
 <code>defaultValue</code> if no such property exists. 
 See @{Configuration#getTrimmed} for more details.
 
 @param name          the property name.
 @param defaultValue  the property default value.
 @return              the value of the <code>name</code> or defaultValue
                      if it is not set.]]>
      </doc>
    </method>
    <method name="getRaw" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property, without doing
 <a href="#VariableExpansion">variable expansion</a>.If the key is 
 deprecated, it returns the value of the first key which replaces 
 the deprecated key and is not null.
 
 @param name the property name.
 @return the value of the <code>name</code> property or 
         its replacing property and null if no such property exists.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the <code>value</code> of the <code>name</code> property. If 
 <code>name</code> is deprecated or there is a deprecated name associated to it,
 it sets the value to both names. Name will be trimmed before put into
 configuration.
 
 @param name property name.
 @param value property value.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <param name="source" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the <code>value</code> of the <code>name</code> property. If 
 <code>name</code> is deprecated, it also sets the <code>value</code> to
 the keys that replace the deprecated key. Name will be trimmed before put
 into configuration.

 @param name property name.
 @param value property value.
 @param source the place that this configuration value came from 
 (For debugging).
 @throws IllegalArgumentException when the value or name is null.]]>
      </doc>
    </method>
    <method name="unset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Unset a previously set property.
 @param name the property name]]>
      </doc>
    </method>
    <method name="setIfUnset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets a property if it is currently unset.
 @param name the property name
 @param value the new value]]>
      </doc>
    </method>
    <method name="get" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code>. If the key is deprecated,
 it returns the value of the first key which replaces the deprecated key
 and is not null.
 If no such property exists,
 then <code>defaultValue</code> is returned.
 
 @param name property name, will be trimmed before get value.
 @param defaultValue default value.
 @return property value, or <code>defaultValue</code> if the property 
         doesn't exist.]]>
      </doc>
    </method>
    <method name="getInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="int"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as an <code>int</code>.
   
 If no such property exists, the provided default value is returned,
 or if the specified value is not a valid <code>int</code>,
 then an error is thrown.
 
 @param name property name.
 @param defaultValue default value.
 @throws NumberFormatException when the value is invalid
 @return property value as an <code>int</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getInts" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a set of comma-delimited
 <code>int</code> values.
 
 If no such property exists, an empty array is returned.
 
 @param name property name
 @return property value interpreted as an array of comma-delimited
         <code>int</code> values]]>
      </doc>
    </method>
    <method name="setInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to an <code>int</code>.
 
 @param name property name.
 @param value <code>int</code> value of the property.]]>
      </doc>
    </method>
    <method name="getLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="long"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>long</code>.  
 If no such property exists, the provided default value is returned,
 or if the specified value is not a valid <code>long</code>,
 then an error is thrown.
 
 @param name property name.
 @param defaultValue default value.
 @throws NumberFormatException when the value is invalid
 @return property value as a <code>long</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getLongBytes" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="long"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>long</code> or
 human readable format. If no such property exists, the provided default
 value is returned, or if the specified value is not a valid
 <code>long</code> or human readable format, then an error is thrown. You
 can use the following suffix (case insensitive): k(kilo), m(mega), g(giga),
 t(tera), p(peta), e(exa)

 @param name property name.
 @param defaultValue default value.
 @throws NumberFormatException when the value is invalid
 @return property value as a <code>long</code>,
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to a <code>long</code>.
 
 @param name property name.
 @param value <code>long</code> value of the property.]]>
      </doc>
    </method>
    <method name="getFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="float"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>float</code>.  
 If no such property exists, the provided default value is returned,
 or if the specified value is not a valid <code>float</code>,
 then an error is thrown.

 @param name property name.
 @param defaultValue default value.
 @throws NumberFormatException when the value is invalid
 @return property value as a <code>float</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to a <code>float</code>.
 
 @param name property name.
 @param value property value.]]>
      </doc>
    </method>
    <method name="getDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="double"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>double</code>.  
 If no such property exists, the provided default value is returned,
 or if the specified value is not a valid <code>double</code>,
 then an error is thrown.

 @param name property name.
 @param defaultValue default value.
 @throws NumberFormatException when the value is invalid
 @return property value as a <code>double</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setDouble"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to a <code>double</code>.
 
 @param name property name.
 @param value property value.]]>
      </doc>
    </method>
    <method name="getBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="boolean"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>boolean</code>.  
 If no such property is specified, or if the specified value is not a valid
 <code>boolean</code>, then <code>defaultValue</code> is returned.
 
 @param name property name.
 @param defaultValue default value.
 @return property value as a <code>boolean</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setBoolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to a <code>boolean</code>.
 
 @param name property name.
 @param value <code>boolean</code> value of the property.]]>
      </doc>
    </method>
    <method name="setBooleanIfUnset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Set the given property, if it is currently unset.
 @param name property name
 @param value new value]]>
      </doc>
    </method>
    <method name="setEnum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="T"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to the given type. This
 is equivalent to <code>set(&lt;name&gt;, value.toString())</code>.
 @param name property name
 @param value new value
 @param <T> enumeration type]]>
      </doc>
    </method>
    <method name="getEnum" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Return value matching this enumerated type.
 Note that the returned value is trimmed by this method.
 @param name Property name
 @param defaultValue Value returned if no mapping exists
 @param <T> enumeration type
 @throws IllegalArgumentException If mapping is illegal for the type
 provided
 @return enumeration type]]>
      </doc>
    </method>
    <method name="setTimeDuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Set the value of <code>name</code> to the given time duration. This
 is equivalent to <code>set(&lt;name&gt;, value + &lt;time suffix&gt;)</code>.
 @param name Property name
 @param value Time duration
 @param unit Unit of time]]>
      </doc>
    </method>
    <method name="getTimeDuration" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Return time duration in the given time unit. Valid units are encoded in
 properties as suffixes: nanoseconds (ns), microseconds (us), milliseconds
 (ms), seconds (s), minutes (m), hours (h), and days (d).

 @param name Property name
 @param defaultValue Value returned if no mapping exists.
 @param unit Unit to convert the stored property, if it exists.
 @throws NumberFormatException If the property stripped of its unit is not
         a number
 @return time duration in given time unit]]>
      </doc>
    </method>
    <method name="getTimeDuration" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="getTimeDuration" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="long"/>
      <param name="defaultUnit" type="java.util.concurrent.TimeUnit"/>
      <param name="returnUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Return time duration in the given time unit. Valid units are encoded in
 properties as suffixes: nanoseconds (ns), microseconds (us), milliseconds
 (ms), seconds (s), minutes (m), hours (h), and days (d). If no unit is
 provided, the default unit is applied.

 @param name Property name
 @param defaultValue Value returned if no mapping exists.
 @param defaultUnit Default time unit if no valid suffix is provided.
 @param returnUnit The unit used for the returned value.
 @throws NumberFormatException If the property stripped of its unit is not
         a number
 @return time duration in given time unit]]>
      </doc>
    </method>
    <method name="getTimeDuration" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <param name="defaultUnit" type="java.util.concurrent.TimeUnit"/>
      <param name="returnUnit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="getTimeDurationHelper" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="vStr" type="java.lang.String"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Return time duration in the given time unit. Valid units are encoded in
 properties as suffixes: nanoseconds (ns), microseconds (us), milliseconds
 (ms), seconds (s), minutes (m), hours (h), and days (d).

 @param name Property name
 @param vStr The string value with time unit suffix to be converted.
 @param unit Unit to convert the stored property, if it exists.
 @return time duration in given time unit.]]>
      </doc>
    </method>
    <method name="getTimeDurations" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="getStorageSize" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <param name="targetUnit" type="org.apache.hadoop.conf.StorageUnit"/>
      <doc>
      <![CDATA[Gets the Storage Size from the config, or returns the defaultValue. The
 unit of return value is specified in target unit.

 @param name - Key Name
 @param defaultValue - Default Value -- e.g. 100MB
 @param targetUnit - The units that we want result to be in.
 @return double -- formatted in target Units]]>
      </doc>
    </method>
    <method name="getStorageSize" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="double"/>
      <param name="targetUnit" type="org.apache.hadoop.conf.StorageUnit"/>
      <doc>
      <![CDATA[Gets storage size from a config file.

 @param name - Key to read.
 @param defaultValue - The default value to return in case the key is
 not present.
 @param targetUnit - The Storage unit that should be used
 for the return value.
 @return - double value in the Storage Unit specified.]]>
      </doc>
    </method>
    <method name="setStorageSize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="double"/>
      <param name="unit" type="org.apache.hadoop.conf.StorageUnit"/>
      <doc>
      <![CDATA[Sets Storage Size for the specified key.

 @param name - Key to set.
 @param value - The numeric value to set.
 @param unit - Storage Unit to be used.]]>
      </doc>
    </method>
    <method name="getPattern" return="java.util.regex.Pattern"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.util.regex.Pattern"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>Pattern</code>.
 If no such property is specified, or if the specified value is not a valid
 <code>Pattern</code>, then <code>DefaultValue</code> is returned.
 Note that the returned value is NOT trimmed by this method.

 @param name property name
 @param defaultValue default value
 @return property value as a compiled Pattern, or defaultValue]]>
      </doc>
    </method>
    <method name="setPattern"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="pattern" type="java.util.regex.Pattern"/>
      <doc>
      <![CDATA[Set the given property to <code>Pattern</code>.
 If the pattern is passed as null, sets the empty pattern which results in
 further calls to getPattern(...) returning the default value.

 @param name property name
 @param pattern new value]]>
      </doc>
    </method>
    <method name="getPropertySources" return="java.lang.String[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets information about why a property was set.  Typically this is the 
 path to the resource objects (file, URL, etc.) the property came from, but
 it can also indicate that it was set programmatically, or because of the
 command line.

 @param name - The property name to get the source of.
 @return null - If the property or its source wasn't found. Otherwise, 
 returns a list of the sources of the resource.  The older sources are
 the first ones in the list.  So for example if a configuration is set from
 the command line, and then written out to a file that is read back in the
 first entry would indicate that it was set from the command line, while
 the second one would indicate the file that the new configuration was read
 in from.]]>
      </doc>
    </method>
    <method name="getRange" return="org.apache.hadoop.conf.Configuration.IntegerRanges"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Parse the given attribute as a set of integer ranges.
 @param name the attribute name
 @param defaultValue the default value if it is not set
 @return a new set of ranges from the configured value]]>
      </doc>
    </method>
    <method name="getStringCollection" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 a collection of <code>String</code>s.  
 If no such property is specified then empty collection is returned.
 <p>
 This is an optimized version of {@link #getStrings(String)}
 
 @param name property name.
 @return property value as a collection of <code>String</code>s.]]>
      </doc>
    </method>
    <method name="getStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 an array of <code>String</code>s.  
 If no such property is specified then <code>null</code> is returned.
 
 @param name property name.
 @return property value as an array of <code>String</code>s, 
         or <code>null</code>.]]>
      </doc>
    </method>
    <method name="getStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 an array of <code>String</code>s.  
 If no such property is specified then default value is returned.
 
 @param name property name.
 @param defaultValue The default value
 @return property value as an array of <code>String</code>s, 
         or default value.]]>
      </doc>
    </method>
    <method name="getTrimmedStringCollection" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 a collection of <code>String</code>s, trimmed of the leading and trailing whitespace.  
 If no such property is specified then empty <code>Collection</code> is returned.

 @param name property name.
 @return property value as a collection of <code>String</code>s, or empty <code>Collection</code>]]>
      </doc>
    </method>
    <method name="getTrimmedStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 an array of <code>String</code>s, trimmed of the leading and trailing whitespace.
 If no such property is specified then an empty array is returned.
 
 @param name property name.
 @return property value as an array of trimmed <code>String</code>s, 
         or empty array.]]>
      </doc>
    </method>
    <method name="getTrimmedStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 an array of <code>String</code>s, trimmed of the leading and trailing whitespace.
 If no such property is specified then default value is returned.
 
 @param name property name.
 @param defaultValue The default value
 @return property value as an array of trimmed <code>String</code>s, 
         or default value.]]>
      </doc>
    </method>
    <method name="setStrings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="values" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Set the array of string values for the <code>name</code> property as 
 as comma delimited values.  
 
 @param name property name.
 @param values The values]]>
      </doc>
    </method>
    <method name="getPassword" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the value for a known password configuration element.
 In order to enable the elimination of clear text passwords in config,
 this method attempts to resolve the property name as an alias through
 the CredentialProvider API and conditionally fallsback to config.
 @param name property name
 @return password
 @throws IOException when error in fetching password]]>
      </doc>
    </method>
    <method name="getPasswordFromCredentialProviders" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Try and resolve the provided element name as a credential provider
 alias.
 @param name alias of the provisioned credential
 @return password or null if not found
 @throws IOException when error in fetching password]]>
      </doc>
    </method>
    <method name="getPasswordFromConfig" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Fallback to clear text passwords in configuration.
 @param name the property name.
 @return clear text password or null]]>
      </doc>
    </method>
    <method name="getSocketAddr" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hostProperty" type="java.lang.String"/>
      <param name="addressProperty" type="java.lang.String"/>
      <param name="defaultAddressValue" type="java.lang.String"/>
      <param name="defaultPort" type="int"/>
      <doc>
      <![CDATA[Get the socket address for <code>hostProperty</code> as a
 <code>InetSocketAddress</code>. If <code>hostProperty</code> is
 <code>null</code>, <code>addressProperty</code> will be used. This
 is useful for cases where we want to differentiate between host
 bind address and address clients should use to establish connection.

 @param hostProperty bind host property name.
 @param addressProperty address property name.
 @param defaultAddressValue the default value
 @param defaultPort the default port
 @return InetSocketAddress]]>
      </doc>
    </method>
    <method name="getSocketAddr" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultAddress" type="java.lang.String"/>
      <param name="defaultPort" type="int"/>
      <doc>
      <![CDATA[Get the socket address for <code>name</code> property as a
 <code>InetSocketAddress</code>.
 @param name property name.
 @param defaultAddress the default value
 @param defaultPort the default port
 @return InetSocketAddress]]>
      </doc>
    </method>
    <method name="setSocketAddr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="addr" type="java.net.InetSocketAddress"/>
      <doc>
      <![CDATA[Set the socket address for the <code>name</code> property as
 a <code>host:port</code>.
 @param name property name.
 @param addr inetSocketAddress addr.]]>
      </doc>
    </method>
    <method name="updateConnectAddr" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hostProperty" type="java.lang.String"/>
      <param name="addressProperty" type="java.lang.String"/>
      <param name="defaultAddressValue" type="java.lang.String"/>
      <param name="addr" type="java.net.InetSocketAddress"/>
      <doc>
      <![CDATA[Set the socket address a client can use to connect for the
 <code>name</code> property as a <code>host:port</code>.  The wildcard
 address is replaced with the local host's address. If the host and address
 properties are configured the host component of the address will be combined
 with the port component of the addr to generate the address.  This is to allow
 optional control over which host name is used in multi-home bind-host
 cases where a host can have multiple names
 @param hostProperty the bind-host configuration name
 @param addressProperty the service address configuration name
 @param defaultAddressValue the service default address configuration value
 @param addr InetSocketAddress of the service listener
 @return InetSocketAddress for clients to connect]]>
      </doc>
    </method>
    <method name="updateConnectAddr" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="addr" type="java.net.InetSocketAddress"/>
      <doc>
      <![CDATA[Set the socket address a client can use to connect for the
 <code>name</code> property as a <code>host:port</code>.  The wildcard
 address is replaced with the local host's address.
 @param name property name.
 @param addr InetSocketAddress of a listener to store in the given property
 @return InetSocketAddress for clients to connect]]>
      </doc>
    </method>
    <method name="getClassByName" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
      <doc>
      <![CDATA[Load a class by name.
 
 @param name the class name.
 @return the class object.
 @throws ClassNotFoundException if the class is not found.]]>
      </doc>
    </method>
    <method name="getClassByNameOrNull" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Load a class by name, returning null rather than throwing an exception
 if it couldn't be loaded. This is to avoid the overhead of creating
 an exception.
 
 @param name the class name
 @return the class object, or null if it could not be found.]]>
      </doc>
    </method>
    <method name="getClasses" return="java.lang.Class[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property
 as an array of <code>Class</code>.
 The value of the property specifies a list of comma separated class names.  
 If no such property is specified, then <code>defaultValue</code> is 
 returned.
 
 @param name the property name.
 @param defaultValue default value.
 @return property value as a <code>Class[]</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.Class"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>Class</code>.  
 If no such property is specified, then <code>defaultValue</code> is 
 returned.
 
 @param name the conf key name.
 @param defaultValue default value.
 @return property value as a <code>Class</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.Class"/>
      <param name="xface" type="java.lang.Class"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>Class</code>
 implementing the interface specified by <code>xface</code>.
   
 If no such property is specified, then <code>defaultValue</code> is 
 returned.
 
 An exception is thrown if the returned class does not implement the named
 interface. 
 
 @param name the conf key name.
 @param defaultValue default value.
 @param xface the interface implemented by the named class.
 @param <U> Interface class type.
 @return property value as a <code>Class</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getInstances" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="xface" type="java.lang.Class"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>List</code>
 of objects implementing the interface specified by <code>xface</code>.
 
 An exception is thrown if any of the classes does not exist, or if it does
 not implement the named interface.
 
 @param name the property name.
 @param xface the interface implemented by the classes named by
        <code>name</code>.
 @param <U> Interface class type.
 @return a <code>List</code> of objects implementing <code>xface</code>.]]>
      </doc>
    </method>
    <method name="setClass"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="theClass" type="java.lang.Class"/>
      <param name="xface" type="java.lang.Class"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to the name of a 
 <code>theClass</code> implementing the given interface <code>xface</code>.
 
 An exception is thrown if <code>theClass</code> does not implement the 
 interface <code>xface</code>. 
 
 @param name property name.
 @param theClass property value.
 @param xface the interface implemented by the named class.]]>
      </doc>
    </method>
    <method name="getLocalPath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dirsProp" type="java.lang.String"/>
      <param name="path" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a local file under a directory named by <i>dirsProp</i> with
 the given <i>path</i>.  If <i>dirsProp</i> contains multiple directories,
 then one is chosen based on <i>path</i>'s hash code.  If the selected
 directory does not exist, an attempt is made to create it.

 @param dirsProp directory in which to locate the file.
 @param path file-path.
 @return local file under the directory with the given path.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dirsProp" type="java.lang.String"/>
      <param name="path" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a local file name under a directory named in <i>dirsProp</i> with
 the given <i>path</i>.  If <i>dirsProp</i> contains multiple directories,
 then one is chosen based on <i>path</i>'s hash code.  If the selected
 directory does not exist, an attempt is made to create it.

 @param dirsProp directory in which to locate the file.
 @param path file-path.
 @return local file under the directory with the given path.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getResource" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the {@link URL} for the named resource.
 
 @param name resource name.
 @return the url for the named resource.]]>
      </doc>
    </method>
    <method name="getConfResourceAsInputStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get an input stream attached to the configuration resource with the
 given <code>name</code>.
 
 @param name configuration resource name.
 @return an input stream attached to the resource.]]>
      </doc>
    </method>
    <method name="getConfResourceAsReader" return="java.io.Reader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a {@link Reader} attached to the configuration resource with the
 given <code>name</code>.
 
 @param name configuration resource name.
 @return a reader attached to the resource.]]>
      </doc>
    </method>
    <method name="getFinalParameters" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the set of parameters marked final.

 @return final parameter set.]]>
      </doc>
    </method>
    <method name="getProps" return="java.util.Properties"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the number of keys in the configuration.

 @return number of keys in the configuration.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears all keys from the configuration.]]>
      </doc>
    </method>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an {@link Iterator} to go through the list of <code>String</code> 
 key-value pairs in the configuration.
 
 @return an iterator over the entries.]]>
      </doc>
    </method>
    <method name="getPropsWithPrefix" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="confPrefix" type="java.lang.String"/>
      <doc>
      <![CDATA[Constructs a mapping of configuration and includes all properties that
 start with the specified configuration prefix.  Property names in the
 mapping are trimmed to remove the configuration prefix.

 @param confPrefix configuration prefix
 @return mapping of configuration properties with prefix stripped]]>
      </doc>
    </method>
    <method name="addTags"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prop" type="java.util.Properties"/>
      <doc>
      <![CDATA[Add tags defined in HADOOP_TAGS_SYSTEM, HADOOP_TAGS_CUSTOM.
 @param prop properties.]]>
      </doc>
    </method>
    <method name="writeXml"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write out the non-default properties in this configuration to the given
 {@link OutputStream} using UTF-8 encoding.

 @param out the output stream to write to.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="writeXml"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeXml"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propertyName" type="java.lang.String"/>
      <param name="out" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Write out the non-default properties in this configuration to the
 given {@link Writer}.
 <ul>
 <li>
 When property name is not empty and the property exists in the
 configuration, this method writes the property and its attributes
 to the {@link Writer}.
 </li>

 <li>
 When property name is null or empty, this method writes all the
 configuration properties and their attributes to the {@link Writer}.
 </li>

 <li>
 When property name is not empty but the property doesn't exist in
 the configuration, this method throws an {@link IllegalArgumentException}.
 </li>
 </ul>
 @param propertyName xml property name.
 @param out the writer to write to.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="dumpConfiguration"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="org.apache.hadoop.conf.Configuration"/>
      <param name="propertyName" type="java.lang.String"/>
      <param name="out" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes properties and their attributes (final and resource)
  to the given {@link Writer}.
  <ul>
  <li>
  When propertyName is not empty, and the property exists
  in the configuration, the format of the output would be,
  <pre>
  {
    "property": {
      "key" : "key1",
      "value" : "value1",
      "isFinal" : "key1.isFinal",
      "resource" : "key1.resource"
    }
  }
  </pre>
  </li>

  <li>
  When propertyName is null or empty, it behaves same as
  {@link #dumpConfiguration(Configuration, Writer)}, the
  output would be,
  <pre>
  { "properties" :
      [ { key : "key1",
          value : "value1",
          isFinal : "key1.isFinal",
          resource : "key1.resource" },
        { key : "key2",
          value : "value2",
          isFinal : "ke2.isFinal",
          resource : "key2.resource" }
       ]
   }
  </pre>
  </li>

  <li>
  When propertyName is not empty, and the property is not
  found in the configuration, this method will throw an
  {@link IllegalArgumentException}.
  </li>
  </ul>
  <p>
 @param config the configuration
 @param propertyName property name
 @param out the Writer to write to
 @throws IOException raised on errors performing I/O.
 @throws IllegalArgumentException when property name is not
   empty and the property is not found in configuration]]>
      </doc>
    </method>
    <method name="dumpConfiguration"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="org.apache.hadoop.conf.Configuration"/>
      <param name="out" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes out all properties and their attributes (final and resource) to
  the given {@link Writer}, the format of the output would be,

  <pre>
  { "properties" :
      [ { key : "key1",
          value : "value1",
          isFinal : "key1.isFinal",
          resource : "key1.resource" },
        { key : "key2",
          value : "value2",
          isFinal : "ke2.isFinal",
          resource : "key2.resource" }
       ]
   }
  </pre>

  It does not output the properties of the configuration object which
  is loaded from an input stream.
  <p>

 @param config the configuration
 @param out the Writer to write to
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getClassLoader" return="java.lang.ClassLoader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link ClassLoader} for this job.

 @return the correct class loader.]]>
      </doc>
    </method>
    <method name="setClassLoader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classLoader" type="java.lang.ClassLoader"/>
      <doc>
      <![CDATA[Set the class loader that will be used to load the various objects.
 
 @param classLoader the new class loader.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setQuietMode"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="quietmode" type="boolean"/>
      <doc>
      <![CDATA[Set the quietness-mode. 
 
 In the quiet-mode, error and informational messages might not be logged.
 
 @param quietmode <code>true</code> to set quiet-mode on, <code>false</code>
              to turn it off.]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[For debugging.  List non-default properties to the terminal and exit.
 @param args the argument to be parsed.
 @throws Exception exception.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getValByRegex" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="regex" type="java.lang.String"/>
      <doc>
      <![CDATA[get keys matching the the regex.
 @param regex the regex to match against.
 @return {@literal Map<String,String>} with matching keys]]>
      </doc>
    </method>
    <method name="dumpDeprecatedKeys"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasWarnedDeprecation" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns whether or not a deprecated name has been warned. If the name is not
 deprecated then always return false
 @param name proprties.
 @return true if name is a warned deprecation.]]>
      </doc>
    </method>
    <method name="getAllPropertiesByTag" return="java.util.Properties"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <doc>
      <![CDATA[Get all properties belonging to tag.
 @param tag tag
 @return Properties with matching tag]]>
      </doc>
    </method>
    <method name="getAllPropertiesByTags" return="java.util.Properties"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagList" type="java.util.List"/>
      <doc>
      <![CDATA[Get all properties belonging to list of input tags. Calls
 getAllPropertiesByTag internally.
 @param tagList list of input tags
 @return Properties with matching tags]]>
      </doc>
    </method>
    <method name="isPropertyTag" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagStr" type="java.lang.String"/>
      <doc>
      <![CDATA[Get Property tag Enum corresponding to given source.

 @param tagStr String representation of Enum
 @return true if tagStr is a valid tag]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides access to configuration parameters.

 <h3 id="Resources">Resources</h3>

 <p>Configurations are specified by resources. A resource contains a set of
 name/value pairs as XML data. Each resource is named by either a 
 <code>String</code> or by a {@link Path}. If named by a <code>String</code>, 
 then the classpath is examined for a file with that name.  If named by a 
 <code>Path</code>, then the local filesystem is examined directly, without 
 referring to the classpath.

 <p>Unless explicitly turned off, Hadoop by default specifies two 
 resources, loaded in-order from the classpath: <ol>
 <li><tt>
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a></tt>: Read-only defaults for hadoop.</li>
 <li><tt>core-site.xml</tt>: Site-specific configuration for a given hadoop
 installation.</li>
 </ol>
 Applications may add additional resources, which are loaded
 subsequent to these resources in the order they are added.
 
 <h4 id="FinalParams">Final Parameters</h4>

 <p>Configuration parameters may be declared <i>final</i>. 
 Once a resource declares a value final, no subsequently-loaded 
 resource can alter that value.  
 For example, one might define a final parameter with:
 <pre><code>
  &lt;property&gt;
    &lt;name&gt;dfs.hosts.include&lt;/name&gt;
    &lt;value&gt;/etc/hadoop/conf/hosts.include&lt;/value&gt;
    <b>&lt;final&gt;true&lt;/final&gt;</b>
  &lt;/property&gt;</code></pre>

 Administrators typically define parameters as final in 
 <tt>core-site.xml</tt> for values that user applications may not alter.

 <h4 id="VariableExpansion">Variable Expansion</h4>

 <p>Value strings are first processed for <i>variable expansion</i>. The
 available properties are:<ol>
 <li>Other properties defined in this Configuration; and, if a name is
 undefined here,</li>
 <li>Environment variables in {@link System#getenv()} if a name starts with
 "env.", or</li>
 <li>Properties in {@link System#getProperties()}.</li>
 </ol>

 <p>For example, if a configuration resource contains the following property
 definitions: 
 <pre><code>
  &lt;property&gt;
    &lt;name&gt;basedir&lt;/name&gt;
    &lt;value&gt;/user/${<i>user.name</i>}&lt;/value&gt;
  &lt;/property&gt;
  
  &lt;property&gt;
    &lt;name&gt;tempdir&lt;/name&gt;
    &lt;value&gt;${<i>basedir</i>}/tmp&lt;/value&gt;
  &lt;/property&gt;

  &lt;property&gt;
    &lt;name&gt;otherdir&lt;/name&gt;
    &lt;value&gt;${<i>env.BASE_DIR</i>}/other&lt;/value&gt;
  &lt;/property&gt;
  </code></pre>

 <p>When <tt>conf.get("tempdir")</tt> is called, then <tt>${<i>basedir</i>}</tt>
 will be resolved to another property in this Configuration, while
 <tt>${<i>user.name</i>}</tt> would then ordinarily be resolved to the value
 of the System property with that name.
 <p>When <tt>conf.get("otherdir")</tt> is called, then <tt>${<i>env.BASE_DIR</i>}</tt>
 will be resolved to the value of the <tt>${<i>BASE_DIR</i>}</tt> environment variable.
 It supports <tt>${<i>env.NAME:-default</i>}</tt> and <tt>${<i>env.NAME-default</i>}</tt> notations.
 The former is resolved to "default" if <tt>${<i>NAME</i>}</tt> environment variable is undefined
 or its value is empty.
 The latter behaves the same way only if <tt>${<i>NAME</i>}</tt> is undefined.
 <p>By default, warnings will be given to any deprecated configuration 
 parameters and these are suppressible by configuring
 <tt>log4j.logger.org.apache.hadoop.conf.Configuration.deprecation</tt> in
 log4j.properties file.

 <h4 id="Tags">Tags</h4>

 <p>Optionally we can tag related properties together by using tag
 attributes. System tags are defined by hadoop.tags.system property. Users
 can define there own custom tags in  hadoop.tags.custom property.

 <p>For example, we can tag existing property as:
 <pre><code>
  &lt;property&gt;
    &lt;name&gt;dfs.replication&lt;/name&gt;
    &lt;value&gt;3&lt;/value&gt;
    &lt;tag&gt;HDFS,REQUIRED&lt;/tag&gt;
  &lt;/property&gt;

  &lt;property&gt;
    &lt;name&gt;dfs.data.transfer.protection&lt;/name&gt;
    &lt;value&gt;3&lt;/value&gt;
    &lt;tag&gt;HDFS,SECURITY&lt;/tag&gt;
  &lt;/property&gt;
 </code></pre>
 <p> Properties marked with tags can be retrieved with <tt>conf
 .getAllPropertiesByTag("HDFS")</tt> or <tt>conf.getAllPropertiesByTags
 (Arrays.asList("YARN","SECURITY"))</tt>.</p>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.Configuration -->
  <!-- start class org.apache.hadoop.conf.Configured -->
  <class name="Configured" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="Configured"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a Configured.]]>
      </doc>
    </constructor>
    <constructor name="Configured" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a Configured.
 @param conf the Configuration object.]]>
      </doc>
    </constructor>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Base class for things that may be configured with a {@link Configuration}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.Configured -->
  <doc>
  <![CDATA[Configuration of system parameters.]]>
  </doc>
</package>
<package name="org.apache.hadoop.crypto">
</package>
<package name="org.apache.hadoop.crypto.key">
  <!-- start class org.apache.hadoop.crypto.key.KeyProvider -->
  <class name="KeyProvider" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="KeyProvider" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor.
 
 @param conf configuration for the provider]]>
      </doc>
    </constructor>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the provider configuration.
 
 @return the provider configuration]]>
      </doc>
    </method>
    <method name="options" return="org.apache.hadoop.crypto.key.KeyProvider.Options"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[A helper function to create an options object.
 @param conf the configuration to use
 @return a new options object]]>
      </doc>
    </method>
    <method name="isTransient" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this provider represents a store
 that is intended for transient use - such as the UserProvider
 is. These providers are generally used to provide access to
 keying material rather than for long term storage.
 @return true if transient, false otherwise]]>
      </doc>
    </method>
    <method name="getKeyVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the key material for a specific version of the key. This method is used
 when decrypting data.
 @param versionName the name of a specific version of the key
 @return the key material
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getKeys" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the key names for all keys.
 @return the list of key names
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getKeysMetadata" return="org.apache.hadoop.crypto.key.KeyProvider.Metadata[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get key metadata in bulk.
 @param names the names of the keys to get
 @throws IOException raised on errors performing I/O.
 @return Metadata Array.]]>
      </doc>
    </method>
    <method name="getKeyVersions" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the key material for all versions of a specific key name.

 @param name the base name of the key.
 @return the list of key material
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getCurrentKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the current version of the key, which should be used for encrypting new
 data.
 @param name the base name of the key
 @return the version name of the current version of the key or null if the
    key version doesn't exist
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getMetadata" return="org.apache.hadoop.crypto.key.KeyProvider.Metadata"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get metadata about the key.
 @param name the basename of the key
 @return the key's metadata or null if the key doesn't exist
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="createKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="material" type="byte[]"/>
      <param name="options" type="org.apache.hadoop.crypto.key.KeyProvider.Options"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a new key. The given key must not already exist.
 @param name the base name of the key
 @param material the key material for the first version of the key.
 @param options the options for the new key.
 @return the version name of the first version of the key.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="generateKey" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="size" type="int"/>
      <param name="algorithm" type="java.lang.String"/>
      <exception name="NoSuchAlgorithmException" type="java.security.NoSuchAlgorithmException"/>
      <doc>
      <![CDATA[Generates a key material.

 @param size length of the key.
 @param algorithm algorithm to use for generating the key.
 @return the generated key.
 @throws NoSuchAlgorithmException no such algorithm exception.]]>
      </doc>
    </method>
    <method name="createKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="options" type="org.apache.hadoop.crypto.key.KeyProvider.Options"/>
      <exception name="NoSuchAlgorithmException" type="java.security.NoSuchAlgorithmException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a new key generating the material for it.
 The given key must not already exist.
 <p>
 This implementation generates the key material and calls the
 {@link #createKey(String, byte[], Options)} method.

 @param name the base name of the key
 @param options the options for the new key.
 @return the version name of the first version of the key.
 @throws IOException raised on errors performing I/O.
 @throws NoSuchAlgorithmException no such algorithm exception.]]>
      </doc>
    </method>
    <method name="deleteKey"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete the given key.
 @param name the name of the key to delete
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="rollNewVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="material" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Roll a new version of the given key.
 @param name the basename of the key
 @param material the new key material
 @return the name of the new version of the key
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Can be used by implementing classes to close any resources
 that require closing]]>
      </doc>
    </method>
    <method name="rollNewVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="NoSuchAlgorithmException" type="java.security.NoSuchAlgorithmException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Roll a new version of the given key generating the material for it.
 <p>
 This implementation generates the key material and calls the
 {@link #rollNewVersion(String, byte[])} method.

 @param name the basename of the key
 @return the name of the new version of the key
 @throws IOException              raised on errors performing I/O.
 @throws NoSuchAlgorithmException This exception is thrown when a particular
                                  cryptographic algorithm is requested
                                  but is not available in the environment.]]>
      </doc>
    </method>
    <method name="invalidateCache"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Can be used by implementing classes to invalidate the caches. This could be
 used after rollNewVersion to provide a strong guarantee to return the new
 version of the given key.

 @param name the basename of the key
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="flush"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Ensures that any changes to the keys are written to persistent store.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getBaseName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Split the versionName in to a base name. Converts "/aaa/bbb/3" to
 "/aaa/bbb".
 @param versionName the version name to split
 @return the base name of the key
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="buildVersionName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="version" type="int"/>
      <doc>
      <![CDATA[Build a version string from a basename and version number. Converts
 "/aaa/bbb" and 3 to "/aaa/bbb@3".
 @param name the basename of the key
 @param version the version of the key
 @return the versionName of the key.]]>
      </doc>
    </method>
    <method name="findProvider" return="org.apache.hadoop.crypto.key.KeyProvider"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerList" type="java.util.List"/>
      <param name="keyName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Find the provider with the given key.

 @param providerList the list of providers
 @param keyName the key name we are looking for.
 @return the KeyProvider that has the key
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="needsPassword" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Does this provider require a password? This means that a password is
 required for normal operation, and it has not been found through normal
 means. If true, the password should be provided by the caller using
 setPassword().
 @return Whether or not the provider requires a password
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="noPasswordWarning" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If a password for the provider is needed, but is not provided, this will
 return a warning and instructions for supplying said password to the
 provider.
 @return A warning and instructions for supplying the password]]>
      </doc>
    </method>
    <method name="noPasswordError" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If a password for the provider is needed, but is not provided, this will
 return an error message and instructions for supplying said password to
 the provider.
 @return An error message and instructions for supplying the password]]>
      </doc>
    </method>
    <field name="DEFAULT_CIPHER_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_CIPHER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_BITLENGTH_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_BITLENGTH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JCEKS_KEY_SERIALFILTER_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JCEKS_KEY_SERIAL_FILTER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A provider of secret key material for Hadoop applications. Provides an
 abstraction to separate key storage from users of encryption. It
 is intended to support getting or storing keys in a variety of ways,
 including third party bindings.
 <p>
 <code>KeyProvider</code> implementations must be thread safe.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyProvider -->
  <!-- start class org.apache.hadoop.crypto.key.KeyProviderFactory -->
  <class name="KeyProviderFactory" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KeyProviderFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createProvider" return="org.apache.hadoop.crypto.key.KeyProvider"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerName" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getProviders" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="get" return="org.apache.hadoop.crypto.key.KeyProvider"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a KeyProvider based on a provided URI.

 @param uri key provider URI
 @param conf configuration to initialize the key provider
 @return the key provider for the specified URI, or <code>NULL</code> if
         a provider for the specified URI scheme could not be found.
 @throws IOException thrown if the provider failed to initialize.]]>
      </doc>
    </method>
    <field name="KEY_PROVIDER_PATH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A factory to create a list of KeyProvider based on the path given in a
 Configuration. It uses a service loader interface to find the available
 KeyProviders and create them based on the list of URIs.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyProviderFactory -->
</package>
<package name="org.apache.hadoop.crypto.key.kms">
</package>
<package name="org.apache.hadoop.crypto.random">
</package>
<package name="org.apache.hadoop.fs">
  <!-- start interface org.apache.hadoop.fs.Abortable -->
  <interface name="Abortable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="abort" return="org.apache.hadoop.fs.Abortable.AbortableResult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Abort the active operation without the output becoming visible.

 This is to provide ability to cancel the write on stream; once
 a stream is aborted, the write MUST NOT become visible.

 @throws UnsupportedOperationException if the operation is not supported.
 @return the result.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abort data being written to  a stream, so that close() does
  not write the data. It is implemented by output streams in
  some object stores, and passed through {@link FSDataOutputStream}.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.Abortable -->
  <!-- start class org.apache.hadoop.fs.AbstractFileSystem -->
  <class name="AbstractFileSystem" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.PathCapabilities"/>
    <constructor name="AbstractFileSystem" type="java.net.URI, java.lang.String, boolean, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="URISyntaxException" type="java.net.URISyntaxException"/>
      <doc>
      <![CDATA[Constructor to be called by subclasses.
 
 @param uri for this file system.
 @param supportedScheme the scheme supported by the implementor
 @param authorityNeeded if true then theURI must have authority, if false
          then the URI must have null authority.
 @param defaultPort default port to use if port is not specified in the URI.
 @throws URISyntaxException <code>uri</code> has syntax error]]>
      </doc>
    </constructor>
    <method name="getStatistics" return="org.apache.hadoop.fs.FileSystem.Statistics"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isValidName" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns true if the specified string is considered valid in the path part
 of a URI by this file system.  The default implementation enforces the rules
 of HDFS, but subclasses may override this method to implement specific
 validation rules for specific file systems.
 
 @param src String source filename to check, path part of the URI
 @return boolean true if the specified string is considered valid]]>
      </doc>
    </method>
    <method name="createFileSystem" return="org.apache.hadoop.fs.AbstractFileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <doc>
      <![CDATA[Create a file system instance for the specified uri using the conf. The
 conf is used to find the class name that implements the file system. The
 conf is also passed to the file system for its configuration.

 @param uri URI of the file system
 @param conf Configuration for the file system
 
 @return Returns the file system for the given URI

 @throws UnsupportedFileSystemException file system for <code>uri</code> is
           not found]]>
      </doc>
    </method>
    <method name="getStatistics" return="org.apache.hadoop.fs.FileSystem.Statistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Get the statistics for a particular file system.
 
 @param uri
          used as key to lookup STATISTICS_TABLE. Only scheme and authority
          part of the uri are used.
 @return a statistics object]]>
      </doc>
    </method>
    <method name="clearStatistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="printStatistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Prints statistics for all file systems.]]>
      </doc>
    </method>
    <method name="getAllStatistics" return="java.util.Map"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="get" return="org.apache.hadoop.fs.AbstractFileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <doc>
      <![CDATA[The main factory method for creating a file system. Get a file system for
 the URI's scheme and authority. The scheme of the <code>uri</code>
 determines a configuration property name,
 <tt>fs.AbstractFileSystem.<i>scheme</i>.impl</tt> whose value names the
 AbstractFileSystem class.
 
 The entire URI and conf is passed to the AbstractFileSystem factory method.
 
 @param uri for the file system to be created.
 @param conf which is passed to the file system impl.
 
 @return file system for the given URI.
 
 @throws UnsupportedFileSystemException if the file system for
           <code>uri</code> is not supported.]]>
      </doc>
    </method>
    <method name="checkScheme"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="supportedScheme" type="java.lang.String"/>
      <doc>
      <![CDATA[Check that the Uri's scheme matches.

 @param uri name URI of the FS.
 @param supportedScheme supported scheme.]]>
      </doc>
    </method>
    <method name="getUriDefaultPort" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The default port of this file system.
 
 @return default port of this file system's Uri scheme
         A uri with a port of -1 =&gt; default port;]]>
      </doc>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a URI whose scheme and authority identify this FileSystem.
 
 @return the uri of this file system.]]>
      </doc>
    </method>
    <method name="checkPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Check that a Path belongs to this FileSystem.
 
 If the path is fully qualified URI, then its scheme and authority
 matches that of this file system. Otherwise the path must be 
 slash-relative name.
 @param path the path.
 @throws InvalidPathException if the path is invalid]]>
      </doc>
    </method>
    <method name="getUriPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Get the path-part of a pathname. Checks that URI matches this file system
 and that the path-part is a valid name.
 
 @param p path
 
 @return path-part of the Path p]]>
      </doc>
    </method>
    <method name="makeQualified" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Make the path fully qualified to this file system
 @param path the path.
 @return the qualified path]]>
      </doc>
    </method>
    <method name="getInitialWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Some file systems like LocalFileSystem have an initial workingDir
 that is used as the starting workingDir. For other file systems
 like HDFS there is no built in notion of an initial workingDir.
 
 @return the initial workingDir if the file system has such a notion
         otherwise return a null.]]>
      </doc>
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the current user's home directory in this file system.
 The default implementation returns "/user/$USER/".
 
 @return current user's home directory.]]>
      </doc>
    </method>
    <method name="getServerDefaults" return="org.apache.hadoop.fs.FsServerDefaults"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #getServerDefaults(Path)} instead">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a set of server default configuration values.
 
 @return server default configuration values
 
 @throws IOException an I/O error occurred
 @deprecated use {@link #getServerDefaults(Path)} instead]]>
      </doc>
    </method>
    <method name="getServerDefaults" return="org.apache.hadoop.fs.FsServerDefaults"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a set of server default configuration values based on path.
 @param f path to fetch server defaults
 @return server default configuration values for path
 @throws IOException an I/O error occurred]]>
      </doc>
    </method>
    <method name="resolvePath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the fully-qualified path of path f resolving the path
 through any internal symlinks or mount point
 @param p path to be resolved
 @return fully qualified path 
 @throws FileNotFoundException when file not find throw.
 @throws AccessControlException when accees control error throw.
 @throws IOException raised on errors performing I/O.
 @throws UnresolvedLinkException if symbolic link on path cannot be
 resolved internally]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="createFlag" type="java.util.EnumSet"/>
      <param name="opts" type="org.apache.hadoop.fs.Options.CreateOpts[]"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#create(Path, EnumSet, Options.CreateOpts...)} except
 that the Path f must be fully qualified and the permission is absolute
 (i.e. umask has been applied).

 @param f the path.
 @param createFlag create_flag.
 @param opts create ops.
 @throws AccessControlException access controll exception.
 @throws FileAlreadyExistsException file already exception.
 @throws FileNotFoundException file not found exception.
 @throws ParentNotDirectoryException parent not dir exception.
 @throws UnsupportedFileSystemException unsupported file system exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.
 @return output stream.]]>
      </doc>
    </method>
    <method name="createInternal" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="flag" type="java.util.EnumSet"/>
      <param name="absolutePermission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="checksumOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
      <param name="createParent" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link #create(Path, EnumSet, Options.CreateOpts...)} except that the opts
 have been declared explicitly.

 @param f the path.
 @param flag create flag.
 @param absolutePermission absolute permission.
 @param bufferSize buffer size.
 @param replication replications.
 @param blockSize block size.
 @param progress progress.
 @param checksumOpt check sum opt.
 @param createParent create parent.
 @throws AccessControlException access control exception.
 @throws FileAlreadyExistsException file already exists exception.
 @throws FileNotFoundException file not found exception.
 @throws ParentNotDirectoryException parent not directory exception.
 @throws UnsupportedFileSystemException unsupported filesystem exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.
 @return output stream.]]>
      </doc>
    </method>
    <method name="mkdir"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="createParent" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#mkdir(Path, FsPermission, boolean)} except that the Path
 f must be fully qualified and the permission is absolute (i.e. 
 umask has been applied).
 @param dir directory.
 @param permission permission.
 @param createParent create parent flag.
 @throws AccessControlException access control exception.
 @throws FileAlreadyExistsException file already exists exception.
 @throws FileNotFoundException file not found exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#delete(Path, boolean)} except that Path f must be for
 this file system.

 @param f the path.
 @param recursive recursive flag.
 @throws AccessControlException access control exception.
 @throws FileNotFoundException file not found exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.
 @return if successfully deleted success true, not false.]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#open(Path)} except that Path f must be for this
 file system.

 @param f the path.
 @throws AccessControlException access control exception.
 @throws FileNotFoundException file not found exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.
 @return input stream.]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#open(Path, int)} except that Path f must be for this
 file system.

 @param f the path.
 @param bufferSize buffer size.
 @throws AccessControlException access control exception.
 @throws FileNotFoundException file not found exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.
 @return if successfully open success true, not false.]]>
      </doc>
    </method>
    <method name="truncate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="newLength" type="long"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#truncate(Path, long)} except that Path f must be for
 this file system.

 @param f the path.
 @param newLength new length.
 @throws AccessControlException access control exception.
 @throws FileNotFoundException file not found exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.
 @return if successfully truncate success true, not false.]]>
      </doc>
    </method>
    <method name="setReplication" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#setReplication(Path, short)} except that Path f must be
 for this file system.

 @param f the path.
 @param replication replication.
 @return if successfully set replication success true, not false.
 @throws AccessControlException access control exception.
 @throws FileNotFoundException file not found exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="rename"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="options" type="org.apache.hadoop.fs.Options.Rename[]"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#rename(Path, Path, Options.Rename...)} except that Path
 f must be for this file system.

 @param src src.
 @param dst dst.
 @param options options.
 @throws AccessControlException access control exception.
 @throws FileAlreadyExistsException file already exists exception.
 @throws FileNotFoundException file not found exception.
 @throws ParentNotDirectoryException parent not directory exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="renameInternal"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#rename(Path, Path, Options.Rename...)} except that Path
 f must be for this file system and NO OVERWRITE is performed.
 
 File systems that do not have a built in overwrite need implement only this
 method and can take advantage of the default impl of the other
 {@link #renameInternal(Path, Path, boolean)}

 @param src src.
 @param dst dst.
 @throws AccessControlException access control exception.
 @throws FileAlreadyExistsException file already exists exception.
 @throws FileNotFoundException file not found exception.
 @throws ParentNotDirectoryException parent not directory exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="renameInternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#rename(Path, Path, Options.Rename...)} except that Path
 f must be for this file system.

 @param src src.
 @param dst dst.
 @param overwrite overwrite flag.
 @throws AccessControlException access control exception.
 @throws FileAlreadyExistsException file already exists exception.
 @throws FileNotFoundException file not found exception.
 @throws ParentNotDirectoryException parent not directory exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="supportsSymlinks" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the file system supports symlinks, false otherwise.
 @return true if filesystem supports symlinks]]>
      </doc>
    </method>
    <method name="createSymlink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.apache.hadoop.fs.Path"/>
      <param name="link" type="org.apache.hadoop.fs.Path"/>
      <param name="createParent" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <doc>
      <![CDATA[The specification of this method matches that of  
 {@link FileContext#createSymlink(Path, Path, boolean)};

 @param target target.
 @param link link.
 @param createParent create parent.
 @throws IOException raised on errors performing I/O.
 @throws UnresolvedLinkException unresolved link exception.]]>
      </doc>
    </method>
    <method name="getLinkTarget" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Partially resolves the path. This is used during symlink resolution in
 {@link FSLinkResolver}, and differs from the similarly named method
 {@link FileContext#getLinkTarget(Path)}.
 @param f the path.
 @return target path.
 @throws IOException subclass implementations may throw IOException]]>
      </doc>
    </method>
    <method name="setPermission"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#setPermission(Path, FsPermission)} except that Path f
 must be for this file system.

 @param f the path.
 @param permission permission.
 @throws AccessControlException access control exception.
 @throws FileNotFoundException file not found exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="setOwner"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#setOwner(Path, String, String)} except that Path f must
 be for this file system.

 @param f the path.
 @param username username.
 @param groupname groupname.
 @throws AccessControlException access control exception.
 @throws FileNotFoundException file not found exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="setTimes"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="mtime" type="long"/>
      <param name="atime" type="long"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#setTimes(Path, long, long)} except that Path f must be
 for this file system.

 @param f the path.
 @param mtime modify time.
 @param atime access time.
 @throws AccessControlException access control exception.
 @throws FileNotFoundException file not found exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getFileChecksum" return="org.apache.hadoop.fs.FileChecksum"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFileChecksum(Path)} except that Path f must be for
 this file system.

 @param f the path.
 @throws AccessControlException access control exception.
 @throws FileNotFoundException file not found exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.
 @return File Check sum.]]>
      </doc>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFileStatus(Path)} 
 except that an UnresolvedLinkException may be thrown if a symlink is 
 encountered in the path.

 @param f the path.
 @throws AccessControlException access control exception.
 @throws FileNotFoundException file not found exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.
 @return File Status]]>
      </doc>
    </method>
    <method name="msync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Synchronize client metadata state.
 <p>
 In some FileSystem implementations such as HDFS metadata
 synchronization is essential to guarantee consistency of read requests
 particularly in HA setting.
 @throws IOException raised on errors performing I/O.
 @throws UnsupportedOperationException Unsupported Operation Exception.]]>
      </doc>
    </method>
    <method name="getFileLinkStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFileLinkStatus(Path)}
 except that an UnresolvedLinkException may be thrown if a symlink is  
 encountered in the path leading up to the final path component.
 If the file system does not support symlinks then the behavior is
 equivalent to {@link AbstractFileSystem#getFileStatus(Path)}.

 @param f the path.
 @throws AccessControlException access control exception.
 @throws FileNotFoundException file not found exception.
 @throws UnsupportedFileSystemException UnSupported File System Exception.
 @throws IOException raised on errors performing I/O.
 @return file status.]]>
      </doc>
    </method>
    <method name="getFileBlockLocations" return="org.apache.hadoop.fs.BlockLocation[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="start" type="long"/>
      <param name="len" type="long"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFileBlockLocations(Path, long, long)} except that
 Path f must be for this file system.

 @param f the path.
 @param start start.
 @param len length.
 @throws AccessControlException access control exception.
 @throws FileNotFoundException file not found exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.
 @return BlockLocation Array.]]>
      </doc>
    </method>
    <method name="getFsStatus" return="org.apache.hadoop.fs.FsStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFsStatus(Path)} except that Path f must be for this
 file system.

 @param f the path.
 @throws AccessControlException access control exception.
 @throws FileNotFoundException file not found exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.
 @return Fs Status.]]>
      </doc>
    </method>
    <method name="getFsStatus" return="org.apache.hadoop.fs.FsStatus"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFsStatus(Path)}.

 @throws AccessControlException access control exception.
 @throws FileNotFoundException file not found exception.
 @throws IOException raised on errors performing I/O.
 @return Fs Status.]]>
      </doc>
    </method>
    <method name="listStatusIterator" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#listStatus(Path)} except that Path f must be for this
 file system.

 @param f path.
 @throws AccessControlException access control exception.
 @throws FileNotFoundException file not found exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.
 @return FileStatus Iterator.]]>
      </doc>
    </method>
    <method name="listLocatedStatus" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#listLocatedStatus(Path)} except that Path f 
 must be for this file system.

 In HDFS implementation, the BlockLocation of returned LocatedFileStatus
 will have different formats for replicated and erasure coded file. Please
 refer to {@link FileSystem#getFileBlockLocations(FileStatus, long, long)}
 for more details.

 @param f the path.
 @throws AccessControlException access control exception.
 @throws FileNotFoundException file not found exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.
 @return FileStatus Iterator.]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext.Util#listStatus(Path)} except that Path f must be 
 for this file system.
 @param f the path.
 @throws AccessControlException access control exception.
 @throws FileNotFoundException file not found exception.
 @throws UnresolvedLinkException unresolved link exception.
 @throws IOException raised on errors performing I/O.
 @return FileStatus Iterator.]]>
      </doc>
    </method>
    <method name="listCorruptFileBlocks" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@return an iterator over the corrupt files under the given path
 (may contain duplicates if a file has more than one corrupt block)
 @param path the path.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="setVerifyChecksum"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="verifyChecksum" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#setVerifyChecksum(boolean, Path)} except that Path f
 must be for this file system.

 @param verifyChecksum verify check sum flag.
 @throws AccessControlException access control exception.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getCanonicalServiceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a canonical name for this file system.
 @return a URI string that uniquely identifies this file system]]>
      </doc>
    </method>
    <method name="modifyAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Modifies ACL entries of files and directories.  This method can add new ACL
 entries or modify the permissions on existing ACL entries.  All existing
 ACL entries that are not specified in this call are retained without
 changes.  (Modifications are merged into the current ACL.)

 @param path Path to modify
 @param aclSpec List{@literal <AclEntry>} describing modifications
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes ACL entries from files and directories.  Other ACL entries are
 retained.

 @param path Path to modify
 @param aclSpec List{@literal <AclEntry>} describing entries to remove
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeDefaultAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes all default ACL entries from files and directories.

 @param path Path to modify
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes all but the base ACL entries of files and directories.  The entries
 for user, group, and others are retained for compatibility with permission
 bits.

 @param path Path to modify
 @throws IOException if an ACL could not be removed]]>
      </doc>
    </method>
    <method name="setAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fully replaces ACL of files and directories, discarding all existing
 entries.

 @param path Path to modify
 @param aclSpec List{@literal <AclEntry>} describing modifications, must
 include entries for user, group, and others for compatibility with
 permission bits.
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="getAclStatus" return="org.apache.hadoop.fs.permission.AclStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets the ACLs of files and directories.

 @param path Path to get
 @return RemoteIterator{@literal <AclStatus>} which returns each AclStatus
 @throws IOException if an ACL could not be read]]>
      </doc>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to modify
 @param name xattr name.
 @param value xattr value.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <param name="flag" type="java.util.EnumSet"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to modify
 @param name xattr name.
 @param value xattr value.
 @param flag xattr set flag
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getXAttr" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get an xattr for a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attribute
 @param name xattr name.
 @return byte[] xattr value.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattrs for a file or directory.
 Only those xattrs for which the logged-in user has permissions to view
 are returned.
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes

 @return {@literal Map<String, byte[]>} describing the XAttrs of the file
 or directory
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="names" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattrs for a file or directory.
 Only those xattrs for which the logged-in user has permissions to view
 are returned.
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @param names XAttr names.
 @return {@literal Map<String, byte[]>} describing the XAttrs of the file
 or directory
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="listXAttrs" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattr names for a file or directory.
 Only the xattr names for which the logged-in user has permissions to view
 are returned.
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @return {@literal Map<String, byte[]>} describing the XAttrs of the file
 or directory
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="removeXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Remove an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to remove extended attribute
 @param name xattr name
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="createSnapshot" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#createSnapshot(Path, String)}.

 @param path the path.
 @param snapshotName snapshot name.
 @throws IOException raised on errors performing I/O.
 @return path.]]>
      </doc>
    </method>
    <method name="renameSnapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotOldName" type="java.lang.String"/>
      <param name="snapshotNewName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#renameSnapshot(Path, String, String)}.

 @param path the path.
 @param snapshotOldName snapshot old name.
 @param snapshotNewName snapshot new name.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="deleteSnapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="snapshotDir" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#deleteSnapshot(Path, String)}.

 @param snapshotDir snapshot dir.
 @param snapshotName snapshot name.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="satisfyStoragePolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the source path to satisfy storage policy.
 @param path The source path referring to either a directory or a file.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="setStoragePolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="policyName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the storage policy for a given file or directory.

 @param path file or directory path.
 @param policyName the name of the target storage policy. The list
                   of supported Storage policies can be retrieved
                   via {@link #getAllStoragePolicies}.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="unsetStoragePolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Unset the storage policy set for a given file or directory.
 @param src file or directory path.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getStoragePolicy" return="org.apache.hadoop.fs.BlockStoragePolicySpi"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Retrieve the storage policy for a given file or directory.

 @param src file or directory path.
 @return storage policy for give file.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getAllStoragePolicies" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Retrieve all the storage policies supported by this file system.

 @return all storage policies supported by this filesystem.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="openFileWithOptions" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="parameters" type="org.apache.hadoop.fs.impl.OpenFileParameters"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Open a file with the given set of options.
 The base implementation performs a blocking
 call to {@link #open(Path, int)}in this call;
 the actual outcome is in the returned {@code CompletableFuture}.
 This avoids having to create some thread pool, while still
 setting up the expectation that the {@code get()} call
 is needed to evaluate the result.
 @param path path to the file
 @param parameters open file parameters from the builder.
 @return a future which will evaluate to the opened file.
 @throws IOException failure to resolve the link.
 @throws IllegalArgumentException unknown mandatory key]]>
      </doc>
    </method>
    <method name="hasPathCapability" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="capability" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createMultipartUploader" return="org.apache.hadoop.fs.MultipartUploaderBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="basePath" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a multipart uploader.
 @param basePath file path under which all files are uploaded
 @return a MultipartUploaderBuilder object to build the uploader
 @throws IOException if some early checks cause IO failures.
 @throws UnsupportedOperationException if support is checked early.]]>
      </doc>
    </method>
    <method name="methodNotSupported"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Helper method that throws an {@link UnsupportedOperationException} for the
 current {@link FileSystem} method being called.]]>
      </doc>
    </method>
    <field name="statistics" type="org.apache.hadoop.fs.FileSystem.Statistics"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The statistics for this file system.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This class provides an interface for implementors of a Hadoop file system
 (analogous to the VFS of Unix). Applications do not access this class;
 instead they access files across all file systems using {@link FileContext}.
 
 Pathnames passed to AbstractFileSystem can be fully qualified URI that
 matches the "this" file system (ie same scheme and authority) 
 or a Slash-relative name that is assumed to be relative
 to the root of the "this" file system .]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.AbstractFileSystem -->
  <!-- start class org.apache.hadoop.fs.AvroFSInput -->
  <class name="AvroFSInput" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <implements name="org.apache.avro.file.SeekableInput"/>
    <constructor name="AvroFSInput" type="org.apache.hadoop.fs.FSDataInputStream, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct given an {@link FSDataInputStream} and its length.

 @param in inputstream.
 @param len len.]]>
      </doc>
    </constructor>
    <constructor name="AvroFSInput" type="org.apache.hadoop.fs.FileContext, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct given a {@link FileContext} and a {@link Path}.
 @param fc filecontext.
 @param p the path.
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </constructor>
    <method name="length" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="seek"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="tell" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Adapts an {@link FSDataInputStream} to Avro's SeekableInput interface.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.AvroFSInput -->
  <!-- start interface org.apache.hadoop.fs.BatchListingOperations -->
  <interface name="BatchListingOperations"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="batchedListStatusIterator" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="paths" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Batched listing API that returns {@link PartialListing}s for the
 passed Paths.

 @param paths List of paths to list.
 @return RemoteIterator that returns corresponding PartialListings.
 @throws IOException failure]]>
      </doc>
    </method>
    <method name="batchedListLocatedStatusIterator" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="paths" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Batched listing API that returns {@link PartialListing}s for the passed
 Paths. The PartialListing will contain {@link LocatedFileStatus} entries
 with locations.

 @param paths List of paths to list.
 @return RemoteIterator that returns corresponding PartialListings.
 @throws IOException failure]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface filesystems MAY implement to offer a batched list.
 If implemented, filesystems SHOULD declare
 {@link CommonPathCapabilities#FS_EXPERIMENTAL_BATCH_LISTING} to be a supported
 path capability.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.BatchListingOperations -->
  <!-- start class org.apache.hadoop.fs.BlockLocation -->
  <class name="BlockLocation" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="BlockLocation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default Constructor.]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="org.apache.hadoop.fs.BlockLocation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Copy constructor.
 @param that blocklocation.]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with host, name, offset and length.
 @param names names array.
 @param hosts host array.
 @param offset offset.
 @param length length.]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], long, long, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with host, name, offset, length and corrupt flag.
 @param names names.
 @param hosts hosts.
 @param offset offset.
 @param length length.
 @param corrupt corrupt.]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], java.lang.String[], long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with host, name, network topology, offset and length.
 @param names names.
 @param hosts hosts.
 @param topologyPaths topologyPaths.
 @param offset offset.
 @param length length.]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], java.lang.String[], long, long, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with host, name, network topology, offset, length 
 and corrupt flag.
 @param names names.
 @param hosts hosts.
 @param topologyPaths topologyPaths.
 @param offset offset.
 @param length length.
 @param corrupt corrupt.]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], java.lang.String[], java.lang.String[], long, long, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], java.lang.String[], java.lang.String[], java.lang.String[], org.apache.hadoop.fs.StorageType[], long, long, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHosts" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the list of hosts (hostname) hosting this block.
 @return hosts array.
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="getCachedHosts" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the list of hosts (hostname) hosting a cached replica of the block.
 @return cached hosts.]]>
      </doc>
    </method>
    <method name="getNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the list of names (IP:xferPort) hosting this block.
 @return names array.
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="getTopologyPaths" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the list of network topology paths for each of the hosts.
 The last component of the path is the "name" (IP:xferPort).
 @return topology paths.
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="getStorageIds" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the storageID of each replica of the block.
 @return storage ids.]]>
      </doc>
    </method>
    <method name="getStorageTypes" return="org.apache.hadoop.fs.StorageType[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the storage type of each replica of the block.
 @return storage type of each replica of the block.]]>
      </doc>
    </method>
    <method name="getOffset" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the start offset of file associated with this block.
 @return start offset of file associated with this block.]]>
      </doc>
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the length of the block.
 @return length of the block.]]>
      </doc>
    </method>
    <method name="isCorrupt" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the corrupt flag.
 @return corrupt flag.]]>
      </doc>
    </method>
    <method name="isStriped" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return true if the block is striped (erasure coded).
 @return if the block is striped true, not false.]]>
      </doc>
    </method>
    <method name="setOffset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="offset" type="long"/>
      <doc>
      <![CDATA[Set the start offset of file associated with this block.
 @param offset start offset.]]>
      </doc>
    </method>
    <method name="setLength"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="length" type="long"/>
      <doc>
      <![CDATA[Set the length of block.
 @param length length of block.]]>
      </doc>
    </method>
    <method name="setCorrupt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="corrupt" type="boolean"/>
      <doc>
      <![CDATA[Set the corrupt flag.
 @param corrupt corrupt flag.]]>
      </doc>
    </method>
    <method name="setHosts"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hosts" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the hosts hosting this block.
 @param hosts hosts array.
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="setCachedHosts"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cachedHosts" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Set the hosts hosting a cached replica of this block.
 @param cachedHosts cached hosts.]]>
      </doc>
    </method>
    <method name="setNames"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the names (host:port) hosting this block.
 @param names names.
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="setTopologyPaths"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="topologyPaths" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the network topology paths of the hosts.

 @param topologyPaths topology paths.
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="setStorageIds"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="storageIds" type="java.lang.String[]"/>
    </method>
    <method name="setStorageTypes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="storageTypes" type="org.apache.hadoop.fs.StorageType[]"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents the network location of a block, information about the hosts
 that contain block replicas, and other block metadata (E.g. the file
 offset associated with the block, length, whether it is corrupt, etc).

 For a single BlockLocation, it will have different meanings for replicated
 and erasure coded files.

 If the file is 3-replicated, offset and length of a BlockLocation represent
 the absolute value in the file and the hosts are the 3 datanodes that
 holding the replicas. Here is an example:
 <pre>
 BlockLocation(offset: 0, length: BLOCK_SIZE,
   hosts: {"host1:9866", "host2:9866, host3:9866"})
 </pre>

 And if the file is erasure-coded, each BlockLocation represents a logical
 block groups. Value offset is the offset of a block group in the file and
 value length is the total length of a block group. Hosts of a BlockLocation
 are the datanodes that holding all the data blocks and parity blocks of a
 block group.
 Suppose we have a RS_3_2 coded file (3 data units and 2 parity units).
 A BlockLocation example will be like:
 <pre>
 BlockLocation(offset: 0, length: 3 * BLOCK_SIZE, hosts: {"host1:9866",
   "host2:9866","host3:9866","host4:9866","host5:9866"})
 </pre>

 Please refer to
 {@link FileSystem#getFileBlockLocations(FileStatus, long, long)} or
 {@link FileContext#getFileBlockLocations(Path, long, long)}
 for more examples.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.BlockLocation -->
  <!-- start interface org.apache.hadoop.fs.BlockStoragePolicySpi -->
  <interface name="BlockStoragePolicySpi"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the name of the storage policy. Policies are uniquely
 identified by name.

 @return the name of the storage policy.]]>
      </doc>
    </method>
    <method name="getStorageTypes" return="org.apache.hadoop.fs.StorageType[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the preferred storage types associated with this policy. These
 storage types are used sequentially for successive block replicas.

 @return preferred storage types used for placing block replicas.]]>
      </doc>
    </method>
    <method name="getCreationFallbacks" return="org.apache.hadoop.fs.StorageType[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the fallback storage types for creating new block replicas. Fallback
 storage types are used if the preferred storage types are not available.

 @return fallback storage types for new block replicas..]]>
      </doc>
    </method>
    <method name="getReplicationFallbacks" return="org.apache.hadoop.fs.StorageType[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the fallback storage types for replicating existing block replicas.
 Fallback storage types are used if the preferred storage types are not
 available.

 @return fallback storage types for replicating existing block replicas.]]>
      </doc>
    </method>
    <method name="isCopyOnCreateFile" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the policy is inherit-only and cannot be changed for
 an existing file.

 @return true if the policy is inherit-only.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A storage policy specifies the placement of block replicas on specific
 storage types.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.BlockStoragePolicySpi -->
  <!-- start interface org.apache.hadoop.fs.ByteBufferPositionedReadable -->
  <interface name="ByteBufferPositionedReadable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="read" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buf" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads up to {@code buf.remaining()} bytes into buf from a given position
 in the file and returns the number of bytes read. Callers should use
 {@code buf.limit(...)} to control the size of the desired read and
 {@code buf.position(...)} to control the offset into the buffer the data
 should be written to.
 <p>
 After a successful call, {@code buf.position()} will be advanced by the
 number of bytes read and {@code buf.limit()} will be unchanged.
 <p>
 In the case of an exception, the state of the buffer (the contents of the
 buffer, the {@code buf.position()}, the {@code buf.limit()}, etc.) is
 undefined, and callers should be prepared to recover from this
 eventuality.
 <p>
 Callers should use {@link StreamCapabilities#hasCapability(String)} with
 {@link StreamCapabilities#PREADBYTEBUFFER} to check if the underlying
 stream supports this interface, otherwise they might get a
 {@link UnsupportedOperationException}.
 <p>
 Implementations should treat 0-length requests as legitimate, and must not
 signal an error upon their receipt.
 <p>
 This does not change the current offset of a file, and is thread-safe.

 @param position position within file
 @param buf the ByteBuffer to receive the results of the read operation.
 @return the number of bytes read, possibly zero, or -1 if reached
         end-of-stream
 @throws IOException if there is some error performing the read]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buf" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads {@code buf.remaining()} bytes into buf from a given position in
 the file or until the end of the data was reached before the read
 operation completed. Callers should use {@code buf.limit(...)} to
 control the size of the desired read and {@code buf.position(...)} to
 control the offset into the buffer the data should be written to.
 <p>
 This operation provides similar semantics to
 {@link #read(long, ByteBuffer)}, the difference is that this method is
 guaranteed to read data until the {@link ByteBuffer} is full, or until
 the end of the data stream is reached.

 @param position position within file
 @param buf the ByteBuffer to receive the results of the read operation.
 @throws IOException if there is some error performing the read
 @throws EOFException the end of the data was reached before
 the read operation completed
 @see #read(long, ByteBuffer)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementers of this interface provide a positioned read API that writes to a
 {@link ByteBuffer} rather than a {@code byte[]}.

 @see PositionedReadable
 @see ByteBufferReadable]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.ByteBufferPositionedReadable -->
  <!-- start interface org.apache.hadoop.fs.ByteBufferReadable -->
  <interface name="ByteBufferReadable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="read" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads up to buf.remaining() bytes into buf. Callers should use
 buf.limit(..) to control the size of the desired read.
 <p>
 After a successful call, {@code buf.position()} will be advanced by the
 number of bytes read and {@code buf.limit()} will be unchanged.
 <p>
 In the case of an exception, the state of the buffer (the contents of the
 buffer, the {@code buf.position()}, the {@code buf.limit()}, etc.) is
 undefined, and callers should be prepared to recover from this
 eventuality.
 <p>
 Callers should use {@link StreamCapabilities#hasCapability(String)} with
 {@link StreamCapabilities#READBYTEBUFFER} to check if the underlying
 stream supports this interface, otherwise they might get a
 {@link UnsupportedOperationException}.
 <p>
 Implementations should treat 0-length requests as legitimate, and must not
 signal an error upon their receipt.

 @param buf
          the ByteBuffer to receive the results of the read operation.
 @return the number of bytes read, possibly zero, or -1 if 
         reach end-of-stream
 @throws IOException
           if there is some error performing the read]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementers of this interface provide a read API that writes to a
 ByteBuffer, not a byte[].]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.ByteBufferReadable -->
  <!-- start interface org.apache.hadoop.fs.CanSetDropBehind -->
  <interface name="CanSetDropBehind"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setDropBehind"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dropCache" type="java.lang.Boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Configure whether the stream should drop the cache.

 @param dropCache     Whether to drop the cache.  null means to use the
                      default value.
 @throws IOException  If there was an error changing the dropBehind
                      setting.
         UnsupportedOperationException  If this stream doesn't support
                                        setting the drop-behind.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.fs.CanSetDropBehind -->
  <!-- start interface org.apache.hadoop.fs.CanSetReadahead -->
  <interface name="CanSetReadahead"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setReadahead"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readahead" type="java.lang.Long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Set the readahead on this stream.

 @param readahead     The readahead to use.  null means to use the default.
 @throws IOException  If there was an error changing the dropBehind
                      setting.
         UnsupportedOperationException  If this stream doesn't support
                                        setting readahead.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.fs.CanSetReadahead -->
  <!-- start interface org.apache.hadoop.fs.CanUnbuffer -->
  <interface name="CanUnbuffer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="unbuffer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reduce the buffering.  This will also free sockets and file descriptors
 held by the stream, if possible.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[FSDataInputStreams implement this interface to indicate that they can clear
 their buffers on request.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.CanUnbuffer -->
  <!-- start class org.apache.hadoop.fs.ChecksumException -->
  <class name="ChecksumException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ChecksumException" type="java.lang.String, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown for checksum errors.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ChecksumException -->
  <!-- start class org.apache.hadoop.fs.ChecksumFileSystem -->
  <class name="ChecksumFileSystem" extends="org.apache.hadoop.fs.FilterFileSystem"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ChecksumFileSystem" type="org.apache.hadoop.fs.FileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getApproxChkSumLength" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="long"/>
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="setVerifyChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="verifyChecksum" type="boolean"/>
      <doc>
      <![CDATA[Set whether to verify checksum.]]>
      </doc>
    </method>
    <method name="setWriteChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writeChecksum" type="boolean"/>
    </method>
    <method name="getRawFileSystem" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the raw file system]]>
      </doc>
    </method>
    <method name="getChecksumFile" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Return the name of the checksum file associated with a file.

 @param file the file path.
 @return name of the checksum file associated with a file.]]>
      </doc>
    </method>
    <method name="isChecksumFile" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Return true if file is a checksum file name.

 @param file the file path.
 @return if file is a checksum file true, not false.]]>
      </doc>
    </method>
    <method name="getChecksumFileLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="fileSize" type="long"/>
      <doc>
      <![CDATA[Return the length of the checksum file given the size of the
 actual file.

 @param file the file path.
 @param fileSize file size.
 @return checksum length.]]>
      </doc>
    </method>
    <method name="getBytesPerSum" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the bytes Per Checksum.

 @return bytes per check sum.]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataInputStream at the indicated Path.
 @param f the file name to open
 @param bufferSize the size of the buffer to be used.
 @throws IOException if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="truncate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="newLength" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="concat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="psrcs" type="org.apache.hadoop.fs.Path[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getChecksumLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="long"/>
      <param name="bytesPerSum" type="int"/>
      <doc>
      <![CDATA[Calculated the length of the checksum file in bytes.
 @param size the length of the data file in bytes
 @param bytesPerSum the number of bytes in a checksum block
 @return the number of bytes in the checksum file]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createNonRecursive" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flags" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="checksumOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createNonRecursive" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flags" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="modifyAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeDefaultAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setReplication" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set replication for an existing file.
 Implement the abstract <tt>setReplication</tt> of <tt>FileSystem</tt>
 @param src file name
 @param replication new replication
 @throws IOException if an I/O error occurs.
 @return true if successful;
         false if file does not exist or is a directory]]>
      </doc>
    </method>
    <method name="rename" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Rename files/dirs]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Implement the delete(Path, boolean) in checksum
 file system.]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses of the files/directories in the given path if the path is
 a directory.

 @param f
          given path
 @return the statuses of the files/directories in the given path
 @throws IOException if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="listStatusIterator" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="listLocatedStatus" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses of the files/directories in the given path if the path is
 a directory.

 @param f
          given path
 @return the statuses of the files/directories in the given patch
 @throws IOException if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under FS, and the dst is on the local disk.
 Copy it from FS control to the local dst name.]]>
      </doc>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="copyCrc" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under FS, and the dst is on the local disk.
 Copy it from FS control to the local dst name.
 If src and dst are directories, the copyCrc parameter
 determines whether to copy CRC files.
 @param src src path.
 @param dst dst path.
 @param copyCrc copy csc flag.
 @throws IOException if an I/O error occurs.]]>
      </doc>
    </method>
    <method name="startLocalOutput" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="completeLocalOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="reportChecksumFailure" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="in" type="org.apache.hadoop.fs.FSDataInputStream"/>
      <param name="inPos" type="long"/>
      <param name="sums" type="org.apache.hadoop.fs.FSDataInputStream"/>
      <param name="sumsPos" type="long"/>
      <doc>
      <![CDATA[Report a checksum error to the file system.
 @param f the file name containing the error
 @param in the stream open on the file
 @param inPos the position of the beginning of the bad data in the file
 @param sums the stream open on the checksum file
 @param sumsPos the position of the beginning of the bad data in the checksum file
 @return if retry is necessary]]>
      </doc>
    </method>
    <method name="openFile" return="org.apache.hadoop.fs.FutureDataInputStreamBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[This is overridden to ensure that this class's
 {@link #openFileWithOptions}() method is called, and so ultimately
 its {@link #open(Path, int)}.

 {@inheritDoc}]]>
      </doc>
    </method>
    <method name="openFileWithOptions" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="parameters" type="org.apache.hadoop.fs.impl.OpenFileParameters"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Open the file as a blocking call to {@link #open(Path, int)}.

 {@inheritDoc}]]>
      </doc>
    </method>
    <method name="createFile" return="org.apache.hadoop.fs.FSDataOutputStreamBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[This is overridden to ensure that this class's create() method is
 ultimately called.

 {@inheritDoc}]]>
      </doc>
    </method>
    <method name="appendFile" return="org.apache.hadoop.fs.FSDataOutputStreamBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[This is overridden to ensure that this class's create() method is
 ultimately called.

 {@inheritDoc}]]>
      </doc>
    </method>
    <method name="hasPathCapability" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="capability" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Disable those operations which the checksummed FS blocks.
 {@inheritDoc}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstract Checksumed FileSystem.
 It provide a basic implementation of a Checksumed FileSystem,
 which creates a checksum file for each raw file.
 It generates &amp; verifies checksums at the client side.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ChecksumFileSystem -->
  <!-- start class org.apache.hadoop.fs.CommonConfigurationKeysPublic -->
  <class name="CommonConfigurationKeysPublic" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CommonConfigurationKeysPublic"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="NET_TOPOLOGY_SCRIPT_NUMBER_ARGS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_SCRIPT_NUMBER_ARGS_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for NET_TOPOLOGY_SCRIPT_NUMBER_ARGS_KEY]]>
      </doc>
    </field>
    <field name="FS_DEFAULT_NAME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_DEFAULT_NAME_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_DEFAULT_NAME_KEY]]>
      </doc>
    </field>
    <field name="FS_DF_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_DF_INTERVAL_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_DF_INTERVAL_KEY]]>
      </doc>
    </field>
    <field name="FS_DU_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_DU_INTERVAL_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_DU_INTERVAL_KEY]]>
      </doc>
    </field>
    <field name="FS_GETSPACEUSED_CLASSNAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_GETSPACEUSED_JITTER_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_GETSPACEUSED_JITTER_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_GETSPACEUSED_JITTER_KEY]]>
      </doc>
    </field>
    <field name="FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_KEY]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_NODE_SWITCH_MAPPING_IMPL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_IMPL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_TABLE_MAPPING_FILE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="NET_DEPENDENCY_SCRIPT_FILE_NAME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FS_TRASH_CHECKPOINT_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_TRASH_CHECKPOINT_INTERVAL_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_TRASH_CHECKPOINT_INTERVAL_KEY]]>
      </doc>
    </field>
    <field name="FS_PROTECTED_DIRECTORIES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Directories that cannot be removed unless empty, even by an
 administrator.]]>
      </doc>
    </field>
    <field name="FS_LOCAL_BLOCK_SIZE_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Not used anywhere, looks like default value for FS_LOCAL_BLOCK_SIZE]]>
      </doc>
    </field>
    <field name="FS_AUTOMATIC_CLOSE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_AUTOMATIC_CLOSE_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_AUTOMATIC_CLOSE_KEY]]>
      </doc>
    </field>
    <field name="FS_CREATION_PARALLEL_COUNT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Number of filesystems instances can be created in parallel.
 <p>
 A higher number here does not necessarily improve performance, especially
 for object stores, where multiple threads may be attempting to create an FS
 instance for the same URI.
 </p>
 Default value: {@value}.]]>
      </doc>
    </field>
    <field name="FS_CREATION_PARALLEL_COUNT_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for {@link #FS_CREATION_PARALLEL_COUNT}.
 <p>
 Default value: {@value}.
 </p>]]>
      </doc>
    </field>
    <field name="FS_FILE_IMPL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_FTP_HOST_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_FTP_HOST_PORT_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_TRASH_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_TRASH_INTERVAL_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_TRASH_INTERVAL_KEY]]>
      </doc>
    </field>
    <field name="FS_CLIENT_TOPOLOGY_RESOLUTION_ENABLED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_CLIENT_TOPOLOGY_RESOLUTION_ENABLED_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_CLIENT_TOPOLOGY_RESOLUTION_ENABLED.]]>
      </doc>
    </field>
    <field name="IO_MAPFILE_BLOOM_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_MAPFILE_BLOOM_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_MAPFILE_BLOOM_SIZE_KEY]]>
      </doc>
    </field>
    <field name="IO_MAPFILE_BLOOM_ERROR_RATE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_MAPFILE_BLOOM_ERROR_RATE_DEFAULT" type="float"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_MAPFILE_BLOOM_ERROR_RATE_KEY]]>
      </doc>
    </field>
    <field name="IO_COMPRESSION_CODEC_LZO_CLASS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Codec class that implements Lzo compression algorithm]]>
      </doc>
    </field>
    <field name="IO_MAP_INDEX_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_MAP_INDEX_INTERVAL_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_MAP_INDEX_INTERVAL_DEFAULT]]>
      </doc>
    </field>
    <field name="IO_MAP_INDEX_SKIP_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_MAP_INDEX_SKIP_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_MAP_INDEX_SKIP_KEY]]>
      </doc>
    </field>
    <field name="IO_SEQFILE_COMPRESS_BLOCKSIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_SEQFILE_COMPRESS_BLOCKSIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_SEQFILE_COMPRESS_BLOCKSIZE_KEY]]>
      </doc>
    </field>
    <field name="IO_FILE_BUFFER_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_FILE_BUFFER_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_FILE_BUFFER_SIZE_KEY]]>
      </doc>
    </field>
    <field name="IO_SKIP_CHECKSUM_ERRORS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_SKIP_CHECKSUM_ERRORS_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_SKIP_CHECKSUM_ERRORS_KEY]]>
      </doc>
    </field>
    <field name="IO_SORT_MB_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Moved to mapreduce, see mapreduce.task.io.sort.mb
 in mapred-default.xml
 See https://issues.apache.org/jira/browse/HADOOP-6801

 For {@link org.apache.hadoop.io.SequenceFile.Sorter} control
 instead, see {@link #SEQ_IO_SORT_MB_KEY}.">
      <doc>
      <![CDATA[@deprecated Moved to mapreduce, see mapreduce.task.io.sort.mb
 in mapred-default.xml
 See https://issues.apache.org/jira/browse/HADOOP-6801

 For {@link org.apache.hadoop.io.SequenceFile.Sorter} control
 instead, see {@link #SEQ_IO_SORT_MB_KEY}.]]>
      </doc>
    </field>
    <field name="IO_SORT_MB_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for {@link #IO_SORT_MB_KEY}.]]>
      </doc>
    </field>
    <field name="IO_SORT_FACTOR_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Moved to mapreduce, see mapreduce.task.io.sort.factor
 in mapred-default.xml
 See https://issues.apache.org/jira/browse/HADOOP-6801

 For {@link org.apache.hadoop.io.SequenceFile.Sorter} control
 instead, see {@link #SEQ_IO_SORT_FACTOR_KEY}.">
      <doc>
      <![CDATA[@deprecated Moved to mapreduce, see mapreduce.task.io.sort.factor
 in mapred-default.xml
 See https://issues.apache.org/jira/browse/HADOOP-6801

 For {@link org.apache.hadoop.io.SequenceFile.Sorter} control
 instead, see {@link #SEQ_IO_SORT_FACTOR_KEY}.]]>
      </doc>
    </field>
    <field name="IO_SORT_FACTOR_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for {@link #IO_SORT_FACTOR_KEY}.]]>
      </doc>
    </field>
    <field name="SEQ_IO_SORT_MB_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="SEQ_IO_SORT_MB_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for {@link #SEQ_IO_SORT_MB_KEY}.]]>
      </doc>
    </field>
    <field name="SEQ_IO_SORT_FACTOR_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="SEQ_IO_SORT_FACTOR_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for {@link #SEQ_IO_SORT_FACTOR_KEY}.]]>
      </doc>
    </field>
    <field name="IO_SERIALIZATIONS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="TFILE_IO_CHUNK_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="TFILE_IO_CHUNK_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for TFILE_IO_CHUNK_SIZE_DEFAULT]]>
      </doc>
    </field>
    <field name="TFILE_FS_INPUT_BUFFER_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="TFILE_FS_INPUT_BUFFER_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for TFILE_FS_INPUT_BUFFER_SIZE_KEY]]>
      </doc>
    </field>
    <field name="TFILE_FS_OUTPUT_BUFFER_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="TFILE_FS_OUTPUT_BUFFER_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for TFILE_FS_OUTPUT_BUFFER_SIZE_KEY]]>
      </doc>
    </field>
    <field name="HADOOP_CALLER_CONTEXT_ENABLED_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_CALLER_CONTEXT_ENABLED_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_CALLER_CONTEXT_MAX_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_CALLER_CONTEXT_MAX_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_CALLER_CONTEXT_SIGNATURE_MAX_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_CALLER_CONTEXT_SIGNATURE_MAX_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_CALLER_CONTEXT_SEPARATOR_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_CALLER_CONTEXT_SEPARATOR_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="IPC_CLIENT_CONNECTION_MAXIDLETIME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECTION_MAXIDLETIME_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_CONNECTION_MAXIDLETIME_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_TIMEOUT_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_TIMEOUT_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_CONNECT_TIMEOUT_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_MAX_RETRIES_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_MAX_RETRIES_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_CONNECT_MAX_RETRIES_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_RETRY_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_RETRY_INTERVAL_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_CONNECT_RETRY_INTERVAL_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_MAX_RETRIES_ON_SOCKET_TIMEOUTS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_MAX_RETRIES_ON_SOCKET_TIMEOUTS_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_CONNECT_MAX_RETRIES_ON_SOCKET_TIMEOUTS_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_TCPNODELAY_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_TCPNODELAY_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_TCPNODELAY_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_LOW_LATENCY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Enable low-latency connections from the client]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_LOW_LATENCY_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value of IPC_CLIENT_LOW_LATENCY]]>
      </doc>
    </field>
    <field name="IPC_SERVER_LISTEN_QUEUE_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_SERVER_LISTEN_QUEUE_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_SERVER_LISTEN_QUEUE_SIZE_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_KILL_MAX_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_KILL_MAX_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_KILL_MAX_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_IDLETHRESHOLD_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_IDLETHRESHOLD_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_IDLETHRESHOLD_DEFAULT]]>
      </doc>
    </field>
    <field name="IPC_SERVER_TCPNODELAY_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_SERVER_TCPNODELAY_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_SERVER_TCPNODELAY_KEY]]>
      </doc>
    </field>
    <field name="IPC_SERVER_REUSEADDR_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_SERVER_REUSEADDR_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_SERVER_REUSEADDR_KEY.]]>
      </doc>
    </field>
    <field name="IPC_SERVER_MAX_CONNECTIONS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_SERVER_MAX_CONNECTIONS_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_SERVER_MAX_CONNECTIONS_KEY]]>
      </doc>
    </field>
    <field name="IPC_SERVER_LOG_SLOW_RPC" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Logs if a RPC is really slow compared to rest of RPCs.]]>
      </doc>
    </field>
    <field name="IPC_SERVER_LOG_SLOW_RPC_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="IPC_SERVER_PURGE_INTERVAL_MINUTES_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="IPC_SERVER_PURGE_INTERVAL_MINUTES_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_RPC_SOCKET_FACTORY_CLASS_DEFAULT_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_RPC_SOCKET_FACTORY_CLASS_DEFAULT_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SOCKS_SERVER_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_UTIL_HASH_TYPE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_UTIL_HASH_TYPE_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for HADOOP_UTIL_HASH_TYPE_KEY]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUP_MAPPING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_SECS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_SECS_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_NEGATIVE_CACHE_SECS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_NEGATIVE_CACHE_SECS_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_WARN_AFTER_MS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_WARN_AFTER_MS_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_BACKGROUND_RELOAD" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_BACKGROUND_RELOAD_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_BACKGROUND_RELOAD_THREADS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_BACKGROUND_RELOAD_THREADS_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUP_SHELL_COMMAND_TIMEOUT_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUP_SHELL_COMMAND_TIMEOUT_SECS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="use
 {@link CommonConfigurationKeysPublic#HADOOP_SECURITY_GROUP_SHELL_COMMAND_TIMEOUT_KEY}
 instead.">
      <doc>
      <![CDATA[@deprecated use
 {@link CommonConfigurationKeysPublic#HADOOP_SECURITY_GROUP_SHELL_COMMAND_TIMEOUT_KEY}
 instead.]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUP_SHELL_COMMAND_TIMEOUT_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUP_SHELL_COMMAND_TIMEOUT_SECS_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="use
 {@link CommonConfigurationKeysPublic#HADOOP_SECURITY_GROUP_SHELL_COMMAND_TIMEOUT_DEFAULT}
 instead.">
      <doc>
      <![CDATA[@deprecated use
 {@link CommonConfigurationKeysPublic#HADOOP_SECURITY_GROUP_SHELL_COMMAND_TIMEOUT_DEFAULT}
 instead.]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_AUTHENTICATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_AUTHORIZATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_INSTRUMENTATION_REQUIRES_ADMIN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_SERVICE_USER_NAME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_AUTH_TO_LOCAL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_AUTH_TO_LOCAL_MECHANISM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_DNS_INTERFACE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_DNS_NAMESERVER_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_TOKEN_FILES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_TOKENS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_HTTP_AUTHENTICATION_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN]]>
      </doc>
    </field>
    <field name="HADOOP_KERBEROS_KEYTAB_LOGIN_AUTORENEWAL_ENABLED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_KERBEROS_KEYTAB_LOGIN_AUTORENEWAL_ENABLED_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for HADOOP_KERBEROS_KEYTAB_LOGIN_AUTORENEWAL_ENABLED.]]>
      </doc>
    </field>
    <field name="HADOOP_RPC_PROTECTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_SASL_PROPS_RESOLVER_CLASS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Class to override Sasl Properties for a connection]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_CODEC_CLASSES_KEY_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_CODEC_CLASSES_AES_CTR_NOPADDING_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_CODEC_CLASSES_AES_CTR_NOPADDING_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_CIPHER_SUITE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_CIPHER_SUITE_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_JCE_PROVIDER_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_JCEKS_KEY_SERIALFILTER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_BUFFER_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_BUFFER_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Defalt value for HADOOP_SECURITY_CRYPTO_BUFFER_SIZE_KEY]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_IMPERSONATION_PROVIDER_CLASS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Class to override Impersonation provider]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_KEY_PROVIDER_PATH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_KEY_DEFAULT_BITLENGTH_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_KEY_DEFAULT_BITLENGTH_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Defalt value for HADOOP_SECURITY_KEY_DEFAULT_BITLENGTH_KEY.]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_KEY_DEFAULT_CIPHER_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_KEY_DEFAULT_CIPHER_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Defalt value for HADOOP_SECURITY_KEY_DEFAULT_CIPHER_KEY.]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_ENC_KEY_CACHE_SIZE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_ENC_KEY_CACHE_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for KMS_CLIENT_ENC_KEY_CACHE_SIZE]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_ENC_KEY_CACHE_LOW_WATERMARK" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_ENC_KEY_CACHE_LOW_WATERMARK_DEFAULT" type="float"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for KMS_CLIENT_ENC_KEY_CACHE_LOW_WATERMARK]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_ENC_KEY_CACHE_NUM_REFILL_THREADS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_ENC_KEY_CACHE_NUM_REFILL_THREADS_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for KMS_CLIENT_ENC_KEY_NUM_REFILL_THREADS]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_ENC_KEY_CACHE_EXPIRY_MS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_ENC_KEY_CACHE_EXPIRY_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for KMS_CLIENT_ENC_KEY_CACHE_EXPIRY (12 hrs)]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_TIMEOUT_SECONDS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_TIMEOUT_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value is the number of providers specified.]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_FAILOVER_SLEEP_BASE_MILLIS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_FAILOVER_SLEEP_BASE_MILLIS_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value is 100 ms.]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_FAILOVER_SLEEP_MAX_MILLIS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_FAILOVER_SLEEP_MAX_MILLIS_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value is 2 secs.]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_JAVA_SECURE_RANDOM_ALGORITHM_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_JAVA_SECURE_RANDOM_ALGORITHM_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Defalt value for HADOOP_SECURITY_JAVA_SECURE_RANDOM_ALGORITHM_KEY]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_SECURE_RANDOM_IMPL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_SECURE_RANDOM_DEVICE_FILE_PATH_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_SECURE_RANDOM_DEVICE_FILE_PATH_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SHELL_MISSING_DEFAULT_FS_WARNING_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SHELL_MISSING_DEFAULT_FS_WARNING_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SHELL_SAFELY_DELETE_LIMIT_NUM_FILES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SHELL_SAFELY_DELETE_LIMIT_NUM_FILES_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_HTTP_LOGS_ENABLED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_HTTP_LOGS_ENABLED_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Defalt value for HADOOP_HTTP_LOGS_ENABLED]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CREDENTIAL_PROVIDER_PATH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CREDENTIAL_CLEAR_TEXT_FALLBACK" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CREDENTIAL_CLEAR_TEXT_FALLBACK_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SECURITY_CREDENTIAL_PASSWORD_FILE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_SENSITIVE_CONFIG_KEYS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_SENSITIVE_CONFIG_KEYS_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SYSTEM_TAGS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Please use
 {@link CommonConfigurationKeysPublic#HADOOP_TAGS_SYSTEM} instead
 See https://issues.apache.org/jira/browse/HADOOP-15474">
      <doc>
      <![CDATA[@deprecated Please use
 {@link CommonConfigurationKeysPublic#HADOOP_TAGS_SYSTEM} instead
 See https://issues.apache.org/jira/browse/HADOOP-15474]]>
      </doc>
    </field>
    <field name="HADOOP_CUSTOM_TAGS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Please use
 {@link CommonConfigurationKeysPublic#HADOOP_TAGS_CUSTOM} instead
 See https://issues.apache.org/jira/browse/HADOOP-15474">
      <doc>
      <![CDATA[@deprecated Please use
 {@link CommonConfigurationKeysPublic#HADOOP_TAGS_CUSTOM} instead
 See https://issues.apache.org/jira/browse/HADOOP-15474]]>
      </doc>
    </field>
    <field name="HADOOP_TAGS_SYSTEM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_TAGS_CUSTOM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SERVICE_SHUTDOWN_TIMEOUT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Configuration option for the shutdown hook manager shutdown time:
  {@value}.]]>
      </doc>
    </field>
    <field name="SERVICE_SHUTDOWN_TIMEOUT_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default shutdown hook timeout: {@value} seconds.]]>
      </doc>
    </field>
    <field name="HADOOP_PROMETHEUS_ENABLED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_PROMETHEUS_ENABLED_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_HTTP_IDLE_TIMEOUT_MS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_HTTP_IDLE_TIMEOUT_MS_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="IPC_SERVER_METRICS_UPDATE_RUNNER_INTERVAL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[To configure scheduling of server metrics update thread. This config is used to indicate
 initial delay and delay between each execution of the metric update runnable thread.]]>
      </doc>
    </field>
    <field name="IPC_SERVER_METRICS_UPDATE_RUNNER_INTERVAL_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This class contains constants for configuration keys used
 in the common code.

 It includes all publicly documented configuration keys. In general
 this class should not be used directly (use CommonConfigurationKeys
 instead)]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.CommonConfigurationKeysPublic -->
  <!-- start class org.apache.hadoop.fs.ContentSummary -->
  <class name="ContentSummary" extends="org.apache.hadoop.fs.QuotaUsage"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="ContentSummary"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor deprecated by ContentSummary.Builder]]>
      </doc>
    </constructor>
    <constructor name="ContentSummary" type="long, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor, deprecated by ContentSummary.Builder
  This constructor implicitly set spaceConsumed the same as length.
  spaceConsumed and length must be set explicitly with
  ContentSummary.Builder.

 @param length length.
 @param fileCount file count.
 @param directoryCount directory count.]]>
      </doc>
    </constructor>
    <constructor name="ContentSummary" type="long, long, long, long, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor, deprecated by ContentSummary.Builder.

 @param length length.
 @param fileCount file count.
 @param directoryCount directory count.
 @param quota quota.
 @param spaceConsumed space consumed.
 @param spaceQuota space quota.]]>
      </doc>
    </constructor>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the length]]>
      </doc>
    </method>
    <method name="getSnapshotLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDirectoryCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the directory count]]>
      </doc>
    </method>
    <method name="getSnapshotDirectoryCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFileCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the file count]]>
      </doc>
    </method>
    <method name="getSnapshotFileCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getSnapshotSpaceConsumed" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getErasureCodingPolicy" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="to" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHeader" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="qOption" type="boolean"/>
      <doc>
      <![CDATA[Return the header of the output.
 if qOption is false, output directory count, file count, and content size;
 if qOption is true, output quota and remaining quota as well.
 
 @param qOption a flag indicating if quota needs to be printed or not
 @return the header of the output]]>
      </doc>
    </method>
    <method name="getSnapshotHeader" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHeaderFields" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the names of the fields from the summary header.
 
 @return names of fields as displayed in the header]]>
      </doc>
    </method>
    <method name="getQuotaHeaderFields" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the names of the fields used in the quota summary.
 
 @return names of quota fields as displayed in the header]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="qOption" type="boolean"/>
      <doc>
      <![CDATA[Return the string representation of the object in the output format.
 if qOption is false, output directory count, file count, and content size;
 if qOption is true, output quota and remaining quota as well.

 @param qOption a flag indicating if quota needs to be printed or not
 @return the string representation of the object]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="qOption" type="boolean"/>
      <param name="hOption" type="boolean"/>
      <doc>
      <![CDATA[Return the string representation of the object in the output format.
 For description of the options,
 @see #toString(boolean, boolean, boolean, boolean, List)
 
 @param qOption a flag indicating if quota needs to be printed or not
 @param hOption a flag indicating if human readable output if to be used
 @return the string representation of the object]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="qOption" type="boolean"/>
      <param name="hOption" type="boolean"/>
      <param name="xOption" type="boolean"/>
      <doc>
      <![CDATA[Return the string representation of the object in the output format.
 For description of the options,
 @see #toString(boolean, boolean, boolean, boolean, List)

 @param qOption a flag indicating if quota needs to be printed or not
 @param hOption a flag indicating if human readable output is to be used
 @param xOption a flag indicating if calculation from snapshots is to be
                included in the output
 @return the string representation of the object]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="qOption" type="boolean"/>
      <param name="hOption" type="boolean"/>
      <param name="tOption" type="boolean"/>
      <param name="types" type="java.util.List"/>
      <doc>
      <![CDATA[Return the string representation of the object in the output format.
 For description of the options,
 @see #toString(boolean, boolean, boolean, boolean, List)

 @param qOption a flag indicating if quota needs to be printed or not
 @param hOption a flag indicating if human readable output if to be used
 @param tOption a flag indicating if display quota by storage types
 @param types Storage types to display
 @return the string representation of the object]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="qOption" type="boolean"/>
      <param name="hOption" type="boolean"/>
      <param name="tOption" type="boolean"/>
      <param name="xOption" type="boolean"/>
      <param name="types" type="java.util.List"/>
      <doc>
      <![CDATA[Return the string representation of the object in the output format.
 if qOption is false, output directory count, file count, and content size;
 if qOption is true, output quota and remaining quota as well.
 if hOption is false, file sizes are returned in bytes
 if hOption is true, file sizes are returned in human readable
 if tOption is true, display the quota by storage types
 if tOption is false, same logic with #toString(boolean,boolean)
 if xOption is false, output includes the calculation from snapshots
 if xOption is true, output excludes the calculation from snapshots

 @param qOption a flag indicating if quota needs to be printed or not
 @param hOption a flag indicating if human readable output is to be used
 @param tOption a flag indicating if display quota by storage types
 @param xOption a flag indicating if calculation from snapshots is to be
                included in the output
 @param types Storage types to display
 @return the string representation of the object]]>
      </doc>
    </method>
    <method name="toSnapshot" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hOption" type="boolean"/>
      <doc>
      <![CDATA[Return the string representation of the snapshot counts in the output
 format.
 @param hOption flag indicating human readable or not
 @return String representation of the snapshot counts]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Store the summary of a content (a directory or a file).]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ContentSummary -->
  <!-- start class org.apache.hadoop.fs.CreateFlag -->
  <class name="CreateFlag" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.fs.CreateFlag[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.fs.CreateFlag"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="validate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="java.util.EnumSet"/>
      <doc>
      <![CDATA[Validate the CreateFlag and throw exception if it is invalid
 @param flag set of CreateFlag
 @throws HadoopIllegalArgumentException if the CreateFlag is invalid]]>
      </doc>
    </method>
    <method name="validate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.Object"/>
      <param name="pathExists" type="boolean"/>
      <param name="flag" type="java.util.EnumSet"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Validate the CreateFlag for create operation
 @param path Object representing the path; usually String or {@link Path}
 @param pathExists pass true if the path exists in the file system
 @param flag set of CreateFlag
 @throws IOException on error
 @throws HadoopIllegalArgumentException if the CreateFlag is invalid]]>
      </doc>
    </method>
    <method name="validateForAppend"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="java.util.EnumSet"/>
      <doc>
      <![CDATA[Validate the CreateFlag for the append operation. The flag must contain
 APPEND, and cannot contain OVERWRITE.

 @param flag enum set flag.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[CreateFlag specifies the file create semantic. Users can combine flags like: <br>
 <code>
 EnumSet.of(CreateFlag.CREATE, CreateFlag.APPEND)
 </code>
 <p>
 
 Use the CreateFlag as follows:
 <ol>
 <li> CREATE - to create a file if it does not exist, 
 else throw FileAlreadyExists.</li>
 <li> APPEND - to append to a file if it exists, 
 else throw FileNotFoundException.</li>
 <li> OVERWRITE - to truncate a file if it exists, 
 else throw FileNotFoundException.</li>
 <li> CREATE|APPEND - to create a file if it does not exist, 
 else append to an existing file.</li>
 <li> CREATE|OVERWRITE - to create a file if it does not exist, 
 else overwrite an existing file.</li>
 <li> SYNC_BLOCK - to force closed blocks to the disk device.
 In addition {@link Syncable#hsync()} should be called after each write,
 if true synchronous behavior is required.</li>
 <li> LAZY_PERSIST - Create the block on transient storage (RAM) if
 available.</li>
 <li> APPEND_NEWBLOCK - Append data to a new block instead of end of the last
 partial block.</li>
 </ol>
 
 Following combinations are not valid and will result in
 {@link HadoopIllegalArgumentException}:
 <ol>
 <li> APPEND|OVERWRITE</li>
 <li> CREATE|APPEND|OVERWRITE</li>
 </ol>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.CreateFlag -->
  <!-- start class org.apache.hadoop.fs.FileAlreadyExistsException -->
  <class name="FileAlreadyExistsException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FileAlreadyExistsException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FileAlreadyExistsException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Used when target file already exists for any operation and 
 is not configured to be overwritten.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileAlreadyExistsException -->
  <!-- start class org.apache.hadoop.fs.FileChecksum -->
  <class name="FileChecksum" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="FileChecksum"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAlgorithmName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The checksum algorithm name.

 @return algorithm name.]]>
      </doc>
    </method>
    <method name="getLength" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The length of the checksum in bytes.

 @return length.]]>
      </doc>
    </method>
    <method name="getBytes" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The value of the checksum in bytes.

 @return byte array.]]>
      </doc>
    </method>
    <method name="getChecksumOpt" return="org.apache.hadoop.fs.Options.ChecksumOpt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
      <doc>
      <![CDATA[Return true if both the algorithms and the values are the same.

 @param other other.
 @return if equal true, not false.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An abstract class representing file checksums for files.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileChecksum -->
  <!-- start class org.apache.hadoop.fs.FileContext -->
  <class name="FileContext" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.PathCapabilities"/>
    <method name="getFSofPath" return="org.apache.hadoop.fs.AbstractFileSystem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="absOrFqPath" type="org.apache.hadoop.fs.Path"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the file system of supplied path.
 
 @param absOrFqPath - absolute or fully qualified path
 @return the file system of the path
 
 @throws UnsupportedFileSystemException If the file system for
           <code>absOrFqPath</code> is not supported.
 @throws IOException If the file system for <code>absOrFqPath</code> could
         not be instantiated.]]>
      </doc>
    </method>
    <method name="getFileContext" return="org.apache.hadoop.fs.FileContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defFS" type="org.apache.hadoop.fs.AbstractFileSystem"/>
      <param name="aConf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Create a FileContext with specified FS as default using the specified
 config.
 
 @param defFS default fs.
 @param aConf configutration.
 @return new FileContext with specified FS as default.]]>
      </doc>
    </method>
    <method name="getFileContext" return="org.apache.hadoop.fs.FileContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="defaultFS" type="org.apache.hadoop.fs.AbstractFileSystem"/>
      <doc>
      <![CDATA[Create a FileContext for specified file system using the default config.
 
 @param defaultFS default fs.
 @return a FileContext with the specified AbstractFileSystem
                 as the default FS.]]>
      </doc>
    </method>
    <method name="getFileContext" return="org.apache.hadoop.fs.FileContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <doc>
      <![CDATA[Create a FileContext using the default config read from the
 $HADOOP_CONFIG/core.xml, Unspecified key-values for config are defaulted
 from core-defaults.xml in the release jar.
 
 @throws UnsupportedFileSystemException If the file system from the default
           configuration is not supported
 @return file context.]]>
      </doc>
    </method>
    <method name="getLocalFSFileContext" return="org.apache.hadoop.fs.FileContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <doc>
      <![CDATA[@return a FileContext for the local file system using the default config.
 @throws UnsupportedFileSystemException If the file system for
           {@link FsConstants#LOCAL_FS_URI} is not supported.]]>
      </doc>
    </method>
    <method name="getFileContext" return="org.apache.hadoop.fs.FileContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaultFsUri" type="java.net.URI"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <doc>
      <![CDATA[Create a FileContext for specified URI using the default config.
 
 @param defaultFsUri defaultFsUri.
 @return a FileContext with the specified URI as the default FS.
 
 @throws UnsupportedFileSystemException If the file system for
           <code>defaultFsUri</code> is not supported]]>
      </doc>
    </method>
    <method name="getFileContext" return="org.apache.hadoop.fs.FileContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaultFsUri" type="java.net.URI"/>
      <param name="aConf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <doc>
      <![CDATA[Create a FileContext for specified default URI using the specified config.
 
 @param defaultFsUri defaultFsUri.
 @param aConf configrution.
 @return new FileContext for specified uri
 @throws UnsupportedFileSystemException If the file system with specified is
           not supported
 @throws RuntimeException If the file system specified is supported but
         could not be instantiated, or if login fails.]]>
      </doc>
    </method>
    <method name="getFileContext" return="org.apache.hadoop.fs.FileContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="aConf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <doc>
      <![CDATA[Create a FileContext using the passed config. Generally it is better to use
 {@link #getFileContext(URI, Configuration)} instead of this one.
 
 
 @param aConf configration.
 @return new FileContext
 @throws UnsupportedFileSystemException If file system in the config
           is not supported]]>
      </doc>
    </method>
    <method name="getLocalFSFileContext" return="org.apache.hadoop.fs.FileContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="aConf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <doc>
      <![CDATA[@param aConf - from which the FileContext is configured
 @return a FileContext for the local file system using the specified config.
 
 @throws UnsupportedFileSystemException If default file system in the config
           is not supported]]>
      </doc>
    </method>
    <method name="setWorkingDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newWDir" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the working directory for wd-relative names (such a "foo/bar"). Working
 directory feature is provided by simply prefixing relative names with the
 working dir. Note this is different from Unix where the wd is actually set
 to the inode. Hence setWorkingDir does not follow symlinks etc. This works
 better in a distributed environment that has multiple independent roots.
 {@link #getWorkingDirectory()} should return what setWorkingDir() set.
 
 @param newWDir new working directory
 @throws IOException 
 <br>
           NewWdir can be one of:
           <ul>
           <li>relative path: "foo/bar";</li>
           <li>absolute without scheme: "/foo/bar"</li>
           <li>fully qualified with scheme: "xx://auth/foo/bar"</li>
           </ul>
 <br>
           Illegal WDs:
           <ul>
           <li>relative with scheme: "xx:foo/bar"</li>
           <li>non existent directory</li>
           </ul>]]>
      </doc>
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the working directory for wd-relative names (such a "foo/bar").
 @return the path.]]>
      </doc>
    </method>
    <method name="getUgi" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the ugi in the file-context
 @return UserGroupInformation]]>
      </doc>
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the current user's home directory in this file system.
 The default implementation returns "/user/$USER/".
 @return the home directory]]>
      </doc>
    </method>
    <method name="getUMask" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the umask of this FileContext]]>
      </doc>
    </method>
    <method name="setUMask"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newUmask" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <doc>
      <![CDATA[Set umask to the supplied parameter.
 @param newUmask  the new umask]]>
      </doc>
    </method>
    <method name="resolvePath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Resolve the path following any symlinks or mount points
 @param f to be resolved
 @return fully qualified resolved path
 
 @throws FileNotFoundException  If <code>f</code> does not exist
 @throws AccessControlException if access denied
 @throws IOException If an IO Error occurred
 @throws UnresolvedLinkException If unresolved link occurred.

 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws
           undeclared exception to RPC server

 RuntimeExceptions:
 @throws InvalidPathException If path <code>f</code> is not valid]]>
      </doc>
    </method>
    <method name="makeQualified" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Make the path fully qualified if it is isn't. 
 A Fully-qualified path has scheme and authority specified and an absolute
 path.
 Use the default file system and working dir in this FileContext to qualify.
 @param path the path.
 @return qualified path]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="createFlag" type="java.util.EnumSet"/>
      <param name="opts" type="org.apache.hadoop.fs.Options.CreateOpts[]"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create or overwrite file on indicated path and returns an output stream for
 writing into the file.
 
 @param f the file name to open
 @param createFlag gives the semantics of create; see {@link CreateFlag}
 @param opts file creation options; see {@link Options.CreateOpts}.
          <ul>
          <li>Progress - to report progress on the operation - default null
          <li>Permission - umask is applied against permission: default is
          FsPermissions:getDefault()
 
          <li>CreateParent - create missing parent path; default is to not
          to create parents
          <li>The defaults for the following are SS defaults of the file
          server implementing the target path. Not all parameters make sense
          for all kinds of file system - eg. localFS ignores Blocksize,
          replication, checksum
          <ul>
          <li>BufferSize - buffersize used in FSDataOutputStream
          <li>Blocksize - block size for file blocks
          <li>ReplicationFactor - replication for blocks
          <li>ChecksumParam - Checksum parameters. server default is used
          if not specified.
          </ul>
          </ul>
 
 @return {@link FSDataOutputStream} for created file
 
 @throws AccessControlException If access is denied
 @throws FileAlreadyExistsException If file <code>f</code> already exists
 @throws FileNotFoundException If parent of <code>f</code> does not exist
           and <code>createParent</code> is false
 @throws ParentNotDirectoryException If parent of <code>f</code> is not a
           directory.
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws
           undeclared exception to RPC server
 
 RuntimeExceptions:
 @throws InvalidPathException If path <code>f</code> is not valid]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStreamBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link FSDataOutputStreamBuilder} for creating or overwriting
 a file on indicated path.

 @param f the file path to create builder for.
 @return {@link FSDataOutputStreamBuilder} to build a
         {@link FSDataOutputStream}.

 Upon {@link FSDataOutputStreamBuilder#build()} being invoked,
 builder parameters will be verified by {@link FileContext} and
 {@link AbstractFileSystem#create}. And filesystem states will be modified.

 Client should expect {@link FSDataOutputStreamBuilder#build()} throw the
 same exceptions as create(Path, EnumSet, CreateOpts...).
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="mkdir"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="createParent" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Make(create) a directory and all the non-existent parents.
 
 @param dir - the dir to make
 @param permission - permissions is set permission{@literal &~}umask
 @param createParent - if true then missing parent dirs are created if false
          then parent must exist
 
 @throws AccessControlException If access is denied
 @throws FileAlreadyExistsException If directory <code>dir</code> already
           exists
 @throws FileNotFoundException If parent of <code>dir</code> does not exist
           and <code>createParent</code> is false
 @throws ParentNotDirectoryException If parent of <code>dir</code> is not a
           directory
 @throws UnsupportedFileSystemException If file system for <code>dir</code>
         is not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server
 
 RuntimeExceptions:
 @throws InvalidPathException If path <code>dir</code> is not valid]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete a file.
 @param f the path to delete.
 @param recursive if path is a directory and set to 
 true, the directory is deleted else throws an exception. In
 case of a file the recursive can be set to either true or false.

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server
 
 RuntimeExceptions:
 @throws InvalidPathException If path <code>f</code> is invalid

 @return if delete success true, not false.]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataInputStream at the indicated Path using
 default buffersize.
 @param f the file name to open

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If file <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code>
         is not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server
 @return input stream.]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataInputStream at the indicated Path.
 
 @param f the file name to open
 @param bufferSize the size of the buffer to be used.
 
 @throws AccessControlException If access is denied
 @throws FileNotFoundException If file <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server
 @return output stream.]]>
      </doc>
    </method>
    <method name="truncate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="newLength" type="long"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Truncate the file in the indicated path to the indicated size.
 <ul>
 <li>Fails if path is a directory.
 <li>Fails if path does not exist.
 <li>Fails if path is not closed.
 <li>Fails if new size is greater than current size.
 </ul>
 @param f The path to the file to be truncated
 @param newLength The size the file is to be truncated to

 @return <code>true</code> if the file has been truncated to the desired
 <code>newLength</code> and is immediately available to be reused for
 write operations such as <code>append</code>, or
 <code>false</code> if a background process of adjusting the length of
 the last block has been started, and clients should wait for it to
 complete before proceeding with further file updates.

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If file <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred

 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="setReplication" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set replication for an existing file.
 
 @param f file name
 @param replication new replication

 @return true if successful

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If file <code>f</code> does not exist
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="rename"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="options" type="org.apache.hadoop.fs.Options.Rename[]"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Renames Path src to Path dst
 <ul>
 <li>Fails if src is a file and dst is a directory.
 <li>Fails if src is a directory and dst is a file.
 <li>Fails if the parent of dst does not exist or is a file.
 </ul>
 <p>
 If OVERWRITE option is not passed as an argument, rename fails if the dst
 already exists.
 <p>
 If OVERWRITE option is passed as an argument, rename overwrites the dst if
 it is a file or an empty directory. Rename fails if dst is a non-empty
 directory.
 <p>
 Note that atomicity of rename is dependent on the file system
 implementation. Please refer to the file system documentation for details
 <p>
 
 @param src path to be renamed
 @param dst new path after rename
 @param options rename options.
 
 @throws AccessControlException If access is denied
 @throws FileAlreadyExistsException If <code>dst</code> already exists and
           <code>options</code> has {@link Options.Rename#OVERWRITE}
           option false.
 @throws FileNotFoundException If <code>src</code> does not exist
 @throws ParentNotDirectoryException If parent of <code>dst</code> is not a
           directory
 @throws UnsupportedFileSystemException If file system for <code>src</code>
           and <code>dst</code> is not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set permission of a path.
 @param f the path.
 @param permission - the new absolute permission (umask is not applied)

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code>
         is not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set owner of a path (i.e. a file or a directory). The parameters username
 and groupname cannot both be null.
 
 @param f The path
 @param username If it is null, the original username remains unchanged.
 @param groupname If it is null, the original groupname remains unchanged.
 
 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server
 
 RuntimeExceptions:
 @throws HadoopIllegalArgumentException If <code>username</code> or
           <code>groupname</code> is invalid.]]>
      </doc>
    </method>
    <method name="setTimes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="mtime" type="long"/>
      <param name="atime" type="long"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set access time of a file.
 @param f The path
 @param mtime Set the modification time of this file.
        The number of milliseconds since epoch (Jan 1, 1970). 
        A value of -1 means that this call should not set modification time.
 @param atime Set the access time of this file.
        The number of milliseconds since Jan 1, 1970. 
        A value of -1 means that this call should not set access time.

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="getFileChecksum" return="org.apache.hadoop.fs.FileChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the checksum of a file.

 @param f file path

 @return The file checksum.  The default return value is null,
  which indicates that no checksum algorithm is implemented
  in the corresponding FileSystem.

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="setVerifyChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="verifyChecksum" type="boolean"/>
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the verify checksum flag for the  file system denoted by the path.
 This is only applicable if the 
 corresponding FileSystem supports checksum. By default doesn't do anything.
 @param verifyChecksum verify check sum.
 @param f set the verifyChecksum for the Filesystem containing this path

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a file status object that represents the path.
 @param f The path we want information from

 @return a FileStatus object

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="msync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Synchronize client metadata state.

 @throws IOException If an I/O error occurred.
 @throws UnsupportedOperationException If file system for <code>f</code> is
                                       not supported.]]>
      </doc>
    </method>
    <method name="getFileLinkStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a file status object that represents the path. If the path 
 refers to a symlink then the FileStatus of the symlink is returned.
 The behavior is equivalent to #getFileStatus() if the underlying
 file system does not support symbolic links.
 @param  f The path we want information from.
 @return A FileStatus object
 
 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred]]>
      </doc>
    </method>
    <method name="getLinkTarget" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the target of the given symbolic link as it was specified
 when the link was created.  Links in the path leading up to the
 final path component are resolved transparently.

 @param f the path to return the target of
 @return The un-interpreted target of the symbolic link.
 
 @throws AccessControlException If access is denied
 @throws FileNotFoundException If path <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If the given path does not refer to a symlink
           or an I/O error occurred]]>
      </doc>
    </method>
    <method name="getFsStatus" return="org.apache.hadoop.fs.FsStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a status object describing the use and capacity of the
 file system denoted by the Parh argument p.
 If the file system has multiple partitions, the
 use and capacity of the partition pointed to by the specified
 path is reflected.
 
 @param f Path for which status should be obtained. null means the
 root partition of the default file system. 

 @return a FsStatus object

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="createSymlink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.apache.hadoop.fs.Path"/>
      <param name="link" type="org.apache.hadoop.fs.Path"/>
      <param name="createParent" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates a symbolic link to an existing file. An exception is thrown if 
 the symlink exits, the user does not have permission to create symlink,
 or the underlying file system does not support symlinks.
 
 Symlink permissions are ignored, access to a symlink is determined by
 the permissions of the symlink target.
 
 Symlinks in paths leading up to the final path component are resolved 
 transparently. If the final path component refers to a symlink some 
 functions operate on the symlink itself, these are:
 - delete(f) and deleteOnExit(f) - Deletes the symlink.
 - rename(src, dst) - If src refers to a symlink, the symlink is 
   renamed. If dst refers to a symlink, the symlink is over-written.
 - getLinkTarget(f) - Returns the target of the symlink. 
 - getFileLinkStatus(f) - Returns a FileStatus object describing
   the symlink.
 Some functions, create() and mkdir(), expect the final path component
 does not exist. If they are given a path that refers to a symlink that 
 does exist they behave as if the path referred to an existing file or 
 directory. All other functions fully resolve, ie follow, the symlink. 
 These are: open, setReplication, setOwner, setTimes, setWorkingDirectory,
 setPermission, getFileChecksum, setVerifyChecksum, getFileBlockLocations,
 getFsStatus, getFileStatus, exists, and listStatus.
 
 Symlink targets are stored as given to createSymlink, assuming the 
 underlying file system is capable of storing a fully qualified URI.
 Dangling symlinks are permitted. FileContext supports four types of 
 symlink targets, and resolves them as follows
 <pre>
 Given a path referring to a symlink of form:
 
   {@literal <---}X{@literal --->}
   fs://host/A/B/link 
   {@literal <-----}Y{@literal ----->}
 
 In this path X is the scheme and authority that identify the file system,
 and Y is the path leading up to the final path component "link". If Y is
 a symlink  itself then let Y' be the target of Y and X' be the scheme and
 authority of Y'. Symlink targets may:
 
 1. Fully qualified URIs
 
 fs://hostX/A/B/file  Resolved according to the target file system.
 
 2. Partially qualified URIs (eg scheme but no host)
 
 fs:///A/B/file  Resolved according to the target file system. Eg resolving
                 a symlink to hdfs:///A results in an exception because
                 HDFS URIs must be fully qualified, while a symlink to 
                 file:///A will not since Hadoop's local file systems 
                 require partially qualified URIs.
 
 3. Relative paths
 
 path  Resolves to [Y'][path]. Eg if Y resolves to hdfs://host/A and path 
       is "../B/file" then [Y'][path] is hdfs://host/B/file
 
 4. Absolute paths
 
 path  Resolves to [X'][path]. Eg if Y resolves hdfs://host/A/B and path
       is "/file" then [X][path] is hdfs://host/file
 </pre>
 
 @param target the target of the symbolic link
 @param link the path to be created that points to target
 @param createParent if true then missing parent dirs are created if 
                     false then parent must exist


 @throws AccessControlException If access is denied
 @throws FileAlreadyExistsException If file <code>link</code> already exists
 @throws FileNotFoundException If <code>target</code> does not exist
 @throws ParentNotDirectoryException If parent of <code>link</code> is not a
           directory.
 @throws UnsupportedFileSystemException If file system for 
           <code>target</code> or <code>link</code> is not supported
 @throws IOException If an I/O error occurred]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses of the files/directories in the given path if the path is
 a directory.
 
 @param f is the path

 @return an iterator that traverses statuses of the files/directories 
         in the given path

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="listCorruptFileBlocks" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List CorruptFile Blocks.

 @param path the path.
 @return an iterator over the corrupt files under the given path
 (may contain duplicates if a file has more than one corrupt block)
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="listLocatedStatus" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses of the files/directories in the given path if the path is
 a directory. 
 Return the file's status and block locations If the path is a file.
 
 If a returned status is a file, it contains the file's block locations.

 @param f is the path

 @return an iterator that traverses statuses of the files/directories 
         in the given path
 If any IO exception (for example the input directory gets deleted while
 listing is being executed), next() or hasNext() of the returned iterator
 may throw a RuntimeException with the io exception as the cause.

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="deleteOnExit" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Mark a path to be deleted on JVM shutdown.
 
 @param f the existing path to delete.

 @return  true if deleteOnExit is successful, otherwise false.

 @throws AccessControlException If access is denied
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="util" return="org.apache.hadoop.fs.FileContext.Util"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="resolve" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Resolves all symbolic links in the specified path.
 Returns the new path object.

 @param f the path.
 @throws FileNotFoundException If <code>f</code> does not exist.
 @throws UnresolvedLinkException If unresolved link occurred.
 @throws AccessControlException If access is denied.
 @throws IOException If an I/O error occurred.
 @return resolve path.]]>
      </doc>
    </method>
    <method name="resolveIntermediate" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Resolves all symbolic links in the specified path leading up 
 to, but not including the final path component.
 @param f path to resolve
 @return the new path object.
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="getStatistics" return="org.apache.hadoop.fs.FileSystem.Statistics"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Get the statistics for a particular file system
 
 @param uri
          the uri to lookup the statistics. Only scheme and authority part
          of the uri are used as the key to store and lookup.
 @return a statistics object]]>
      </doc>
    </method>
    <method name="clearStatistics"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears all the statistics stored in AbstractFileSystem, for all the file
 systems.]]>
      </doc>
    </method>
    <method name="printStatistics"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Prints the statistics to standard output. File System is identified by the
 scheme and authority.]]>
      </doc>
    </method>
    <method name="getAllStatistics" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Map of uri and statistics for each filesystem instantiated. The uri
         consists of scheme and authority for the filesystem.]]>
      </doc>
    </method>
    <method name="modifyAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Modifies ACL entries of files and directories.  This method can add new ACL
 entries or modify the permissions on existing ACL entries.  All existing
 ACL entries that are not specified in this call are retained without
 changes.  (Modifications are merged into the current ACL.)

 @param path Path to modify
 @param aclSpec List{@literal <}AclEntry{@literal >} describing
 modifications
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes ACL entries from files and directories.  Other ACL entries are
 retained.

 @param path Path to modify
 @param aclSpec List{@literal <}AclEntry{@literal >} describing entries
 to remove
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeDefaultAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes all default ACL entries from files and directories.

 @param path Path to modify
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes all but the base ACL entries of files and directories.  The entries
 for user, group, and others are retained for compatibility with permission
 bits.

 @param path Path to modify
 @throws IOException if an ACL could not be removed]]>
      </doc>
    </method>
    <method name="setAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fully replaces ACL of files and directories, discarding all existing
 entries.

 @param path Path to modify
 @param aclSpec List{@literal <}AclEntry{@literal >} describing
 modifications, must include entries for user, group, and others for
 compatibility with permission bits.
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="getAclStatus" return="org.apache.hadoop.fs.permission.AclStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets the ACLs of files and directories.

 @param path Path to get
 @return RemoteIterator{@literal <}AclStatus{@literal >} which returns
         each AclStatus
 @throws IOException if an ACL could not be read]]>
      </doc>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to modify
 @param name xattr name.
 @param value xattr value.
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <param name="flag" type="java.util.EnumSet"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to modify
 @param name xattr name.
 @param value xattr value.
 @param flag xattr set flag
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="getXAttr" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get an xattr for a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attribute
 @param name xattr name.
 @return byte[] xattr value.
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattrs for a file or directory.
 Only those xattrs for which the logged-in user has permissions to view
 are returned.
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @return Map{@literal <}String, byte[]{@literal >} describing the XAttrs
 of the file or directory
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="names" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattrs for a file or directory.
 Only those xattrs for which the logged-in user has permissions to view
 are returned.
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @param names XAttr names.
 @return Map{@literal <}String, byte[]{@literal >} describing the XAttrs
 of the file or directory
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="removeXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Remove an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to remove extended attribute
 @param name xattr name
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="listXAttrs" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattr names for a file or directory.
 Only those xattr names which the logged-in user has permissions to view
 are returned.
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @return List{@literal <}String{@literal >} of the XAttr names of the
 file or directory
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="createSnapshot" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a snapshot with a default name.

 @param path The directory where snapshots will be taken.
 @return the snapshot path.

 @throws IOException If an I/O error occurred

 <p>Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="createSnapshot" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a snapshot.

 @param path The directory where snapshots will be taken.
 @param snapshotName The name of the snapshot
 @return the snapshot path.

 @throws IOException If an I/O error occurred

 <p>Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="renameSnapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotOldName" type="java.lang.String"/>
      <param name="snapshotNewName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Rename a snapshot.

 @param path The directory path where the snapshot was taken
 @param snapshotOldName Old name of the snapshot
 @param snapshotNewName New name of the snapshot

 @throws IOException If an I/O error occurred

 <p>Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="deleteSnapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete a snapshot of a directory.

 @param path The directory that the to-be-deleted snapshot belongs to
 @param snapshotName The name of the snapshot

 @throws IOException If an I/O error occurred

 <p>Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="satisfyStoragePolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the source path to satisfy storage policy.
 @param path The source path referring to either a directory or a file.
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="setStoragePolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="policyName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the storage policy for a given file or directory.

 @param path file or directory path.
 @param policyName the name of the target storage policy. The list
                   of supported Storage policies can be retrieved
                   via {@link #getAllStoragePolicies}.
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="unsetStoragePolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Unset the storage policy set for a given file or directory.
 @param src file or directory path.
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="getStoragePolicy" return="org.apache.hadoop.fs.BlockStoragePolicySpi"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Query the effective storage policy ID for the given file or directory.

 @param path file or directory path.
 @return storage policy for give file.
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="getAllStoragePolicies" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Retrieve all the storage policies supported by this file system.

 @return all storage policies supported by this filesystem.
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="openFile" return="org.apache.hadoop.fs.FutureDataInputStreamBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Open a file for reading through a builder API.
 Ultimately calls {@link #open(Path, int)} unless a subclass
 executes the open command differently.

 The semantics of this call are therefore the same as that of
 {@link #open(Path, int)} with one special point: it is in
 {@code FSDataInputStreamBuilder.build()} in which the open operation
 takes place -it is there where all preconditions to the operation
 are checked.
 @param path file path
 @return a FSDataInputStreamBuilder object to build the input stream
 @throws IOException if some early checks cause IO failures.
 @throws UnsupportedOperationException if support is checked early.]]>
      </doc>
    </method>
    <method name="hasPathCapability" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="capability" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the path capabilities of the bonded {@code AbstractFileSystem}.
 @param path path to query the capability of.
 @param capability string to query the stream support for.
 @return true iff the capability is supported under that FS.
 @throws IOException path resolution or other IO failure
 @throws IllegalArgumentException invalid arguments]]>
      </doc>
    </method>
    <method name="getServerDefaults" return="org.apache.hadoop.fs.FsServerDefaults"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a set of server default configuration values based on path.
 @param path path to fetch server defaults
 @return server default configuration values for path
 @throws IOException an I/O error occurred]]>
      </doc>
    </method>
    <method name="createMultipartUploader" return="org.apache.hadoop.fs.MultipartUploaderBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="basePath" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a multipart uploader.
 @param basePath file path under which all files are uploaded
 @return a MultipartUploaderBuilder object to build the uploader
 @throws IOException if some early checks cause IO failures.
 @throws UnsupportedOperationException if support is checked early.]]>
      </doc>
    </method>
    <field name="LOG" type="org.slf4j.Logger"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_PERM" type="org.apache.hadoop.fs.permission.FsPermission"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default permission for directory and symlink
 In previous versions, this default permission was also used to
 create files, so files created end up with ugo+x permission.
 See HADOOP-9155 for detail. 
 Two new constants are added to solve this, please use 
 {@link FileContext#DIR_DEFAULT_PERM} for directory, and use
 {@link FileContext#FILE_DEFAULT_PERM} for file.
 This constant is kept for compatibility.]]>
      </doc>
    </field>
    <field name="DIR_DEFAULT_PERM" type="org.apache.hadoop.fs.permission.FsPermission"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default permission for directory]]>
      </doc>
    </field>
    <field name="FILE_DEFAULT_PERM" type="org.apache.hadoop.fs.permission.FsPermission"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default permission for file]]>
      </doc>
    </field>
    <field name="SHUTDOWN_HOOK_PRIORITY" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Priority of the FileContext shutdown hook.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[The FileContext class provides an interface for users of the Hadoop
 file system. It exposes a number of file system operations, e.g. create,
 open, list.
 
 <h2>Path Names</h2>
 
 The Hadoop file system supports a URI namespace and URI names. This enables
 multiple types of file systems to be referenced using fully-qualified URIs.
 Two common Hadoop file system implementations are
 <ul>
 <li>the local file system: file:///path
 <li>the HDFS file system: hdfs://nnAddress:nnPort/path
 </ul>
 
 The Hadoop file system also supports additional naming schemes besides URIs.
 Hadoop has the concept of a <i>default file system</i>, which implies a
 default URI scheme and authority. This enables <i>slash-relative names</i>
 relative to the default FS, which are more convenient for users and
 application writers. The default FS is typically set by the user's
 environment, though it can also be manually specified.
 <p>
 
 Hadoop also supports <i>working-directory-relative</i> names, which are paths
 relative to the current working directory (similar to Unix). The working
 directory can be in a different file system than the default FS.
 <p>
 Thus, Hadoop path names can be specified as one of the following:
 <ul>
 <li>a fully-qualified URI: scheme://authority/path (e.g.
 hdfs://nnAddress:nnPort/foo/bar)
 <li>a slash-relative name: path relative to the default file system (e.g.
 /foo/bar)
 <li>a working-directory-relative name: path relative to the working dir (e.g.
 foo/bar)
 </ul>
  Relative paths with scheme (scheme:foo/bar) are illegal.
  
 <h2>Role of FileContext and Configuration Defaults</h2>

 The FileContext is the analogue of per-process file-related state in Unix. It
 contains two properties:
 
 <ul>
 <li>the default file system (for resolving slash-relative names)
 <li>the umask (for file permissions)
 </ul>
 In general, these properties are obtained from the default configuration file
 in the user's environment (see {@link Configuration}).
 
 Further file system properties are specified on the server-side. File system
 operations default to using these server-side defaults unless otherwise
 specified.
 <p>
 The file system related server-side defaults are:
  <ul>
  <li> the home directory (default is "/user/userName")
  <li> the initial wd (only for local fs)
  <li> replication factor
  <li> block size
  <li> buffer size
  <li> encryptDataTransfer 
  <li> checksum option. (checksumType and  bytesPerChecksum)
  </ul>

 <h2>Example Usage</h2>

 Example 1: use the default config read from the $HADOOP_CONFIG/core.xml.
   Unspecified values come from core-defaults.xml in the release jar.
  <ul>  
  <li> myFContext = FileContext.getFileContext(); // uses the default config
                                                // which has your default FS 
  <li>  myFContext.create(path, ...);
  <li>  myFContext.setWorkingDir(path);
  <li>  myFContext.open (path, ...);  
  <li>...
  </ul>  
 Example 2: Get a FileContext with a specific URI as the default FS
  <ul>  
  <li> myFContext = FileContext.getFileContext(URI);
  <li> myFContext.create(path, ...);
  <li>...
 </ul>
 Example 3: FileContext with local file system as the default
  <ul> 
  <li> myFContext = FileContext.getLocalFSFileContext();
  <li> myFContext.create(path, ...);
  <li> ...
  </ul> 
 Example 4: Use a specific config, ignoring $HADOOP_CONFIG
  Generally you should not need use a config unless you are doing
   <ul> 
   <li> configX = someConfigSomeOnePassedToYou;
   <li> myFContext = getFileContext(configX); // configX is not changed,
                                              // is passed down 
   <li> myFContext.create(path, ...);
   <li>...
  </ul>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileContext -->
  <!-- start class org.apache.hadoop.fs.FileStatus -->
  <class name="FileStatus" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <implements name="java.lang.Comparable"/>
    <implements name="java.io.Serializable"/>
    <implements name="java.io.ObjectInputValidation"/>
    <constructor name="FileStatus"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FileStatus" type="long, boolean, int, long, long, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FileStatus" type="long, boolean, int, long, long, long, org.apache.hadoop.fs.permission.FsPermission, java.lang.String, java.lang.String, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for file systems on which symbolic links are not supported

 @param length length.
 @param isdir isdir.
 @param block_replication block replication.
 @param blocksize block size.
 @param modification_time modification time.
 @param access_time access_time.
 @param permission permission.
 @param owner owner.
 @param group group.
 @param path the path.]]>
      </doc>
    </constructor>
    <constructor name="FileStatus" type="long, boolean, int, long, long, long, org.apache.hadoop.fs.permission.FsPermission, java.lang.String, java.lang.String, org.apache.hadoop.fs.Path, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FileStatus" type="long, boolean, int, long, long, long, org.apache.hadoop.fs.permission.FsPermission, java.lang.String, java.lang.String, org.apache.hadoop.fs.Path, org.apache.hadoop.fs.Path, boolean, boolean, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FileStatus" type="long, boolean, int, long, long, long, org.apache.hadoop.fs.permission.FsPermission, java.lang.String, java.lang.String, org.apache.hadoop.fs.Path, org.apache.hadoop.fs.Path, java.util.Set"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FileStatus" type="org.apache.hadoop.fs.FileStatus"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy constructor.

 @param other FileStatus to copy
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </constructor>
    <method name="attributes" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="acl" type="boolean"/>
      <param name="crypt" type="boolean"/>
      <param name="ec" type="boolean"/>
      <param name="sn" type="boolean"/>
      <doc>
      <![CDATA[Convert boolean attributes to a set of flags.
 @param acl   See {@link AttrFlags#HAS_ACL}.
 @param crypt See {@link AttrFlags#HAS_CRYPT}.
 @param ec    See {@link AttrFlags#HAS_EC}.
 @param sn    See {@link AttrFlags#SNAPSHOT_ENABLED}.
 @return converted set of flags.]]>
      </doc>
    </method>
    <method name="getLen" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the length of this file, in bytes.
 @return the length of this file, in bytes.]]>
      </doc>
    </method>
    <method name="isFile" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Is this a file?
 @return true if this is a file]]>
      </doc>
    </method>
    <method name="isDirectory" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Is this a directory?
 @return true if this is a directory]]>
      </doc>
    </method>
    <method name="isDir" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="Use {@link FileStatus#isFile()},
 {@link FileStatus#isDirectory()}, and {@link FileStatus#isSymlink()}
 instead.">
      <doc>
      <![CDATA[Old interface, instead use the explicit {@link FileStatus#isFile()},
 {@link FileStatus#isDirectory()}, and {@link FileStatus#isSymlink()}
 @return true if this is a directory.
 @deprecated Use {@link FileStatus#isFile()},
 {@link FileStatus#isDirectory()}, and {@link FileStatus#isSymlink()}
 instead.]]>
      </doc>
    </method>
    <method name="isSymlink" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Is this a symbolic link?
 @return true if this is a symbolic link]]>
      </doc>
    </method>
    <method name="getBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the block size of the file.
 @return the number of bytes]]>
      </doc>
    </method>
    <method name="getReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the replication factor of a file.
 @return the replication factor of a file.]]>
      </doc>
    </method>
    <method name="getModificationTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the modification time of the file.
 @return the modification time of file in milliseconds since January 1, 1970 UTC.]]>
      </doc>
    </method>
    <method name="getAccessTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the access time of the file.
 @return the access time of file in milliseconds since January 1, 1970 UTC.]]>
      </doc>
    </method>
    <method name="getPermission" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get FsPermission associated with the file.
 @return permission. If a filesystem does not have a notion of permissions
         or if permissions could not be determined, then default 
         permissions equivalent of "rwxrwxrwx" is returned.]]>
      </doc>
    </method>
    <method name="hasAcl" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Tell whether the underlying file or directory has ACLs set.

 @return true if the underlying file or directory has ACLs set.]]>
      </doc>
    </method>
    <method name="isEncrypted" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Tell whether the underlying file or directory is encrypted or not.

 @return true if the underlying file is encrypted.]]>
      </doc>
    </method>
    <method name="isErasureCoded" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Tell whether the underlying file or directory is erasure coded or not.

 @return true if the underlying file or directory is erasure coded.]]>
      </doc>
    </method>
    <method name="isSnapshotEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check if directory is Snapshot enabled or not.

 @return true if directory is snapshot enabled]]>
      </doc>
    </method>
    <method name="getOwner" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the owner of the file.
 @return owner of the file. The string could be empty if there is no
         notion of owner of a file in a filesystem or if it could not 
         be determined (rare).]]>
      </doc>
    </method>
    <method name="getGroup" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the group associated with the file.
 @return group for the file. The string could be empty if there is no
         notion of group of a file in a filesystem or if it could not 
         be determined (rare).]]>
      </doc>
    </method>
    <method name="getPath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <doc>
      <![CDATA[Sets permission.
 @param permission if permission is null, default value is set]]>
      </doc>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="owner" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets owner.
 @param owner if it is null, default value is set]]>
      </doc>
    </method>
    <method name="setGroup"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="group" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets group.
 @param group if it is null, default value is set]]>
      </doc>
    </method>
    <method name="getSymlink" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@return The contents of the symbolic link.

 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="setSymlink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.fs.FileStatus"/>
      <doc>
      <![CDATA[Compare this FileStatus to another FileStatus
 @param   o the FileStatus to be compared.
 @return  a negative integer, zero, or a positive integer as this object
   is less than, equal to, or greater than the specified object.]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compare this FileStatus to another FileStatus.
 This method was added back by HADOOP-14683 to keep binary compatibility.

 @param   o the FileStatus to be compared.
 @return  a negative integer, zero, or a positive integer as this object
   is less than, equal to, or greater than the specified object.
 @throws ClassCastException if the specified object is not FileStatus]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compare if this object is equal to another object
 @param   o the object to be compared.
 @return  true if two file status has the same path name; false if not.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash code value for the object, which is defined as
 the hash code of the path name.

 @return  a hash code value for the path name.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use the {@link PBHelper} and protobuf serialization directly.">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read instance encoded as protobuf from stream.
 @param in Input stream
 @see PBHelper#convert(FileStatus)
 @deprecated Use the {@link PBHelper} and protobuf serialization directly.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use the {@link PBHelper} and protobuf serialization directly.">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write instance encoded as protobuf to stream.
 @param out Output stream
 @see PBHelper#convert(FileStatus)
 @deprecated Use the {@link PBHelper} and protobuf serialization directly.]]>
      </doc>
    </method>
    <method name="validateObject"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InvalidObjectException" type="java.io.InvalidObjectException"/>
    </method>
    <field name="NONE" type="java.util.Set"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shared, empty set of attributes (a common case for FileStatus).]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Interface that represents the client side information for a file.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileStatus -->
  <!-- start class org.apache.hadoop.fs.FileSystem -->
  <class name="FileSystem" extends="org.apache.hadoop.conf.Configured"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <implements name="org.apache.hadoop.security.token.DelegationTokenIssuer"/>
    <implements name="org.apache.hadoop.fs.PathCapabilities"/>
    <constructor name="FileSystem"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="user" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Get a FileSystem instance based on the uri, the passed in
 configuration and the user.
 @param uri of the filesystem
 @param conf the configuration to use
 @param user to perform the get as
 @return the filesystem instance
 @throws IOException failure to load
 @throws InterruptedException If the {@code UGI.doAs()} call was
 somehow interrupted.]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the configured FileSystem implementation.
 @param conf the configuration to use
 @return FileSystem.
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="getDefaultUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the default FileSystem URI from a configuration.
 @param conf the configuration to use
 @return the uri of the default filesystem]]>
      </doc>
    </method>
    <method name="setDefaultUri"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Set the default FileSystem URI in a configuration.
 @param conf the configuration to alter
 @param uri the new default filesystem uri]]>
      </doc>
    </method>
    <method name="setDefaultUri"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the default FileSystem URI in a configuration.
 @param conf the configuration to alter
 @param uri the new default filesystem uri]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Initialize a FileSystem.

 Called after the new FileSystem instance is constructed, and before it
 is ready for use.

 FileSystem implementations overriding this method MUST forward it to
 their superclass, though the order in which it is done, and whether
 to alter the configuration before the invocation are options of the
 subclass.
 @param name a URI whose authority section names the host, port, etc.
   for this FileSystem
 @param conf the configuration
 @throws IOException on any failure to initialize this instance.
 @throws IllegalArgumentException if the URI is considered invalid.]]>
      </doc>
    </method>
    <method name="getScheme" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the protocol scheme for this FileSystem.
 <p>
 This implementation throws an <code>UnsupportedOperationException</code>.

 @return the protocol scheme for this FileSystem.
 @throws UnsupportedOperationException if the operation is unsupported
         (default).]]>
      </doc>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a URI which identifies this FileSystem.

 @return the URI of this filesystem.]]>
      </doc>
    </method>
    <method name="getCanonicalUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a canonicalized form of this FileSystem's URI.

 The default implementation simply calls {@link #canonicalizeUri(URI)}
 on the filesystem's own URI, so subclasses typically only need to
 implement that method.

 @see #canonicalizeUri(URI)
 @return the URI of this filesystem.]]>
      </doc>
    </method>
    <method name="canonicalizeUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Canonicalize the given URI.

 This is implementation-dependent, and may for example consist of
 canonicalizing the hostname using DNS and adding the default
 port if not specified.

 The default implementation simply fills in the default port if
 not specified and if {@link #getDefaultPort()} returns a
 default port.

 @param uri url.
 @return URI
 @see NetUtils#getCanonicalUri(URI, int)]]>
      </doc>
    </method>
    <method name="getDefaultPort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the default port for this FileSystem.
 @return the default port or 0 if there isn't one]]>
      </doc>
    </method>
    <method name="getFSofPath" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="absOrFqPath" type="org.apache.hadoop.fs.Path"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCanonicalServiceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a canonical service name for this FileSystem.
 The token cache is the only user of the canonical service name,
 and uses it to lookup this FileSystem's service tokens.
 If the file system provides a token of its own then it must have a
 canonical name, otherwise the canonical name can be null.

 Default implementation: If the FileSystem has child file systems
 (such as an embedded file system) then it is assumed that the FS has no
 tokens of its own and hence returns a null name; otherwise a service
 name is built using Uri and port.

 @return a service string that uniquely identifies this file system, null
         if the filesystem does not implement tokens
 @see SecurityUtil#buildDTServiceName(URI, int)]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="call {@link #getUri()} instead.">
      <doc>
      <![CDATA[@return uri to string.
 @deprecated call {@link #getUri()} instead.]]>
      </doc>
    </method>
    <method name="getNamed" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="call {@link #get(URI, Configuration)} instead.">
      <param name="name" type="java.lang.String"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@deprecated call {@link #get(URI, Configuration)} instead.

 @param name name.
 @param conf configuration.
 @return file system.
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="getLocal" return="org.apache.hadoop.fs.LocalFileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the local FileSystem.
 @param conf the configuration to configure the FileSystem with
 if it is newly instantiated.
 @return a LocalFileSystem
 @throws IOException if somehow the local FS cannot be instantiated.]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a FileSystem for this URI's scheme and authority.
 <ol>
 <li>
   If the configuration has the property
   {@code "fs.$SCHEME.impl.disable.cache"} set to true,
   a new instance will be created, initialized with the supplied URI and
   configuration, then returned without being cached.
 </li>
 <li>
   If the there is a cached FS instance matching the same URI, it will
   be returned.
 </li>
 <li>
   Otherwise: a new FS instance will be created, initialized with the
   configuration and URI, cached and returned to the caller.
 </li>
 </ol>
 @param uri uri of the filesystem.
 @param conf configrution.
 @return filesystem instance.
 @throws IOException if the FileSystem cannot be instantiated.]]>
      </doc>
    </method>
    <method name="newInstance" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="user" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Returns the FileSystem for this URI's scheme and authority and the
 given user. Internally invokes {@link #newInstance(URI, Configuration)}
 @param uri uri of the filesystem.
 @param conf the configuration to use
 @param user to perform the get as
 @return filesystem instance
 @throws IOException if the FileSystem cannot be instantiated.
 @throws InterruptedException If the {@code UGI.doAs()} call was
         somehow interrupted.]]>
      </doc>
    </method>
    <method name="newInstance" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="config" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the FileSystem for this URI's scheme and authority.
 The entire URI is passed to the FileSystem instance's initialize method.
 This always returns a new FileSystem object.
 @param uri FS URI
 @param config configuration to use
 @return the new FS instance
 @throws IOException FS creation or initialization failure.]]>
      </doc>
    </method>
    <method name="newInstance" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a unique configured FileSystem implementation for the default
 filesystem of the supplied configuration.
 This always returns a new FileSystem object.
 @param conf the configuration to use
 @return the new FS instance
 @throws IOException FS creation or initialization failure.]]>
      </doc>
    </method>
    <method name="newInstanceLocal" return="org.apache.hadoop.fs.LocalFileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a unique local FileSystem object.
 @param conf the configuration to configure the FileSystem with
 @return a new LocalFileSystem object.
 @throws IOException FS creation or initialization failure.]]>
      </doc>
    </method>
    <method name="closeAll"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close all cached FileSystem instances. After this operation, they
 may not be used in any operations.

 @throws IOException a problem arose closing one or more filesystem.]]>
      </doc>
    </method>
    <method name="closeAllForUGI"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ugi" type="org.apache.hadoop.security.UserGroupInformation"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close all cached FileSystem instances for a given UGI.
 Be sure those filesystems are not used anymore.
 @param ugi user group info to close
 @throws IOException a problem arose closing one or more filesystem.]]>
      </doc>
    </method>
    <method name="makeQualified" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Qualify a path to one which uses this FileSystem and, if relative,
 made absolute.
 @param path to qualify.
 @return this path if it contains a scheme and authority and is absolute, or
 a new path that includes a path and authority and is fully qualified
 @see Path#makeQualified(URI, Path)
 @throws IllegalArgumentException if the path has a schema/URI different
 from this FileSystem.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a file with the provided permission.

 The permission of the file is set to be the provided permission as in
 setPermission, not permission{@literal &~}umask

 The HDFS implementation is implemented using two RPCs.
 It is understood that it is inefficient,
 but the implementation is thread-safe. The other option is to change the
 value of umask in configuration to be 0, but it is not thread-safe.

 @param fs FileSystem
 @param file the name of the file to be created
 @param permission the permission of the file
 @return an output stream
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dir" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a directory with the provided permission.
 The permission of the directory is set to be the provided permission as in
 setPermission, not permission{@literal &~}umask

 @see #create(FileSystem, Path, FsPermission)

 @param fs FileSystem handle
 @param dir the name of the directory to be created
 @param permission the permission of the directory
 @return true if the directory creation succeeds; false otherwise
 @throws IOException A problem creating the directories.]]>
      </doc>
    </method>
    <method name="checkPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Check that a Path belongs to this FileSystem.

 The base implementation performs case insensitive equality checks
 of the URIs' schemes and authorities. Subclasses may implement slightly
 different checks.
 @param path to check
 @throws IllegalArgumentException if the path is not considered to be
 part of this FileSystem.]]>
      </doc>
    </method>
    <method name="getFileBlockLocations" return="org.apache.hadoop.fs.BlockLocation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.FileStatus"/>
      <param name="start" type="long"/>
      <param name="len" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return an array containing hostnames, offset and size of
 portions of the given file.  For nonexistent
 file or regions, {@code null} is returned.

 <pre>
   if f == null :
     result = null
   elif f.getLen() {@literal <=} start:
     result = []
   else result = [ locations(FS, b) for b in blocks(FS, p, s, s+l)]
 </pre>
 This call is most helpful with and distributed filesystem
 where the hostnames of machines that contain blocks of the given file
 can be determined.

 The default implementation returns an array containing one element:
 <pre>
 BlockLocation( { "localhost:9866" },  { "localhost" }, 0, file.getLen())
 </pre>

 In HDFS, if file is three-replicated, the returned array contains
 elements like:
 <pre>
 BlockLocation(offset: 0, length: BLOCK_SIZE,
   hosts: {"host1:9866", "host2:9866, host3:9866"})
 BlockLocation(offset: BLOCK_SIZE, length: BLOCK_SIZE,
   hosts: {"host2:9866", "host3:9866, host4:9866"})
 </pre>

 And if a file is erasure-coded, the returned BlockLocation are logical
 block groups.

 Suppose we have a RS_3_2 coded file (3 data units and 2 parity units).
 1. If the file size is less than one stripe size, say 2 * CELL_SIZE, then
 there will be one BlockLocation returned, with 0 offset, actual file size
 and 4 hosts (2 data blocks and 2 parity blocks) hosting the actual blocks.
 3. If the file size is less than one group size but greater than one
 stripe size, then there will be one BlockLocation returned, with 0 offset,
 actual file size with 5 hosts (3 data blocks and 2 parity blocks) hosting
 the actual blocks.
 4. If the file size is greater than one group size, 3 * BLOCK_SIZE + 123
 for example, then the result will be like:
 <pre>
 BlockLocation(offset: 0, length: 3 * BLOCK_SIZE, hosts: {"host1:9866",
   "host2:9866","host3:9866","host4:9866","host5:9866"})
 BlockLocation(offset: 3 * BLOCK_SIZE, length: 123, hosts: {"host1:9866",
   "host4:9866", "host5:9866"})
 </pre>

 @param file FilesStatus to get data from
 @param start offset into the given file
 @param len length for which to get locations for
 @throws IOException IO failure
 @return block location array.]]>
      </doc>
    </method>
    <method name="getFileBlockLocations" return="org.apache.hadoop.fs.BlockLocation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="start" type="long"/>
      <param name="len" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return an array containing hostnames, offset and size of
 portions of the given file.  For a nonexistent
 file or regions, {@code null} is returned.

 This call is most helpful with location-aware distributed
 filesystems, where it returns hostnames of machines that
 contain the given file.

 A FileSystem will normally return the equivalent result
 of passing the {@code FileStatus} of the path to
 {@link #getFileBlockLocations(FileStatus, long, long)}

 @param p path is used to identify an FS since an FS could have
          another FS that it could be delegating the call to
 @param start offset into the given file
 @param len length for which to get locations for
 @throws FileNotFoundException when the path does not exist
 @throws IOException IO failure
 @return block location array.]]>
      </doc>
    </method>
    <method name="getServerDefaults" return="org.apache.hadoop.fs.FsServerDefaults"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #getServerDefaults(Path)} instead">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a set of server default configuration values.
 @return server default configuration values
 @throws IOException IO failure
 @deprecated use {@link #getServerDefaults(Path)} instead]]>
      </doc>
    </method>
    <method name="getServerDefaults" return="org.apache.hadoop.fs.FsServerDefaults"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a set of server default configuration values.
 @param p path is used to identify an FS since an FS could have
          another FS that it could be delegating the call to
 @return server default configuration values
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="resolvePath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the fully-qualified path of path, resolving the path
 through any symlinks or mount point.
 @param p path to be resolved
 @return fully qualified path
 @throws FileNotFoundException if the path is not present
 @throws IOException for any other error]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataInputStream at the indicated Path.
 @param f the file name to open
 @param bufferSize the size of the buffer to be used.
 @throws IOException IO failure
 @return input stream.]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataInputStream at the indicated Path.
 @param f the file to open
 @throws IOException IO failure
 @return input stream.]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fd" type="org.apache.hadoop.fs.PathHandle"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Open an FSDataInputStream matching the PathHandle instance. The
 implementation may encode metadata in PathHandle to address the
 resource directly and verify that the resource referenced
 satisfies constraints specified at its construciton.
 @param fd PathHandle object returned by the FS authority.
 @throws InvalidPathHandleException If {@link PathHandle} constraints are
                                    not satisfied
 @throws IOException IO failure
 @throws UnsupportedOperationException If {@link #open(PathHandle, int)}
                                       not overridden by subclass
 @return input stream.]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fd" type="org.apache.hadoop.fs.PathHandle"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Open an FSDataInputStream matching the PathHandle instance. The
 implementation may encode metadata in PathHandle to address the
 resource directly and verify that the resource referenced
 satisfies constraints specified at its construciton.
 @param fd PathHandle object returned by the FS authority.
 @param bufferSize the size of the buffer to use
 @throws InvalidPathHandleException If {@link PathHandle} constraints are
                                    not satisfied
 @throws IOException IO failure
 @throws UnsupportedOperationException If not overridden by subclass
 @return input stream.]]>
      </doc>
    </method>
    <method name="getPathHandle" return="org.apache.hadoop.fs.PathHandle"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="stat" type="org.apache.hadoop.fs.FileStatus"/>
      <param name="opt" type="org.apache.hadoop.fs.Options.HandleOpt[]"/>
      <doc>
      <![CDATA[Create a durable, serializable handle to the referent of the given
 entity.
 @param stat Referent in the target FileSystem
 @param opt If absent, assume {@link HandleOpt#path()}.
 @throws IllegalArgumentException If the FileStatus does not belong to
         this FileSystem
 @throws UnsupportedOperationException If {@link #createPathHandle}
         not overridden by subclass.
 @throws UnsupportedOperationException If this FileSystem cannot enforce
         the specified constraints.
 @return path handle.]]>
      </doc>
    </method>
    <method name="createPathHandle" return="org.apache.hadoop.fs.PathHandle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="stat" type="org.apache.hadoop.fs.FileStatus"/>
      <param name="opt" type="org.apache.hadoop.fs.Options.HandleOpt[]"/>
      <doc>
      <![CDATA[Hook to implement support for {@link PathHandle} operations.
 @param stat Referent in the target FileSystem
 @param opt Constraints that determine the validity of the
            {@link PathHandle} reference.
 @return path handle.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path.
 Files are overwritten by default.
 @param f the file to create
 @throws IOException IO failure
 @return output stream.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path.
 @param f the file to create
 @param overwrite if a file with this name already exists, then if true,
   the file will be overwritten, and if false an exception will be thrown.
 @throws IOException IO failure
 @return output stream.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path with write-progress
 reporting.
 Files are overwritten by default.
 @param f the file to create
 @param progress to report progress
 @throws IOException IO failure
 @return output stream.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path.
 Files are overwritten by default.
 @param f the file to create
 @param replication the replication factor
 @throws IOException IO failure
 @return output stream1]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path with write-progress
 reporting.
 Files are overwritten by default.
 @param f the file to create
 @param replication the replication factor
 @param progress to report progress
 @throws IOException IO failure
 @return output stream.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path.
 @param f the file to create
 @param overwrite if a path with this name already exists, then if true,
   the file will be overwritten, and if false an error will be thrown.
 @param bufferSize the size of the buffer to be used.
 @throws IOException IO failure
 @return output stream.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an {@link FSDataOutputStream} at the indicated Path
 with write-progress reporting.

 The frequency of callbacks is implementation-specific; it may be "none".
 @param f the path of the file to open
 @param overwrite if a file with this name already exists, then if true,
   the file will be overwritten, and if false an error will be thrown.
 @param bufferSize the size of the buffer to be used.
 @param progress to report progress.
 @throws IOException IO failure
 @return output stream.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path.
 @param f the file name to open
 @param overwrite if a file with this name already exists, then if true,
   the file will be overwritten, and if false an error will be thrown.
 @param bufferSize the size of the buffer to be used.
 @param replication required block replication for the file.
 @param blockSize the size of the buffer to be used.
 @throws IOException IO failure
 @return output stream.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path with write-progress
 reporting.
 @param f the file name to open
 @param overwrite if a file with this name already exists, then if true,
   the file will be overwritten, and if false an error will be thrown.
 @param bufferSize the size of the buffer to be used.
 @param replication required block replication for the file.
 @param blockSize the size of the buffer to be used.
 @param progress to report progress.
 @throws IOException IO failure
 @return output stream.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path with write-progress
 reporting.
 @param f the file name to open
 @param permission file permission
 @param overwrite if a file with this name already exists, then if true,
   the file will be overwritten, and if false an error will be thrown.
 @param bufferSize the size of the buffer to be used.
 @param replication required block replication for the file.
 @param blockSize block size
 @param progress the progress reporter
 @throws IOException IO failure
 @see #setPermission(Path, FsPermission)
 @return output stream.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flags" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path with write-progress
 reporting.
 @param f the file name to open
 @param permission file permission
 @param flags {@link CreateFlag}s to use for this stream.
 @param bufferSize the size of the buffer to be used.
 @param replication required block replication for the file.
 @param blockSize block size
 @param progress the progress reporter
 @throws IOException IO failure
 @see #setPermission(Path, FsPermission)
 @return output stream.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flags" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="checksumOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path with a custom
 checksum option.
 @param f the file name to open
 @param permission file permission
 @param flags {@link CreateFlag}s to use for this stream.
 @param bufferSize the size of the buffer to be used.
 @param replication required block replication for the file.
 @param blockSize block size
 @param progress the progress reporter
 @param checksumOpt checksum parameter. If null, the values
        found in conf will be used.
 @throws IOException IO failure
 @see #setPermission(Path, FsPermission)
 @return output stream.]]>
      </doc>
    </method>
    <method name="primitiveCreate" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="absolutePermission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flag" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="checksumOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This create has been added to support the FileContext that processes
 the permission with umask before calling this method.
 This a temporary method added to support the transition from FileSystem
 to FileContext for user applications.

 @param f path.
 @param absolutePermission permission.
 @param flag create flag.
 @param bufferSize buffer size.
 @param replication replication.
 @param blockSize block size.
 @param progress progress.
 @param checksumOpt check sum opt.
 @return output stream.
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="primitiveMkdir" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="absolutePermission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This version of the mkdirs method assumes that the permission is absolute.
 It has been added to support the FileContext that processes the permission
 with umask before calling this method.
 This a temporary method added to support the transition from FileSystem
 to FileContext for user applications.
 @param f path
 @param absolutePermission permissions
 @return true if the directory was actually created.
 @throws IOException IO failure
 @see #mkdirs(Path, FsPermission)]]>
      </doc>
    </method>
    <method name="primitiveMkdir"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="absolutePermission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="createParent" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This version of the mkdirs method assumes that the permission is absolute.
 It has been added to support the FileContext that processes the permission
 with umask before calling this method.
 This a temporary method added to support the transition from FileSystem
 to FileContext for user applications.

 @param f the path.
 @param absolutePermission permission.
 @param createParent create parent.
 @throws IOException IO failure.]]>
      </doc>
    </method>
    <method name="createNonRecursive" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataOutputStream at the indicated Path with write-progress
 reporting. Same as create(), except fails if parent directory doesn't
 already exist.
 @param f the file name to open
 @param overwrite if a file with this name already exists, then if true,
 the file will be overwritten, and if false an error will be thrown.
 @param bufferSize the size of the buffer to be used.
 @param replication required block replication for the file.
 @param blockSize block size
 @param progress the progress reporter
 @throws IOException IO failure
 @see #setPermission(Path, FsPermission)
 @return output stream.]]>
      </doc>
    </method>
    <method name="createNonRecursive" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataOutputStream at the indicated Path with write-progress
 reporting. Same as create(), except fails if parent directory doesn't
 already exist.
 @param f the file name to open
 @param permission file permission
 @param overwrite if a file with this name already exists, then if true,
 the file will be overwritten, and if false an error will be thrown.
 @param bufferSize the size of the buffer to be used.
 @param replication required block replication for the file.
 @param blockSize block size
 @param progress the progress reporter
 @throws IOException IO failure
 @see #setPermission(Path, FsPermission)
 @return output stream.]]>
      </doc>
    </method>
    <method name="createNonRecursive" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flags" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataOutputStream at the indicated Path with write-progress
 reporting. Same as create(), except fails if parent directory doesn't
 already exist.
 @param f the file name to open
 @param permission file permission
 @param flags {@link CreateFlag}s to use for this stream.
 @param bufferSize the size of the buffer to be used.
 @param replication required block replication for the file.
 @param blockSize block size
 @param progress the progress reporter
 @throws IOException IO failure
 @see #setPermission(Path, FsPermission)
 @return output stream.]]>
      </doc>
    </method>
    <method name="createNewFile" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates the given Path as a brand-new zero-length file.  If
 create fails, or if it already existed, return false.
 <i>Important: the default implementation is not atomic</i>
 @param f path to use for create
 @throws IOException IO failure
 @return if create new file success true,not false.]]>
      </doc>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Append to an existing file (optional operation).
 Same as
 {@code append(f, getConf().getInt(IO_FILE_BUFFER_SIZE_KEY,
     IO_FILE_BUFFER_SIZE_DEFAULT), null)}
 @param f the existing file to be appended.
 @throws IOException IO failure
 @throws UnsupportedOperationException if the operation is unsupported
         (default).
 @return output stream.]]>
      </doc>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Append to an existing file (optional operation).
 Same as append(f, bufferSize, null).
 @param f the existing file to be appended.
 @param bufferSize the size of the buffer to be used.
 @throws IOException IO failure
 @throws UnsupportedOperationException if the operation is unsupported
         (default).
 @return output stream.]]>
      </doc>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Append to an existing file (optional operation).
 @param f the existing file to be appended.
 @param bufferSize the size of the buffer to be used.
 @param progress for reporting progress if it is not null.
 @throws IOException IO failure
 @throws UnsupportedOperationException if the operation is unsupported
         (default).
 @return output stream.]]>
      </doc>
    </method>
    <method name="concat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="trg" type="org.apache.hadoop.fs.Path"/>
      <param name="psrcs" type="org.apache.hadoop.fs.Path[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Concat existing files together.
 @param trg the path to the target destination.
 @param psrcs the paths to the sources to use for the concatenation.
 @throws IOException IO failure
 @throws UnsupportedOperationException if the operation is unsupported
         (default).]]>
      </doc>
    </method>
    <method name="getReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #getFileStatus(Path)} instead">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the replication factor.

 @deprecated Use {@link #getFileStatus(Path)} instead
 @param src file name
 @return file replication
 @throws FileNotFoundException if the path does not resolve.
 @throws IOException an IO failure]]>
      </doc>
    </method>
    <method name="setReplication" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the replication for an existing file.
 If a filesystem does not support replication, it will always
 return true: the check for a file existing may be bypassed.
 This is the default behavior.
 @param src file name
 @param replication new replication
 @throws IOException an IO failure.
 @return true if successful, or the feature in unsupported;
         false if replication is supported but the file does not exist,
         or is a directory]]>
      </doc>
    </method>
    <method name="rename" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Renames Path src to Path dst.
 @param src path to be renamed
 @param dst new path after rename
 @throws IOException on failure
 @return true if rename is successful]]>
      </doc>
    </method>
    <method name="rename"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="options" type="org.apache.hadoop.fs.Options.Rename[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Renames Path src to Path dst
 <ul>
   <li>Fails if src is a file and dst is a directory.</li>
   <li>Fails if src is a directory and dst is a file.</li>
   <li>Fails if the parent of dst does not exist or is a file.</li>
 </ul>
 <p>
 If OVERWRITE option is not passed as an argument, rename fails
 if the dst already exists.
 </p>
 <p>
 If OVERWRITE option is passed as an argument, rename overwrites
 the dst if it is a file or an empty directory. Rename fails if dst is
 a non-empty directory.
 </p>
 Note that atomicity of rename is dependent on the file system
 implementation. Please refer to the file system documentation for
 details. This default implementation is non atomic.
 <p>
 This method is deprecated since it is a temporary method added to
 support the transition from FileSystem to FileContext for user
 applications.
 </p>

 @param src path to be renamed
 @param dst new path after rename
 @param options rename options.
 @throws FileNotFoundException src path does not exist, or the parent
 path of dst does not exist.
 @throws FileAlreadyExistsException dest path exists and is a file
 @throws ParentNotDirectoryException if the parent path of dest is not
 a directory
 @throws IOException on failure]]>
      </doc>
    </method>
    <method name="truncate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="newLength" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Truncate the file in the indicated path to the indicated size.
 <ul>
   <li>Fails if path is a directory.</li>
   <li>Fails if path does not exist.</li>
   <li>Fails if path is not closed.</li>
   <li>Fails if new size is greater than current size.</li>
 </ul>
 @param f The path to the file to be truncated
 @param newLength The size the file is to be truncated to

 @return <code>true</code> if the file has been truncated to the desired
 <code>newLength</code> and is immediately available to be reused for
 write operations such as <code>append</code>, or
 <code>false</code> if a background process of adjusting the length of
 the last block has been started, and clients should wait for it to
 complete before proceeding with further file updates.
 @throws IOException IO failure
 @throws UnsupportedOperationException if the operation is unsupported
         (default).]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #delete(Path, boolean)} instead.">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete a file/directory.
 @param f the path.
 @throws IOException IO failure.
 @return if delete success true, not false.
 @deprecated Use {@link #delete(Path, boolean)} instead.]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete a file.

 @param f the path to delete.
 @param recursive if path is a directory and set to
 true, the directory is deleted else throws an exception. In
 case of a file the recursive can be set to either true or false.
 @return  true if delete is successful else false.
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="deleteOnExit" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Mark a path to be deleted when its FileSystem is closed.
 When the JVM shuts down cleanly, all cached FileSystem objects will be
 closed automatically. These the marked paths will be deleted as a result.

 If a FileSystem instance is not cached, i.e. has been created with
 {@link #createFileSystem(URI, Configuration)}, then the paths will
 be deleted in when {@link #close()} is called on that instance.

 The path must exist in the filesystem at the time of the method call;
 it does not have to exist at the time of JVM shutdown.

 Notes
 <ol>
   <li>Clean shutdown of the JVM cannot be guaranteed.</li>
   <li>The time to shut down a FileSystem will depends on the number of
   files to delete. For filesystems where the cost of checking
   for the existence of a file/directory and the actual delete operation
   (for example: object stores) is high, the time to shutdown the JVM can be
   significantly extended by over-use of this feature.</li>
   <li>Connectivity problems with a remote filesystem may delay shutdown
   further, and may cause the files to not be deleted.</li>
 </ol>
 @param f the path to delete.
 @return  true if deleteOnExit is successful, otherwise false.
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="cancelDeleteOnExit" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Cancel the scheduled deletion of the path when the FileSystem is closed.
 @param f the path to cancel deletion
 @return true if the path was found in the delete-on-exit list.]]>
      </doc>
    </method>
    <method name="processDeleteOnExit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Delete all paths that were marked as delete-on-exit. This recursively
 deletes all files and directories in the specified paths.

 The time to process this operation is {@code O(paths)}, with the actual
 time dependent on the time for existence and deletion operations to
 complete, successfully or not.]]>
      </doc>
    </method>
    <method name="exists" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Check if a path exists.

 It is highly discouraged to call this method back to back with other
 {@link #getFileStatus(Path)} calls, as this will involve multiple redundant
 RPC calls in HDFS.

 @param f source path
 @return true if the path exists
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="isDirectory" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #getFileStatus(Path)} instead">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[True iff the named path is a directory.
 Note: Avoid using this method. Instead reuse the FileStatus
 returned by getFileStatus() or listStatus() methods.

 @param f path to check
 @throws IOException IO failure
 @deprecated Use {@link #getFileStatus(Path)} instead
 @return if f is directory true, not false.]]>
      </doc>
    </method>
    <method name="isFile" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #getFileStatus(Path)} instead">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[True iff the named path is a regular file.
 Note: Avoid using this method. Instead reuse the FileStatus
 returned by {@link #getFileStatus(Path)} or listStatus() methods.

 @param f path to check
 @throws IOException IO failure
 @deprecated Use {@link #getFileStatus(Path)} instead
 @return if f is file true, not false.]]>
      </doc>
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #getFileStatus(Path)} instead.">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The number of bytes in a file.
 @param f the path.
 @return the number of bytes; 0 for a directory
 @deprecated Use {@link #getFileStatus(Path)} instead.
 @throws FileNotFoundException if the path does not resolve
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="getContentSummary" return="org.apache.hadoop.fs.ContentSummary"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the {@link ContentSummary} of a given {@link Path}.
 @param f path to use
 @throws FileNotFoundException if the path does not resolve
 @throws IOException IO failure
 @return content summary.]]>
      </doc>
    </method>
    <method name="getQuotaUsage" return="org.apache.hadoop.fs.QuotaUsage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the {@link QuotaUsage} of a given {@link Path}.
 @param f path to use
 @return the quota usage
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="setQuota"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="namespaceQuota" type="long"/>
      <param name="storagespaceQuota" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set quota for the given {@link Path}.

 @param src the target path to set quota for
 @param namespaceQuota the namespace quota (i.e., # of files/directories)
                       to set
 @param storagespaceQuota the storage space quota to set
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="setQuotaByStorageType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="type" type="org.apache.hadoop.fs.StorageType"/>
      <param name="quota" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set per storage type quota for the given {@link Path}.

 @param src the target path to set storage type quota for
 @param type the storage type to set
 @param quota the quota to set for the given storage type
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses of the files/directories in the given path if the path is
 a directory.
 <p>
 Does not guarantee to return the List of files/directories status in a
 sorted order.
 <p>
 Will not return null. Expect IOException upon access error.
 @param f given path
 @return the statuses of the files/directories in the given patch
 @throws FileNotFoundException when the path does not exist
 @throws IOException see specific implementation]]>
      </doc>
    </method>
    <method name="listCorruptFileBlocks" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List corrupted file blocks.

 @param path the path.
 @return an iterator over the corrupt files under the given path
 (may contain duplicates if a file has more than one corrupt block)
 @throws UnsupportedOperationException if the operation is unsupported
         (default).
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="filter" type="org.apache.hadoop.fs.PathFilter"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Filter files/directories in the given path using the user-supplied path
 filter.
 <p>
 Does not guarantee to return the List of files/directories status in a
 sorted order.

 @param f
          a path name
 @param filter
          the user-supplied path filter
 @return an array of FileStatus objects for the files under the given path
         after applying the filter
 @throws FileNotFoundException when the path does not exist
 @throws IOException see specific implementation]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="files" type="org.apache.hadoop.fs.Path[]"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Filter files/directories in the given list of paths using default
 path filter.
 <p>
 Does not guarantee to return the List of files/directories status in a
 sorted order.

 @param files
          a list of paths
 @return a list of statuses for the files under the given paths after
         applying the filter default Path filter
 @throws FileNotFoundException when the path does not exist
 @throws IOException see specific implementation]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="files" type="org.apache.hadoop.fs.Path[]"/>
      <param name="filter" type="org.apache.hadoop.fs.PathFilter"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Filter files/directories in the given list of paths using user-supplied
 path filter.
 <p>
 Does not guarantee to return the List of files/directories status in a
 sorted order.

 @param files
          a list of paths
 @param filter
          the user-supplied path filter
 @return a list of statuses for the files under the given paths after
         applying the filter
 @throws FileNotFoundException when the path does not exist
 @throws IOException see specific implementation]]>
      </doc>
    </method>
    <method name="globStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pathPattern" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Return all the files that match filePattern and are not checksum
 files. Results are sorted by their names.

 <p>
 A filename pattern is composed of <i>regular</i> characters and
 <i>special pattern matching</i> characters, which are:

 <dl>
  <dd>
   <dl>
    <dt> <tt> ? </tt>
    <dd> Matches any single character.

    <dt> <tt> * </tt>
    <dd> Matches zero or more characters.

    <dt> <tt> [<i>abc</i>] </tt>
    <dd> Matches a single character from character set
     <tt>{<i>a,b,c</i>}</tt>.

    <dt> <tt> [<i>a</i>-<i>b</i>] </tt>
    <dd> Matches a single character from the character range
     <tt>{<i>a...b</i>}</tt>.  Note that character <tt><i>a</i></tt> must be
     lexicographically less than or equal to character <tt><i>b</i></tt>.

    <dt> <tt> [^<i>a</i>] </tt>
    <dd> Matches a single character that is not from character set or range
     <tt>{<i>a</i>}</tt>.  Note that the <tt>^</tt> character must occur
     immediately to the right of the opening bracket.

    <dt> <tt> \<i>c</i> </tt>
    <dd> Removes (escapes) any special meaning of character <i>c</i>.

    <dt> <tt> {ab,cd} </tt>
    <dd> Matches a string from the string set <tt>{<i>ab, cd</i>} </tt>

    <dt> <tt> {ab,c{de,fh}} </tt>
    <dd> Matches a string from the string set <tt>{<i>ab, cde, cfh</i>}</tt>

   </dl>
  </dd>
 </dl>

 @param pathPattern a glob specifying a path pattern

 @return an array of paths that match the path pattern
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="globStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pathPattern" type="org.apache.hadoop.fs.Path"/>
      <param name="filter" type="org.apache.hadoop.fs.PathFilter"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return an array of {@link FileStatus} objects whose path names match
 {@code pathPattern} and is accepted by the user-supplied path filter.
 Results are sorted by their path names.

 @param pathPattern a glob specifying the path pattern
 @param filter a user-supplied path filter
 @return null if {@code pathPattern} has no glob and the path does not exist
         an empty array if {@code pathPattern} has a glob and no path
         matches it else an array of {@link FileStatus} objects matching the
         pattern
 @throws IOException if any I/O error occurs when fetching file status]]>
      </doc>
    </method>
    <method name="listLocatedStatus" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses of the files/directories in the given path if the path is
 a directory.
 Return the file's status and block locations If the path is a file.

 If a returned status is a file, it contains the file's block locations.

 @param f is the path

 @return an iterator that traverses statuses of the files/directories
         in the given path

 @throws FileNotFoundException If <code>f</code> does not exist
 @throws IOException If an I/O error occurred]]>
      </doc>
    </method>
    <method name="listLocatedStatus" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="filter" type="org.apache.hadoop.fs.PathFilter"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List a directory.
 The returned results include its block location if it is a file
 The results are filtered by the given path filter
 @param f a path
 @param filter a path filter
 @return an iterator that traverses statuses of the files/directories
         in the given path
 @throws FileNotFoundException if <code>f</code> does not exist
 @throws IOException if any I/O error occurred]]>
      </doc>
    </method>
    <method name="listStatusIterator" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a remote iterator so that followup calls are made on demand
 while consuming the entries. Each FileSystem implementation should
 override this method and provide a more efficient implementation, if
 possible.

 Does not guarantee to return the iterator that traverses statuses
 of the files in a sorted order.

 @param p target path
 @return remote iterator
 @throws FileNotFoundException if <code>p</code> does not exist
 @throws IOException if any I/O error occurred]]>
      </doc>
    </method>
    <method name="listFiles" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses and block locations of the files in the given path.
 Does not guarantee to return the iterator that traverses statuses
 of the files in a sorted order.

 <pre>
 If the path is a directory,
   if recursive is false, returns files in the directory;
   if recursive is true, return files in the subtree rooted at the path.
 If the path is a file, return the file's status and block locations.
 </pre>
 @param f is the path
 @param recursive if the subdirectories need to be traversed recursively

 @return an iterator that traverses statuses of the files

 @throws FileNotFoundException when the path does not exist;
 @throws IOException see specific implementation]]>
      </doc>
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the current user's home directory in this FileSystem.
 The default implementation returns {@code "/user/$USER/"}.
 @return the path.]]>
      </doc>
    </method>
    <method name="setWorkingDirectory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="new_dir" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Set the current working directory for the given FileSystem. All relative
 paths will be resolved relative to it.

 @param new_dir Path of new working directory]]>
      </doc>
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current working directory for the given FileSystem
 @return the directory pathname]]>
      </doc>
    </method>
    <method name="getInitialWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Note: with the new FileContext class, getWorkingDirectory()
 will be removed.
 The working directory is implemented in FileContext.

 Some FileSystems like LocalFileSystem have an initial workingDir
 that we use as the starting workingDir. For other file systems
 like HDFS there is no built in notion of an initial workingDir.

 @return if there is built in notion of workingDir then it
 is returned; else a null is returned.]]>
      </doc>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Call {@link #mkdirs(Path, FsPermission)} with default permission.
 @param f path
 @return true if the directory was created
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Make the given file and all non-existent parents into
 directories. Has roughly the semantics of Unix @{code mkdir -p}.
 Existence of the directory hierarchy is not an error.
 @param f path to create
 @param permission to apply to f
 @throws IOException IO failure
 @return if mkdir success true, not false.]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is on the local disk.  Add it to filesystem at
 the given dst name and the source is kept intact afterwards
 @param src path
 @param dst path
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="moveFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcs" type="org.apache.hadoop.fs.Path[]"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src files is on the local disk.  Add it to filesystem at
 the given dst name, removing the source afterwards.
 @param srcs source paths
 @param dst path
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="moveFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is on the local disk.  Add it to the filesystem at
 the given dst name, removing the source afterwards.
 @param src local path
 @param dst path
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is on the local disk.  Add it to the filesystem at
 the given dst name.
 delSrc indicates if the source should be removed
 @param delSrc whether to delete the src
 @param src path
 @param dst path
 @throws IOException IO failure.]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <param name="srcs" type="org.apache.hadoop.fs.Path[]"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src files are on the local disk.  Add it to the filesystem at
 the given dst name.
 delSrc indicates if the source should be removed
 @param delSrc whether to delete the src
 @param overwrite whether to overwrite an existing file
 @param srcs array of paths which are source
 @param dst path
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is on the local disk.  Add it to the filesystem at
 the given dst name.
 delSrc indicates if the source should be removed
 @param delSrc whether to delete the src
 @param overwrite whether to overwrite an existing file
 @param src path
 @param dst path
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy it a file from the remote filesystem to the local one.
 @param src path src file in the remote filesystem
 @param dst path local destination
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="moveToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy a file to the local filesystem, then delete it from the
 remote filesystem (if successfully copied).
 @param src path src file in the remote filesystem
 @param dst path local destination
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy it a file from a remote filesystem to the local one.
 delSrc indicates if the src will be removed or not.
 @param delSrc whether to delete the src
 @param src path src file in the remote filesystem
 @param dst path local destination
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="useRawLocalFileSystem" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under this filesystem, and the dst is on the local disk.
 Copy it from the remote filesystem to the local dst name.
 delSrc indicates if the src will be removed
 or not. useRawLocalFileSystem indicates whether to use RawLocalFileSystem
 as the local file system or not. RawLocalFileSystem is non checksumming,
 So, It will not create any crc files at local.

 @param delSrc
          whether to delete the src
 @param src
          path
 @param dst
          path
 @param useRawLocalFileSystem
          whether to use RawLocalFileSystem as local file system or not.

 @throws IOException for any IO error]]>
      </doc>
    </method>
    <method name="startLocalOutput" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a local file that the user can write output to.  The caller
 provides both the eventual target name in this FileSystem
 and the local working file path.
 If this FileSystem is local, we write directly into the target.  If
 the FileSystem is not local, we write into the tmp local area.
 @param fsOutputFile path of output file
 @param tmpLocalFile path of local tmp file
 @throws IOException IO failure
 @return the path.]]>
      </doc>
    </method>
    <method name="completeLocalOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Called when we're all done writing to the target.
 A local FS will do nothing, because we've written to exactly the
 right place.
 A remote FS will copy the contents of tmpLocalFile to the correct target at
 fsOutputFile.
 @param fsOutputFile path of output file
 @param tmpLocalFile path to local tmp file
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close this FileSystem instance.
 Will release any held locks, delete all files queued for deletion
 through calls to {@link #deleteOnExit(Path)}, and remove this FS instance
 from the cache, if cached.

 After this operation, the outcome of any method call on this FileSystem
 instance, or any input/output stream created by it is <i>undefined</i>.
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="getUsed" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the total size of all files in the filesystem.
 @throws IOException IO failure
 @return the number of path used.]]>
      </doc>
    </method>
    <method name="getUsed" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the total size of all files from a specified path.
 @param path the path.
 @throws IOException IO failure
 @return the number of path content summary.]]>
      </doc>
    </method>
    <method name="getBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #getFileStatus(Path)} instead">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the block size for a particular file.
 @param f the filename
 @return the number of bytes in a block
 @deprecated Use {@link #getFileStatus(Path)} instead
 @throws FileNotFoundException if the path is not present
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="getDefaultBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #getDefaultBlockSize(Path)} instead">
      <doc>
      <![CDATA[Return the number of bytes that large input files should be optimally
 be split into to minimize I/O time.
 @deprecated use {@link #getDefaultBlockSize(Path)} instead
 @return default block size.]]>
      </doc>
    </method>
    <method name="getDefaultBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Return the number of bytes that large input files should be optimally
 be split into to minimize I/O time.  The given path will be used to
 locate the actual filesystem.  The full path does not have to exist.
 @param f path of file
 @return the default block size for the path's filesystem]]>
      </doc>
    </method>
    <method name="getDefaultReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #getDefaultReplication(Path)} instead">
      <doc>
      <![CDATA[Get the default replication.
 @return the replication; the default value is "1".
 @deprecated use {@link #getDefaultReplication(Path)} instead]]>
      </doc>
    </method>
    <method name="getDefaultReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Get the default replication for a path.
 The given path will be used to locate the actual FileSystem to query.
 The full path does not have to exist.
 @param path of the file
 @return default replication for the path's filesystem]]>
      </doc>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a file status object that represents the path.
 @param f The path we want information from
 @return a FileStatus object
 @throws FileNotFoundException when the path does not exist
 @throws IOException see specific implementation]]>
      </doc>
    </method>
    <method name="msync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Synchronize client metadata state.
 <p>
 In some FileSystem implementations such as HDFS metadata
 synchronization is essential to guarantee consistency of read requests
 particularly in HA setting.
 @throws IOException If an I/O error occurred.
 @throws UnsupportedOperationException if the operation is unsupported.]]>
      </doc>
    </method>
    <method name="fixRelativePart" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[See {@link FileContext#fixRelativePart}.
 @param p the path.
 @return relative part.]]>
      </doc>
    </method>
    <method name="createSymlink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.apache.hadoop.fs.Path"/>
      <param name="link" type="org.apache.hadoop.fs.Path"/>
      <param name="createParent" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[See {@link FileContext#createSymlink(Path, Path, boolean)}.

 @param target target path.
 @param link link.
 @param createParent create parent.
 @throws AccessControlException if access is denied.
 @throws FileAlreadyExistsException when the path does not exist.
 @throws FileNotFoundException when the path does not exist.
 @throws ParentNotDirectoryException if the parent path of dest is not
                                     a directory.
 @throws UnsupportedFileSystemException if there was no known implementation
                                        for the scheme.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getFileLinkStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[See {@link FileContext#getFileLinkStatus(Path)}.

 @param f the path.
 @throws AccessControlException if access is denied.
 @throws FileNotFoundException when the path does not exist.
 @throws IOException raised on errors performing I/O.
 @throws UnsupportedFileSystemException if there was no known implementation
                                        for the scheme.
 @return file status]]>
      </doc>
    </method>
    <method name="supportsSymlinks" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See {@link AbstractFileSystem#supportsSymlinks()}.
 @return if support symlinkls true, not false.]]>
      </doc>
    </method>
    <method name="getLinkTarget" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[See {@link FileContext#getLinkTarget(Path)}.
 @param f the path.
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).
 @throws IOException IO failure.
 @return the path.]]>
      </doc>
    </method>
    <method name="resolveLink" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[See {@link AbstractFileSystem#getLinkTarget(Path)}.
 @param f the path.
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).
 @throws IOException IO failure.
 @return the path.]]>
      </doc>
    </method>
    <method name="getFileChecksum" return="org.apache.hadoop.fs.FileChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the checksum of a file, if the FS supports checksums.

 @param f The file path
 @return The file checksum.  The default return value is null,
  which indicates that no checksum algorithm is implemented
  in the corresponding FileSystem.
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="getFileChecksum" return="org.apache.hadoop.fs.FileChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="length" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the checksum of a file, from the beginning of the file till the
 specific length.
 @param f The file path
 @param length The length of the file range for checksum calculation
 @return The file checksum or null if checksums are not supported.
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="setVerifyChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="verifyChecksum" type="boolean"/>
      <doc>
      <![CDATA[Set the verify checksum flag. This is only applicable if the
 corresponding filesystem supports checksums.
 By default doesn't do anything.
 @param verifyChecksum Verify checksum flag]]>
      </doc>
    </method>
    <method name="setWriteChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writeChecksum" type="boolean"/>
      <doc>
      <![CDATA[Set the write checksum flag. This is only applicable if the
 corresponding filesystem supports checksums.
 By default doesn't do anything.
 @param writeChecksum Write checksum flag]]>
      </doc>
    </method>
    <method name="getStatus" return="org.apache.hadoop.fs.FsStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a status object describing the use and capacity of the
 filesystem. If the filesystem has multiple partitions, the
 use and capacity of the root partition is reflected.

 @return a FsStatus object
 @throws IOException
           see specific implementation]]>
      </doc>
    </method>
    <method name="getStatus" return="org.apache.hadoop.fs.FsStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a status object describing the use and capacity of the
 filesystem. If the filesystem has multiple partitions, the
 use and capacity of the partition pointed to by the specified
 path is reflected.
 @param p Path for which status should be obtained. null means
 the default partition.
 @return a FsStatus object
 @throws IOException
           see specific implementation]]>
      </doc>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set permission of a path.
 @param p The path
 @param permission permission
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set owner of a path (i.e. a file or a directory).
 The parameters username and groupname cannot both be null.
 @param p The path
 @param username If it is null, the original username remains unchanged.
 @param groupname If it is null, the original groupname remains unchanged.
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="setTimes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="mtime" type="long"/>
      <param name="atime" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set access time of a file.
 @param p The path
 @param mtime Set the modification time of this file.
              The number of milliseconds since Jan 1, 1970.
              A value of -1 means that this call should not set modification time.
 @param atime Set the access time of this file.
              The number of milliseconds since Jan 1, 1970.
              A value of -1 means that this call should not set access time.
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="createSnapshot" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a snapshot with a default name.
 @param path The directory where snapshots will be taken.
 @return the snapshot path.
 @throws IOException IO failure
 @throws UnsupportedOperationException if the operation is unsupported]]>
      </doc>
    </method>
    <method name="createSnapshot" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a snapshot.
 @param path The directory where snapshots will be taken.
 @param snapshotName The name of the snapshot
 @return the snapshot path.
 @throws IOException IO failure
 @throws UnsupportedOperationException if the operation is unsupported]]>
      </doc>
    </method>
    <method name="renameSnapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotOldName" type="java.lang.String"/>
      <param name="snapshotNewName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Rename a snapshot.
 @param path The directory path where the snapshot was taken
 @param snapshotOldName Old name of the snapshot
 @param snapshotNewName New name of the snapshot
 @throws IOException IO failure
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).]]>
      </doc>
    </method>
    <method name="deleteSnapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete a snapshot of a directory.
 @param path  The directory that the to-be-deleted snapshot belongs to
 @param snapshotName The name of the snapshot
 @throws IOException IO failure
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).]]>
      </doc>
    </method>
    <method name="modifyAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Modifies ACL entries of files and directories.  This method can add new ACL
 entries or modify the permissions on existing ACL entries.  All existing
 ACL entries that are not specified in this call are retained without
 changes.  (Modifications are merged into the current ACL.)

 @param path Path to modify
 @param aclSpec List&lt;AclEntry&gt; describing modifications
 @throws IOException if an ACL could not be modified
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).]]>
      </doc>
    </method>
    <method name="removeAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes ACL entries from files and directories.  Other ACL entries are
 retained.

 @param path Path to modify
 @param aclSpec List describing entries to remove
 @throws IOException if an ACL could not be modified
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).]]>
      </doc>
    </method>
    <method name="removeDefaultAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes all default ACL entries from files and directories.

 @param path Path to modify
 @throws IOException if an ACL could not be modified
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).]]>
      </doc>
    </method>
    <method name="removeAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes all but the base ACL entries of files and directories.  The entries
 for user, group, and others are retained for compatibility with permission
 bits.

 @param path Path to modify
 @throws IOException if an ACL could not be removed
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).]]>
      </doc>
    </method>
    <method name="setAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fully replaces ACL of files and directories, discarding all existing
 entries.

 @param path Path to modify
 @param aclSpec List describing modifications, which must include entries
   for user, group, and others for compatibility with permission bits.
 @throws IOException if an ACL could not be modified
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).]]>
      </doc>
    </method>
    <method name="getAclStatus" return="org.apache.hadoop.fs.permission.AclStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets the ACL of a file or directory.

 @param path Path to get
 @return AclStatus describing the ACL of the file or directory
 @throws IOException if an ACL could not be read
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).]]>
      </doc>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to modify
 @param name xattr name.
 @param value xattr value.
 @throws IOException IO failure
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).]]>
      </doc>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <param name="flag" type="java.util.EnumSet"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to modify
 @param name xattr name.
 @param value xattr value.
 @param flag xattr set flag
 @throws IOException IO failure
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).]]>
      </doc>
    </method>
    <method name="getXAttr" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get an xattr name and value for a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attribute
 @param name xattr name.
 @return byte[] xattr value.
 @throws IOException IO failure
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).]]>
      </doc>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattr name/value pairs for a file or directory.
 Only those xattrs which the logged-in user has permissions to view
 are returned.
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @return Map describing the XAttrs of the file or directory
 @throws IOException IO failure
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).]]>
      </doc>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="names" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattrs name/value pairs for a file or directory.
 Only those xattrs which the logged-in user has permissions to view
 are returned.
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @param names XAttr names.
 @return Map describing the XAttrs of the file or directory
 @throws IOException IO failure
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).]]>
      </doc>
    </method>
    <method name="listXAttrs" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattr names for a file or directory.
 Only those xattr names which the logged-in user has permissions to view
 are returned.
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @return List{@literal <String>} of the XAttr names of the file or directory
 @throws IOException IO failure
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).]]>
      </doc>
    </method>
    <method name="removeXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Remove an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to remove extended attribute
 @param name xattr name
 @throws IOException IO failure
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).]]>
      </doc>
    </method>
    <method name="satisfyStoragePolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the source path to satisfy storage policy.
 @param path The source path referring to either a directory or a file.
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="setStoragePolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="policyName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the storage policy for a given file or directory.

 @param src file or directory path.
 @param policyName the name of the target storage policy. The list
                   of supported Storage policies can be retrieved
                   via {@link #getAllStoragePolicies}.
 @throws IOException IO failure
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).]]>
      </doc>
    </method>
    <method name="unsetStoragePolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Unset the storage policy set for a given file or directory.
 @param src file or directory path.
 @throws IOException IO failure
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).]]>
      </doc>
    </method>
    <method name="getStoragePolicy" return="org.apache.hadoop.fs.BlockStoragePolicySpi"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Query the effective storage policy ID for the given file or directory.

 @param src file or directory path.
 @return storage policy for give file.
 @throws IOException IO failure
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).]]>
      </doc>
    </method>
    <method name="getAllStoragePolicies" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Retrieve all the storage policies supported by this file system.

 @return all storage policies supported by this filesystem.
 @throws IOException IO failure
 @throws UnsupportedOperationException if the operation is unsupported
         (default outcome).]]>
      </doc>
    </method>
    <method name="getTrashRoot" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Get the root directory of Trash for current user when the path specified
 is deleted.

 @param path the trash root of the path to be determined.
 @return the default implementation returns {@code /user/$USER/.Trash}]]>
      </doc>
    </method>
    <method name="getTrashRoots" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="allUsers" type="boolean"/>
      <doc>
      <![CDATA[Get all the trash roots for current user or all users.

 @param allUsers return trash roots for all users if true.
 @return all the trash root directories.
         Default FileSystem returns .Trash under users' home directories if
         {@code /user/$USER/.Trash} exists.]]>
      </doc>
    </method>
    <method name="hasPathCapability" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="capability" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The base FileSystem implementation generally has no knowledge
 of the capabilities of actual implementations.
 Unless it has a way to explicitly determine the capabilities,
 this method returns false.
 {@inheritDoc}]]>
      </doc>
    </method>
    <method name="getFileSystemClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scheme" type="java.lang.String"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the FileSystem implementation class of a filesystem.
 This triggers a scan and load of all FileSystem implementations listed as
 services and discovered via the {@link ServiceLoader}
 @param scheme URL scheme of FS
 @param conf configuration: can be null, in which case the check for
 a filesystem binding declaration in the configuration is skipped.
 @return the filesystem
 @throws UnsupportedFileSystemException if there was no known implementation
         for the scheme.
 @throws IOException if the filesystem could not be loaded]]>
      </doc>
    </method>
    <method name="getStatistics" return="java.util.Map"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="use {@link #getGlobalStorageStatistics()}">
      <doc>
      <![CDATA[Get the Map of Statistics object indexed by URI Scheme.
 @return a Map having a key as URI scheme and value as Statistics object
 @deprecated use {@link #getGlobalStorageStatistics()}]]>
      </doc>
    </method>
    <method name="getAllStatistics" return="java.util.List"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="use {@link #getGlobalStorageStatistics()}">
      <doc>
      <![CDATA[Return the FileSystem classes that have Statistics.
 @deprecated use {@link #getGlobalStorageStatistics()}
 @return statistics lists.]]>
      </doc>
    </method>
    <method name="getStatistics" return="org.apache.hadoop.fs.FileSystem.Statistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="use {@link #getGlobalStorageStatistics()}">
      <param name="scheme" type="java.lang.String"/>
      <param name="cls" type="java.lang.Class"/>
      <doc>
      <![CDATA[Get the statistics for a particular file system.
 @param scheme scheme.
 @param cls the class to lookup
 @return a statistics object
 @deprecated use {@link #getGlobalStorageStatistics()}]]>
      </doc>
    </method>
    <method name="clearStatistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reset all statistics for all file systems.]]>
      </doc>
    </method>
    <method name="printStatistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Print all statistics for all file systems to {@code System.out}
 @throws IOException If an I/O error occurred.]]>
      </doc>
    </method>
    <method name="areSymlinksEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="enableSymlinks"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStorageStatistics" return="org.apache.hadoop.fs.StorageStatistics"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the StorageStatistics for this FileSystem object.  These statistics are
 per-instance.  They are not shared with any other FileSystem object.

 <p>This is a default method which is intended to be overridden by
 subclasses. The default implementation returns an empty storage statistics
 object.</p>

 @return    The StorageStatistics for this FileSystem instance.
            Will never be null.]]>
      </doc>
    </method>
    <method name="getGlobalStorageStatistics" return="org.apache.hadoop.fs.GlobalStorageStatistics"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the global storage statistics.
 @return global storage statistics.]]>
      </doc>
    </method>
    <method name="createDataOutputStreamBuilder" return="org.apache.hadoop.fs.FSDataOutputStreamBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fileSystem" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Create instance of the standard FSDataOutputStreamBuilder for the
 given filesystem and path.
 @param fileSystem owner
 @param path path to create
 @return a builder.]]>
      </doc>
    </method>
    <method name="createFile" return="org.apache.hadoop.fs.FSDataOutputStreamBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Create a new FSDataOutputStreamBuilder for the file with path.
 Files are overwritten by default.

 @param path file path
 @return a FSDataOutputStreamBuilder object to build the file

 HADOOP-14384. Temporarily reduce the visibility of method before the
 builder interface becomes stable.]]>
      </doc>
    </method>
    <method name="appendFile" return="org.apache.hadoop.fs.FSDataOutputStreamBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Create a Builder to append a file.
 @param path file path.
 @return a {@link FSDataOutputStreamBuilder} to build file append request.]]>
      </doc>
    </method>
    <method name="openFile" return="org.apache.hadoop.fs.FutureDataInputStreamBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Open a file for reading through a builder API.
 Ultimately calls {@link #open(Path, int)} unless a subclass
 executes the open command differently.

 The semantics of this call are therefore the same as that of
 {@link #open(Path, int)} with one special point: it is in
 {@code FSDataInputStreamBuilder.build()} in which the open operation
 takes place -it is there where all preconditions to the operation
 are checked.
 @param path file path
 @return a FSDataInputStreamBuilder object to build the input stream
 @throws IOException if some early checks cause IO failures.
 @throws UnsupportedOperationException if support is checked early.]]>
      </doc>
    </method>
    <method name="openFile" return="org.apache.hadoop.fs.FutureDataInputStreamBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pathHandle" type="org.apache.hadoop.fs.PathHandle"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Open a file for reading through a builder API.
 Ultimately calls {@link #open(PathHandle, int)} unless a subclass
 executes the open command differently.

 If PathHandles are unsupported, this may fail in the
 {@code FSDataInputStreamBuilder.build()}  command,
 rather than in this {@code openFile()} operation.
 @param pathHandle path handle.
 @return a FSDataInputStreamBuilder object to build the input stream
 @throws IOException if some early checks cause IO failures.
 @throws UnsupportedOperationException if support is checked early.]]>
      </doc>
    </method>
    <method name="openFileWithOptions" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="parameters" type="org.apache.hadoop.fs.impl.OpenFileParameters"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Execute the actual open file operation.

 This is invoked from {@code FSDataInputStreamBuilder.build()}
 and from {@link DelegateToFileSystem} and is where
 the action of opening the file should begin.

 The base implementation performs a blocking
 call to {@link #open(Path, int)} in this call;
 the actual outcome is in the returned {@code CompletableFuture}.
 This avoids having to create some thread pool, while still
 setting up the expectation that the {@code get()} call
 is needed to evaluate the result.
 @param path path to the file
 @param parameters open file parameters from the builder.
 @return a future which will evaluate to the opened file.
 @throws IOException failure to resolve the link.
 @throws IllegalArgumentException unknown mandatory key]]>
      </doc>
    </method>
    <method name="openFileWithOptions" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="pathHandle" type="org.apache.hadoop.fs.PathHandle"/>
      <param name="parameters" type="org.apache.hadoop.fs.impl.OpenFileParameters"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Execute the actual open file operation.
 The base implementation performs a blocking
 call to {@link #open(Path, int)} in this call;
 the actual outcome is in the returned {@code CompletableFuture}.
 This avoids having to create some thread pool, while still
 setting up the expectation that the {@code get()} call
 is needed to evaluate the result.
 @param pathHandle path to the file
 @param parameters open file parameters from the builder.
 @return a future which will evaluate to the opened file.
 @throws IOException failure to resolve the link.
 @throws IllegalArgumentException unknown mandatory key
 @throws UnsupportedOperationException PathHandles are not supported.
 This may be deferred until the future is evaluated.]]>
      </doc>
    </method>
    <method name="createMultipartUploader" return="org.apache.hadoop.fs.MultipartUploaderBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="basePath" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a multipart uploader.
 @param basePath file path under which all files are uploaded
 @return a MultipartUploaderBuilder object to build the uploader
 @throws IOException if some early checks cause IO failures.
 @throws UnsupportedOperationException if support is checked early.]]>
      </doc>
    </method>
    <field name="FS_DEFAULT_NAME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_FS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This log is widely used in the org.apache.hadoop.fs code and tests,
 so must be considered something to only be changed with care.]]>
      </doc>
    </field>
    <field name="SHUTDOWN_HOOK_PRIORITY" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Priority of the FileSystem shutdown hook: {@value}.]]>
      </doc>
    </field>
    <field name="TRASH_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Prefix for trash directory: {@value}.]]>
      </doc>
    </field>
    <field name="USER_HOME_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="statistics" type="org.apache.hadoop.fs.FileSystem.Statistics"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The statistics for this file system.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[An abstract base class for a fairly generic filesystem.  It
 may be implemented as a distributed filesystem, or as a "local"
 one that reflects the locally-connected disk.  The local version
 exists for small Hadoop instances and for testing.

 <p>

 All user code that may potentially use the Hadoop Distributed
 File System should be written to use a FileSystem object or its
 successor, {@link FileContext}.
 </p>
 <p>
 The local implementation is {@link LocalFileSystem} and distributed
 implementation is DistributedFileSystem. There are other implementations
 for object stores and (outside the Apache Hadoop codebase),
 third party filesystems.
 </p>
 Notes
 <ol>
 <li>The behaviour of the filesystem is
 <a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/filesystem/filesystem.html">
 specified in the Hadoop documentation. </a>
 However, the normative specification of the behavior of this class is
 actually HDFS: if HDFS does not behave the way these Javadocs or
 the specification in the Hadoop documentations define, assume that
 the documentation is incorrect.
 </li>
 <li>The term {@code FileSystem} refers to an instance of this class.</li>
 <li>The acronym "FS" is used as an abbreviation of FileSystem.</li>
 <li>The term {@code filesystem} refers to the distributed/local filesystem
 itself, rather than the class used to interact with it.</li>
 <li>The term "file" refers to a file in the remote filesystem,
 rather than instances of {@code java.io.File}.</li>
 </ol>

 This is a carefully evolving class.
 New methods may be marked as Unstable or Evolving for their initial release,
 as a warning that they are new and may change based on the
 experience of use in applications.
 <p>
 <b>Important note for developers</b>
 </p>
 If you are making changes here to the public API or protected methods,
 you must review the following subclasses and make sure that
 they are filtering/passing through new methods as appropriate.

 {@link FilterFileSystem}: methods are passed through. If not,
 then {@code TestFilterFileSystem.MustNotImplement} must be
 updated with the unsupported interface.
 Furthermore, if the new API's support is probed for via
 {@link #hasPathCapability(Path, String)} then
 {@link FilterFileSystem#hasPathCapability(Path, String)}
 must return false, always.
 <p>
 {@link ChecksumFileSystem}: checksums are created and
 verified.
 </p>
 {@code TestHarFileSystem} will need its {@code MustNotImplement}
 interface updated.

 <p>
 There are some external places your changes will break things.
 Do co-ordinate changes here.
 </p>

 HBase: HBoss
 <p>
 Hive: HiveShim23
 </p>
 {@code shims/0.23/src/main/java/org/apache/hadoop/hive/shims/Hadoop23Shims.java}]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileSystem -->
  <!-- start class org.apache.hadoop.fs.FileUtil -->
  <class name="FileUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FileUtil"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="stat2Paths" return="org.apache.hadoop.fs.Path[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stats" type="org.apache.hadoop.fs.FileStatus[]"/>
      <doc>
      <![CDATA[convert an array of FileStatus to an array of Path

 @param stats
          an array of FileStatus objects
 @return an array of paths corresponding to the input]]>
      </doc>
    </method>
    <method name="stat2Paths" return="org.apache.hadoop.fs.Path[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stats" type="org.apache.hadoop.fs.FileStatus[]"/>
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[convert an array of FileStatus to an array of Path.
 If stats if null, return path
 @param stats
          an array of FileStatus objects
 @param path
          default path to return in stats is null
 @return an array of paths corresponding to the input]]>
      </doc>
    </method>
    <method name="fullyDeleteOnExit"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <doc>
      <![CDATA[Register all files recursively to be deleted on exit.
 @param file File/directory to be deleted]]>
      </doc>
    </method>
    <method name="fullyDelete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <doc>
      <![CDATA[Delete a directory and all its contents.  If
 we return false, the directory may be partially-deleted.
 (1) If dir is symlink to a file, the symlink is deleted. The file pointed
     to by the symlink is not deleted.
 (2) If dir is symlink to a directory, symlink is deleted. The directory
     pointed to by symlink is not deleted.
 (3) If dir is a normal file, it is deleted.
 (4) If dir is a normal directory, then dir and all its contents recursively
     are deleted.
 @param dir dir.
 @return fully delete status.]]>
      </doc>
    </method>
    <method name="fullyDelete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <param name="tryGrantPermissions" type="boolean"/>
      <doc>
      <![CDATA[Delete a directory and all its contents.  If
 we return false, the directory may be partially-deleted.
 (1) If dir is symlink to a file, the symlink is deleted. The file pointed
     to by the symlink is not deleted.
 (2) If dir is symlink to a directory, symlink is deleted. The directory
     pointed to by symlink is not deleted.
 (3) If dir is a normal file, it is deleted.
 (4) If dir is a normal directory, then dir and all its contents recursively
     are deleted.
 @param dir the file or directory to be deleted
 @param tryGrantPermissions true if permissions should be modified to delete a file.
 @return true on success false on failure.]]>
      </doc>
    </method>
    <method name="readLink" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <doc>
      <![CDATA[Returns the target of the given symlink. Returns the empty string if
 the given path does not refer to a symlink or there is an error
 accessing the symlink.
 @param f File representing the symbolic link.
 @return The target of the symbolic link, empty string on error or if not
         a symlink.]]>
      </doc>
    </method>
    <method name="fullyDeleteContents" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <doc>
      <![CDATA[Delete the contents of a directory, not the directory itself.  If
 we return false, the directory may be partially-deleted.
 If dir is a symlink to a directory, all the contents of the actual
 directory pointed to by dir will be deleted.

 @param dir dir.
 @return fullyDeleteContents Status.]]>
      </doc>
    </method>
    <method name="fullyDeleteContents" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <param name="tryGrantPermissions" type="boolean"/>
      <doc>
      <![CDATA[Delete the contents of a directory, not the directory itself.  If
 we return false, the directory may be partially-deleted.
 If dir is a symlink to a directory, all the contents of the actual
 directory pointed to by dir will be deleted.

 @param dir dir.
 @param tryGrantPermissions if 'true', try grant +rwx permissions to this
 and all the underlying directories before trying to delete their contents.
 @return fully delete contents status.]]>
      </doc>
    </method>
    <method name="fullyDelete"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link FileSystem#delete(Path, boolean)}">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dir" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Recursively delete a directory.

 @param fs {@link FileSystem} on which the path is present
 @param dir directory to recursively delete
 @throws IOException raised on errors performing I/O.
 @deprecated Use {@link FileSystem#delete(Path, boolean)}]]>
      </doc>
    </method>
    <method name="copy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dstFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteSource" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy files between FileSystems.
 @param srcFS src fs.
 @param src src.
 @param dstFS dst fs.
 @param dst dst.
 @param deleteSource delete source.
 @param conf configuration.
 @return if copy success true, not false.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="copy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="srcs" type="org.apache.hadoop.fs.Path[]"/>
      <param name="dstFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteSource" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="copy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dstFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteSource" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy files between FileSystems.

 @param srcFS srcFs.
 @param src src.
 @param dstFS dstFs.
 @param dst dst.
 @param deleteSource delete source.
 @param overwrite overwrite.
 @param conf configuration.
 @throws IOException raised on errors performing I/O.
 @return true if the operation succeeded.]]>
      </doc>
    </method>
    <method name="copy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="srcStatus" type="org.apache.hadoop.fs.FileStatus"/>
      <param name="dstFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteSource" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy a file/directory tree within/between filesystems.
 <p>
 returns true if the operation succeeded. When deleteSource is true,
 this means "after the copy, delete(source) returned true"
 If the destination is a directory, and mkdirs (dest) fails,
 the operation will return false rather than raise any exception.
 </p>
 The overwrite flag is about overwriting files; it has no effect about
 handing an attempt to copy a file atop a directory (expect an IOException),
 or a directory over a path which contains a file (mkdir will fail, so
 "false").
 <p>
 The operation is recursive, and the deleteSource operation takes place
 as each subdirectory is copied. Therefore, if an operation fails partway
 through, the source tree may be partially deleted.
 </p>
 @param srcFS source filesystem
 @param srcStatus status of source
 @param dstFS destination filesystem
 @param dst path of source
 @param deleteSource delete the source?
 @param overwrite overwrite files at destination?
 @param conf configuration to use when opening files
 @return true if the operation succeeded.
 @throws IOException failure]]>
      </doc>
    </method>
    <method name="copy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="java.io.File"/>
      <param name="dstFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteSource" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy local files to a FileSystem.

 @param src src.
 @param dstFS dstFs.
 @param dst dst.
 @param deleteSource delete source.
 @param conf configuration.
 @throws IOException raised on errors performing I/O.
 @return true if the operation succeeded.]]>
      </doc>
    </method>
    <method name="copy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="java.io.File"/>
      <param name="deleteSource" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy FileSystem files to local files.

 @param srcFS srcFs.
 @param src src.
 @param dst dst.
 @param deleteSource delete source.
 @param conf configuration.
 @throws IOException raised on errors performing I/O.
 @return true if the operation succeeded.]]>
      </doc>
    </method>
    <method name="makeShellPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Convert a os-native filename to a path that works for the shell.
 @param filename The filename to convert
 @return The unix pathname
 @throws IOException on windows, there can be problems with the subprocess]]>
      </doc>
    </method>
    <method name="makeShellPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Convert a os-native filename to a path that works for the shell.
 @param file The filename to convert
 @return The unix pathname
 @throws IOException on windows, there can be problems with the subprocess]]>
      </doc>
    </method>
    <method name="makeSecureShellPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Convert a os-native filename to a path that works for the shell
 and avoids script injection attacks.
 @param file The filename to convert
 @return The unix pathname
 @throws IOException on windows, there can be problems with the subprocess]]>
      </doc>
    </method>
    <method name="makeShellPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="makeCanonicalPath" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Convert a os-native filename to a path that works for the shell.
 @param file The filename to convert
 @param makeCanonicalPath
          Whether to make canonical path for the file passed
 @return The unix pathname
 @throws IOException on windows, there can be problems with the subprocess]]>
      </doc>
    </method>
    <method name="getDU" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <doc>
      <![CDATA[Takes an input dir and returns the du on that local directory. Very basic
 implementation.

 @param dir
          The input dir to get the disk space of this local dir
 @return The total disk space of the input local directory]]>
      </doc>
    </method>
    <method name="unZip"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputStream" type="java.io.InputStream"/>
      <param name="toDir" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Given a stream input it will unzip the it in the unzip directory.
 passed as the second parameter
 @param inputStream The zip file as input
 @param toDir The unzip directory where to unzip the zip file.
 @throws IOException an exception occurred]]>
      </doc>
    </method>
    <method name="unZip"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inFile" type="java.io.File"/>
      <param name="unzipDir" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Given a File input it will unzip it in the unzip directory.
 passed as the second parameter
 @param inFile The zip file as input
 @param unzipDir The unzip directory where to unzip the zip file.
 @throws IOException An I/O exception has occurred]]>
      </doc>
    </method>
    <method name="unTar"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputStream" type="java.io.InputStream"/>
      <param name="untarDir" type="java.io.File"/>
      <param name="gzipped" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <exception name="ExecutionException" type="java.util.concurrent.ExecutionException"/>
      <doc>
      <![CDATA[Given a Tar File as input it will untar the file in a the untar directory
 passed as the second parameter

 This utility will untar ".tar" files and ".tar.gz","tgz" files.

 @param inputStream The tar file as input.
 @param untarDir The untar directory where to untar the tar file.
 @param gzipped The input stream is gzipped
                TODO Use magic number and PusbackInputStream to identify
 @throws IOException an exception occurred
 @throws InterruptedException command interrupted
 @throws ExecutionException task submit failed]]>
      </doc>
    </method>
    <method name="unTar"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inFile" type="java.io.File"/>
      <param name="untarDir" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Given a Tar File as input it will untar the file in a the untar directory
 passed as the second parameter

 This utility will untar ".tar" files and ".tar.gz","tgz" files.

 @param inFile The tar file as input.
 @param untarDir The untar directory where to untar the tar file.
 @throws IOException an exception occurred.]]>
      </doc>
    </method>
    <method name="symLink" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="java.lang.String"/>
      <param name="linkname" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a soft link between a src and destination
 only on a local disk. HDFS does not support this.
 On Windows, when symlink creation fails due to security
 setting, we will log a warning. The return code in this
 case is 2.

 @param target the target for symlink
 @param linkname the symlink
 @return 0 on success
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="chmod" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="java.lang.String"/>
      <param name="perm" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Change the permissions on a filename.
 @param filename the name of the file to change
 @param perm the permission string
 @return the exit code from the command
 @throws IOException raised on errors performing I/O.
 @throws InterruptedException command interrupted.]]>
      </doc>
    </method>
    <method name="chmod" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="java.lang.String"/>
      <param name="perm" type="java.lang.String"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Change the permissions on a file / directory, recursively, if
 needed.
 @param filename name of the file whose permissions are to change
 @param perm permission string
 @param recursive true, if permissions should be changed recursively
 @return the exit code from the command.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the ownership on a file / directory. User name and group name
 cannot both be null.
 @param file the file to change
 @param username the new user owner name
 @param groupname the new group owner name
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="setReadable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <param name="readable" type="boolean"/>
      <doc>
      <![CDATA[Platform independent implementation for {@link File#setReadable(boolean)}
 File#setReadable does not work as expected on Windows.
 @param f input file
 @param readable readable.
 @return true on success, false otherwise]]>
      </doc>
    </method>
    <method name="setWritable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <param name="writable" type="boolean"/>
      <doc>
      <![CDATA[Platform independent implementation for {@link File#setWritable(boolean)}
 File#setWritable does not work as expected on Windows.
 @param f input file
 @param writable writable.
 @return true on success, false otherwise]]>
      </doc>
    </method>
    <method name="setExecutable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <param name="executable" type="boolean"/>
      <doc>
      <![CDATA[Platform independent implementation for {@link File#setExecutable(boolean)}
 File#setExecutable does not work as expected on Windows.
 Note: revoking execute permission on folders does not have the same
 behavior on Windows as on Unix platforms. Creating, deleting or renaming
 a file within that folder will still succeed on Windows.
 @param f input file
 @param executable executable.
 @return true on success, false otherwise]]>
      </doc>
    </method>
    <method name="canRead" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <doc>
      <![CDATA[Platform independent implementation for {@link File#canRead()}
 @param f input file
 @return On Unix, same as {@link File#canRead()}
         On Windows, true if process has read access on the path]]>
      </doc>
    </method>
    <method name="canWrite" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <doc>
      <![CDATA[Platform independent implementation for {@link File#canWrite()}
 @param f input file
 @return On Unix, same as {@link File#canWrite()}
         On Windows, true if process has write access on the path]]>
      </doc>
    </method>
    <method name="canExecute" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <doc>
      <![CDATA[Platform independent implementation for {@link File#canExecute()}
 @param f input file
 @return On Unix, same as {@link File#canExecute()}
         On Windows, true if process has execute access on the path]]>
      </doc>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set permissions to the required value. Uses the java primitives instead
 of forking if group == other.
 @param f the file to change
 @param permission the new permissions
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="createLocalTempFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="basefile" type="java.io.File"/>
      <param name="prefix" type="java.lang.String"/>
      <param name="isDeleteOnExit" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a tmp file for a base file.
 @param basefile the base file of the tmp
 @param prefix file name prefix of tmp
 @param isDeleteOnExit if true, the tmp will be deleted when the VM exits
 @return a newly created tmp file
 @exception IOException If a tmp file cannot created
 @see java.io.File#createTempFile(String, String, File)
 @see java.io.File#deleteOnExit()]]>
      </doc>
    </method>
    <method name="replaceFile"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="java.io.File"/>
      <param name="target" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Move the src file to the name specified by target.
 @param src the source file
 @param target the target file
 @exception IOException If this operation fails]]>
      </doc>
    </method>
    <method name="listFiles" return="java.io.File[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A wrapper for {@link File#listFiles()}. This java.io API returns null
 when a dir is not a directory or for any I/O error. Instead of having
 null check everywhere File#listFiles() is used, we will add utility API
 to get around this problem. For the majority of cases where we prefer
 an IOException to be thrown.
 @param dir directory for which listing should be performed
 @return list of files or empty list
 @exception IOException for invalid directory or for a bad disk.]]>
      </doc>
    </method>
    <method name="list" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A wrapper for {@link File#list()}. This java.io API returns null
 when a dir is not a directory or for any I/O error. Instead of having
 null check everywhere File#list() is used, we will add utility API
 to get around this problem. For the majority of cases where we prefer
 an IOException to be thrown.
 @param dir directory for which listing should be performed
 @return list of file names or empty string list
 @exception AccessDeniedException for unreadable directory
 @exception IOException for invalid directory or for bad disk]]>
      </doc>
    </method>
    <method name="createJarWithClassPath" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputClassPath" type="java.lang.String"/>
      <param name="pwd" type="org.apache.hadoop.fs.Path"/>
      <param name="callerEnv" type="java.util.Map"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createJarWithClassPath" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputClassPath" type="java.lang.String"/>
      <param name="pwd" type="org.apache.hadoop.fs.Path"/>
      <param name="targetDir" type="org.apache.hadoop.fs.Path"/>
      <param name="callerEnv" type="java.util.Map"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a jar file at the given path, containing a manifest with a classpath
 that references all specified entries.

 Some platforms may have an upper limit on command line length.  For example,
 the maximum command line length on Windows is 8191 characters, but the
 length of the classpath may exceed this.  To work around this limitation,
 use this method to create a small intermediate jar with a manifest that
 contains the full classpath.  It returns the absolute path to the new jar,
 which the caller may set as the classpath for a new process.

 Environment variable evaluation is not supported within a jar manifest, so
 this method expands environment variables before inserting classpath entries
 to the manifest.  The method parses environment variables according to
 platform-specific syntax (%VAR% on Windows, or $VAR otherwise).  On Windows,
 environment variables are case-insensitive.  For example, %VAR% and %var%
 evaluate to the same value.

 Specifying the classpath in a jar manifest does not support wildcards, so
 this method expands wildcards internally.  Any classpath entry that ends
 with * is translated to all files at that path with extension .jar or .JAR.

 @param inputClassPath String input classpath to bundle into the jar manifest
 @param pwd Path to working directory to save jar
 @param targetDir path to where the jar execution will have its working dir
 @param callerEnv Map {@literal <}String, String{@literal >} caller's
 environment variables to use for expansion
 @return String[] with absolute path to new jar in position 0 and
   unexpanded wild card entry path in position 1
 @throws IOException if there is an I/O error while writing the jar file]]>
      </doc>
    </method>
    <method name="getJarsInDirectory" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns all jars that are in the directory. It is useful in expanding a
 wildcard path to return all jars from the directory to use in a classpath.
 It operates only on local paths.

 @param path the path to the directory. The path may include the wildcard.
 @return the list of jars as URLs, or an empty list if there are no jars, or
 the directory does not exist locally]]>
      </doc>
    </method>
    <method name="getJarsInDirectory" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="useLocal" type="boolean"/>
      <doc>
      <![CDATA[Returns all jars that are in the directory. It is useful in expanding a
 wildcard path to return all jars from the directory to use in a classpath.

 @param path the path to the directory. The path may include the wildcard.
 @param useLocal use local.
 @return the list of jars as URLs, or an empty list if there are no jars, or
 the directory does not exist]]>
      </doc>
    </method>
    <method name="compareFs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcFs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="destFs" type="org.apache.hadoop.fs.FileSystem"/>
    </method>
    <method name="write" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="bytes" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes bytes to a file. This utility method opens the file for writing,
 creating the file if it does not exist, or overwrites an existing file. All
 bytes in the byte array are written to the file.

 @param fs the file system with which to create the file
 @param path the path to the file
 @param bytes the byte array with the bytes to write

 @return the file system

 @throws NullPointerException if any of the arguments are {@code null}
 @throws IOException if an I/O error occurs creating or writing to the file]]>
      </doc>
    </method>
    <method name="write" return="org.apache.hadoop.fs.FileContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileContext" type="org.apache.hadoop.fs.FileContext"/>
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="bytes" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes bytes to a file. This utility method opens the file for writing,
 creating the file if it does not exist, or overwrites an existing file. All
 bytes in the byte array are written to the file.

 @param fileContext the file context with which to create the file
 @param path the path to the file
 @param bytes the byte array with the bytes to write

 @return the file context

 @throws NullPointerException if any of the arguments are {@code null}
 @throws IOException if an I/O error occurs creating or writing to the file]]>
      </doc>
    </method>
    <method name="write" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="lines" type="java.lang.Iterable"/>
      <param name="cs" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write lines of text to a file. Each line is a char sequence and is written
 to the file in sequence with each line terminated by the platform's line
 separator, as defined by the system property {@code
 line.separator}. Characters are encoded into bytes using the specified
 charset. This utility method opens the file for writing, creating the file
 if it does not exist, or overwrites an existing file.

 @param fs the file system with which to create the file
 @param path the path to the file
 @param lines a Collection to iterate over the char sequences
 @param cs the charset to use for encoding

 @return the file system

 @throws NullPointerException if any of the arguments are {@code null}
 @throws IOException if an I/O error occurs creating or writing to the file]]>
      </doc>
    </method>
    <method name="write" return="org.apache.hadoop.fs.FileContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileContext" type="org.apache.hadoop.fs.FileContext"/>
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="lines" type="java.lang.Iterable"/>
      <param name="cs" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write lines of text to a file. Each line is a char sequence and is written
 to the file in sequence with each line terminated by the platform's line
 separator, as defined by the system property {@code
 line.separator}. Characters are encoded into bytes using the specified
 charset. This utility method opens the file for writing, creating the file
 if it does not exist, or overwrites an existing file.

 @param fileContext the file context with which to create the file
 @param path the path to the file
 @param lines a Collection to iterate over the char sequences
 @param cs the charset to use for encoding

 @return the file context

 @throws NullPointerException if any of the arguments are {@code null}
 @throws IOException if an I/O error occurs creating or writing to the file]]>
      </doc>
    </method>
    <method name="write" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="charseq" type="java.lang.CharSequence"/>
      <param name="cs" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a line of text to a file. Characters are encoded into bytes using the
 specified charset. This utility method opens the file for writing, creating
 the file if it does not exist, or overwrites an existing file.

 @param fs the file system with which to create the file
 @param path the path to the file
 @param charseq the char sequence to write to the file
 @param cs the charset to use for encoding

 @return the file system

 @throws NullPointerException if any of the arguments are {@code null}
 @throws IOException if an I/O error occurs creating or writing to the file]]>
      </doc>
    </method>
    <method name="write" return="org.apache.hadoop.fs.FileContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileContext"/>
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="charseq" type="java.lang.CharSequence"/>
      <param name="cs" type="java.nio.charset.Charset"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a line of text to a file. Characters are encoded into bytes using the
 specified charset. This utility method opens the file for writing, creating
 the file if it does not exist, or overwrites an existing file.

 @param fs the file context with which to create the file
 @param path the path to the file
 @param charseq the char sequence to write to the file
 @param cs the charset to use for encoding

 @return the file context

 @throws NullPointerException if any of the arguments are {@code null}
 @throws IOException if an I/O error occurs creating or writing to the file]]>
      </doc>
    </method>
    <method name="write" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="charseq" type="java.lang.CharSequence"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a line of text to a file. Characters are encoded into bytes using
 UTF-8. This utility method opens the file for writing, creating the file if
 it does not exist, or overwrites an existing file.

 @param fs the files system with which to create the file
 @param path the path to the file
 @param charseq the char sequence to write to the file

 @return the file system

 @throws NullPointerException if any of the arguments are {@code null}
 @throws IOException if an I/O error occurs creating or writing to the file]]>
      </doc>
    </method>
    <method name="write" return="org.apache.hadoop.fs.FileContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileContext" type="org.apache.hadoop.fs.FileContext"/>
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="charseq" type="java.lang.CharSequence"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a line of text to a file. Characters are encoded into bytes using
 UTF-8. This utility method opens the file for writing, creating the file if
 it does not exist, or overwrites an existing file.

 @param fileContext the files system with which to create the file
 @param path the path to the file
 @param charseq the char sequence to write to the file

 @return the file context

 @throws NullPointerException if any of the arguments are {@code null}
 @throws IOException if an I/O error occurs creating or writing to the file]]>
      </doc>
    </method>
    <field name="SYMLINK_NO_PRIVILEGE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A collection of file-processing util methods]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileUtil -->
  <!-- start class org.apache.hadoop.fs.FilterFileSystem -->
  <class name="FilterFileSystem" extends="org.apache.hadoop.fs.FileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FilterFileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FilterFileSystem" type="org.apache.hadoop.fs.FileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getRawFileSystem" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the raw file system 
 @return FileSystem being filtered]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Called after a new FileSystem instance is constructed.
 @param name a uri whose authority section names the host, port, etc.
   for this FileSystem
 @param conf the configuration]]>
      </doc>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a URI whose scheme and authority identify this FileSystem.]]>
      </doc>
    </method>
    <method name="getCanonicalUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="canonicalizeUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
    </method>
    <method name="makeQualified" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Make sure that a path specifies a FileSystem.]]>
      </doc>
    </method>
    <method name="checkPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Check that a Path belongs to this FileSystem.]]>
      </doc>
    </method>
    <method name="getFileBlockLocations" return="org.apache.hadoop.fs.BlockLocation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.FileStatus"/>
      <param name="start" type="long"/>
      <param name="len" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="resolvePath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataInputStream at the indicated Path.
 @param f the file name to open
 @param bufferSize the size of the buffer to be used.]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fd" type="org.apache.hadoop.fs.PathHandle"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createPathHandle" return="org.apache.hadoop.fs.PathHandle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="stat" type="org.apache.hadoop.fs.FileStatus"/>
      <param name="opts" type="org.apache.hadoop.fs.Options.HandleOpt[]"/>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="concat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="psrcs" type="org.apache.hadoop.fs.Path[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flags" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="checksumOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="listLocatedStatus" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="filter" type="org.apache.hadoop.fs.PathFilter"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createNonRecursive" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flags" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setReplication" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set replication for an existing file.
 
 @param src file name
 @param replication new replication
 @throws IOException raised on errors performing I/O.
 @return true if successful;
         false if file does not exist or is a directory]]>
      </doc>
    </method>
    <method name="rename" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Renames Path src to Path dst.  Can take place on local fs
 or remote DFS.]]>
      </doc>
    </method>
    <method name="rename"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="options" type="org.apache.hadoop.fs.Options.Rename[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="truncate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="newLength" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete a file]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List files in a directory.]]>
      </doc>
    </method>
    <method name="listCorruptFileBlocks" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="listLocatedStatus" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List files and its block locations in a directory.]]>
      </doc>
    </method>
    <method name="listStatusIterator" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a remote iterator for listing in a directory]]>
      </doc>
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setWorkingDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newDir" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Set the current working directory for the given file system. All relative
 paths will be resolved relative to it.
 
 @param newDir new dir.]]>
      </doc>
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current working directory for the given file system
 
 @return the directory pathname]]>
      </doc>
    </method>
    <method name="getInitialWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getStatus" return="org.apache.hadoop.fs.FsStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is on the local disk.  Add it to FS at
 the given dst name.
 delSrc indicates if the source should be removed]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <param name="srcs" type="org.apache.hadoop.fs.Path[]"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src files are on the local disk.  Add it to FS at
 the given dst name.
 delSrc indicates if the source should be removed]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is on the local disk.  Add it to FS at
 the given dst name.
 delSrc indicates if the source should be removed]]>
      </doc>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under FS, and the dst is on the local disk.
 Copy it from FS control to the local dst name.
 delSrc indicates if the src will be removed or not.]]>
      </doc>
    </method>
    <method name="startLocalOutput" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a local File that the user can write output to.  The caller
 provides both the eventual FS target name and the local working
 file.  If the FS is local, we write directly into the target.  If
 the FS is remote, we write into the tmp local area.]]>
      </doc>
    </method>
    <method name="completeLocalOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Called when we're all done writing to the target.  A local FS will
 do nothing, because we've written to exactly the right place.  A remote
 FS will copy the contents of tmpLocalFile to the correct target at
 fsOutputFile.]]>
      </doc>
    </method>
    <method name="getUsed" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the total size of all files in the filesystem.]]>
      </doc>
    </method>
    <method name="getUsed" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the total size of all files from a specified path.]]>
      </doc>
    </method>
    <method name="getDefaultBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDefaultReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getServerDefaults" return="org.apache.hadoop.fs.FsServerDefaults"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getDefaultBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="getDefaultReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="getServerDefaults" return="org.apache.hadoop.fs.FsServerDefaults"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get file status.]]>
      </doc>
    </method>
    <method name="msync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
    </method>
    <method name="access"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="mode" type="org.apache.hadoop.fs.permission.FsAction"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createSymlink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.apache.hadoop.fs.Path"/>
      <param name="link" type="org.apache.hadoop.fs.Path"/>
      <param name="createParent" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileLinkStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="supportsSymlinks" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLinkTarget" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="resolveLink" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileChecksum" return="org.apache.hadoop.fs.FileChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileChecksum" return="org.apache.hadoop.fs.FileChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="length" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setVerifyChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="verifyChecksum" type="boolean"/>
    </method>
    <method name="setWriteChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writeChecksum" type="boolean"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setTimes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="mtime" type="long"/>
      <param name="atime" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="primitiveCreate" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="absolutePermission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flag" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="checksumOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="primitiveMkdir" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="abdolutePermission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getChildFileSystems" return="org.apache.hadoop.fs.FileSystem[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createSnapshot" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="renameSnapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotOldName" type="java.lang.String"/>
      <param name="snapshotNewName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="deleteSnapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="modifyAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeDefaultAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getAclStatus" return="org.apache.hadoop.fs.permission.AclStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <param name="flag" type="java.util.EnumSet"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getXAttr" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="names" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="listXAttrs" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="satisfyStoragePolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setStoragePolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="policyName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="unsetStoragePolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getStoragePolicy" return="org.apache.hadoop.fs.BlockStoragePolicySpi"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getAllStoragePolicies" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getTrashRoot" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="getTrashRoots" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="allUsers" type="boolean"/>
    </method>
    <method name="createFile" return="org.apache.hadoop.fs.FSDataOutputStreamBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="appendFile" return="org.apache.hadoop.fs.FSDataOutputStreamBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="openFile" return="org.apache.hadoop.fs.FutureDataInputStreamBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
    </method>
    <method name="openFile" return="org.apache.hadoop.fs.FutureDataInputStreamBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pathHandle" type="org.apache.hadoop.fs.PathHandle"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
    </method>
    <method name="openFileWithOptions" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="parameters" type="org.apache.hadoop.fs.impl.OpenFileParameters"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="openFileWithOptions" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="pathHandle" type="org.apache.hadoop.fs.PathHandle"/>
      <param name="parameters" type="org.apache.hadoop.fs.impl.OpenFileParameters"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="hasPathCapability" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="capability" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="fs" type="org.apache.hadoop.fs.FileSystem"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="swapScheme" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A <code>FilterFileSystem</code> contains
 some other file system, which it uses as
 its  basic file system, possibly transforming
 the data along the way or providing  additional
 functionality. The class <code>FilterFileSystem</code>
 itself simply overrides all  methods of
 <code>FileSystem</code> with versions that
 pass all requests to the contained  file
 system. Subclasses of <code>FilterFileSystem</code>
 may further override some of  these methods
 and may also provide additional methods
 and fields.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FilterFileSystem -->
  <!-- start interface org.apache.hadoop.fs.FSBuilder -->
  <interface name="FSBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="opt" return="B"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Set optional Builder parameter.
 @param key key.
 @param value value.
 @return generic type B.]]>
      </doc>
    </method>
    <method name="opt" return="B"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Set optional boolean parameter for the Builder.
 @param key key.
 @param value value.
 @return generic type B.
 @see #opt(String, String)]]>
      </doc>
    </method>
    <method name="opt" return="B"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Set optional int parameter for the Builder.

 @param key key.
 @param value value.
 @return generic type B.
 @see #opt(String, String)]]>
      </doc>
    </method>
    <method name="opt" return="B"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Set optional float parameter for the Builder.

 @param key key.
 @param value value.
 @return generic type B.
 @see #opt(String, String)]]>
      </doc>
    </method>
    <method name="opt" return="B"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Set optional long parameter for the Builder.

 @param key key.
 @param value value.
 @return generic type B.
 @see #opt(String, String)]]>
      </doc>
    </method>
    <method name="opt" return="B"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Set optional double parameter for the Builder.

 @param key key.
 @param value value.
 @return generic type B.
 @see #opt(String, String)]]>
      </doc>
    </method>
    <method name="opt" return="B"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="values" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Set an array of string values as optional parameter for the Builder.

 @param key key.
 @param values values.
 @return generic type B.
 @see #opt(String, String)]]>
      </doc>
    </method>
    <method name="must" return="B"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Set mandatory option to the Builder.

 If the option is not supported or unavailable,
 the client should expect {@link #build()} throws IllegalArgumentException.

 @param key key.
 @param value value.
 @return generic type B.]]>
      </doc>
    </method>
    <method name="must" return="B"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Set mandatory boolean option.

 @param key key.
 @param value value.
 @return generic type B.
 @see #must(String, String)]]>
      </doc>
    </method>
    <method name="must" return="B"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Set mandatory int option.

 @param key key.
 @param value value.
 @return generic type B.
 @see #must(String, String)]]>
      </doc>
    </method>
    <method name="must" return="B"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Set mandatory float option.

 @param key key.
 @param value value.
 @return generic type B.
 @see #must(String, String)]]>
      </doc>
    </method>
    <method name="must" return="B"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Set mandatory long option.

 @param key key.
 @param value value.
 @return generic type B.
 @see #must(String, String)]]>
      </doc>
    </method>
    <method name="must" return="B"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Set mandatory double option.

 @param key key.
 @param value value.
 @return generic type B.
 @see #must(String, String)]]>
      </doc>
    </method>
    <method name="must" return="B"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="values" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Set a string array as mandatory option.

 @param key key.
 @param values values.
 @return generic type B.
 @see #must(String, String)]]>
      </doc>
    </method>
    <method name="build" return="S"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Instantiate the object which was being built.

 @throws IllegalArgumentException if the parameters are not valid.
 @throws UnsupportedOperationException if the filesystem does not support
 the specific operation.
 @throws IOException on filesystem IO errors.
 @return generic type S.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The base interface which various FileSystem FileContext Builder
 interfaces can extend, and which underlying implementations
 will then implement.
 @param <S> Return type on the {@link #build()} call.
 @param <B> type of builder itself.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.FSBuilder -->
  <!-- start interface org.apache.hadoop.fs.FsConstants -->
  <interface name="FsConstants"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="LOCAL_FS_URI" type="java.net.URI"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FTP_SCHEME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MAX_PATH_LINKS" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="VIEWFS_URI" type="java.net.URI"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[ViewFs: viewFs file system (ie the mount file system on client side)]]>
      </doc>
    </field>
    <field name="VIEWFS_SCHEME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FS_VIEWFS_OVERLOAD_SCHEME_TARGET_FS_IMPL_PATTERN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="VIEWFS_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[FileSystem related constants.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.FsConstants -->
  <!-- start class org.apache.hadoop.fs.FSDataInputStream -->
  <class name="FSDataInputStream" extends="java.io.DataInputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.Seekable"/>
    <implements name="org.apache.hadoop.fs.PositionedReadable"/>
    <implements name="org.apache.hadoop.fs.ByteBufferReadable"/>
    <implements name="org.apache.hadoop.fs.HasFileDescriptor"/>
    <implements name="org.apache.hadoop.fs.CanSetDropBehind"/>
    <implements name="org.apache.hadoop.fs.CanSetReadahead"/>
    <implements name="org.apache.hadoop.fs.HasEnhancedByteBufferAccess"/>
    <implements name="org.apache.hadoop.fs.CanUnbuffer"/>
    <implements name="org.apache.hadoop.fs.StreamCapabilities"/>
    <implements name="org.apache.hadoop.fs.ByteBufferPositionedReadable"/>
    <implements name="org.apache.hadoop.fs.statistics.IOStatisticsSource"/>
    <constructor name="FSDataInputStream" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="seek"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="desired" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Seek to the given offset.

 @param desired offset to seek to]]>
      </doc>
    </method>
    <method name="getPos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the current position in the input stream.

 @return current position in the input stream]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read bytes from the given position in the stream to the given buffer.

 @param position  position in the input stream to seek
 @param buffer    buffer into which data is read
 @param offset    offset into the buffer in which data is written
 @param length    maximum number of bytes to read
 @return total number of bytes read into the buffer, or <code>-1</code>
         if there is no more data because the end of the stream has been
         reached]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read bytes from the given position in the stream to the given buffer.
 Continues to read until <code>length</code> bytes have been read.

 @param position  position in the input stream to seek
 @param buffer    buffer into which data is read
 @param offset    offset into the buffer in which data is written
 @param length    the number of bytes to read
 @throws IOException IO problems
 @throws EOFException If the end of stream is reached while reading.
                      If an exception is thrown an undetermined number
                      of bytes in the buffer may have been written.]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[See {@link #readFully(long, byte[], int, int)}.]]>
      </doc>
    </method>
    <method name="seekToNewSource" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetPos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Seek to the given position on an alternate copy of the data.

 @param  targetPos  position to seek to
 @return true if a new source is found, false otherwise]]>
      </doc>
    </method>
    <method name="getWrappedStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a reference to the wrapped input stream. Used by unit tests.

 @return the underlying input stream]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileDescriptor" return="java.io.FileDescriptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setReadahead"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readahead" type="java.lang.Long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
    </method>
    <method name="setDropBehind"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dropBehind" type="java.lang.Boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
    </method>
    <method name="read" return="java.nio.ByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bufferPool" type="org.apache.hadoop.io.ByteBufferPool"/>
      <param name="maxLength" type="int"/>
      <param name="opts" type="java.util.EnumSet"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
    </method>
    <method name="read" return="java.nio.ByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="bufferPool" type="org.apache.hadoop.io.ByteBufferPool"/>
      <param name="maxLength" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
    </method>
    <method name="releaseBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buffer" type="java.nio.ByteBuffer"/>
    </method>
    <method name="unbuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasCapability" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="capability" type="java.lang.String"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[String value. Includes the string value of the inner stream
 @return the stream]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buf" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buf" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getIOStatistics" return="org.apache.hadoop.fs.statistics.IOStatistics"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the IO Statistics of the nested stream, falling back to
 null if the stream does not implement the interface
 {@link IOStatisticsSource}.
 @return an IOStatistics instance or null]]>
      </doc>
    </method>
    <method name="minSeekForVectorReads" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="maxReadSizeForVectorReads" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readVectored"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ranges" type="java.util.List"/>
      <param name="allocate" type="java.util.function.IntFunction"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Utility that wraps a {@link FSInputStream} in a {@link DataInputStream}
 and buffers input through a {@link java.io.BufferedInputStream}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FSDataInputStream -->
  <!-- start class org.apache.hadoop.fs.FSDataOutputStream -->
  <class name="FSDataOutputStream" extends="java.io.DataOutputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.Syncable"/>
    <implements name="org.apache.hadoop.fs.CanSetDropBehind"/>
    <implements name="org.apache.hadoop.fs.StreamCapabilities"/>
    <implements name="org.apache.hadoop.fs.statistics.IOStatisticsSource"/>
    <implements name="org.apache.hadoop.fs.Abortable"/>
    <constructor name="FSDataOutputStream" type="java.io.OutputStream, org.apache.hadoop.fs.FileSystem.Statistics"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FSDataOutputStream" type="java.io.OutputStream, org.apache.hadoop.fs.FileSystem.Statistics, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current position in the output stream.

 @return the current position in the output stream]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close the underlying output stream.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasCapability" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="capability" type="java.lang.String"/>
    </method>
    <method name="hflush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="hsync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setDropBehind"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dropBehind" type="java.lang.Boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getIOStatistics" return="org.apache.hadoop.fs.statistics.IOStatistics"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the IO Statistics of the nested stream, falling back to
 empty statistics if the stream does not implement the interface
 {@link IOStatisticsSource}.
 @return an IOStatistics instance.]]>
      </doc>
    </method>
    <method name="abort" return="org.apache.hadoop.fs.Abortable.AbortableResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Invoke {@code abort()} on the wrapped stream if it
 is Abortable, otherwise raise an
 {@code UnsupportedOperationException}.
 @throws UnsupportedOperationException if not available.
 @return the result.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility that wraps a {@link OutputStream} in a {@link DataOutputStream}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FSDataOutputStream -->
  <!-- start class org.apache.hadoop.fs.FSDataOutputStreamBuilder -->
  <class name="FSDataOutputStreamBuilder" extends="org.apache.hadoop.fs.impl.AbstractFSBuilderImpl"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FSDataOutputStreamBuilder" type="org.apache.hadoop.fs.FileSystem, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor.

 @param fileSystem file system.
 @param p the path.]]>
      </doc>
    </constructor>
    <method name="getThisBuilder" return="B"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the concrete implementation of the builder instance.]]>
      </doc>
    </method>
    <method name="getFS" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getPermission" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="permission" return="B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <doc>
      <![CDATA[Set permission for the file.

 @param perm permission.
 @return B Generics Type.]]>
      </doc>
    </method>
    <method name="getBufferSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="bufferSize" return="B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bufSize" type="int"/>
      <doc>
      <![CDATA[Set the size of the buffer to be used.

 @param bufSize buffer size.
 @return Generics Type B.]]>
      </doc>
    </method>
    <method name="getReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="replication" return="B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="replica" type="short"/>
      <doc>
      <![CDATA[Set replication factor.

 @param replica replica.
 @return Generics Type B.]]>
      </doc>
    </method>
    <method name="getBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="blockSize" return="B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="blkSize" type="long"/>
      <doc>
      <![CDATA[Set block size.

 @param blkSize block size.
 @return B Generics Type.]]>
      </doc>
    </method>
    <method name="isRecursive" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return true to create the parent directories if they do not exist.

 @return if create the parent directories if they do not exist true,not false.]]>
      </doc>
    </method>
    <method name="recursive" return="B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create the parent directory if they do not exist.

 @return B Generics Type.]]>
      </doc>
    </method>
    <method name="getProgress" return="org.apache.hadoop.util.Progressable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="progress" return="B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prog" type="org.apache.hadoop.util.Progressable"/>
      <doc>
      <![CDATA[Set the facility of reporting progress.

 @param prog progress.
 @return B Generics Type.]]>
      </doc>
    </method>
    <method name="getFlags" return="java.util.EnumSet"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="create" return="B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an FSDataOutputStream at the specified path.

 @return return Generics Type B.]]>
      </doc>
    </method>
    <method name="overwrite" return="B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="overwrite" type="boolean"/>
      <doc>
      <![CDATA[Set to true to overwrite the existing file.
 Set it to false, an exception will be thrown when calling {@link #build()}
 if the file exists.

 @param overwrite overrite.
 @return Generics Type B.]]>
      </doc>
    </method>
    <method name="append" return="B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Append to an existing file (optional operation).

 @return Generics Type B.]]>
      </doc>
    </method>
    <method name="getChecksumOpt" return="org.apache.hadoop.fs.Options.ChecksumOpt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="checksumOpt" return="B"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="chksumOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
      <doc>
      <![CDATA[Set checksum opt.

 @param chksumOpt check sum opt.
 @return Generics Type B.]]>
      </doc>
    </method>
    <method name="build" return="S"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the FSDataOutputStream to write on the file system.

 @throws IllegalArgumentException if the parameters are not valid.
 @throws IOException on errors when file system creates or appends the file.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Builder for {@link FSDataOutputStream} and its subclasses.

 It is used to create {@link FSDataOutputStream} when creating a new file or
 appending an existing file on {@link FileSystem}.

 By default, it does not create parent directory that do not exist.
 {@link FileSystem#createNonRecursive(Path, boolean, int, short, long,
 Progressable)}.

 To create missing parent directory, use {@link #recursive()}.

 To be more generic, {@link #opt(String, int)} and {@link #must(String, int)}
 variants provide implementation-agnostic way to customize the builder.
 Each FS-specific builder implementation can interpret the FS-specific
 options accordingly, for example:

 <code>

 // Don't
 if (fs instanceof FooFileSystem) {
   FooFileSystem fs = (FooFileSystem) fs;
   OutputStream out = dfs.createFile(path)
     .optionA()
     .optionB("value")
     .cache()
   .build()
 } else if (fs instanceof BarFileSystem) {
   ...
 }

 // Do
 OutputStream out = fs.createFile(path)
   .permission(perm)
   .bufferSize(bufSize)
   .opt("foofs:option.a", true)
   .opt("foofs:option.b", "value")
   .opt("barfs:cache", true)
   .must("foofs:cache", true)
   .must("barfs:cache-size", 256 * 1024 * 1024)
   .build();
 </code>

 If the option is not related to the file system, the option will be ignored.
 If the option is must, but not supported by the file system, a
 {@link IllegalArgumentException} will be thrown.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FSDataOutputStreamBuilder -->
  <!-- start class org.apache.hadoop.fs.FSError -->
  <class name="FSError" extends="java.lang.Error"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Thrown for unexpected filesystem errors, presumed to reflect disk errors
 in the native filesystem.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FSError -->
  <!-- start class org.apache.hadoop.fs.FSInputStream -->
  <class name="FSInputStream" extends="java.io.InputStream"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.Seekable"/>
    <implements name="org.apache.hadoop.fs.PositionedReadable"/>
    <constructor name="FSInputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="seek"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Seek to the given offset from the start of the file.
 The next read() will be from that location.  Can't
 seek past the end of the file.]]>
      </doc>
    </method>
    <method name="getPos" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the current offset from the start of the file]]>
      </doc>
    </method>
    <method name="seekToNewSource" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetPos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Seeks a different copy of the data.  Returns true if 
 found a new source, false otherwise.]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="validatePositionedReadArgs"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="EOFException" type="java.io.EOFException"/>
      <doc>
      <![CDATA[Validation code, available for use in subclasses.
 @param position position: if negative an EOF exception is raised
 @param buffer destination buffer
 @param offset offset within the buffer
 @param length length of bytes to read
 @throws EOFException if the position is negative
 @throws IndexOutOfBoundsException if there isn't space for the amount of
 data requested.
 @throws IllegalArgumentException other arguments are invalid.]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[toString method returns the superclass toString, but if the subclass
 implements {@link IOStatisticsSource} then those statistics are
 extracted and included in the output.
 That is: statistics of subclasses are automatically reported.
 @return a string value.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[FSInputStream is a generic old InputStream with a little bit
 of RAF-style seek ability.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FSInputStream -->
  <!-- start class org.apache.hadoop.fs.FsServerDefaults -->
  <class name="FsServerDefaults" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="FsServerDefaults"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FsServerDefaults" type="long, int, int, short, int, boolean, long, org.apache.hadoop.util.DataChecksum.Type"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FsServerDefaults" type="long, int, int, short, int, boolean, long, org.apache.hadoop.util.DataChecksum.Type, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FsServerDefaults" type="long, int, int, short, int, boolean, long, org.apache.hadoop.util.DataChecksum.Type, java.lang.String, byte"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBytesPerChecksum" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getWritePacketSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFileBufferSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEncryptDataTransfer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTrashInterval" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getChecksumType" return="org.apache.hadoop.util.DataChecksum.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKeyProviderUri" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDefaultStoragePolicyId" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Provides server default configuration values to clients.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FsServerDefaults -->
  <!-- start class org.apache.hadoop.fs.FsStatus -->
  <class name="FsStatus" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="FsStatus" type="long, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a FsStatus object, using the specified statistics.

 @param capacity capacity.
 @param used used.
 @param remaining remaining.]]>
      </doc>
    </constructor>
    <method name="getCapacity" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the capacity in bytes of the file system.
 @return capacity.]]>
      </doc>
    </method>
    <method name="getUsed" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the number of bytes used on the file system.
 @return used.]]>
      </doc>
    </method>
    <method name="getRemaining" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the number of remaining bytes on the file system.
 @return remaining.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[This class is used to represent the capacity, free and used space on a
 {@link FileSystem}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FsStatus -->
  <!-- start interface org.apache.hadoop.fs.FutureDataInputStreamBuilder -->
  <interface name="FutureDataInputStreamBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.FSBuilder"/>
    <method name="build" return="java.util.concurrent.CompletableFuture"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="withFileStatus" return="org.apache.hadoop.fs.FutureDataInputStreamBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="status" type="org.apache.hadoop.fs.FileStatus"/>
      <doc>
      <![CDATA[A FileStatus may be provided to the open request.
 It is up to the implementation whether to use this or not.
 @param status status: may be null
 @return the builder.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Builder for input streams and subclasses whose return value is
 actually a completable future: this allows for better asynchronous
 operation.

 To be more generic, {@link #opt(String, int)} and {@link #must(String, int)}
 variants provide implementation-agnostic way to customize the builder.
 Each FS-specific builder implementation can interpret the FS-specific
 options accordingly, for example:

 If the option is not related to the file system, the option will be ignored.
 If the option is must, but not supported/known by the file system, an
 {@link IllegalArgumentException} will be thrown.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.FutureDataInputStreamBuilder -->
  <!-- start class org.apache.hadoop.fs.GlobalStorageStatistics -->
  <class name="GlobalStorageStatistics" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.fs.GlobalStorageStatistics[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.fs.GlobalStorageStatistics"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="get" return="org.apache.hadoop.fs.StorageStatistics"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the StorageStatistics object with the given name.

 @param name        The storage statistics object name.
 @return            The StorageStatistics object with the given name, or
                      null if there is none.]]>
      </doc>
    </method>
    <method name="put" return="org.apache.hadoop.fs.StorageStatistics"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="provider" type="org.apache.hadoop.fs.GlobalStorageStatistics.StorageStatisticsProvider"/>
      <doc>
      <![CDATA[Create or return the StorageStatistics object with the given name.

 @param name        The storage statistics object name.
 @param provider    An object which can create a new StorageStatistics
                      object if needed.
 @return            The StorageStatistics object with the given name.
 @throws RuntimeException  If the StorageStatisticsProvider provides a null
                           object or a new StorageStatistics object with the
                           wrong name.]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reset all global storage statistics.]]>
      </doc>
    </method>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an iterator that we can use to iterate throw all the global storage
 statistics objects.

 @return StorageStatistics Iterator.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Stores global storage statistics objects.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.GlobalStorageStatistics -->
  <!-- start class org.apache.hadoop.fs.GlobFilter -->
  <class name="GlobFilter" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.PathFilter"/>
    <constructor name="GlobFilter" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates a glob filter with the specified file pattern.

 @param filePattern the file pattern.
 @throws IOException thrown if the file pattern is incorrect.]]>
      </doc>
    </constructor>
    <constructor name="GlobFilter" type="java.lang.String, org.apache.hadoop.fs.PathFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates a glob filter with the specified file pattern and an user filter.

 @param filePattern the file pattern.
 @param filter user filter in addition to the glob pattern.
 @throws IOException thrown if the file pattern is incorrect.]]>
      </doc>
    </constructor>
    <method name="hasPattern" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="accept" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
    </method>
    <doc>
    <![CDATA[A filter for POSIX glob pattern with brace expansions.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.GlobFilter -->
  <!-- start class org.apache.hadoop.fs.InvalidPathException -->
  <class name="InvalidPathException" extends="org.apache.hadoop.HadoopIllegalArgumentException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvalidPathException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs exception with the specified detail message.
 
 @param path invalid path.]]>
      </doc>
    </constructor>
    <constructor name="InvalidPathException" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs exception with the specified detail message.
 
 @param path invalid path.
 @param reason Reason <code>path</code> is invalid]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Path string is invalid either because it has invalid characters or due to
 other file system specific reasons.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.InvalidPathException -->
  <!-- start class org.apache.hadoop.fs.InvalidPathHandleException -->
  <class name="InvalidPathHandleException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvalidPathHandleException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="InvalidPathHandleException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Thrown when the constraints enoded in a {@link PathHandle} do not hold.
 For example, if a handle were created with the default
 {@link Options.HandleOpt#path()} constraints, a call to
 {@link FileSystem#open(PathHandle)} would succeed if the file were
 modified, but if a different file was at that location then it would throw
 this exception.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.InvalidPathHandleException -->
  <!-- start class org.apache.hadoop.fs.LocalFileSystem -->
  <class name="LocalFileSystem" extends="org.apache.hadoop.fs.ChecksumFileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LocalFileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LocalFileSystem" type="org.apache.hadoop.fs.FileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getScheme" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the protocol scheme for the FileSystem.
 <p>

 @return <code>file</code>]]>
      </doc>
    </method>
    <method name="getRaw" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pathToFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Convert a path to a File.
 @param path the path.
 @return file.]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="reportChecksumFailure" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="in" type="org.apache.hadoop.fs.FSDataInputStream"/>
      <param name="inPos" type="long"/>
      <param name="sums" type="org.apache.hadoop.fs.FSDataInputStream"/>
      <param name="sumsPos" type="long"/>
      <doc>
      <![CDATA[Moves files to a bad file directory on the same device, so that their
 storage will not be reused.]]>
      </doc>
    </method>
    <method name="supportsSymlinks" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createSymlink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.apache.hadoop.fs.Path"/>
      <param name="link" type="org.apache.hadoop.fs.Path"/>
      <param name="createParent" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileLinkStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getLinkTarget" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Implement the FileSystem API for the checksumed local filesystem.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.LocalFileSystem -->
  <!-- start class org.apache.hadoop.fs.LocatedFileStatus -->
  <class name="LocatedFileStatus" extends="org.apache.hadoop.fs.FileStatus"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LocatedFileStatus"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LocatedFileStatus" type="org.apache.hadoop.fs.FileStatus, org.apache.hadoop.fs.BlockLocation[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor 
 @param stat a file status
 @param locations a file's block locations]]>
      </doc>
    </constructor>
    <constructor name="LocatedFileStatus" type="long, boolean, int, long, long, long, org.apache.hadoop.fs.permission.FsPermission, java.lang.String, java.lang.String, org.apache.hadoop.fs.Path, org.apache.hadoop.fs.Path, org.apache.hadoop.fs.BlockLocation[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor
 
 @param length a file's length
 @param isdir if the path is a directory
 @param block_replication the file's replication factor
 @param blocksize a file's block size
 @param modification_time a file's modification time
 @param access_time a file's access time
 @param permission a file's permission
 @param owner a file's owner
 @param group a file's group
 @param symlink symlink if the path is a symbolic link
 @param path the path's qualified name
 @param locations a file's block locations]]>
      </doc>
    </constructor>
    <constructor name="LocatedFileStatus" type="long, boolean, int, long, long, long, org.apache.hadoop.fs.permission.FsPermission, java.lang.String, java.lang.String, org.apache.hadoop.fs.Path, org.apache.hadoop.fs.Path, boolean, boolean, boolean, org.apache.hadoop.fs.BlockLocation[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor.

 @param length a file's length
 @param isdir if the path is a directory
 @param block_replication the file's replication factor
 @param blocksize a file's block size
 @param modification_time a file's modification time
 @param access_time a file's access time
 @param permission a file's permission
 @param owner a file's owner
 @param group a file's group
 @param symlink symlink if the path is a symbolic link
 @param path the path's qualified name
 @param hasAcl entity has associated ACLs
 @param isEncrypted entity is encrypted
 @param isErasureCoded entity is erasure coded
 @param locations a file's block locations]]>
      </doc>
    </constructor>
    <constructor name="LocatedFileStatus" type="long, boolean, int, long, long, long, org.apache.hadoop.fs.permission.FsPermission, java.lang.String, java.lang.String, org.apache.hadoop.fs.Path, org.apache.hadoop.fs.Path, java.util.Set, org.apache.hadoop.fs.BlockLocation[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor.

 @param length a file's length
 @param isdir if the path is a directory
 @param block_replication the file's replication factor
 @param blocksize a file's block size
 @param modification_time a file's modification time
 @param access_time a file's access time
 @param permission a file's permission
 @param owner a file's owner
 @param group a file's group
 @param symlink symlink if the path is a symbolic link
 @param path the path's qualified name
 @param attr Attribute flags (See {@link FileStatus.AttrFlags}).
 @param locations a file's block locations]]>
      </doc>
    </constructor>
    <method name="getBlockLocations" return="org.apache.hadoop.fs.BlockLocation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the file's block locations

 In HDFS, the returned BlockLocation will have different formats for
 replicated and erasure coded file.
 Please refer to
 {@link FileSystem#getFileBlockLocations(FileStatus, long, long)}
 for more details.

 @return the file's block locations]]>
      </doc>
    </method>
    <method name="setBlockLocations"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="locations" type="org.apache.hadoop.fs.BlockLocation[]"/>
      <doc>
      <![CDATA[Hook for subclasses to lazily set block locations. The {@link #locations}
 field should be null before this is called.
 @param locations Block locations for this instance.]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.fs.FileStatus"/>
      <doc>
      <![CDATA[Compare this FileStatus to another FileStatus
 @param   o the FileStatus to be compared.
 @return  a negative integer, zero, or a positive integer as this object
   is less than, equal to, or greater than the specified object.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compare if this object is equal to another object
 @param   o the object to be compared.
 @return  true if two file status has the same path name; false if not.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash code value for the object, which is defined as
 the hash code of the path name.

 @return  a hash code value for the path name.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class defines a FileStatus that includes a file's block locations.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.LocatedFileStatus -->
  <!-- start interface org.apache.hadoop.fs.MultipartUploader -->
  <interface name="MultipartUploader"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <implements name="org.apache.hadoop.fs.statistics.IOStatisticsSource"/>
    <method name="startUpload" return="java.util.concurrent.CompletableFuture"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filePath" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Initialize a multipart upload.
 @param filePath Target path for upload.
 @return unique identifier associating part uploads.
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="putPart" return="java.util.concurrent.CompletableFuture"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uploadId" type="org.apache.hadoop.fs.UploadHandle"/>
      <param name="partNumber" type="int"/>
      <param name="filePath" type="org.apache.hadoop.fs.Path"/>
      <param name="inputStream" type="java.io.InputStream"/>
      <param name="lengthInBytes" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Put part as part of a multipart upload.
 It is possible to have parts uploaded in any order (or in parallel).
 @param uploadId Identifier from {@link #startUpload(Path)}.
 @param partNumber Index of the part relative to others.
 @param filePath Target path for upload (as {@link #startUpload(Path)}).
 @param inputStream Data for this part. Implementations MUST close this
 stream after reading in the data.
 @param lengthInBytes Target length to read from the stream.
 @return unique PartHandle identifier for the uploaded part.
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="complete" return="java.util.concurrent.CompletableFuture"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uploadId" type="org.apache.hadoop.fs.UploadHandle"/>
      <param name="filePath" type="org.apache.hadoop.fs.Path"/>
      <param name="handles" type="java.util.Map"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Complete a multipart upload.
 @param uploadId Identifier from {@link #startUpload(Path)}.
 @param filePath Target path for upload (as {@link #startUpload(Path)}.
 @param handles non-empty map of part number to part handle.
          from {@link #putPart(UploadHandle, int, Path, InputStream, long)}.
 @return unique PathHandle identifier for the uploaded file.
 @throws IOException IO failure]]>
      </doc>
    </method>
    <method name="abort" return="java.util.concurrent.CompletableFuture"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uploadId" type="org.apache.hadoop.fs.UploadHandle"/>
      <param name="filePath" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Aborts a multipart upload.
 @param uploadId Identifier from {@link #startUpload(Path)}.
 @param filePath Target path for upload (same as {@link #startUpload(Path)}.
 @throws IOException IO failure
 @return a future; the operation will have completed]]>
      </doc>
    </method>
    <method name="abortUploadsUnderPath" return="java.util.concurrent.CompletableFuture"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Best effort attempt to aborts multipart uploads under a path.
 Not all implementations support this, and those which do may
 be vulnerable to eventually consistent listings of current uploads
 -some may be missed.
 @param path path to abort uploads under.
 @return a future to the number of entries aborted;
 -1 if aborting is unsupported
 @throws IOException IO failure]]>
      </doc>
    </method>
    <doc>
    <![CDATA[MultipartUploader is an interface for copying files multipart and across
 multiple nodes.
 <p>
 The interface extends {@link IOStatisticsSource} so that there is no
 need to cast an instance to see if is a source of statistics.
 However, implementations MAY return null for their actual statistics.
 </p>]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.MultipartUploader -->
  <!-- start class org.apache.hadoop.fs.Options -->
  <class name="Options" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[This class contains options related to file system operations.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.Options -->
  <!-- start class org.apache.hadoop.fs.Options.OpenFileOptions -->
  <class name="Options.OpenFileOptions" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="FS_OPTION_OPENFILE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Prefix for all openFile options: {@value}.]]>
      </doc>
    </field>
    <field name="FS_OPTION_OPENFILE_LENGTH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[OpenFile option for file length: {@value}.]]>
      </doc>
    </field>
    <field name="FS_OPTION_OPENFILE_SPLIT_START" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[OpenFile option for split start: {@value}.]]>
      </doc>
    </field>
    <field name="FS_OPTION_OPENFILE_SPLIT_END" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[OpenFile option for split end: {@value}.]]>
      </doc>
    </field>
    <field name="FS_OPTION_OPENFILE_BUFFER_SIZE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[OpenFile option for buffer size: {@value}.]]>
      </doc>
    </field>
    <field name="FS_OPTION_OPENFILE_READ_POLICY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[OpenFile option for read policies: {@value}.]]>
      </doc>
    </field>
    <field name="FS_OPTION_OPENFILE_STANDARD_OPTIONS" type="java.util.Set"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Set of standard options which openFile implementations
 MUST recognize, even if they ignore the actual values.]]>
      </doc>
    </field>
    <field name="FS_OPTION_OPENFILE_READ_POLICY_ADAPTIVE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Read policy for adaptive IO: {@value}.]]>
      </doc>
    </field>
    <field name="FS_OPTION_OPENFILE_READ_POLICY_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Read policy {@value} -whateve the implementation does by default.]]>
      </doc>
    </field>
    <field name="FS_OPTION_OPENFILE_READ_POLICY_RANDOM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Read policy for random IO: {@value}.]]>
      </doc>
    </field>
    <field name="FS_OPTION_OPENFILE_READ_POLICY_SEQUENTIAL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Read policy for sequential IO: {@value}.]]>
      </doc>
    </field>
    <field name="FS_OPTION_OPENFILE_READ_POLICY_VECTOR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Vectored IO API to be used: {@value}.]]>
      </doc>
    </field>
    <field name="FS_OPTION_OPENFILE_READ_POLICY_WHOLE_FILE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whole file to be read, end-to-end: {@value}.]]>
      </doc>
    </field>
    <field name="FS_OPTION_OPENFILE_READ_POLICIES" type="java.util.Set"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[All the current read policies as a set.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[The standard {@code openFile()} options.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.Options.OpenFileOptions -->
  <!-- start class org.apache.hadoop.fs.ParentNotDirectoryException -->
  <class name="ParentNotDirectoryException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ParentNotDirectoryException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ParentNotDirectoryException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Indicates that the parent of specified Path is not a directory
 as expected.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ParentNotDirectoryException -->
  <!-- start interface org.apache.hadoop.fs.PartHandle -->
  <interface name="PartHandle"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Serialized from in bytes.]]>
      </doc>
    </method>
    <method name="bytes" return="java.nio.ByteBuffer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[Opaque, serializable reference to a part id for multipart uploads.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.PartHandle -->
  <!-- start class org.apache.hadoop.fs.PartialListing -->
  <class name="PartialListing" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PartialListing" type="org.apache.hadoop.fs.Path, java.util.List"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PartialListing" type="org.apache.hadoop.fs.Path, org.apache.hadoop.ipc.RemoteException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Partial listing of the path being listed. In the case where the path is
 a file. The list will be a singleton with the file itself.

 @return Partial listing of the path being listed.
 @throws IOException if there was an exception getting the listing.]]>
      </doc>
    </method>
    <method name="getListedPath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Path being listed.

 @return the path being listed.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 A partial listing of the children of a parent directory. Since it is a
 partial listing, multiple PartialListing may need to be combined to obtain
 the full listing of a parent directory.
 </p>
 ListingBatch behaves similar to a Future, in that getting the result via
 {@link #get()} will throw an Exception if there was a failure.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.PartialListing -->
  <!-- start class org.apache.hadoop.fs.Path -->
  <class name="Path" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <implements name="java.io.Serializable"/>
    <implements name="java.io.ObjectInputValidation"/>
    <constructor name="Path" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new Path based on the child path resolved against the parent path.

 @param parent the parent path
 @param child the child path]]>
      </doc>
    </constructor>
    <constructor name="Path" type="org.apache.hadoop.fs.Path, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new Path based on the child path resolved against the parent path.

 @param parent the parent path
 @param child the child path]]>
      </doc>
    </constructor>
    <constructor name="Path" type="java.lang.String, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new Path based on the child path resolved against the parent path.

 @param parent the parent path
 @param child the child path]]>
      </doc>
    </constructor>
    <constructor name="Path" type="org.apache.hadoop.fs.Path, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new Path based on the child path resolved against the parent path.

 @param parent the parent path
 @param child the child path]]>
      </doc>
    </constructor>
    <constructor name="Path" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Construct a path from a String.  Path strings are URIs, but with
 unescaped elements and some additional normalization.

 @param pathString the path string]]>
      </doc>
    </constructor>
    <constructor name="Path" type="java.net.URI"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a path from a URI

 @param aUri the source URI]]>
      </doc>
    </constructor>
    <constructor name="Path" type="java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a Path from components.

 @param scheme the scheme
 @param authority the authority
 @param path the path]]>
      </doc>
    </constructor>
    <method name="getPathWithoutSchemeAndAuthority" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Return a version of the given Path without the scheme information.

 @param path the source Path
 @return a copy of this Path without the scheme information]]>
      </doc>
    </method>
    <method name="mergePaths" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path1" type="org.apache.hadoop.fs.Path"/>
      <param name="path2" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Merge 2 paths such that the second path is appended relative to the first.
 The returned path has the scheme and authority of the first path.  On
 Windows, the drive specification in the second path is discarded.
 
 @param path1 the first path
 @param path2 the second path, to be appended relative to path1
 @return the merged path]]>
      </doc>
    </method>
    <method name="isWindowsAbsolutePath" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pathString" type="java.lang.String"/>
      <param name="slashed" type="boolean"/>
      <doc>
      <![CDATA[Determine whether a given path string represents an absolute path on
 Windows. e.g. "C:/a/b" is an absolute path. "C:a/b" is not.

 @param pathString the path string to evaluate
 @param slashed true if the given path is prefixed with "/"
 @return true if the supplied path looks like an absolute path with a Windows
 drive-specifier]]>
      </doc>
    </method>
    <method name="toUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Convert this Path to a URI.

 @return this Path as a URI]]>
      </doc>
    </method>
    <method name="getFileSystem" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the FileSystem that owns this Path.

 @param conf the configuration to use when resolving the FileSystem
 @return the FileSystem that owns this Path
 @throws java.io.IOException thrown if there's an issue resolving the
 FileSystem]]>
      </doc>
    </method>
    <method name="isAbsoluteAndSchemeAuthorityNull" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the path component (i.e. directory) of this URI is
 absolute <strong>and</strong> the scheme is null, <b>and</b> the authority
 is null.

 @return whether the path is absolute and the URI has no scheme nor
 authority parts]]>
      </doc>
    </method>
    <method name="isUriPathAbsolute" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the path component (i.e. directory) of this URI is
 absolute.

 @return whether this URI's path is absolute]]>
      </doc>
    </method>
    <method name="isAbsolute" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the path component (i.e. directory) of this URI is
 absolute.  This method is a wrapper for {@link #isUriPathAbsolute()}.

 @return whether this URI's path is absolute]]>
      </doc>
    </method>
    <method name="isRoot" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if and only if this path represents the root of a file system.

 @return true if and only if this path represents the root of a file system]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the final component of this path.

 @return the final component of this path]]>
      </doc>
    </method>
    <method name="getParent" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the parent of a path or null if at root.
 @return the parent of a path or null if at root]]>
      </doc>
    </method>
    <method name="suffix" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="suffix" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds a suffix to the final name in the path.

 @param suffix the suffix to add
 @return a new path with the suffix added]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="depth" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of elements in this path.
 @return the number of elements in this path]]>
      </doc>
    </method>
    <method name="makeQualified" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #makeQualified(URI, Path)}">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <doc>
      <![CDATA[Returns a qualified path object for the {@link FileSystem}'s working
 directory.
  
 @param fs the target FileSystem
 @return a qualified path object for the FileSystem's working directory
 @deprecated use {@link #makeQualified(URI, Path)}]]>
      </doc>
    </method>
    <method name="validateObject"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InvalidObjectException" type="java.io.InvalidObjectException"/>
      <doc>
      <![CDATA[Validate the contents of a deserialized Path, so as
 to defend against malicious object streams.
 @throws InvalidObjectException if there's no URI]]>
      </doc>
    </method>
    <field name="SEPARATOR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The directory separator, a slash.]]>
      </doc>
    </field>
    <field name="SEPARATOR_CHAR" type="char"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The directory separator, a slash, as a character.]]>
      </doc>
    </field>
    <field name="CUR_DIR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The current directory, ".".]]>
      </doc>
    </field>
    <field name="WINDOWS" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether the current host is a Windows machine.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Names a file or directory in a {@link FileSystem}.
 Path strings use slash as the directory separator.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.Path -->
  <!-- start interface org.apache.hadoop.fs.PathFilter -->
  <interface name="PathFilter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="accept" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Tests whether or not the specified abstract pathname should be
 included in a pathname list.

 @param  path  The abstract pathname to be tested
 @return  <code>true</code> if and only if <code>pathname</code>
          should be included]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.fs.PathFilter -->
  <!-- start interface org.apache.hadoop.fs.PathHandle -->
  <interface name="PathHandle"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Serialized form in bytes.]]>
      </doc>
    </method>
    <method name="bytes" return="java.nio.ByteBuffer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the bytes of this path handle.
 @return the bytes to get to the process completing the upload.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[Opaque, serializable reference to an entity in the FileSystem. May contain
 metadata sufficient to resolve or verify subsequent accesses independent of
 other modifications to the FileSystem.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.PathHandle -->
  <!-- start interface org.apache.hadoop.fs.PositionedReadable -->
  <interface name="PositionedReadable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="read" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read up to the specified number of bytes, from a given
 position within a file, and return the number of bytes read. This does not
 change the current offset of a file, and is thread-safe.

 <i>Warning: Not all filesystems satisfy the thread-safety requirement.</i>
 @param position position within file
 @param buffer destination buffer
 @param offset offset in the buffer
 @param length number of bytes to read
 @return actual number of bytes read; -1 means "none"
 @throws IOException IO problems.]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read the specified number of bytes, from a given
 position within a file. This does not
 change the current offset of a file, and is thread-safe.

 <i>Warning: Not all filesystems satisfy the thread-safety requirement.</i>
 @param position position within file
 @param buffer destination buffer
 @param offset offset in the buffer
 @param length number of bytes to read
 @throws IOException IO problems.
 @throws EOFException the end of the data was reached before
 the read operation completed]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read number of bytes equal to the length of the buffer, from a given
 position within a file. This does not
 change the current offset of a file, and is thread-safe.

 <i>Warning: Not all filesystems satisfy the thread-safety requirement.</i>
 @param position position within file
 @param buffer destination buffer
 @throws IOException IO problems.
 @throws EOFException the end of the data was reached before
 the read operation completed]]>
      </doc>
    </method>
    <method name="minSeekForVectorReads" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[What is the smallest reasonable seek?
 @return the minimum number of bytes]]>
      </doc>
    </method>
    <method name="maxReadSizeForVectorReads" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[What is the largest size that we should group ranges together as?
 @return the number of bytes to read at once]]>
      </doc>
    </method>
    <method name="readVectored"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ranges" type="java.util.List"/>
      <param name="allocate" type="java.util.function.IntFunction"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read fully a list of file ranges asynchronously from this file.
 The default iterates through the ranges to read each synchronously, but
 the intent is that FSDataInputStream subclasses can make more efficient
 readers.
 As a result of the call, each range will have FileRange.setData(CompletableFuture)
 called with a future that when complete will have a ByteBuffer with the
 data from the file's range.
 <p>
   The position returned by getPos() after readVectored() is undefined.
 </p>
 <p>
   If a file is changed while the readVectored() operation is in progress, the output is
   undefined. Some ranges may have old data, some may have new and some may have both.
 </p>
 <p>
   While a readVectored() operation is in progress, normal read api calls may block.
 </p>
 @param ranges the byte ranges to read
 @param allocate the function to allocate ByteBuffer
 @throws IOException any IOE.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Stream that permits positional reading.

 Implementations are required to implement thread-safe operations; this may
 be supported by concurrent access to the data, or by using a synchronization
 mechanism to serialize access.

 Not all implementations meet this requirement. Those that do not cannot
 be used as a backing store for some applications, such as Apache HBase.

 Independent of whether or not they are thread safe, some implementations
 may make the intermediate state of the system, specifically the position
 obtained in {@code Seekable.getPos()} visible.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.PositionedReadable -->
  <!-- start class org.apache.hadoop.fs.QuotaUsage -->
  <class name="QuotaUsage" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="QuotaUsage"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="QuotaUsage" type="org.apache.hadoop.fs.QuotaUsage.Builder"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Build the instance based on the builder.
 @param builder bulider.]]>
      </doc>
    </constructor>
    <method name="setQuota"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="quota" type="long"/>
    </method>
    <method name="setSpaceConsumed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="spaceConsumed" type="long"/>
    </method>
    <method name="setSpaceQuota"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="spaceQuota" type="long"/>
    </method>
    <method name="getFileAndDirectoryCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the directory count.

 @return file and directory count.]]>
      </doc>
    </method>
    <method name="getQuota" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the directory quota.

 @return quota.]]>
      </doc>
    </method>
    <method name="getSpaceConsumed" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return (disk) space consumed.

 @return space consumed.]]>
      </doc>
    </method>
    <method name="getSpaceQuota" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return (disk) space quota.

 @return space quota.]]>
      </doc>
    </method>
    <method name="getTypeQuota" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.apache.hadoop.fs.StorageType"/>
      <doc>
      <![CDATA[Return storage type quota.

 @param type storage type.
 @return type quota.]]>
      </doc>
    </method>
    <method name="getTypeConsumed" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.apache.hadoop.fs.StorageType"/>
      <doc>
      <![CDATA[Return storage type consumed.

 @param type storage type.
 @return type consumed.]]>
      </doc>
    </method>
    <method name="isTypeQuotaSet" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return true if any storage type quota has been set.

 @return if any storage type quota has been set true, not false.]]>
      </doc>
    </method>
    <method name="isTypeConsumedAvailable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return true if any storage type consumption information is available.

 @return if any storage type consumption information
 is available, not false.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="getHeader" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the header of the output.
 @return the header of the output]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hOption" type="boolean"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hOption" type="boolean"/>
      <param name="tOption" type="boolean"/>
      <param name="types" type="java.util.List"/>
      <doc>
      <![CDATA[Return the string representation of the object in the output format.
 if hOption is false file sizes are returned in bytes
 if hOption is true file sizes are returned in human readable

 @param hOption a flag indicating if human readable output if to be used
 @param tOption type option.
 @param types storage types.
 @return the string representation of the object.]]>
      </doc>
    </method>
    <method name="getQuotaUsage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="hOption" type="boolean"/>
    </method>
    <method name="getTypesQuotaUsage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="hOption" type="boolean"/>
      <param name="types" type="java.util.List"/>
    </method>
    <method name="getStorageTypeHeader" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="storageTypes" type="java.util.List"/>
      <doc>
      <![CDATA[return the header of with the StorageTypes.

 @param storageTypes storage types.
 @return storage header string]]>
      </doc>
    </method>
    <field name="QUOTA_STRING_FORMAT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Output format:
 |----12----| |----15----| |----15----| |----15----| |-------18-------|
    QUOTA   REMAINING_QUOTA SPACE_QUOTA SPACE_QUOTA_REM FILE_NAME]]>
      </doc>
    </field>
    <field name="SPACE_QUOTA_STRING_FORMAT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="QUOTA_HEADER_FIELDS" type="java.lang.String[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="QUOTA_HEADER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Store the quota usage of a directory.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.QuotaUsage -->
  <!-- start class org.apache.hadoop.fs.RawLocalFileSystem -->
  <class name="RawLocalFileSystem" extends="org.apache.hadoop.fs.FileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RawLocalFileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="useStatIfAvailable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pathToFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Convert a path to a File.

 @param path the path.
 @return file.]]>
      </doc>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fd" type="org.apache.hadoop.fs.PathHandle"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createOutputStream" return="java.io.OutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="append" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createOutputStreamWithMode" return="java.io.OutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="append" type="boolean"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createNonRecursive" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flags" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createNonRecursive" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="concat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="trg" type="org.apache.hadoop.fs.Path"/>
      <param name="psrcs" type="org.apache.hadoop.fs.Path[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="rename" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="handleEmptyDstDirectoryOnWindows" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="srcFile" type="java.io.File"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="dstFile" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="truncate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="newLength" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete the given path to a file or directory.
 @param p the path to delete
 @param recursive to delete sub-directories
 @return true if the file or directory and all its contents were deleted
 @throws IOException if p is non-empty and recursive is false]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[{@inheritDoc}

 (<b>Note</b>: Returned list is not sorted in any given order,
 due to reliance on Java's {@link File#list()} API.)]]>
      </doc>
    </method>
    <method name="exists" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mkOneDir" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="p2f" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mkOneDirWithMode" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="p2f" type="java.io.File"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates the specified directory hierarchy. Does not
 treat existence as an error.]]>
      </doc>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setWorkingDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newDir" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Set the working directory to the given directory.]]>
      </doc>
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInitialWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getStatus" return="org.apache.hadoop.fs.FsStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="moveFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startLocalOutput" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="completeLocalOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsWorkingFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Use the command chown to set owner.]]>
      </doc>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Use the command chmod to set permission.]]>
      </doc>
    </method>
    <method name="setTimes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="mtime" type="long"/>
      <param name="atime" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Sets the {@link Path}'s last modified time and last access time to
 the given valid times.

 @param mtime the modification time to set (only if no less than zero).
 @param atime the access time to set (only if no less than zero).
 @throws IOException if setting the times fails.]]>
      </doc>
    </method>
    <method name="createPathHandle" return="org.apache.hadoop.fs.PathHandle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="stat" type="org.apache.hadoop.fs.FileStatus"/>
      <param name="opts" type="org.apache.hadoop.fs.Options.HandleOpt[]"/>
      <doc>
      <![CDATA[Hook to implement support for {@link PathHandle} operations.
 @param stat Referent in the target FileSystem
 @param opts Constraints that determine the validity of the
            {@link PathHandle} reference.]]>
      </doc>
    </method>
    <method name="supportsSymlinks" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createSymlink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.apache.hadoop.fs.Path"/>
      <param name="link" type="org.apache.hadoop.fs.Path"/>
      <param name="createParent" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileLinkStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a FileStatus representing the given path. If the path refers
 to a symlink return a FileStatus representing the link rather than
 the object the link refers to.]]>
      </doc>
    </method>
    <method name="getLinkTarget" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="hasPathCapability" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="capability" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Implement the FileSystem API for the raw local filesystem.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.RawLocalFileSystem -->
  <!-- start class org.apache.hadoop.fs.ReadOption -->
  <class name="ReadOption" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.fs.ReadOption[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.fs.ReadOption"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Options that can be used when reading from a FileSystem.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ReadOption -->
  <!-- start interface org.apache.hadoop.fs.Seekable -->
  <interface name="Seekable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="seek"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Seek to the given offset from the start of the file.
 The next read() will be from that location.  Can't
 seek past the end of the file.

 @param pos offset from the start of the file.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getPos" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the current offset from the start of the file

 @return offset from the start of the file.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Stream that permits seeking.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.Seekable -->
  <!-- start class org.apache.hadoop.fs.StorageStatistics -->
  <class name="StorageStatistics" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="StorageStatistics" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the name of this StorageStatistics object.
 @return name of this StorageStatistics object]]>
      </doc>
    </method>
    <method name="getScheme" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the associated file system scheme if this is scheme specific,
 else return null.]]>
      </doc>
    </method>
    <method name="getLongStatistics" return="java.util.Iterator"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an iterator over all the currently tracked long statistics.

 The values returned will depend on the type of FileSystem or FileContext
 object.  The values do not necessarily reflect a snapshot in time.

 @return LongStatistic Iterator.]]>
      </doc>
    </method>
    <method name="getLong" return="java.lang.Long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of a statistic.

 @param key key.
 @return         null if the statistic is not being tracked or is not a
                 long statistic. The value of the statistic, otherwise.]]>
      </doc>
    </method>
    <method name="isTracked" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Return true if a statistic is being tracked.

 @param key key.
 @return         True only if the statistic is being tracked.]]>
      </doc>
    </method>
    <method name="reset"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reset all the statistic data.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[StorageStatistics contains statistics data for a FileSystem or FileContext
 instance.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.StorageStatistics -->
  <!-- start class org.apache.hadoop.fs.StorageType -->
  <class name="StorageType" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.fs.StorageType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.fs.StorageType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="isTransient" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="supportTypeQuota" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isMovable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="asList" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMovableTypes" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTypesSupportingQuota" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="parseStorageType" return="org.apache.hadoop.fs.StorageType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
    </method>
    <method name="parseStorageType" return="org.apache.hadoop.fs.StorageType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
    </method>
    <field name="DEFAULT" type="org.apache.hadoop.fs.StorageType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EMPTY_ARRAY" type="org.apache.hadoop.fs.StorageType[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Defines the types of supported storage media. The default storage
 medium is assumed to be DISK.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.StorageType -->
  <!-- start interface org.apache.hadoop.fs.StreamCapabilities -->
  <interface name="StreamCapabilities"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="hasCapability" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="capability" type="java.lang.String"/>
      <doc>
      <![CDATA[Query the stream for a specific capability.

 @param capability string to query the stream support for.
 @return True if the stream supports capability.]]>
      </doc>
    </method>
    <field name="HFLUSH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stream hflush capability implemented by {@link Syncable#hflush()}.

 Use the {@link #HSYNC} probe to check for the support of Syncable;
 it's that presence of {@code hsync()} which matters.]]>
      </doc>
    </field>
    <field name="HSYNC" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stream hsync capability implemented by {@link Syncable#hsync()}.]]>
      </doc>
    </field>
    <field name="READAHEAD" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stream setReadahead capability implemented by
 {@link CanSetReadahead#setReadahead(Long)}.]]>
      </doc>
    </field>
    <field name="DROPBEHIND" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stream setDropBehind capability implemented by
 {@link CanSetDropBehind#setDropBehind(Boolean)}.]]>
      </doc>
    </field>
    <field name="UNBUFFER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stream unbuffer capability implemented by {@link CanUnbuffer#unbuffer()}.]]>
      </doc>
    </field>
    <field name="READBYTEBUFFER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stream read(ByteBuffer) capability implemented by
 {@link ByteBufferReadable#read(java.nio.ByteBuffer)}.]]>
      </doc>
    </field>
    <field name="PREADBYTEBUFFER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stream read(long, ByteBuffer) capability implemented by
 {@link ByteBufferPositionedReadable#read(long, java.nio.ByteBuffer)}.]]>
      </doc>
    </field>
    <field name="IOSTATISTICS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[IOStatisticsSource API.]]>
      </doc>
    </field>
    <field name="VECTOREDIO" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Support for vectored IO api.
 See {@code PositionedReadable#readVectored(List, IntFunction)}.]]>
      </doc>
    </field>
    <field name="ABORTABLE_STREAM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stream abort() capability implemented by {@link Abortable#abort()}.
 This matches the Path Capability
 {@link CommonPathCapabilities#ABORTABLE_STREAM}.]]>
      </doc>
    </field>
    <field name="IOSTATISTICS_CONTEXT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Streams that support IOStatistics context and capture thread-level
 IOStatistics.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Interface to query streams for supported capabilities.

 Capability strings must be in lower case.

 Constant strings are chosen over enums in order to allow other file systems
 to define their own capabilities.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.StreamCapabilities -->
  <!-- start class org.apache.hadoop.fs.StreamCapabilitiesPolicy -->
  <class name="StreamCapabilitiesPolicy" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="StreamCapabilitiesPolicy"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="unbuffer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <doc>
      <![CDATA[Implement the policy for {@link CanUnbuffer#unbuffer()}.

 @param in the input stream]]>
      </doc>
    </method>
    <field name="CAN_UNBUFFER_NOT_IMPLEMENTED_MESSAGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Static methods to implement policies for {@link StreamCapabilities}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.StreamCapabilitiesPolicy -->
  <!-- start interface org.apache.hadoop.fs.Syncable -->
  <interface name="Syncable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="hflush"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Flush out the data in client's user buffer. After the return of
 this call, new readers will see the data.
 @throws IOException if any error occurs]]>
      </doc>
    </method>
    <method name="hsync"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Similar to posix fsync, flush out the data in client's user buffer 
 all the way to the disk device (but the disk may have it in its cache).
 @throws IOException if error occurs]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This is the interface for flush/sync operations.
 Consult the Hadoop filesystem specification for the definition of the
 semantics of these operations.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.Syncable -->
  <!-- start class org.apache.hadoop.fs.Trash -->
  <class name="Trash" extends="org.apache.hadoop.conf.Configured"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Trash" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a trash can accessor.
 @param conf a Configuration
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </constructor>
    <constructor name="Trash" type="org.apache.hadoop.fs.FileSystem, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a trash can accessor for the FileSystem provided.
 @param fs the FileSystem
 @param conf a Configuration
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </constructor>
    <method name="moveToAppropriateTrash" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[In case of the symlinks or mount points, one has to move the appropriate
 trashbin in the actual volume of the path p being deleted.

 Hence we get the file system of the fully-qualified resolved-path and
 then move the path p to the trashbin in that volume,
 @param fs - the filesystem of path p
 @param p - the  path being deleted - to be moved to trasg
 @param conf - configuration
 @return false if the item is already in the trash or trash is disabled
 @throws IOException on error]]>
      </doc>
    </method>
    <method name="isEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the trash is enabled for this filesystem.

 @return return if isEnabled true,not false.]]>
      </doc>
    </method>
    <method name="moveToTrash" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Move a file or directory to the current trash directory.

 @param path the path.
 @return false if the item is already in the trash or trash is disabled
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="checkpoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a trash checkpoint.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="expunge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete old checkpoint(s).
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="expungeImmediately"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete all trash immediately.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getEmptier" return="java.lang.Runnable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a {@link Runnable} that periodically empties the trash of all
 users, intended to be run by the superuser.

 @throws IOException on raised on errors performing I/O.
 @return Runnable.]]>
      </doc>
    </method>
    <method name="getCurrentTrashDir" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Provides a trash facility which supports pluggable Trash policies. 

 See the implementation of the configured TrashPolicy for more
 details.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.Trash -->
  <!-- start class org.apache.hadoop.fs.TrashPolicy -->
  <class name="TrashPolicy" extends="org.apache.hadoop.conf.Configured"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TrashPolicy"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="initialize"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #initialize(Configuration, FileSystem)} instead.">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="home" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Used to setup the trash policy. Must be implemented by all TrashPolicy
 implementations.
 @param conf the configuration to be used
 @param fs the filesystem to be used
 @param home the home directory
 @deprecated Use {@link #initialize(Configuration, FileSystem)} instead.]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <doc>
      <![CDATA[Used to setup the trash policy. Must be implemented by all TrashPolicy
 implementations. Different from initialize(conf, fs, home), this one does
 not assume trash always under /user/$USER due to HDFS encryption zone.
 @param conf the configuration to be used
 @param fs the filesystem to be used]]>
      </doc>
    </method>
    <method name="isEnabled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the Trash Policy is enabled for this filesystem.

 @return if isEnabled true,not false.]]>
      </doc>
    </method>
    <method name="moveToTrash" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Move a file or directory to the current trash directory.
 @param path the path.
 @return false if the item is already in the trash or trash is disabled
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="createCheckpoint"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a trash checkpoint.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="deleteCheckpoint"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete old trash checkpoint(s).
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="deleteCheckpointsImmediately"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete all checkpoints immediately, ie empty trash.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getCurrentTrashDir" return="org.apache.hadoop.fs.Path"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current working directory of the Trash Policy
 This API does not work with files deleted from encryption zone when HDFS
 data encryption at rest feature is enabled as rename file between
 encryption zones or encryption zone and non-encryption zone is not allowed.

 The caller is recommend to use the new API
 TrashPolicy#getCurrentTrashDir(Path path).
 It returns the trash location correctly for the path specified no matter
 the path is in encryption zone or not.

 @return the path.]]>
      </doc>
    </method>
    <method name="getCurrentTrashDir" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the current trash directory for path specified based on the Trash
 Policy
 @param path path to be deleted
 @return current trash directory for the path to be deleted
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getEmptier" return="java.lang.Runnable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a {@link Runnable} that periodically empties the trash of all
 users, intended to be run by the superuser.

 @throws IOException raised on errors performing I/O.
 @return Runnable.]]>
      </doc>
    </method>
    <method name="getInstance" return="org.apache.hadoop.fs.TrashPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #getInstance(Configuration, FileSystem)} instead.">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="home" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Get an instance of the configured TrashPolicy based on the value
 of the configuration parameter fs.trash.classname.

 @param conf the configuration to be used
 @param fs the file system to be used
 @param home the home directory
 @return an instance of TrashPolicy
 @deprecated Use {@link #getInstance(Configuration, FileSystem)} instead.]]>
      </doc>
    </method>
    <method name="getInstance" return="org.apache.hadoop.fs.TrashPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <doc>
      <![CDATA[Get an instance of the configured TrashPolicy based on the value
 of the configuration parameter fs.trash.classname.

 @param conf the configuration to be used
 @param fs the file system to be used
 @return an instance of TrashPolicy]]>
      </doc>
    </method>
    <field name="fs" type="org.apache.hadoop.fs.FileSystem"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="trash" type="org.apache.hadoop.fs.Path"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="deletionInterval" type="long"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This interface is used for implementing different Trash policies.
 Provides factory method to create instances of the configured Trash policy.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.TrashPolicy -->
  <!-- start class org.apache.hadoop.fs.UnsupportedFileSystemException -->
  <class name="UnsupportedFileSystemException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UnsupportedFileSystemException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs exception with the specified detail message. 
 @param message exception message.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[File system for a given file system name/scheme is not supported]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.UnsupportedFileSystemException -->
  <!-- start class org.apache.hadoop.fs.UnsupportedMultipartUploaderException -->
  <class name="UnsupportedMultipartUploaderException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UnsupportedMultipartUploaderException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs exception with the specified detail message.

 @param message exception message.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[MultipartUploader for a given file system name/scheme is not supported.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.UnsupportedMultipartUploaderException -->
  <!-- start interface org.apache.hadoop.fs.UploadHandle -->
  <interface name="UploadHandle"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Serialized from in bytes.]]>
      </doc>
    </method>
    <method name="bytes" return="java.nio.ByteBuffer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <doc>
    <![CDATA[Opaque, serializable reference to an uploadId for multipart uploads.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.UploadHandle -->
  <!-- start class org.apache.hadoop.fs.XAttrCodec -->
  <class name="XAttrCodec" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.fs.XAttrCodec[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.fs.XAttrCodec"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="decodeValue" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Decode string representation of a value and check whether it's 
 encoded. If the given string begins with 0x or 0X, it expresses
 a hexadecimal number. If the given string begins with 0s or 0S,
 base64 encoding is expected. If the given string is enclosed in 
 double quotes, the inner string is treated as text. Otherwise 
 the given string is treated as text. 
 @param value string representation of the value.
 @return byte[] the value
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="encodeValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte[]"/>
      <param name="encoding" type="org.apache.hadoop.fs.XAttrCodec"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Encode byte[] value to string representation with encoding. 
 Values encoded as text strings are enclosed in double quotes (\"), 
 while strings encoded as hexadecimal and base64 are prefixed with 
 0x and 0s, respectively.
 @param value byte[] value
 @param encoding encoding.
 @return String string representation of value
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The value of <code>XAttr</code> is byte[], this class is to 
 covert byte[] to some kind of string representation or convert back.
 String representation is convenient for display and input. For example
 display in screen as shell response and json response, input as http
 or shell parameter.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.XAttrCodec -->
  <!-- start class org.apache.hadoop.fs.XAttrSetFlag -->
  <class name="XAttrSetFlag" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.fs.XAttrSetFlag[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.fs.XAttrSetFlag"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="validate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xAttrName" type="java.lang.String"/>
      <param name="xAttrExists" type="boolean"/>
      <param name="flag" type="java.util.EnumSet"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.fs.XAttrSetFlag -->
  <doc>
  <![CDATA[An abstract file system API.]]>
  </doc>
</package>
<package name="org.apache.hadoop.fs.audit">
  <!-- start class org.apache.hadoop.fs.audit.CommonAuditContext -->
  <class name="CommonAuditContext" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="put" return="java.util.function.Supplier"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Put a context entry.
 @param key key
 @param value new value., If null, triggers removal.
 @return old value or null]]>
      </doc>
    </method>
    <method name="put" return="java.util.function.Supplier"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.util.function.Supplier"/>
      <doc>
      <![CDATA[Put a context entry dynamically evaluated on demand.
 Important: as these supplier methods are long-lived,
 the supplier function <i>MUST NOT</i> be part of/refer to
 any object instance of significant memory size.
 Applications SHOULD remove references when they are
 no longer needed.
 When logged at TRACE, prints the key and stack trace of the caller,
 to allow for debugging of any problems.
 @param key key
 @param value new value
 @return old value or null]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Remove a context entry.
 @param key key]]>
      </doc>
    </method>
    <method name="get" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a context entry.
 @param key key
 @return value or null]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Rest the context; will set the standard options again.
 Primarily for testing.]]>
      </doc>
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Does the context contain a specific key?
 @param key key
 @return true if it is in the context.]]>
      </doc>
    </method>
    <method name="currentAuditContext" return="org.apache.hadoop.fs.audit.CommonAuditContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current common audit context. Thread local.
 @return the audit context of this thread.]]>
      </doc>
    </method>
    <method name="currentThreadID" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A thread ID which is unique for this process and shared across all
 S3A clients on the same thread, even those using different FS instances.
 @return a thread ID for reporting.]]>
      </doc>
    </method>
    <method name="getEvaluatedEntries" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the evaluated operations.
 This is the map unique to this context.
 @return the operations map.]]>
      </doc>
    </method>
    <method name="setGlobalContextEntry"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Set a global entry.
 @param key key
 @param value value]]>
      </doc>
    </method>
    <method name="getGlobalContextEntry" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a global entry.
 @param key key
 @return value or null]]>
      </doc>
    </method>
    <method name="removeGlobalContextEntry"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Remove a global entry.
 @param key key to clear.]]>
      </doc>
    </method>
    <method name="noteEntryPoint"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tool" type="java.lang.Object"/>
      <doc>
      <![CDATA[Add the entry point as a context entry with the key
 {@link AuditConstants#PARAM_COMMAND}
 if it has not  already been recorded.
 This is called via ToolRunner but may be used at any
 other entry point.
 @param tool object loaded/being launched.]]>
      </doc>
    </method>
    <method name="getGlobalContextEntries" return="java.lang.Iterable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an iterator over the global entries.
 Thread safe.
 @return an iterable to enumerate the values.]]>
      </doc>
    </method>
    <field name="PROCESS_ID" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Process ID; currently built from UUID and timestamp.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[The common audit context is a map of common context information
 which can be used with any audit span.
 This context is shared across all Filesystems within the
 thread.
 Audit spans will be created with a reference to the current
 context of their thread;
 That reference is retained even as they are moved across threads, so
 context information (including thread ID Java runtime).

 The Global context entries are a set of key-value pairs which span
 all threads; the {@code HttpReferrerAuditHeader} picks these
 up automatically. It is intended for minimal use of
 shared constant values (process ID, entry point).

 An attribute set in {@link #setGlobalContextEntry(String, String)}
 will be set across all audit spans in all threads.

 The {@link #noteEntryPoint(Object)} method should be
 used in entry points (ToolRunner.run, etc). It extracts
 the final element of the classname and attaches that
 to the global context with the attribute key
 {@link AuditConstants#PARAM_COMMAND}, if not already
 set.
 This helps identify the application being executued.

 All other values set are specific to this context, which
 is thread local.
 The attributes which can be added to ths common context include
 evaluator methods which will be evaluated in whichever thread
 invokes {@link #getEvaluatedEntries()} and then evaluates them.
 That map of evaluated options may evaluated later, in a different
 thread.

 For setting and clearing thread-level options, use
 {@link #currentAuditContext()} to get the thread-local
 context for the caller, which can then be manipulated.

 For further information, especially related to memory consumption,
 read the document `auditing_architecture` in the `hadoop-aws` module.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.audit.CommonAuditContext -->
</package>
<package name="org.apache.hadoop.fs.crypto">
</package>
<package name="org.apache.hadoop.fs.ftp">
  <!-- start class org.apache.hadoop.fs.ftp.FTPException -->
  <class name="FTPException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FTPException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FTPException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FTPException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[A class to wrap a {@link Throwable} into a Runtime Exception.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ftp.FTPException -->
  <!-- start class org.apache.hadoop.fs.ftp.FTPFileSystem -->
  <class name="FTPFileSystem" extends="org.apache.hadoop.fs.FileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FTPFileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getScheme" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the protocol scheme for the FileSystem.
 <p>

 @return <code>ftp</code>]]>
      </doc>
    </method>
    <method name="getDefaultPort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the default port for this FTPFileSystem.

 @return the default port]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A stream obtained via this call must be closed before using other APIs of
 this class or else the invocation will block.]]>
      </doc>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This optional operation is not yet supported.]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="rename" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setWorkingDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newDir" type="org.apache.hadoop.fs.Path"/>
    </method>
    <field name="LOG" type="org.slf4j.Logger"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_BUFFER_SIZE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_BLOCK_SIZE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_TIMEOUT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FS_FTP_USER_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FS_FTP_HOST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FS_FTP_HOST_PORT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FS_FTP_PASSWORD_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FS_FTP_DATA_CONNECTION_MODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FS_FTP_TRANSFER_MODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="E_SAME_DIRECTORY_ONLY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FS_FTP_TIMEOUT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[<p>
 A {@link FileSystem} backed by an FTP client provided by <a
 href="http://commons.apache.org/net/">Apache Commons Net</a>.
 </p>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ftp.FTPFileSystem -->
</package>
<package name="org.apache.hadoop.fs.http">
</package>
<package name="org.apache.hadoop.fs.protocolPB">
</package>
<package name="org.apache.hadoop.fs.sftp">
</package>
<package name="org.apache.hadoop.fs.shell.find">
</package>
<package name="org.apache.hadoop.fs.statistics">
  <!-- start class org.apache.hadoop.fs.statistics.DurationStatisticSummary -->
  <class name="DurationStatisticSummary" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="DurationStatisticSummary" type="java.lang.String, boolean, long, long, long, org.apache.hadoop.fs.statistics.MeanStatistic"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor.
 @param key Statistic key.
 @param success Are these success or failure statistics.
 @param count Count of operation invocations.
 @param max Max duration; -1 if unknown.
 @param min Min duration; -1 if unknown.
 @param mean Mean duration -may be null. (will be cloned)]]>
      </doc>
    </constructor>
    <method name="getKey" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isSuccess" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMax" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMin" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMean" return="org.apache.hadoop.fs.statistics.MeanStatistic"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="fetchDurationSummary" return="org.apache.hadoop.fs.statistics.DurationStatisticSummary"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.apache.hadoop.fs.statistics.IOStatistics"/>
      <param name="key" type="java.lang.String"/>
      <param name="success" type="boolean"/>
      <doc>
      <![CDATA[Fetch the duration timing summary of success or failure operations
 from an IO Statistics source.
 If the duration key is unknown, the summary will be incomplete.
 @param source source of data
 @param key duration statistic key
 @param success fetch success statistics, or if false, failure stats.
 @return a summary of the statistics.]]>
      </doc>
    </method>
    <method name="fetchSuccessSummary" return="org.apache.hadoop.fs.statistics.DurationStatisticSummary"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.apache.hadoop.fs.statistics.IOStatistics"/>
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Fetch the duration timing summary from an IOStatistics source.
 If the duration key is unknown, the summary will be incomplete.
 @param source source of data
 @param key duration statistic key
 @return a summary of the statistics.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Summary of duration tracking statistics
 as extracted from an IOStatistics instance.
 <p>
 This is for reporting and testing.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.statistics.DurationStatisticSummary -->
  <!-- start interface org.apache.hadoop.fs.statistics.IOStatistics -->
  <interface name="IOStatistics"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="counters" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Map of counters.
 @return the current map of counters.]]>
      </doc>
    </method>
    <method name="gauges" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Map of gauges.
 @return the current map of gauges.]]>
      </doc>
    </method>
    <method name="minimums" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Map of minimums.
 @return the current map of minimums.]]>
      </doc>
    </method>
    <method name="maximums" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Map of maximums.
 @return the current map of maximums.]]>
      </doc>
    </method>
    <method name="meanStatistics" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Map of meanStatistics.
 @return the current map of MeanStatistic statistics.]]>
      </doc>
    </method>
    <field name="MIN_UNSET_VALUE" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Value when a minimum value has never been set.]]>
      </doc>
    </field>
    <field name="MAX_UNSET_VALUE" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Value when a max value has never been set.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[IO Statistics.
 <p>
 These are low-cost per-instance statistics provided by any Hadoop
 I/O class instance.
 <p>
 Consult the filesystem specification document for the requirements
 of an implementation of this interface.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.statistics.IOStatistics -->
  <!-- start interface org.apache.hadoop.fs.statistics.IOStatisticsAggregator -->
  <interface name="IOStatisticsAggregator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="aggregate" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistics" type="org.apache.hadoop.fs.statistics.IOStatistics"/>
      <doc>
      <![CDATA[Aggregate the supplied statistics into the current
 set.

 @param statistics statistics; may be null
 @return true if the statistics reference was not null and
 so aggregated.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface exported by classes which support
 aggregation of {@link IOStatistics}.
 Implementations MAY aggregate all statistics
 exported by the IOStatistics reference passed in to
 {@link #aggregate(IOStatistics)}, or they
 may selectively aggregate specific values/classes
 of statistics.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.statistics.IOStatisticsAggregator -->
  <!-- start class org.apache.hadoop.fs.statistics.IOStatisticsLogging -->
  <class name="IOStatisticsLogging" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="ioStatisticsSourceToString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Object"/>
      <doc>
      <![CDATA[Extract the statistics from a source object -or ""
 if it is not an instance of {@link IOStatistics},
 {@link IOStatisticsSource} or the retrieved
 statistics are null.
 <p>
 Exceptions are caught and downgraded to debug logging.
 @param source source of statistics.
 @return a string for logging.]]>
      </doc>
    </method>
    <method name="ioStatisticsToString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistics" type="org.apache.hadoop.fs.statistics.IOStatistics"/>
      <doc>
      <![CDATA[Convert IOStatistics to a string form.
 @param statistics A statistics instance.
 @return string value or the empty string if null]]>
      </doc>
    </method>
    <method name="ioStatisticsToPrettyString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistics" type="org.apache.hadoop.fs.statistics.IOStatistics"/>
      <doc>
      <![CDATA[Convert IOStatistics to a string form, with all the metrics sorted
 and empty value stripped.
 This is more expensive than the simple conversion, so should only
 be used for logging/output where it's known/highly likely that the
 caller wants to see the values. Not for debug logging.
 @param statistics A statistics instance.
 @return string value or the empty string if null]]>
      </doc>
    </method>
    <method name="demandStringifyIOStatisticsSource" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.apache.hadoop.fs.statistics.IOStatisticsSource"/>
      <doc>
      <![CDATA[On demand stringifier of an IOStatisticsSource instance.
 <p>
 Whenever this object's toString() method is called, it evaluates the
 statistics.
 <p>
 This is designed to affordable to use in log statements.
 @param source source of statistics -may be null.
 @return an object whose toString() operation returns the current values.]]>
      </doc>
    </method>
    <method name="demandStringifyIOStatistics" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistics" type="org.apache.hadoop.fs.statistics.IOStatistics"/>
      <doc>
      <![CDATA[On demand stringifier of an IOStatistics instance.
 <p>
 Whenever this object's toString() method is called, it evaluates the
 statistics.
 <p>
 This is for use in log statements where for the cost of creation
 of this entry is low; it is affordable to use in log statements.
 @param statistics statistics to stringify -may be null.
 @return an object whose toString() operation returns the current values.]]>
      </doc>
    </method>
    <method name="logIOStatisticsAtDebug"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="log" type="org.slf4j.Logger"/>
      <param name="message" type="java.lang.String"/>
      <param name="source" type="java.lang.Object"/>
      <doc>
      <![CDATA[Extract any statistics from the source and log at debug, if
 the log is set to log at debug.
 No-op if logging is not at debug or the source is null/of
 the wrong type/doesn't provide statistics.
 @param log log to log to
 @param message message for log -this must contain "{}" for the
 statistics report to actually get logged.
 @param source source object]]>
      </doc>
    </method>
    <method name="logIOStatisticsAtDebug"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="source" type="java.lang.Object"/>
      <doc>
      <![CDATA[Extract any statistics from the source and log to
 this class's log at debug, if
 the log is set to log at debug.
 No-op if logging is not at debug or the source is null/of
 the wrong type/doesn't provide statistics.
 @param message message for log -this must contain "{}" for the
 statistics report to actually get logged.
 @param source source object]]>
      </doc>
    </method>
    <method name="logIOStatisticsAtLevel"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="log" type="org.slf4j.Logger"/>
      <param name="level" type="java.lang.String"/>
      <param name="source" type="java.lang.Object"/>
      <doc>
      <![CDATA[A method to log IOStatistics from a source at different levels.

 @param log    Logger for logging.
 @param level  LOG level.
 @param source Source to LOG.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility operations convert IO Statistics sources/instances
 to strings, especially for robustly logging.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.statistics.IOStatisticsLogging -->
  <!-- start class org.apache.hadoop.fs.statistics.IOStatisticsSnapshot -->
  <class name="IOStatisticsSnapshot" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.statistics.IOStatistics"/>
    <implements name="java.io.Serializable"/>
    <implements name="org.apache.hadoop.fs.statistics.IOStatisticsAggregator"/>
    <constructor name="IOStatisticsSnapshot"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct.]]>
      </doc>
    </constructor>
    <constructor name="IOStatisticsSnapshot" type="org.apache.hadoop.fs.statistics.IOStatistics"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct, taking a snapshot of the source statistics data
 if the source is non-null.
 If the source is null, the empty maps are created
 @param source statistics source. Nullable.]]>
      </doc>
    </constructor>
    <method name="clear"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clear all the maps.]]>
      </doc>
    </method>
    <method name="snapshot"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.apache.hadoop.fs.statistics.IOStatistics"/>
      <doc>
      <![CDATA[Take a snapshot.

 This completely overwrites the map data with the statistics
 from the source.
 @param source statistics source.]]>
      </doc>
    </method>
    <method name="aggregate" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.apache.hadoop.fs.statistics.IOStatistics"/>
      <doc>
      <![CDATA[Aggregate the current statistics with the
 source reference passed in.

 The operation is synchronized.
 @param source source; may be null
 @return true if a merge took place.]]>
      </doc>
    </method>
    <method name="counters" return="java.util.Map"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="gauges" return="java.util.Map"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="minimums" return="java.util.Map"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="maximums" return="java.util.Map"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="meanStatistics" return="java.util.Map"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="serializer" return="org.apache.hadoop.util.JsonSerialization"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a JSON serializer for this class.
 @return a serializer.]]>
      </doc>
    </method>
    <method name="requiredSerializationClasses" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[What classes are needed to deserialize this class?
 Needed to securely unmarshall this from untrusted sources.
 @return a list of required classes to deserialize the data.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Snapshot of statistics from a different source.
 <p>
 It is serializable so that frameworks which can use java serialization
 to propagate data (Spark, Flink...) can send the statistics
 back. For this reason, TreeMaps are explicitly used as field types,
 even though IDEs can recommend use of Map instead.
 For security reasons, untrusted java object streams should never be
 deserialized. If for some reason this is required, use
 {@link #requiredSerializationClasses()} to get the list of classes
 used when deserializing instances of this object.
 </p>
 <p>
 It is annotated for correct serializations with jackson2.
 </p>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.statistics.IOStatisticsSnapshot -->
  <!-- start class org.apache.hadoop.fs.statistics.IOStatisticsSupport -->
  <class name="IOStatisticsSupport" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="snapshotIOStatistics" return="org.apache.hadoop.fs.statistics.IOStatisticsSnapshot"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="statistics" type="org.apache.hadoop.fs.statistics.IOStatistics"/>
      <doc>
      <![CDATA[Take a snapshot of the current statistics state.
 <p>
 This is not an atomic option.
 <p>
 The instance can be serialized, and its
 {@code toString()} method lists all the values.
 @param statistics statistics
 @return a snapshot of the current values.]]>
      </doc>
    </method>
    <method name="snapshotIOStatistics" return="org.apache.hadoop.fs.statistics.IOStatisticsSnapshot"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a snapshot statistics instance ready to aggregate data.

 The instance can be serialized, and its
 {@code toString()} method lists all the values.
 @return an empty snapshot]]>
      </doc>
    </method>
    <method name="retrieveIOStatistics" return="org.apache.hadoop.fs.statistics.IOStatistics"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Object"/>
      <doc>
      <![CDATA[Get the IOStatistics of the source, casting it
 if it is of the relevant type, otherwise,
 if it implements {@link IOStatisticsSource}
 extracting the value.

 Returns null if the source isn't of the write type
 or the return value of
 {@link IOStatisticsSource#getIOStatistics()} was null.
 @param source source.
 @return an IOStatistics instance or null]]>
      </doc>
    </method>
    <method name="stubDurationTrackerFactory" return="org.apache.hadoop.fs.statistics.DurationTrackerFactory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a stub duration tracker factory whose returned trackers
 are always no-ops.

 As singletons are returned, this is very low-cost to use.
 @return a duration tracker factory.]]>
      </doc>
    </method>
    <method name="stubDurationTracker" return="org.apache.hadoop.fs.statistics.DurationTracker"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a stub duration tracker.
 @return a stub tracker.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Support for working with IOStatistics.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.statistics.IOStatisticsSupport -->
  <!-- start class org.apache.hadoop.fs.statistics.MeanStatistic -->
  <class name="MeanStatistic" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <implements name="java.lang.Cloneable"/>
    <constructor name="MeanStatistic" type="long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor, with some resilience against invalid sample counts.
 If the sample count is 0 or less, the sum is set to 0 and
 the sample count to 0.
 @param samples sample count.
 @param sum sum value]]>
      </doc>
    </constructor>
    <constructor name="MeanStatistic" type="org.apache.hadoop.fs.statistics.MeanStatistic"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create from another statistic.
 @param that source]]>
      </doc>
    </constructor>
    <constructor name="MeanStatistic"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an empty statistic.]]>
      </doc>
    </constructor>
    <method name="getSum" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the sum of samples.
 @return the sum]]>
      </doc>
    </method>
    <method name="getSamples" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the sample count.
 @return the sample count; 0 means empty]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Is a statistic empty?
 @return true if the sample count is 0]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Set the values to 0.]]>
      </doc>
    </method>
    <method name="setSamplesAndSum"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sampleCount" type="long"/>
      <param name="newSum" type="long"/>
      <doc>
      <![CDATA[Set the sum and samples.
 Synchronized.
 @param sampleCount new sample count.
 @param newSum new sum]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.fs.statistics.MeanStatistic"/>
      <doc>
      <![CDATA[Set the statistic to the values of another.
 Synchronized.
 @param other the source.]]>
      </doc>
    </method>
    <method name="setSum"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sum" type="long"/>
      <doc>
      <![CDATA[Set the sum.
 @param sum new sum]]>
      </doc>
    </method>
    <method name="setSamples"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="samples" type="long"/>
      <doc>
      <![CDATA[Set the sample count.

 If this is less than zero, it is set to zero.
 This stops an ill-formed JSON entry from
 breaking deserialization, or get an invalid sample count
 into an entry.
 @param samples sample count.]]>
      </doc>
    </method>
    <method name="mean" return="double"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the arithmetic mean value.
 @return the mean]]>
      </doc>
    </method>
    <method name="add" return="org.apache.hadoop.fs.statistics.MeanStatistic"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.fs.statistics.MeanStatistic"/>
      <doc>
      <![CDATA[Add another MeanStatistic.
 @param other other value
 @return mean statistic.]]>
      </doc>
    </method>
    <method name="addSample"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Add a sample.
 Thread safe.
 @param value value to add to the sum]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The hash code is derived from the mean
 and sample count: if either is changed
 the statistic cannot be used as a key
 for hash tables/maps.
 @return a hash value]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="clone" return="org.apache.hadoop.fs.statistics.MeanStatistic"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="copy" return="org.apache.hadoop.fs.statistics.MeanStatistic"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a copy of this instance.
 @return copy.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A mean statistic represented as the sum and the sample count;
 the mean is calculated on demand.
 <p>
 It can be used to accrue values so as to dynamically update
 the mean. If so, know that there is no synchronization
 on the methods.
 </p>
 <p>
 If a statistic has 0 samples then it is considered to be empty.
 </p>
 <p>
 All 'empty' statistics are equivalent, independent of the sum value.
 </p>
 <p>
 For non-empty statistics, sum and sample values must match
 for equality.
 </p>
 <p>
 It is serializable and annotated for correct serializations with jackson2.
 </p>
 <p>
 Thread safety. The operations to add/copy sample data, are thread safe.
 </p>
 <ol>
   <li>{@link #add(MeanStatistic)}</li>
   <li>{@link #addSample(long)} </li>
   <li>{@link #clear()} </li>
   <li>{@link #setSamplesAndSum(long, long)}</li>
   <li>{@link #set(MeanStatistic)}</li>
   <li>{@link #setSamples(long)} and {@link #setSum(long)}</li>
 </ol>
 <p>
 So is the {@link #mean()} method. This ensures that when
 used to aggregated statistics, the aggregate value and sample
 count are set and evaluated consistently.
 </p>
 <p>
   Other methods marked as synchronized because Findbugs overreacts
   to the idea that some operations to update sum and sample count
   are synchronized, but that things like equals are not.
 </p>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.statistics.MeanStatistic -->
  <!-- start class org.apache.hadoop.fs.statistics.StoreStatisticNames -->
  <class name="StoreStatisticNames" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="OP_ABORT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_ACCESS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[access() API call {@value}.]]>
      </doc>
    </field>
    <field name="OP_APPEND" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_COPY_FROM_LOCAL_FILE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_CREATE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_CREATE_FILE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_CREATE_NON_RECURSIVE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_DELETE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_EXISTS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_GET_CONTENT_SUMMARY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_GET_DELEGATION_TOKEN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_GET_FILE_CHECKSUM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_GET_FILE_STATUS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_GET_STATUS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_GLOB_STATUS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_IS_FILE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_HFLUSH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_HSYNC" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_IS_DIRECTORY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_LIST_FILES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_LIST_LOCATED_STATUS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_LIST_STATUS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_MKDIRS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_MODIFY_ACL_ENTRIES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_MSYNC" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_OPEN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_OPENFILE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Call to openFile() {@value}.]]>
      </doc>
    </field>
    <field name="OP_REMOVE_ACL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_REMOVE_ACL_ENTRIES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_REMOVE_DEFAULT_ACL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_RENAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_SET_ACL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_SET_OWNER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_SET_PERMISSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_SET_TIMES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_TRUNCATE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="OP_XATTR_GET_MAP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Invoke {@code getXAttrs(Path path)}: {@value}.]]>
      </doc>
    </field>
    <field name="OP_XATTR_GET_NAMED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Invoke {@code getXAttr(Path, String)}: {@value}.]]>
      </doc>
    </field>
    <field name="OP_XATTR_GET_NAMED_MAP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Invoke {@code getXAttrs(Path path, List<String> names)}: {@value}.]]>
      </doc>
    </field>
    <field name="OP_XATTR_LIST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Invoke {@code listXAttrs(Path path)}: {@value}.]]>
      </doc>
    </field>
    <field name="DELEGATION_TOKENS_ISSUED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@value}.]]>
      </doc>
    </field>
    <field name="STORE_EXISTS_PROBE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Probe for store existing: {@value}.]]>
      </doc>
    </field>
    <field name="STORE_IO_THROTTLED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Requests throttled and retried: {@value}.]]>
      </doc>
    </field>
    <field name="STORE_IO_RATE_LIMITED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Rate limiting was reported {@value}.]]>
      </doc>
    </field>
    <field name="STORE_IO_REQUEST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Requests made of a store: {@value}.]]>
      </doc>
    </field>
    <field name="STORE_IO_RETRY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[IO retried: {@value}.]]>
      </doc>
    </field>
    <field name="OBJECT_LIST_REQUEST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A store's equivalent of a paged LIST request was initiated: {@value}.]]>
      </doc>
    </field>
    <field name="OBJECT_CONTINUE_LIST_REQUEST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Number of continued object listings made.
 Value :{@value}.]]>
      </doc>
    </field>
    <field name="OBJECT_BULK_DELETE_REQUEST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A bulk DELETE request was made: {@value}.
 A separate statistic from {@link #OBJECT_DELETE_REQUEST}
 so that metrics on duration of the operations can
 be distinguished.]]>
      </doc>
    </field>
    <field name="OBJECT_DELETE_REQUEST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A store's equivalent of a DELETE request was made: {@value}.
 This may be an HTTP DELETE verb, or it may be some custom
 operation which takes a list of objects to delete.]]>
      </doc>
    </field>
    <field name="OBJECT_DELETE_OBJECTS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The count of objects deleted in delete requests.]]>
      </doc>
    </field>
    <field name="OBJECT_MULTIPART_UPLOAD_INITIATED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Object multipart upload initiated.
 Value :{@value}.]]>
      </doc>
    </field>
    <field name="OBJECT_MULTIPART_UPLOAD_ABORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Object multipart upload aborted.
 Value :{@value}.]]>
      </doc>
    </field>
    <field name="OBJECT_PUT_REQUEST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Object put/multipart upload count.
 Value :{@value}.]]>
      </doc>
    </field>
    <field name="OBJECT_PUT_REQUEST_COMPLETED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Object put/multipart upload completed count.
 Value :{@value}.]]>
      </doc>
    </field>
    <field name="OBJECT_PUT_REQUEST_ACTIVE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Current number of active put requests.
 Value :{@value}.]]>
      </doc>
    </field>
    <field name="OBJECT_PUT_BYTES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[number of bytes uploaded.
 Value :{@value}.]]>
      </doc>
    </field>
    <field name="OBJECT_PUT_BYTES_PENDING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[number of bytes queued for upload/being actively uploaded.
 Value :{@value}.]]>
      </doc>
    </field>
    <field name="OBJECT_SELECT_REQUESTS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of S3 Select (or similar) requests issued.
 Value :{@value}.]]>
      </doc>
    </field>
    <field name="SUFFIX_MIN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Suffix to use for a minimum value when
 the same key is shared across min/mean/max
 statistics.

 Value {@value}.]]>
      </doc>
    </field>
    <field name="SUFFIX_MAX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Suffix to use for a maximum value when
 the same key is shared across max/mean/max
 statistics.

 Value {@value}.]]>
      </doc>
    </field>
    <field name="SUFFIX_MEAN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Suffix to use for a mean statistic value when
 the same key is shared across mean/mean/max
 statistics.

 Value {@value}.]]>
      </doc>
    </field>
    <field name="SUFFIX_FAILURES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[String to add to counters and other stats to track failures.
 This comes before the .min/.mean//max suffixes.

 Value {@value}.]]>
      </doc>
    </field>
    <field name="ACTION_EXECUTOR_ACQUIRED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The name of the statistic collected for executor acquisition if
 a duration tracker factory is passed in to the constructor.
 {@value}.]]>
      </doc>
    </field>
    <field name="ACTION_FILE_OPENED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A file was opened: {@value}.]]>
      </doc>
    </field>
    <field name="ACTION_HTTP_HEAD_REQUEST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An HTTP HEAD request was made: {@value}.]]>
      </doc>
    </field>
    <field name="ACTION_HTTP_GET_REQUEST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An HTTP GET request was made: {@value}.]]>
      </doc>
    </field>
    <field name="ACTION_HTTP_DELETE_REQUEST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An HTTP DELETE request was made: {@value}.]]>
      </doc>
    </field>
    <field name="ACTION_HTTP_PUT_REQUEST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An HTTP PUT request was made: {@value}.]]>
      </doc>
    </field>
    <field name="ACTION_HTTP_PATCH_REQUEST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An HTTP PATCH request was made: {@value}.]]>
      </doc>
    </field>
    <field name="ACTION_HTTP_POST_REQUEST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An HTTP POST request was made: {@value}.]]>
      </doc>
    </field>
    <field name="OBJECT_METADATA_REQUESTS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An HTTP HEAD request was made: {@value}.]]>
      </doc>
    </field>
    <field name="OBJECT_COPY_REQUESTS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="STORE_IO_THROTTLE_RATE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MULTIPART_UPLOAD_INSTANTIATED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MULTIPART_UPLOAD_PART_PUT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MULTIPART_UPLOAD_PART_PUT_BYTES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MULTIPART_UPLOAD_ABORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MULTIPART_UPLOAD_ABORT_UNDER_PATH_INVOKED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MULTIPART_UPLOAD_COMPLETED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MULTIPART_UPLOAD_STARTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MULTIPART_UPLOAD_LIST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Common statistic names for object store operations..
 <p>
 When adding new common statistic name constants, please make them unique.
 By convention:
 </p>
 <ul>
   <li>the name of the constants are uppercase, words separated by
   underscores.</li>
   <li>the value of the constants are lowercase of the constant names.</li>
 </ul>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.statistics.StoreStatisticNames -->
  <!-- start class org.apache.hadoop.fs.statistics.StreamStatisticNames -->
  <class name="StreamStatisticNames" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="STREAM_READ_ABORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of times the TCP stream was aborted.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_BYTES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Bytes read from an input stream in read()/readVectored() calls.
 Does not include bytes read and then discarded in seek/close etc.
 These are the bytes returned to the caller.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_BYTES_DISCARDED_ABORT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of bytes discarded by aborting an input stream .
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_BYTES_DISCARDED_CLOSE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of bytes read and discarded when closing an input stream.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_CLOSED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of times the TCP stream was closed.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_CLOSE_OPERATIONS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Total count of times an attempt to close an input stream was made.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_OPENED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Total count of times an input stream to was opened.
 For object stores, that means the count a GET request was initiated.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_EXCEPTIONS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of exceptions raised during input stream reads.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_FULLY_OPERATIONS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of readFully() operations in an input stream.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_OPERATIONS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of read() operations in an input stream.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_VECTORED_OPERATIONS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of readVectored() operations in an input stream.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_VECTORED_READ_BYTES_DISCARDED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of bytes discarded during readVectored() operation
 in an input stream.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_VECTORED_INCOMING_RANGES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of incoming file ranges during readVectored() operation.
 Value: {@value}]]>
      </doc>
    </field>
    <field name="STREAM_READ_VECTORED_COMBINED_RANGES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of combined file ranges during readVectored() operation.
 Value: {@value}]]>
      </doc>
    </field>
    <field name="STREAM_READ_OPERATIONS_INCOMPLETE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of incomplete read() operations in an input stream,
 that is, when the bytes returned were less than that requested.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_REMOTE_STREAM_ABORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[count/duration of aborting a remote stream during stream IO
 IO.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_REMOTE_STREAM_DRAINED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[count/duration of closing a remote stream,
 possibly including draining the stream to recycle
 the HTTP connection.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_VERSION_MISMATCHES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of version mismatches encountered while reading an input stream.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_SEEK_BACKWARD_OPERATIONS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of executed seek operations which went backwards in a stream.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_SEEK_BYTES_BACKWARDS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of bytes moved backwards during seek operations
 in an input stream.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_SEEK_BYTES_DISCARDED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of bytes read and discarded during seek() in an input stream.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_SEEK_BYTES_SKIPPED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of bytes skipped during forward seek operations.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_SEEK_FORWARD_OPERATIONS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of executed seek operations which went forward in
 an input stream.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_SEEK_POLICY_CHANGED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of times the seek policy was dynamically changed
 in an input stream.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_SEEK_OPERATIONS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of seek operations in an input stream.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_SKIP_OPERATIONS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of {@code InputStream.skip()} calls.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_SKIP_BYTES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count bytes skipped in {@code InputStream.skip()} calls.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_TOTAL_BYTES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Total count of bytes read from an input stream.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_READ_UNBUFFERED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of calls of {@code CanUnbuffer.unbuffer()}.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_WRITE_EXCEPTIONS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA["Count of stream write failures reported.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_WRITE_EXCEPTIONS_COMPLETING_UPLOADS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of failures when finalizing a multipart upload:
 {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_WRITE_BLOCK_UPLOADS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of block/partition uploads complete.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_WRITE_BLOCK_UPLOADS_ABORTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of number of block uploads aborted.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_WRITE_BLOCK_UPLOADS_ACTIVE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of block/partition uploads active.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_WRITE_BLOCK_UPLOADS_BYTES_PENDING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gauge of data queued to be written.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_WRITE_BLOCK_UPLOADS_COMMITTED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of number of block uploads committed.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_WRITE_BLOCK_UPLOADS_PENDING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gauge of block/partitions uploads queued to be written.
 Value: {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_WRITE_BYTES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA["Count of bytes written to output stream including all not yet uploaded.
 {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_WRITE_TOTAL_TIME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Count of total time taken for uploads to complete.
 {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_WRITE_QUEUE_DURATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Total queue duration of all block uploads.
 {@value}.]]>
      </doc>
    </field>
    <field name="STREAM_WRITE_TOTAL_DATA" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BYTES_TO_UPLOAD" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Number of bytes to upload from an OutputStream.]]>
      </doc>
    </field>
    <field name="BYTES_UPLOAD_SUCCESSFUL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Number of bytes uploaded successfully to the object store.]]>
      </doc>
    </field>
    <field name="BYTES_UPLOAD_FAILED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Number of bytes failed to upload to the object store.]]>
      </doc>
    </field>
    <field name="TIME_SPENT_ON_TASK_WAIT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Total time spent on waiting for a task to complete.]]>
      </doc>
    </field>
    <field name="QUEUE_SHRUNK_OPS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Number of task queue shrunk operations.]]>
      </doc>
    </field>
    <field name="WRITE_CURRENT_BUFFER_OPERATIONS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Number of times current buffer is written to the service.]]>
      </doc>
    </field>
    <field name="TIME_SPENT_ON_PUT_REQUEST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Total time spent on completing a PUT request.]]>
      </doc>
    </field>
    <field name="SEEK_IN_BUFFER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Number of seeks in buffer.]]>
      </doc>
    </field>
    <field name="BYTES_READ_BUFFER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Number of bytes read from the buffer.]]>
      </doc>
    </field>
    <field name="REMOTE_READ_OP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Total number of remote read operations performed.]]>
      </doc>
    </field>
    <field name="READ_AHEAD_BYTES_READ" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Total number of bytes read from readAhead.]]>
      </doc>
    </field>
    <field name="REMOTE_BYTES_READ" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Total number of bytes read from remote operations.]]>
      </doc>
    </field>
    <field name="BLOCKS_ALLOCATED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Total number of Data blocks allocated by an outputStream.]]>
      </doc>
    </field>
    <field name="BLOCKS_RELEASED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Total number of Data blocks released by an outputStream.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[These are common statistic names.
 <p>
 When adding new common statistic name constants, please make them unique.
 By convention, they are implicitly unique:
 <ul>
   <li>
     The name of the constants are uppercase, words separated by
     underscores.
   </li>
   <li>
     The value of the constants are lowercase of the constant names.
   </li>
 </ul>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.statistics.StreamStatisticNames -->
</package>
<package name="org.apache.hadoop.ha">
  <!-- start class org.apache.hadoop.ha.BadFencingConfigurationException -->
  <class name="BadFencingConfigurationException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BadFencingConfigurationException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BadFencingConfigurationException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Indicates that the operator has specified an invalid configuration
 for fencing methods.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ha.BadFencingConfigurationException -->
  <!-- start class org.apache.hadoop.ha.FailoverFailedException -->
  <class name="FailoverFailedException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FailoverFailedException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FailoverFailedException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Exception thrown to indicate service failover has failed.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ha.FailoverFailedException -->
  <!-- start interface org.apache.hadoop.ha.FenceMethod -->
  <interface name="FenceMethod"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="checkArgs"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String"/>
      <exception name="BadFencingConfigurationException" type="org.apache.hadoop.ha.BadFencingConfigurationException"/>
      <doc>
      <![CDATA[Verify that the given fencing method's arguments are valid.
 @param args the arguments provided in the configuration. This may
        be null if the operator did not configure any arguments.
 @throws BadFencingConfigurationException if the arguments are invalid]]>
      </doc>
    </method>
    <method name="tryFence" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.apache.hadoop.ha.HAServiceTarget"/>
      <param name="args" type="java.lang.String"/>
      <exception name="BadFencingConfigurationException" type="org.apache.hadoop.ha.BadFencingConfigurationException"/>
      <doc>
      <![CDATA[Attempt to fence the target node.
 @param target the target of the service to fence
 @param args the configured arguments, which were checked at startup by
             {@link #checkArgs(String)}
 @return true if fencing was successful, false if unsuccessful or
              indeterminate
 @throws BadFencingConfigurationException if the configuration was
         determined to be invalid only at runtime]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A fencing method is a method by which one node can forcibly prevent
 another node from making continued progress. This might be implemented
 by killing a process on the other node, by denying the other node's
 access to shared storage, or by accessing a PDU to cut the other node's
 power.
 <p>
 Since these methods are often vendor- or device-specific, operators
 may implement this interface in order to achieve fencing.
 <p>
 Fencing is configured by the operator as an ordered list of methods to
 attempt. Each method will be tried in turn, and the next in the list
 will only be attempted if the previous one fails. See {@link NodeFencer}
 for more information.
 <p>
 If an implementation also implements {@link Configurable} then its
 <code>setConf</code> method will be called upon instantiation.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.ha.FenceMethod -->
  <!-- start interface org.apache.hadoop.ha.HAServiceProtocol -->
  <interface name="HAServiceProtocol"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="monitorHealth"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="HealthCheckFailedException" type="org.apache.hadoop.ha.HealthCheckFailedException"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Monitor the health of service. This periodically called by the HA
 frameworks to monitor the health of the service.
 
 Service is expected to perform checks to ensure it is functional.
 If the service is not healthy due to failure or partial failure,
 it is expected to throw {@link HealthCheckFailedException}.
 The definition of service not healthy is left to the service.
 
 Note that when health check of an Active service fails,
 failover to standby may be done.
 
 @throws HealthCheckFailedException
           if the health check of a service fails.
 @throws AccessControlException
           if access is denied.
 @throws IOException
           if other errors happen]]>
      </doc>
    </method>
    <method name="transitionToActive"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reqInfo" type="org.apache.hadoop.ha.HAServiceProtocol.StateChangeRequestInfo"/>
      <exception name="ServiceFailedException" type="org.apache.hadoop.ha.ServiceFailedException"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Request service to transition to active state. No operation, if the
 service is already in active state.

 @param reqInfo reqInfo.
 @throws ServiceFailedException
           if transition from standby to active fails.
 @throws AccessControlException
           if access is denied.
 @throws IOException
           if other errors happen]]>
      </doc>
    </method>
    <method name="transitionToStandby"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reqInfo" type="org.apache.hadoop.ha.HAServiceProtocol.StateChangeRequestInfo"/>
      <exception name="ServiceFailedException" type="org.apache.hadoop.ha.ServiceFailedException"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Request service to transition to standby state. No operation, if the
 service is already in standby state.

 @param reqInfo reqInfo.
 @throws ServiceFailedException
           if transition from active to standby fails.
 @throws AccessControlException
           if access is denied.
 @throws IOException
           if other errors happen]]>
      </doc>
    </method>
    <method name="transitionToObserver"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reqInfo" type="org.apache.hadoop.ha.HAServiceProtocol.StateChangeRequestInfo"/>
      <exception name="ServiceFailedException" type="org.apache.hadoop.ha.ServiceFailedException"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Request service to transition to observer state. No operation, if the
 service is already in observer state.

 @param reqInfo reqInfo.
 @throws ServiceFailedException
           if transition from standby to observer fails.
 @throws AccessControlException
           if access is denied.
 @throws IOException
           if other errors happen]]>
      </doc>
    </method>
    <method name="getServiceStatus" return="org.apache.hadoop.ha.HAServiceStatus"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the current status of the service. The status indicates
 the current <em>state</em> (e.g ACTIVE/STANDBY) as well as
 some additional information.
 
 @throws AccessControlException
           if access is denied.
 @throws IOException
           if other errors happen
 @see HAServiceStatus
 @return HAServiceStatus.]]>
      </doc>
    </method>
    <field name="versionID" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initial version of the protocol]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Protocol interface that provides High Availability related primitives to
 monitor and fail-over the service.
 
 This interface could be used by HA frameworks to manage the service.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.ha.HAServiceProtocol -->
  <!-- start class org.apache.hadoop.ha.HAServiceProtocolHelper -->
  <class name="HAServiceProtocolHelper" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HAServiceProtocolHelper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="monitorHealth"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="svc" type="org.apache.hadoop.ha.HAServiceProtocol"/>
      <param name="reqInfo" type="org.apache.hadoop.ha.HAServiceProtocol.StateChangeRequestInfo"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="transitionToActive"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="svc" type="org.apache.hadoop.ha.HAServiceProtocol"/>
      <param name="reqInfo" type="org.apache.hadoop.ha.HAServiceProtocol.StateChangeRequestInfo"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="transitionToStandby"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="svc" type="org.apache.hadoop.ha.HAServiceProtocol"/>
      <param name="reqInfo" type="org.apache.hadoop.ha.HAServiceProtocol.StateChangeRequestInfo"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="transitionToObserver"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="svc" type="org.apache.hadoop.ha.HAServiceProtocol"/>
      <param name="reqInfo" type="org.apache.hadoop.ha.HAServiceProtocol.StateChangeRequestInfo"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Helper for making {@link HAServiceProtocol} RPC calls. This helper
 unwraps the {@link RemoteException} to specific exceptions.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ha.HAServiceProtocolHelper -->
  <!-- start class org.apache.hadoop.ha.HAServiceTarget -->
  <class name="HAServiceTarget" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HAServiceTarget"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAddress" return="java.net.InetSocketAddress"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the IPC address of the target node.]]>
      </doc>
    </method>
    <method name="getHealthMonitorAddress" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an optional separate RPC server address for health checks at the
 target node.  If defined, then this address is used by the health monitor
 for the {@link HAServiceProtocol#monitorHealth()} and
 {@link HAServiceProtocol#getServiceStatus()} calls.  This can be useful for
 separating out these calls onto separate RPC handlers to protect against
 resource exhaustion in the main RPC handler pool.  If null (which is the
 default implementation), then all RPC calls go to the address defined by
 {@link #getAddress()}.

 @return IPC address of the lifeline RPC server on the target node, or null
     if no lifeline RPC server is used]]>
      </doc>
    </method>
    <method name="getZKFCAddress" return="java.net.InetSocketAddress"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the IPC address of the ZKFC on the target node]]>
      </doc>
    </method>
    <method name="getFencer" return="org.apache.hadoop.ha.NodeFencer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return a Fencer implementation configured for this target node]]>
      </doc>
    </method>
    <method name="checkFencingConfigured"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="BadFencingConfigurationException" type="org.apache.hadoop.ha.BadFencingConfigurationException"/>
      <doc>
      <![CDATA[@throws BadFencingConfigurationException if the fencing configuration
 appears to be invalid. This is divorced from the above
 {@link #getFencer()} method so that the configuration can be checked
 during the pre-flight phase of failover.]]>
      </doc>
    </method>
    <method name="getProxy" return="org.apache.hadoop.ha.HAServiceProtocol"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="timeoutMs" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@return a proxy to connect to the target HA Service.
 @param timeoutMs timeout in milliseconds.
 @param conf Configuration.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="setTransitionTargetHAStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="status" type="org.apache.hadoop.ha.HAServiceProtocol.HAServiceState"/>
    </method>
    <method name="getTransitionTargetHAStatus" return="org.apache.hadoop.ha.HAServiceProtocol.HAServiceState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHealthMonitorProxy" return="org.apache.hadoop.ha.HAServiceProtocol"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="timeoutMs" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a proxy to connect to the target HA service for health monitoring.
 If {@link #getHealthMonitorAddress()} is implemented to return a non-null
 address, then this proxy will connect to that address.  Otherwise, the
 returned proxy defaults to using {@link #getAddress()}, which means this
 method's behavior is identical to {@link #getProxy(Configuration, int)}.

 @param conf configuration.
 @param timeoutMs timeout in milliseconds
 @return a proxy to connect to the target HA service for health monitoring
 @throws IOException if there is an error]]>
      </doc>
    </method>
    <method name="getHealthMonitorProxy" return="org.apache.hadoop.ha.HAServiceProtocol"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="timeoutMs" type="int"/>
      <param name="retries" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getZKFCProxy" return="org.apache.hadoop.ha.ZKFCProtocol"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="timeoutMs" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@return a proxy to the ZKFC which is associated with this HA service.
 @param conf configuration.
 @param timeoutMs timeout in milliseconds.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getFencingParameters" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addFencingParameters"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="ret" type="java.util.Map"/>
      <doc>
      <![CDATA[Hook to allow subclasses to add any parameters they would like to
 expose to fencing implementations/scripts. Fencing methods are free
 to use this map as they see fit -- notably, the shell script
 implementation takes each entry, prepends 'target_', substitutes
 '_' for '.', and adds it to the environment of the script.

 Subclass implementations should be sure to delegate to the superclass
 implementation as well as adding their own keys.

 @param ret map which can be mutated to pass parameters to the fencer]]>
      </doc>
    </method>
    <method name="isAutoFailoverEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return true if auto failover should be considered enabled]]>
      </doc>
    </method>
    <method name="supportObserver" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return true if this target supports the Observer state, false otherwise.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a target of the client side HA administration commands.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ha.HAServiceTarget -->
  <!-- start class org.apache.hadoop.ha.HealthCheckFailedException -->
  <class name="HealthCheckFailedException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HealthCheckFailedException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="HealthCheckFailedException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Exception thrown to indicate that health check of a service failed.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ha.HealthCheckFailedException -->
  <!-- start class org.apache.hadoop.ha.ServiceFailedException -->
  <class name="ServiceFailedException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServiceFailedException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServiceFailedException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Exception thrown to indicate that an operation performed
 to modify the state of a service or application failed.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ha.ServiceFailedException -->
</package>
<package name="org.apache.hadoop.ha.protocolPB">
  <!-- start interface org.apache.hadoop.ha.protocolPB.HAServiceProtocolPB -->
  <interface name="HAServiceProtocolPB"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.ha.proto.HAServiceProtocolProtos.HAServiceProtocolService.BlockingInterface"/>
    <implements name="org.apache.hadoop.ipc.VersionedProtocol"/>
  </interface>
  <!-- end interface org.apache.hadoop.ha.protocolPB.HAServiceProtocolPB -->
  <!-- start interface org.apache.hadoop.ha.protocolPB.ZKFCProtocolPB -->
  <interface name="ZKFCProtocolPB"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.ha.proto.ZKFCProtocolProtos.ZKFCProtocolService.BlockingInterface"/>
    <implements name="org.apache.hadoop.ipc.VersionedProtocol"/>
  </interface>
  <!-- end interface org.apache.hadoop.ha.protocolPB.ZKFCProtocolPB -->
</package>
<package name="org.apache.hadoop.http.lib">
  <doc>
  <![CDATA[This package provides user-selectable (via configuration) classes that add
functionality to the web UI. They are configured as a list of classes in the
configuration parameter <b>hadoop.http.filter.initializers</b>.

<ul>
<li> <b>StaticUserWebFilter</b> - An authorization plugin that makes all
users a static configured user.
</ul>]]>
  </doc>
</package>
<package name="org.apache.hadoop.io">
  <!-- start class org.apache.hadoop.io.AbstractMapWritable -->
  <class name="AbstractMapWritable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="AbstractMapWritable"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[constructor.]]>
      </doc>
    </constructor>
    <method name="addToMap"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <doc>
      <![CDATA[Add a Class to the maps if it is not already present.
 @param clazz clazz.]]>
      </doc>
    </method>
    <method name="getClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="id" type="byte"/>
      <doc>
      <![CDATA[the Class class for the specified id.
 @param id id.
 @return the Class class for the specified id.]]>
      </doc>
    </method>
    <method name="getId" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <doc>
      <![CDATA[get id.
 @return the id for the specified Class.
 @param clazz clazz.]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.io.Writable"/>
      <doc>
      <![CDATA[Used by child copy constructors.
 @param other other.]]>
      </doc>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the conf]]>
      </doc>
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[@param conf the conf to set]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Abstract base class for MapWritable and SortedMapWritable
 
 Unlike org.apache.nutch.crawl.MapWritable, this class allows creation of
 MapWritable&lt;Writable, MapWritable&gt; so the CLASS_TO_ID and ID_TO_CLASS
 maps travel with the class instead of being static.
 
 Class ids range from 1 to 127 so there can be at most 127 distinct classes
 in any specific map instance.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.AbstractMapWritable -->
  <!-- start class org.apache.hadoop.io.ArrayFile -->
  <class name="ArrayFile" extends="org.apache.hadoop.io.MapFile"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ArrayFile"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[A dense file-based mapping from integers to values.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ArrayFile -->
  <!-- start class org.apache.hadoop.io.ArrayPrimitiveWritable -->
  <class name="ArrayPrimitiveWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="ArrayPrimitiveWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct an empty instance, for use during Writable read]]>
      </doc>
    </constructor>
    <constructor name="ArrayPrimitiveWritable" type="java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct an instance of known type but no value yet
 for use with type-specific wrapper classes.

 @param componentType componentType.]]>
      </doc>
    </constructor>
    <constructor name="ArrayPrimitiveWritable" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Wrap an existing array of primitives
 @param value - array of primitives]]>
      </doc>
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the original array.  
 Client must cast it back to type componentType[]
 (or may use type-specific wrapper classes).
 @return - original array as Object]]>
      </doc>
    </method>
    <method name="getComponentType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDeclaredComponentType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isDeclaredComponentType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="componentType" type="java.lang.Class"/>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[This is a wrapper class.  It wraps a Writable implementation around
 an array of primitives (e.g., int[], long[], etc.), with optimized 
 wire format, and without creating new objects per element.
 
 This is a wrapper class only; it does not make a copy of the 
 underlying array.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ArrayPrimitiveWritable -->
  <!-- start class org.apache.hadoop.io.ArrayWritable -->
  <class name="ArrayWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="ArrayWritable" type="java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ArrayWritable" type="java.lang.Class, org.apache.hadoop.io.Writable[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ArrayWritable" type="java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getValueClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toArray" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="org.apache.hadoop.io.Writable[]"/>
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A Writable for arrays containing instances of a class. The elements of this
 writable must all be instances of the same class. If this writable will be
 the input for a Reducer, you will need to create a subclass that sets the
 value to be of the proper type.

 For example:
 <code>
 public class IntArrayWritable extends ArrayWritable {
   public IntArrayWritable() { 
     super(IntWritable.class); 
   }	
 }
 </code>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ArrayWritable -->
  <!-- start class org.apache.hadoop.io.BinaryComparable -->
  <class name="BinaryComparable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <constructor name="BinaryComparable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLength" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return n st bytes 0..n-1 from {#getBytes()} are valid.

 @return length.]]>
      </doc>
    </method>
    <method name="getBytes" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return representative byte array for this instance.

 @return getBytes.]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.io.BinaryComparable"/>
      <doc>
      <![CDATA[Compare bytes from {#getBytes()}.
 @see org.apache.hadoop.io.WritableComparator#compareBytes(byte[],int,int,byte[],int,int)]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Compare bytes from {#getBytes()} to those provided.

 @param other other.
 @param off off.
 @param len len.
 @return compareBytes.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
      <doc>
      <![CDATA[Return true if bytes from {#getBytes()} match.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a hash of the bytes returned from {#getBytes()}.
 @see org.apache.hadoop.io.WritableComparator#hashBytes(byte[],int)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface supported by {@link org.apache.hadoop.io.WritableComparable}
 types supporting ordering/permutation by a representative set of bytes.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.BinaryComparable -->
  <!-- start class org.apache.hadoop.io.BloomMapFile -->
  <class name="BloomMapFile" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BloomMapFile"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="delete"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="BLOOM_FILE_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HASH_COUNT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This class extends {@link MapFile} and provides very much the same
 functionality. However, it uses dynamic Bloom filters to provide
 quick membership test for keys, and it offers a fast version of 
 {@link Reader#get(WritableComparable, Writable)} operation, especially in
 case of sparsely populated MapFile-s.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.BloomMapFile -->
  <!-- start class org.apache.hadoop.io.BooleanWritable -->
  <class name="BooleanWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="BooleanWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BooleanWritable" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param value value.]]>
      </doc>
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Set the value of the BooleanWritable.
 @param value value.]]>
      </doc>
    </method>
    <method name="get" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of the BooleanWritable.
 @return the value of the BooleanWritable.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.io.BooleanWritable"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for booleans.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.BooleanWritable -->
  <!-- start interface org.apache.hadoop.io.ByteBufferPool -->
  <interface name="ByteBufferPool"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getBuffer" return="java.nio.ByteBuffer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="direct" type="boolean"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Get a new direct ByteBuffer.  The pool can provide this from
 removing a buffer from its internal cache, or by allocating a 
 new buffer.

 @param direct     Whether the buffer should be direct.
 @param length     The minimum length the buffer will have.
 @return           A new ByteBuffer.  This ByteBuffer must be direct.
                   Its capacity can be less than what was requested, but
                   must be at least 1 byte.]]>
      </doc>
    </method>
    <method name="putBuffer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buffer" type="java.nio.ByteBuffer"/>
      <doc>
      <![CDATA[Release a buffer back to the pool.
 The pool may choose to put this buffer into its cache.

 @param buffer    a direct bytebuffer]]>
      </doc>
    </method>
    <method name="release"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clear the buffer pool thus releasing all the buffers.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.io.ByteBufferPool -->
  <!-- start class org.apache.hadoop.io.BytesWritable -->
  <class name="BytesWritable" extends="org.apache.hadoop.io.BinaryComparable"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="BytesWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a zero-size sequence.]]>
      </doc>
    </constructor>
    <constructor name="BytesWritable" type="byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a BytesWritable using the byte array as the initial value.
 @param bytes This array becomes the backing storage for the object.]]>
      </doc>
    </constructor>
    <constructor name="BytesWritable" type="byte[], int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a BytesWritable using the byte array as the initial value
 and length as the length. Use this constructor if the array is larger
 than the value it represents.
 @param bytes This array becomes the backing storage for the object.
 @param length The number of bytes to use from array.]]>
      </doc>
    </constructor>
    <method name="copyBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a copy of the bytes that is exactly the length of the data.
 See {@link #getBytes()} for faster access to the underlying array.

 @return copyBytes.]]>
      </doc>
    </method>
    <method name="getBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the data backing the BytesWritable. Please use {@link #copyBytes()}
 if you need the returned array to be precisely the length of the data.
 @return The data is only valid between 0 and getLength() - 1.]]>
      </doc>
    </method>
    <method name="get" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #getBytes()} instead.">
      <doc>
      <![CDATA[Get the data from the BytesWritable.
 @deprecated Use {@link #getBytes()} instead.
 @return data from the BytesWritable.]]>
      </doc>
    </method>
    <method name="getLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current size of the buffer.]]>
      </doc>
    </method>
    <method name="getSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #getLength()} instead.">
      <doc>
      <![CDATA[Get the current size of the buffer.
 @deprecated Use {@link #getLength()} instead.
 @return current size of the buffer.]]>
      </doc>
    </method>
    <method name="setSize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Change the size of the buffer. The values in the old range are preserved
 and any new values are undefined. The capacity is changed if it is 
 necessary.
 @param size The new number of bytes]]>
      </doc>
    </method>
    <method name="getCapacity" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the capacity, which is the maximum size that could handled without
 resizing the backing storage.
 @return The number of bytes]]>
      </doc>
    </method>
    <method name="setCapacity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="new_cap" type="int"/>
      <doc>
      <![CDATA[Change the capacity of the backing storage.
 The data is preserved.
 @param new_cap The new capacity in bytes.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newData" type="org.apache.hadoop.io.BytesWritable"/>
      <doc>
      <![CDATA[Set the BytesWritable to the contents of the given newData.
 @param newData the value to set this BytesWritable to.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newData" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Set the value to a copy of the given byte range
 @param newData the new values to copy in
 @param offset the offset in newData to start at
 @param length the number of bytes to copy]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="right_obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Are the two byte sequences equal?]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Generate the stream of bytes as hex pairs separated by ' '.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A byte sequence that is usable as a key or value.
 It is resizable and distinguishes between the size of the sequence and
 the current capacity. The hash function is the front of the md5 of the 
 buffer. The sort order is the same as memcmp.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.BytesWritable -->
  <!-- start class org.apache.hadoop.io.ByteWritable -->
  <class name="ByteWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="ByteWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ByteWritable" type="byte"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Set the value of this ByteWritable.
 @param value value.]]>
      </doc>
    </method>
    <method name="get" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the value of this ByteWritable.
 @return value bytes.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a ByteWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.io.ByteWritable"/>
      <doc>
      <![CDATA[Compares two ByteWritables.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for a single byte.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ByteWritable -->
  <!-- start interface org.apache.hadoop.io.Closeable -->
  <interface name="Closeable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="use java.io.Closeable">
    <implements name="java.io.Closeable"/>
    <doc>
    <![CDATA[@deprecated use java.io.Closeable]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.Closeable -->
  <!-- start class org.apache.hadoop.io.CompressedWritable -->
  <class name="CompressedWritable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="CompressedWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="ensureInflated"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Must be called by all methods which access fields to ensure that the data
 has been uncompressed.]]>
      </doc>
    </method>
    <method name="readFieldsCompressed"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Subclasses implement this instead of {@link #readFields(DataInput)}.
 @param in data input.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCompressed"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Subclasses implement this instead of {@link #write(DataOutput)}.

 @param out data output.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A base-class for Writables which store themselves compressed and lazily
 inflate on field access.  This is useful for large objects whose fields are
 not be altered during a map or reduce operation: leaving the field data
 compressed makes copying the instance from one file to another much
 faster.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.CompressedWritable -->
  <!-- start class org.apache.hadoop.io.DataOutputOutputStream -->
  <class name="DataOutputOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="constructOutputStream" return="java.io.OutputStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <doc>
      <![CDATA[Construct an OutputStream from the given DataOutput. If 'out'
 is already an OutputStream, simply returns it. Otherwise, wraps
 it in an OutputStream.
 @param out the DataOutput to wrap
 @return an OutputStream instance that outputs to 'out']]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[OutputStream implementation that wraps a DataOutput.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.DataOutputOutputStream -->
  <!-- start class org.apache.hadoop.io.DefaultStringifier -->
  <class name="DefaultStringifier" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Stringifier"/>
    <constructor name="DefaultStringifier" type="org.apache.hadoop.conf.Configuration, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="fromString" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="T"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="store"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="item" type="K"/>
      <param name="keyName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Stores the item in the configuration with the given keyName.
 
 @param <K>  the class of the item
 @param conf the configuration to store
 @param item the object to be stored
 @param keyName the name of the key to use
 @throws IOException : forwards Exceptions from the underlying 
 {@link Serialization} classes.]]>
      </doc>
    </method>
    <method name="load" return="K"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="keyName" type="java.lang.String"/>
      <param name="itemClass" type="java.lang.Class"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Restores the object from the configuration.
 
 @param <K> the class of the item
 @param conf the configuration to use
 @param keyName the name of the key to use
 @param itemClass the class of the item
 @return restored object
 @throws IOException : forwards Exceptions from the underlying 
 {@link Serialization} classes.]]>
      </doc>
    </method>
    <method name="storeArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="items" type="K[]"/>
      <param name="keyName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Stores the array of items in the configuration with the given keyName.
 
 @param <K> the class of the item
 @param conf the configuration to use 
 @param items the objects to be stored
 @param keyName the name of the key to use
 @throws IndexOutOfBoundsException if the items array is empty
 @throws IOException : forwards Exceptions from the underlying 
 {@link Serialization} classes.]]>
      </doc>
    </method>
    <method name="loadArray" return="K[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="keyName" type="java.lang.String"/>
      <param name="itemClass" type="java.lang.Class"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Restores the array of objects from the configuration.
 
 @param <K> the class of the item
 @param conf the configuration to use
 @param keyName the name of the key to use
 @param itemClass the class of the item
 @return restored object
 @throws IOException : forwards Exceptions from the underlying 
 {@link Serialization} classes.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[DefaultStringifier is the default implementation of the {@link Stringifier}
 interface which stringifies the objects using base64 encoding of the
 serialized version of the objects. The {@link Serializer} and
 {@link Deserializer} are obtained from the {@link SerializationFactory}.
 <br>
 DefaultStringifier offers convenience methods to store/load objects to/from
 the configuration.
 
 @param <T> the class of the objects to stringify]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.DefaultStringifier -->
  <!-- start class org.apache.hadoop.io.DoubleWritable -->
  <class name="DoubleWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="DoubleWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DoubleWritable" type="double"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
    </method>
    <method name="get" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a DoubleWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.io.DoubleWritable"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Writable for Double values.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.DoubleWritable -->
  <!-- start class org.apache.hadoop.io.ElasticByteBufferPool -->
  <class name="ElasticByteBufferPool" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.ByteBufferPool"/>
    <constructor name="ElasticByteBufferPool"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBuffer" return="java.nio.ByteBuffer"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="direct" type="boolean"/>
      <param name="length" type="int"/>
    </method>
    <method name="putBuffer"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buffer" type="java.nio.ByteBuffer"/>
    </method>
    <doc>
    <![CDATA[This is a simple ByteBufferPool which just creates ByteBuffers as needed.
 It also caches ByteBuffers after they're released.  It will always return
 the smallest cached buffer with at least the capacity you request.
 We don't try to do anything clever here like try to limit the maximum cache
 size.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ElasticByteBufferPool -->
  <!-- start class org.apache.hadoop.io.EnumSetWritable -->
  <class name="EnumSetWritable" extends="java.util.AbstractCollection"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="EnumSetWritable" type="java.util.EnumSet, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a new EnumSetWritable. If the <tt>value</tt> argument is null or
 its size is zero, the <tt>elementType</tt> argument must not be null. If
 the argument <tt>value</tt>'s size is bigger than zero, the argument
 <tt>elementType</tt> is not be used.
 
 @param value enumSet value.
 @param elementType elementType.]]>
      </doc>
    </constructor>
    <constructor name="EnumSetWritable" type="java.util.EnumSet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a new EnumSetWritable. Argument <tt>value</tt> should not be null
 or empty.
 
 @param value enumSet value.]]>
      </doc>
    </constructor>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="add" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.util.EnumSet"/>
      <param name="elementType" type="java.lang.Class"/>
      <doc>
      <![CDATA[reset the EnumSetWritable with specified
 <tt>value</tt> and <tt>elementType</tt>. If the <tt>value</tt> argument
 is null or its size is zero, the <tt>elementType</tt> argument must not be
 null. If the argument <tt>value</tt>'s size is bigger than zero, the
 argument <tt>elementType</tt> is not be used.
 
 @param value enumSet Value.
 @param elementType elementType.]]>
      </doc>
    </method>
    <method name="get" return="java.util.EnumSet"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the value of this EnumSetWritable.
 @return EnumSet.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true if <code>o</code> is an EnumSetWritable with the same value,
 or both are null.]]>
      </doc>
    </method>
    <method name="getElementType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the class of all the elements of the underlying EnumSetWriable. It
 may return null.
 
 @return the element class]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <doc>
    <![CDATA[A Writable wrapper for EnumSet.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.EnumSetWritable -->
  <!-- start class org.apache.hadoop.io.FloatWritable -->
  <class name="FloatWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="FloatWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FloatWritable" type="float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Set the value of this FloatWritable.
 @param value value.]]>
      </doc>
    </method>
    <method name="get" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the value of this FloatWritable.
 @return value.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a FloatWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.io.FloatWritable"/>
      <doc>
      <![CDATA[Compares two FloatWritables.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for floats.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.FloatWritable -->
  <!-- start class org.apache.hadoop.io.GenericWritable -->
  <class name="GenericWritable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="GenericWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="org.apache.hadoop.io.Writable"/>
      <doc>
      <![CDATA[Set the instance that is wrapped.
 
 @param obj input obj.]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the wrapped instance.
 @return the wrapped instance.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getTypes" return="java.lang.Class[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return all classes that may be wrapped.  Subclasses should implement this
 to return a constant array of classes.
 @return all classes that may be wrapped.]]>
      </doc>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <doc>
    <![CDATA[A wrapper for Writable instances.
 <p>
 When two sequence files, which have same Key type but different Value
 types, are mapped out to reduce, multiple Value types is not allowed.
 In this case, this class can help you wrap instances with different types.
 </p>
 
 <p>
 Compared with <code>ObjectWritable</code>, this class is much more effective,
 because <code>ObjectWritable</code> will append the class declaration as a String 
 into the output file in every Key-Value pair.
 </p>
 
 <p>
 Generic Writable implements {@link Configurable} interface, so that it will be 
 configured by the framework. The configuration is passed to the wrapped objects
 implementing {@link Configurable} interface <i>before deserialization</i>. 
 </p>
 
 how to use it: <br>
 1. Write your own class, such as GenericObject, which extends GenericWritable.<br> 
 2. Implements the abstract method <code>getTypes()</code>, defines 
    the classes which will be wrapped in GenericObject in application.
    Attention: this classes defined in <code>getTypes()</code> method, must
    implement <code>Writable</code> interface.
 <br><br>
 
 The code looks like this:
 <blockquote><pre>
 public class GenericObject extends GenericWritable {
 
   private static Class[] CLASSES = {
               ClassType1.class, 
               ClassType2.class,
               ClassType3.class,
               };

   protected Class[] getTypes() {
       return CLASSES;
   }

 }
 </pre></blockquote>
 
 @since Nov 8, 2006]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.GenericWritable -->
  <!-- start class org.apache.hadoop.io.IntWritable -->
  <class name="IntWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="IntWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="IntWritable" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Set the value of this IntWritable.
 @param value input value.]]>
      </doc>
    </method>
    <method name="get" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the value of this IntWritable.
 @return value of this IntWritable.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a IntWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.io.IntWritable"/>
      <doc>
      <![CDATA[Compares two IntWritables.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for ints.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.IntWritable -->
  <!-- start class org.apache.hadoop.io.IOUtils -->
  <class name="IOUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="IOUtils"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="copyBytes"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="out" type="java.io.OutputStream"/>
      <param name="buffSize" type="int"/>
      <param name="close" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies from one stream to another.

 @param in InputStrem to read from
 @param out OutputStream to write to
 @param buffSize the size of the buffer 
 @param close whether or not close the InputStream and 
 OutputStream at the end. The streams are closed in the finally clause.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="copyBytes"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="out" type="java.io.OutputStream"/>
      <param name="buffSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies from one stream to another.
 
 @param in InputStrem to read from
 @param out OutputStream to write to
 @param buffSize the size of the buffer.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="copyBytes"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="out" type="java.io.OutputStream"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies from one stream to another. <strong>closes the input and output streams 
 at the end</strong>.

 @param in InputStrem to read from
 @param out OutputStream to write to
 @param conf the Configuration object.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="copyBytes"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="out" type="java.io.OutputStream"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="close" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies from one stream to another.

 @param in InputStream to read from
 @param out OutputStream to write to
 @param conf the Configuration object
 @param close whether or not close the InputStream and 
 OutputStream at the end. The streams are closed in the finally clause.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="copyBytes"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="out" type="java.io.OutputStream"/>
      <param name="count" type="long"/>
      <param name="close" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies count bytes from one stream to another.

 @param in InputStream to read from
 @param out OutputStream to write to
 @param count number of bytes to copy
 @param close whether to close the streams
 @throws IOException if bytes can not be read or written]]>
      </doc>
    </method>
    <method name="wrappedReadForCompressedData" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="is" type="java.io.InputStream"/>
      <param name="buf" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Utility wrapper for reading from {@link InputStream}. It catches any errors
 thrown by the underlying stream (either IO or decompression-related), and
 re-throws as an IOException.
 
 @param is - InputStream to be read from
 @param buf - buffer the data is read into
 @param off - offset within buf
 @param len - amount of data to be read
 @return number of bytes read
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="buf" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads len bytes in a loop.

 @param in InputStream to read from
 @param buf The buffer to fill
 @param off offset from the buffer
 @param len the length of bytes to read
 @throws IOException if it could not read requested number of bytes 
 for any reason (including EOF)]]>
      </doc>
    </method>
    <method name="skipFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="len" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Similar to readFully(). Skips bytes in a loop.
 @param in The InputStream to skip bytes from
 @param len number of bytes to skip.
 @throws IOException if it could not skip requested number of bytes 
 for any reason (including EOF)]]>
      </doc>
    </method>
    <method name="cleanup"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use {@link #cleanupWithLogger(Logger, java.io.Closeable...)}
 instead">
      <param name="log" type="org.apache.commons.logging.Log"/>
      <param name="closeables" type="java.io.Closeable[]"/>
      <doc>
      <![CDATA[Close the Closeable objects and <b>ignore</b> any {@link Throwable} or
 null pointers. Must only be used for cleanup in exception handlers.

 @param log the log to record problems to at debug level. Can be null.
 @param closeables the objects to close
 @deprecated use {@link #cleanupWithLogger(Logger, java.io.Closeable...)}
 instead]]>
      </doc>
    </method>
    <method name="cleanupWithLogger"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="logger" type="org.slf4j.Logger"/>
      <param name="closeables" type="java.io.Closeable[]"/>
      <doc>
      <![CDATA[Close the Closeable objects and <b>ignore</b> any {@link Throwable} or
 null pointers. Must only be used for cleanup in exception handlers.

 @param logger the log to record problems to at debug level. Can be null.
 @param closeables the objects to close]]>
      </doc>
    </method>
    <method name="closeStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.Closeable"/>
      <doc>
      <![CDATA[Closes the stream ignoring {@link Throwable}.
 Must only be called in cleaning up from exception handlers.

 @param stream the Stream to close]]>
      </doc>
    </method>
    <method name="closeStreams"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="streams" type="java.io.Closeable[]"/>
      <doc>
      <![CDATA[Closes the streams ignoring {@link Throwable}.
 Must only be called in cleaning up from exception handlers.

 @param streams the Streams to close]]>
      </doc>
    </method>
    <method name="closeSocket"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sock" type="java.net.Socket"/>
      <doc>
      <![CDATA[Closes the socket ignoring {@link IOException}

 @param sock the Socket to close]]>
      </doc>
    </method>
    <method name="writeFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bc" type="java.nio.channels.WritableByteChannel"/>
      <param name="buf" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a ByteBuffer to a WritableByteChannel, handling short writes.
 
 @param bc               The WritableByteChannel to write to
 @param buf              The input buffer
 @throws IOException     On I/O error]]>
      </doc>
    </method>
    <method name="writeFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fc" type="java.nio.channels.FileChannel"/>
      <param name="buf" type="java.nio.ByteBuffer"/>
      <param name="offset" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a ByteBuffer to a FileChannel at a given offset, 
 handling short writes.
 
 @param fc               The FileChannel to write to
 @param buf              The input buffer
 @param offset           The offset in the file to start writing at
 @throws IOException     On I/O error]]>
      </doc>
    </method>
    <method name="listDirectory" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <param name="filter" type="java.io.FilenameFilter"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the complete list of files in a directory as strings.<p>

 This is better than File#listDir because it does not ignore IOExceptions.

 @param dir              The directory to list.
 @param filter           If non-null, the filter to use when listing
                         this directory.
 @return                 The list of files in the directory.

 @throws IOException     On I/O error]]>
      </doc>
    </method>
    <method name="fsync"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileToSync" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Ensure that any writes to the given file is written to the storage device
 that contains it. This method opens channel on given File and closes it
 once the sync is done.<br>
 Borrowed from Uwe Schindler in LUCENE-5588
 @param fileToSync the file to fsync
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="fsync"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="channel" type="java.nio.channels.FileChannel"/>
      <param name="isDir" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Ensure that any writes to the given file is written to the storage device
 that contains it. This method opens channel on given File and closes it
 once the sync is done.
 Borrowed from Uwe Schindler in LUCENE-5588
 @param channel Channel to sync
 @param isDir if true, the given file is a directory (Channel should be
          opened for read and ignore IOExceptions, because not all file
          systems and operating systems allow to fsync on a directory)
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="wrapException" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.String"/>
      <param name="methodName" type="java.lang.String"/>
      <param name="exception" type="java.io.IOException"/>
      <doc>
      <![CDATA[Takes an IOException, file/directory path, and method name and returns an
 IOException with the input exception as the cause and also include the
 file,method details. The new exception provides the stack trace of the
 place where the exception is thrown and some extra diagnostics
 information.

 Return instance of same exception if exception class has a public string
 constructor; Otherwise return an PathIOException.
 InterruptedIOException and PathIOException are returned unwrapped.

 @param path file/directory path
 @param methodName method name
 @param exception the caught exception.
 @return an exception to throw]]>
      </doc>
    </method>
    <method name="readFullyToByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a DataInput until EOF and returns a byte array.  Make sure not to
 pass in an infinite DataInput or this will never return.

 @param in A DataInput
 @return a byte array containing the data from the DataInput
 @throws IOException on I/O error, other than EOF]]>
      </doc>
    </method>
    <field name="LOG" type="org.slf4j.Logger"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[An utility class for I/O related functionality.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.IOUtils -->
  <!-- start class org.apache.hadoop.io.LongWritable -->
  <class name="LongWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="LongWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LongWritable" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Set the value of this LongWritable.
 @param value value.]]>
      </doc>
    </method>
    <method name="get" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the value of this LongWritable.
 @return value of this LongWritable.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a LongWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.io.LongWritable"/>
      <doc>
      <![CDATA[Compares two LongWritables.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for longs.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.LongWritable -->
  <!-- start class org.apache.hadoop.io.MapFile -->
  <class name="MapFile" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MapFile"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="rename"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="oldName" type="java.lang.String"/>
      <param name="newName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Renames an existing map directory.
 @param fs fs.
 @param oldName oldName.
 @param newName newName.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="delete"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deletes the named map file.
 @param fs input fs.
 @param name input name.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="fix" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dir" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valueClass" type="java.lang.Class"/>
      <param name="dryrun" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[This method attempts to fix a corrupt MapFile by re-creating its index.
 @param fs filesystem
 @param dir directory containing the MapFile data and index
 @param keyClass key class (has to be a subclass of Writable)
 @param valueClass value class (has to be a subclass of Writable)
 @param dryrun do not perform any changes, just report what needs to be done
 @param conf configuration.
 @return number of valid entries in this MapFile, or -1 if no fixing was needed
 @throws Exception Exception.]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <field name="INDEX_FILE_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The name of the index file.]]>
      </doc>
    </field>
    <field name="DATA_FILE_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The name of the data file.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A file-based map from keys to values.
 
 <p>A map is a directory containing two files, the <code>data</code> file,
 containing all keys and values in the map, and a smaller <code>index</code>
 file, containing a fraction of the keys.  The fraction is determined by
 {@link Writer#getIndexInterval()}.

 <p>The index file is read entirely into memory.  Thus key implementations
 should try to keep themselves small.

 <p>Map files are created by adding entries in-order.  To maintain a large
 database, perform updates by copying the previous version of a database and
 merging in a sorted change list, to create a new version of the database in
 a new file.  Sorting large change lists can be done with {@link
 SequenceFile.Sorter}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.MapFile -->
  <!-- start class org.apache.hadoop.io.MapWritable -->
  <class name="MapWritable" extends="org.apache.hadoop.io.AbstractMapWritable"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map"/>
    <constructor name="MapWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.]]>
      </doc>
    </constructor>
    <constructor name="MapWritable" type="org.apache.hadoop.io.MapWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Copy constructor.
 
 @param other the map to copy from]]>
      </doc>
    </constructor>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="entrySet" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keySet" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="put" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.Writable"/>
      <param name="value" type="org.apache.hadoop.io.Writable"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.util.Map"/>
    </method>
    <method name="remove" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A Writable Map.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.MapWritable -->
  <!-- start class org.apache.hadoop.io.MD5Hash -->
  <class name="MD5Hash" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="MD5Hash"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an MD5Hash.]]>
      </doc>
    </constructor>
    <constructor name="MD5Hash" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an MD5Hash from a hex string.
 @param hex input hex.]]>
      </doc>
    </constructor>
    <constructor name="MD5Hash" type="byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an MD5Hash with a specified value.
 @param digest digest.]]>
      </doc>
    </constructor>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="org.apache.hadoop.io.MD5Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Constructs, reads and returns an instance.
 @param in in.
 @throws IOException raised on errors performing I/O.
 @return MD5Hash.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="that" type="org.apache.hadoop.io.MD5Hash"/>
      <doc>
      <![CDATA[Copy the contents of another instance into this instance.
 @param that that.]]>
      </doc>
    </method>
    <method name="getDigest" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the digest bytes.
 @return digest.]]>
      </doc>
    </method>
    <method name="digest" return="org.apache.hadoop.io.MD5Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="byte[]"/>
      <doc>
      <![CDATA[Construct a hash value for a byte array.
 @param data data.
 @return MD5Hash.]]>
      </doc>
    </method>
    <method name="getDigester" return="java.security.MessageDigest"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a thread local MD5 digester.
 @return MessageDigest.]]>
      </doc>
    </method>
    <method name="digest" return="org.apache.hadoop.io.MD5Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a hash value for the content from the InputStream.
 @param in input stream.
 @return MD5Hash.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="digest" return="org.apache.hadoop.io.MD5Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Construct a hash value for a byte array.
 @param data data.
 @param start start.
 @param len len.
 @return MD5Hash.]]>
      </doc>
    </method>
    <method name="digest" return="org.apache.hadoop.io.MD5Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataArr" type="byte[][]"/>
      <param name="start" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Construct a hash value for an array of byte array.
 @param dataArr dataArr.
 @param start start.
 @param len len.
 @return MD5Hash.]]>
      </doc>
    </method>
    <method name="digest" return="org.apache.hadoop.io.MD5Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Construct a hash value for a String.
 @param string string.
 @return MD5Hash.]]>
      </doc>
    </method>
    <method name="digest" return="org.apache.hadoop.io.MD5Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="org.apache.hadoop.io.UTF8"/>
      <doc>
      <![CDATA[Construct a hash value for a String.
 @param utf8 utf8.
 @return MD5Hash.]]>
      </doc>
    </method>
    <method name="halfDigest" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a half-sized version of this MD5.  Fits in a long.
 @return halfDigest.]]>
      </doc>
    </method>
    <method name="quarterDigest" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a 32-bit digest of the MD5.
 @return the first 4 bytes of the md5]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is an MD5Hash whose digest contains the
 same values.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash code value for this object.
 Only uses the first 4 bytes, since md5s are evenly distributed.]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="that" type="org.apache.hadoop.io.MD5Hash"/>
      <doc>
      <![CDATA[Compares this object with the specified object for order.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of this object.]]>
      </doc>
    </method>
    <method name="setDigest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hex" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the digest value from a hex string.
 @param hex hex.]]>
      </doc>
    </method>
    <field name="MD5_LEN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A Writable for MD5 hash values.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.MD5Hash -->
  <!-- start class org.apache.hadoop.io.MultipleIOException -->
  <class name="MultipleIOException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getExceptions" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the underlying exceptions]]>
      </doc>
    </method>
    <method name="createIOException" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exceptions" type="java.util.List"/>
      <doc>
      <![CDATA[A convenient method to create an {@link IOException}.
 @param exceptions IOException List.
 @return IOException.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Encapsulate a list of {@link IOException} into an {@link IOException}]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.MultipleIOException -->
  <!-- start class org.apache.hadoop.io.NullWritable -->
  <class name="NullWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <method name="get" return="org.apache.hadoop.io.NullWritable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the single instance of this class.
 @return the single instance of this class.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.io.NullWritable"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Singleton Writable with no data.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.NullWritable -->
  <!-- start class org.apache.hadoop.io.ObjectWritable -->
  <class name="ObjectWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="ObjectWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectWritable" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectWritable" type="java.lang.Class, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the instance, or null if none.
 @return the instance, or null if none.]]>
      </doc>
    </method>
    <method name="getDeclaredClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the class this is meant to be.
 @return the class this is meant to be.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[Reset the instance.
 @param instance instance.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeObject"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="instance" type="java.lang.Object"/>
      <param name="declaredClass" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a {@link Writable}, {@link String}, primitive type, or an array of
 the preceding.

 @param out DataOutput.
 @param instance instance.
 @param conf Configuration.
 @param declaredClass declaredClass.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="writeObject"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="instance" type="java.lang.Object"/>
      <param name="declaredClass" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="allowCompactArrays" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a {@link Writable}, {@link String}, primitive type, or an array of
 the preceding.  
 
 @param allowCompactArrays - set true for RPC and internal or intra-cluster
 usages.  Set false for inter-cluster, File, and other persisted output 
 usages, to preserve the ability to interchange files with other clusters 
 that may not be running the same version of software.  Sometime in ~2013 
 we can consider removing this parameter and always using the compact format.

 @param conf configuration.
 @param out dataoutput.
 @param declaredClass declaredClass.
 @param instance instance.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="readObject" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a {@link Writable}, {@link String}, primitive type, or an array of
 the preceding.

 @param conf configuration.
 @param in DataInput.
 @return Object.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="readObject" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="objectWritable" type="org.apache.hadoop.io.ObjectWritable"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a {@link Writable}, {@link String}, primitive type, or an array of
 the preceding.

 @param in DataInput.
 @param objectWritable objectWritable.
 @param conf configuration.
 @return Object.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="loadClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="className" type="java.lang.String"/>
      <doc>
      <![CDATA[Find and load the class with given name <tt>className</tt> by first finding
 it in the specified <tt>conf</tt>. If the specified <tt>conf</tt> is null,
 try load it directly.

 @param conf configuration.
 @param className classname.
 @return Class.]]>
      </doc>
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A polymorphic Writable that writes an instance with it's class name.
 Handles arrays, strings and primitive types without a Writable wrapper.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ObjectWritable -->
  <!-- start interface org.apache.hadoop.io.RawComparator -->
  <interface name="RawComparator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Comparator"/>
    <method name="compare" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
      <doc>
      <![CDATA[Compare two objects in binary.
 b1[s1:l1] is the first object, and b2[s2:l2] is the second object.
 
 @param b1 The first byte array.
 @param s1 The position index in b1. The object under comparison's starting index.
 @param l1 The length of the object in b1.
 @param b2 The second byte array.
 @param s2 The position index in b2. The object under comparison's starting index.
 @param l2 The length of the object under comparison in b2.
 @return An integer result of the comparison.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 A {@link Comparator} that operates directly on byte representations of
 objects.
 </p>
 @param <T> generic type.
 @see DeserializerComparator]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.RawComparator -->
  <!-- start class org.apache.hadoop.io.SequenceFile -->
  <class name="SequenceFile" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getDefaultCompressionType" return="org.apache.hadoop.io.SequenceFile.CompressionType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="job" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the compression type for the reduce outputs
 @param job the job config to look in
 @return the kind of compression to use]]>
      </doc>
    </method>
    <method name="setDefaultCompressionType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="job" type="org.apache.hadoop.conf.Configuration"/>
      <param name="val" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <doc>
      <![CDATA[Set the default compression type for sequence files.
 @param job the configuration to modify
 @param val the new compression type (none, block, record)]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="opts" type="org.apache.hadoop.io.SequenceFile.Writer.Option[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a new Writer with the given options.
 @param conf the configuration to use
 @param opts the options to create the file with
 @return a new Writer
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem. 
 @param conf The configuration.
 @param name The name of the file. 
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException raised on errors performing I/O.
 @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem. 
 @param conf The configuration.
 @param name The name of the file. 
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException raised on errors performing I/O.
 @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem. 
 @param conf The configuration.
 @param name The name of the file. 
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @param progress The Progressable object to track progress.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException raised on errors performing I/O.
 @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem. 
 @param conf The configuration.
 @param name The name of the file. 
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @param codec The compression codec.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException raised on errors performing I/O.
 @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="metadata" type="org.apache.hadoop.io.SequenceFile.Metadata"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem. 
 @param conf The configuration.
 @param name The name of the file. 
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @param codec The compression codec.
 @param progress The Progressable object to track progress.
 @param metadata The metadata of the file.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException raised on errors performing I/O.
 @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="metadata" type="org.apache.hadoop.io.SequenceFile.Metadata"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem.
 @param conf The configuration.
 @param name The name of the file.
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param bufferSize buffer size for the underlaying outputstream.
 @param replication replication factor for the file.
 @param blockSize block size for the file.
 @param compressionType The compression type.
 @param codec The compression codec.
 @param progress The Progressable object to track progress.
 @param metadata The metadata of the file.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException raised on errors performing I/O.
 @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="createParent" type="boolean"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <param name="metadata" type="org.apache.hadoop.io.SequenceFile.Metadata"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem.
 @param conf The configuration.
 @param name The name of the file.
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param bufferSize buffer size for the underlaying outputstream.
 @param replication replication factor for the file.
 @param blockSize block size for the file.
 @param createParent create parent directory if non-existent
 @param compressionType The compression type.
 @param codec The compression codec.
 @param metadata The metadata of the file.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fc" type="org.apache.hadoop.fs.FileContext"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <param name="metadata" type="org.apache.hadoop.io.SequenceFile.Metadata"/>
      <param name="createFlag" type="java.util.EnumSet"/>
      <param name="opts" type="org.apache.hadoop.fs.Options.CreateOpts[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fc The context for the specified file.
 @param conf The configuration.
 @param name The name of the file.
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @param codec The compression codec.
 @param metadata The metadata of the file.
 @param createFlag gives the semantics of create: overwrite, append etc.
 @param opts file creation options; see {@link CreateOpts}.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem. 
 @param conf The configuration.
 @param name The name of the file. 
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @param codec The compression codec.
 @param progress The Progressable object to track progress.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException raised on errors performing I/O.
 @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="out" type="org.apache.hadoop.fs.FSDataOutputStream"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <param name="metadata" type="org.apache.hadoop.io.SequenceFile.Metadata"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of 'raw' SequenceFile Writer.
 @param conf The configuration.
 @param out The stream on top which the writer is to be constructed.
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @param codec The compression codec.
 @param metadata The metadata of the file.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException raised on errors performing I/O.
 @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="out" type="org.apache.hadoop.fs.FSDataOutputStream"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of 'raw' SequenceFile Writer.
 @param conf The configuration.
 @param out The stream on top which the writer is to be constructed.
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @param codec The compression codec.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException raised on errors performing I/O.
 @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.]]>
      </doc>
    </method>
    <field name="SYNC_INTERVAL" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes between sync points. 100 KB, default.
 Computed as 5 KB * 20 = 100 KB]]>
      </doc>
    </field>
    <doc>
    <![CDATA[<code>SequenceFile</code>s are flat files consisting of binary key/value 
 pairs.
 
 <p><code>SequenceFile</code> provides {@link SequenceFile.Writer},
 {@link SequenceFile.Reader} and {@link Sorter} classes for writing,
 reading and sorting respectively.</p>
 
 There are three <code>SequenceFile</code> <code>Writer</code>s based on the 
 {@link CompressionType} used to compress key/value pairs:
 <ol>
   <li>
   <code>Writer</code> : Uncompressed records.
   </li>
   <li>
   <code>RecordCompressWriter</code> : Record-compressed files, only compress 
                                       values.
   </li>
   <li>
   <code>BlockCompressWriter</code> : Block-compressed files, both keys &amp;
                                      values are collected in 'blocks' 
                                      separately and compressed. The size of 
                                      the 'block' is configurable.
 </ol>
 
 <p>The actual compression algorithm used to compress key and/or values can be
 specified by using the appropriate {@link CompressionCodec}.</p>
 
 <p>The recommended way is to use the static <tt>createWriter</tt> methods
 provided by the <code>SequenceFile</code> to chose the preferred format.</p>

 <p>The {@link SequenceFile.Reader} acts as the bridge and can read any of the
 above <code>SequenceFile</code> formats.</p>

 <h3 id="Formats">SequenceFile Formats</h3>
 
 <p>Essentially there are 3 different formats for <code>SequenceFile</code>s
 depending on the <code>CompressionType</code> specified. All of them share a
 <a href="#Header">common header</a> described below.
 
 <h4 id="Header">SequenceFile Header</h4>
 <ul>
   <li>
   version - 3 bytes of magic header <b>SEQ</b>, followed by 1 byte of actual 
             version number (e.g. SEQ4 or SEQ6)
   </li>
   <li>
   keyClassName -key class
   </li>
   <li>
   valueClassName - value class
   </li>
   <li>
   compression - A boolean which specifies if compression is turned on for 
                 keys/values in this file.
   </li>
   <li>
   blockCompression - A boolean which specifies if block-compression is 
                      turned on for keys/values in this file.
   </li>
   <li>
   compression codec - <code>CompressionCodec</code> class which is used for  
                       compression of keys and/or values (if compression is 
                       enabled).
   </li>
   <li>
   metadata - {@link Metadata} for this file.
   </li>
   <li>
   sync - A sync marker to denote end of the header.
   </li>
 </ul>
 
 <h5>Uncompressed SequenceFile Format</h5>
 <ul>
 <li>
 <a href="#Header">Header</a>
 </li>
 <li>
 Record
   <ul>
     <li>Record length</li>
     <li>Key length</li>
     <li>Key</li>
     <li>Value</li>
   </ul>
 </li>
 <li>
 A sync-marker every few <code>100</code> kilobytes or so.
 </li>
 </ul>

 <h5>Record-Compressed SequenceFile Format</h5>
 <ul>
 <li>
 <a href="#Header">Header</a>
 </li>
 <li>
 Record
   <ul>
     <li>Record length</li>
     <li>Key length</li>
     <li>Key</li>
     <li><i>Compressed</i> Value</li>
   </ul>
 </li>
 <li>
 A sync-marker every few <code>100</code> kilobytes or so.
 </li>
 </ul>
 
 <h5>Block-Compressed SequenceFile Format</h5>
 <ul>
 <li>
 <a href="#Header">Header</a>
 </li>
 <li>
 Record <i>Block</i>
   <ul>
     <li>Uncompressed number of records in the block</li>
     <li>Compressed key-lengths block-size</li>
     <li>Compressed key-lengths block</li>
     <li>Compressed keys block-size</li>
     <li>Compressed keys block</li>
     <li>Compressed value-lengths block-size</li>
     <li>Compressed value-lengths block</li>
     <li>Compressed values block-size</li>
     <li>Compressed values block</li>
   </ul>
 </li>
 <li>
 A sync-marker every block.
 </li>
 </ul>
 
 <p>The compressed blocks of key lengths and value lengths consist of the 
 actual lengths of individual keys/values encoded in ZeroCompressedInteger 
 format.</p>
 
 @see CompressionCodec]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SequenceFile -->
  <!-- start class org.apache.hadoop.io.SetFile -->
  <class name="SetFile" extends="org.apache.hadoop.io.MapFile"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SetFile"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[A file-based set of keys.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SetFile -->
  <!-- start class org.apache.hadoop.io.ShortWritable -->
  <class name="ShortWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="ShortWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ShortWritable" type="short"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="short"/>
      <doc>
      <![CDATA[Set the value of this ShortWritable.
 @param value input value.]]>
      </doc>
    </method>
    <method name="get" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Return the value of this ShortWritable.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[read the short value]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[write short value]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a ShortWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[hash code]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.io.ShortWritable"/>
      <doc>
      <![CDATA[Compares two ShortWritable.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Short values in string format]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A WritableComparable for shorts.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ShortWritable -->
  <!-- start class org.apache.hadoop.io.SortedMapWritable -->
  <class name="SortedMapWritable" extends="org.apache.hadoop.io.AbstractMapWritable"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.SortedMap"/>
    <constructor name="SortedMapWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[default constructor.]]>
      </doc>
    </constructor>
    <constructor name="SortedMapWritable" type="org.apache.hadoop.io.SortedMapWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Copy constructor.
 
 @param other the map to copy from]]>
      </doc>
    </constructor>
    <method name="comparator" return="java.util.Comparator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="firstKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="headMap" return="java.util.SortedMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toKey" type="K"/>
    </method>
    <method name="lastKey" return="K"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="subMap" return="java.util.SortedMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
      <param name="toKey" type="K"/>
    </method>
    <method name="tailMap" return="java.util.SortedMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="K"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="entrySet" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keySet" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="put" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="K"/>
      <param name="value" type="org.apache.hadoop.io.Writable"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.util.Map"/>
    </method>
    <method name="remove" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A Writable SortedMap.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SortedMapWritable -->
  <!-- start interface org.apache.hadoop.io.Stringifier -->
  <interface name="Stringifier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <method name="toString" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="T"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Converts the object to a string representation
 @param obj the object to convert
 @return the string representation of the object
 @throws IOException if the object cannot be converted]]>
      </doc>
    </method>
    <method name="fromString" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Restores the object from its string representation.
 @param str the string representation of the object
 @return restored object
 @throws IOException if the object cannot be restored]]>
      </doc>
    </method>
    <method name="close"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Closes this object. 
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Stringifier interface offers two methods to convert an object 
 to a string representation and restore the object given its 
 string representation.
 @param <T> the class of the objects to stringify]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.Stringifier -->
  <!-- start class org.apache.hadoop.io.Text -->
  <class name="Text" extends="org.apache.hadoop.io.BinaryComparable"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="Text"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Text" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct from a string.
 @param string input string.]]>
      </doc>
    </constructor>
    <constructor name="Text" type="org.apache.hadoop.io.Text"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct from another text.
 @param utf8 input utf8.]]>
      </doc>
    </constructor>
    <constructor name="Text" type="byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct from a byte array.
 @param utf8 input utf8.]]>
      </doc>
    </constructor>
    <method name="copyBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Get a copy of the bytes that is exactly the length of the data.
 See {@link #getBytes()} for faster access to the underlying array.]]>
      </doc>
    </method>
    <method name="getBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the raw bytes; however, only data up to {@link #getLength()} is
 valid. Please use {@link #copyBytes()} if you
 need the returned array to be precisely the length of the data.]]>
      </doc>
    </method>
    <method name="getLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of bytes in the byte array]]>
      </doc>
    </method>
    <method name="charAt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="int"/>
      <doc>
      <![CDATA[Returns the Unicode Scalar Value (32-bit integer value)
 for the character at <code>position</code>. Note that this
 method avoids using the converter or doing String instantiation.

 @param position input position.
 @return the Unicode scalar value at position or -1
          if the position is invalid or points to a
          trailing byte.]]>
      </doc>
    </method>
    <method name="find" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="java.lang.String"/>
    </method>
    <method name="find" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="java.lang.String"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Finds any occurrence of <code>what</code> in the backing
 buffer, starting as position <code>start</code>. The starting
 position is measured in bytes and the return value is in
 terms of byte position in the buffer. The backing buffer is
 not converted to a string for this operation.

 @param what input what.
 @param start input start.
 @return byte position of the first occurrence of the search
         string in the UTF-8 buffer or -1 if not found]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Set to contain the contents of a string.
 @param string input string.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <doc>
      <![CDATA[Set to a utf8 byte array.
 @param utf8 input utf8.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.io.Text"/>
      <doc>
      <![CDATA[copy a text.
 @param other input other.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Set the Text to range of bytes
 @param utf8 the data to copy from
 @param start the first position of the new string
 @param len the number of bytes of the new string]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Append a range of bytes to the end of the given text
 @param utf8 the data to copy from
 @param start the first position to append from utf8
 @param len the number of bytes to append]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clear the string to empty.

 <em>Note</em>: For performance reasons, this call does not clear the
 underlying byte array that is retrievable via {@link #getBytes()}.
 In order to free the byte-array memory, call {@link #set(byte[])}
 with an empty byte array (For example, <code>new byte[0]</code>).]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Convert text back to string
 @see java.lang.Object#toString()]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[deserialize]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="maxLength" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Skips over one Text in the input.
 @param in input in.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="readWithKnownLength"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a Text object whose length is already known.
 This allows creating Text from a stream which uses a different serialization
 format.

 @param in input in.
 @param len input len.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[serialize
 write this object to out
 length uses zero-compressed encoding
 @see Writable#write(DataOutput)]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="maxLength" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a Text with the same contents.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="decode" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <exception name="CharacterCodingException" type="java.nio.charset.CharacterCodingException"/>
      <doc>
      <![CDATA[@return Converts the provided byte array to a String using the
 UTF-8 encoding. If the input is malformed,
 replace by a default value.

 @param utf8 input utf8.
 @throws CharacterCodingException a character encoding or
 decoding error occurs.]]>
      </doc>
    </method>
    <method name="decode" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="length" type="int"/>
      <exception name="CharacterCodingException" type="java.nio.charset.CharacterCodingException"/>
    </method>
    <method name="decode" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="length" type="int"/>
      <param name="replace" type="boolean"/>
      <exception name="CharacterCodingException" type="java.nio.charset.CharacterCodingException"/>
      <doc>
      <![CDATA[@return Converts the provided byte array to a String using the
 UTF-8 encoding. If <code>replace</code> is true, then
 malformed input is replaced with the
 substitution character, which is U+FFFD. Otherwise the
 method throws a MalformedInputException.

 @param utf8 input utf8.
 @param start input start.
 @param length input length.
 @param replace input replace.
 @throws CharacterCodingException a character encoding or
 decoding error occurs.]]>
      </doc>
    </method>
    <method name="encode" return="java.nio.ByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <exception name="CharacterCodingException" type="java.nio.charset.CharacterCodingException"/>
      <doc>
      <![CDATA[Converts the provided String to bytes using the
 UTF-8 encoding. If the input is malformed,
 invalid chars are replaced by a default value.

 @param string input string.
 @return ByteBuffer: bytes stores at ByteBuffer.array() 
                     and length is ByteBuffer.limit()
 @throws CharacterCodingException
 a character encoding or decoding error occurs.]]>
      </doc>
    </method>
    <method name="encode" return="java.nio.ByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="replace" type="boolean"/>
      <exception name="CharacterCodingException" type="java.nio.charset.CharacterCodingException"/>
      <doc>
      <![CDATA[Converts the provided String to bytes using the
 UTF-8 encoding. If <code>replace</code> is true, then
 malformed input is replaced with the
 substitution character, which is U+FFFD. Otherwise the
 method throws a MalformedInputException.

 @param string input string.
 @param replace input replace.
 @return ByteBuffer: bytes stores at ByteBuffer.array() 
                     and length is ByteBuffer.limit()
 @throws CharacterCodingException a character encoding or decoding error occurs.]]>
      </doc>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@return Read a UTF8 encoded string from in.
 @param in input in.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="maxLength" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@return Read a UTF8 encoded string with a maximum size.
 @param in input in.
 @param maxLength input maxLength.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="writeString" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="s" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@return Write a UTF8 encoded string to out.

 @param out input out.
 @param s input s.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="writeString" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="s" type="java.lang.String"/>
      <param name="maxLength" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@return Write a UTF8 encoded string with a maximum size to out.

 @param out input out.
 @param s input s.
 @param maxLength input maxLength.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="validateUTF8"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <exception name="MalformedInputException" type="java.nio.charset.MalformedInputException"/>
      <doc>
      <![CDATA[Check if a byte array contains valid utf-8
 @param utf8 byte array
 @throws MalformedInputException if the byte array contains invalid utf-8]]>
      </doc>
    </method>
    <method name="validateUTF8"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="len" type="int"/>
      <exception name="MalformedInputException" type="java.nio.charset.MalformedInputException"/>
      <doc>
      <![CDATA[Check to see if a byte array is valid utf-8
 @param utf8 the array of bytes
 @param start the offset of the first byte in the array
 @param len the length of the byte sequence
 @throws MalformedInputException if the byte array contains invalid bytes]]>
      </doc>
    </method>
    <method name="bytesToCodePoint" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="java.nio.ByteBuffer"/>
      <doc>
      <![CDATA[@return Returns the next code point at the current position in
 the buffer. The buffer's position will be incremented.
 Any mark set on this buffer will be changed by this method!
 @param bytes input bytes.]]>
      </doc>
    </method>
    <method name="utf8Length" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[For the given string, returns the number of UTF-8 bytes
 required to encode the string.
 @param string text to encode
 @return number of UTF-8 bytes required to encode]]>
      </doc>
    </method>
    <field name="DEFAULT_MAX_LEN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This class stores text using standard UTF8 encoding.  It provides methods
 to serialize, deserialize, and compare texts at byte level.  The type of
 length is integer and is serialized using zero-compressed format.  <p>In
 addition, it provides methods for string traversal without converting the
 byte array to a string.  <p>Also includes utilities for
 serializing/deserialing a string, coding/decoding a string, checking if a
 byte array contains valid UTF8 code, calculating the length of an encoded
 string.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.Text -->
  <!-- start class org.apache.hadoop.io.TwoDArrayWritable -->
  <class name="TwoDArrayWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="TwoDArrayWritable" type="java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TwoDArrayWritable" type="java.lang.Class, org.apache.hadoop.io.Writable[][]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="toArray" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="org.apache.hadoop.io.Writable[][]"/>
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable[][]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A Writable for 2D arrays containing a matrix of instances of a class.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.TwoDArrayWritable -->
  <!-- start class org.apache.hadoop.io.VersionedWritable -->
  <class name="VersionedWritable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="VersionedWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getVersion" return="byte"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Return the version number of the current implementation.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A base class for Writables that provides version checking.

 <p>This is useful when a class may evolve, so that instances written by the
 old version of the class may still be processed by the new version.  To
 handle this situation, {@link #readFields(DataInput)}
 implementations should catch {@link VersionMismatchException}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.VersionedWritable -->
  <!-- start class org.apache.hadoop.io.VersionMismatchException -->
  <class name="VersionMismatchException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="VersionMismatchException" type="byte, byte"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of this object.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Thrown by {@link VersionedWritable#readFields(DataInput)} when the
 version of an object being read does not match the current implementation
 version as returned by {@link VersionedWritable#getVersion()}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.VersionMismatchException -->
  <!-- start class org.apache.hadoop.io.VIntWritable -->
  <class name="VIntWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="VIntWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="VIntWritable" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Set the value of this VIntWritable.
 @param value input value.]]>
      </doc>
    </method>
    <method name="get" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Return the value of this VIntWritable.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a VIntWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.io.VIntWritable"/>
      <doc>
      <![CDATA[Compares two VIntWritables.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for integer values stored in variable-length format.
 Such values take between one and five bytes.  Smaller values take fewer bytes.
 
 @see org.apache.hadoop.io.WritableUtils#readVInt(DataInput)]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.VIntWritable -->
  <!-- start class org.apache.hadoop.io.VLongWritable -->
  <class name="VLongWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="VLongWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="VLongWritable" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Set the value of this LongWritable.
 @param value input value.]]>
      </doc>
    </method>
    <method name="get" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Return the value of this LongWritable.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a VLongWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.io.VLongWritable"/>
      <doc>
      <![CDATA[Compares two VLongWritables.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for longs in a variable-length format. Such values take
  between one and five bytes.  Smaller values take fewer bytes.
  
  @see org.apache.hadoop.io.WritableUtils#readVLong(DataInput)]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.VLongWritable -->
  <!-- start interface org.apache.hadoop.io.Writable -->
  <interface name="Writable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="write"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serialize the fields of this object to <code>out</code>.
 
 @param out <code>DataOuput</code> to serialize this object into.
 @throws IOException any other problem for write.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deserialize the fields of this object from <code>in</code>.  
 
 <p>For efficiency, implementations should attempt to re-use storage in the 
 existing object where possible.</p>
 
 @param in <code>DataInput</code> to deseriablize this object from.
 @throws IOException any other problem for readFields.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A serializable object which implements a simple, efficient, serialization 
 protocol, based on {@link DataInput} and {@link DataOutput}.

 <p>Any <code>key</code> or <code>value</code> type in the Hadoop Map-Reduce
 framework implements this interface.</p>
 
 <p>Implementations typically implement a static <code>read(DataInput)</code>
 method which constructs a new instance, calls {@link #readFields(DataInput)} 
 and returns the instance.</p>
 
 <p>Example:</p>
 <blockquote><pre>
     public class MyWritable implements Writable {
       // Some data
       private int counter;
       private long timestamp;

       // Default constructor to allow (de)serialization
       MyWritable() { }

       public void write(DataOutput out) throws IOException {
         out.writeInt(counter);
         out.writeLong(timestamp);
       }

       public void readFields(DataInput in) throws IOException {
         counter = in.readInt();
         timestamp = in.readLong();
       }

       public static MyWritable read(DataInput in) throws IOException {
         MyWritable w = new MyWritable();
         w.readFields(in);
         return w;
       }
     }
 </pre></blockquote>]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.Writable -->
  <!-- start interface org.apache.hadoop.io.WritableComparable -->
  <interface name="WritableComparable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <implements name="java.lang.Comparable"/>
    <doc>
    <![CDATA[A {@link Writable} which is also {@link Comparable}. 

 <p><code>WritableComparable</code>s can be compared to each other, typically 
 via <code>Comparator</code>s. Any type which is to be used as a 
 <code>key</code> in the Hadoop Map-Reduce framework should implement this
 interface.</p>

 <p>Note that <code>hashCode()</code> is frequently used in Hadoop to partition
 keys. It's important that your implementation of hashCode() returns the same 
 result across different instances of the JVM. Note also that the default 
 <code>hashCode()</code> implementation in <code>Object</code> does <b>not</b>
 satisfy this property.</p>
  
 <p>Example:</p>
 <blockquote><pre>
     public class MyWritableComparable implements
      WritableComparable{@literal <MyWritableComparable>} {
       // Some data
       private int counter;
       private long timestamp;
       
       public void write(DataOutput out) throws IOException {
         out.writeInt(counter);
         out.writeLong(timestamp);
       }
       
       public void readFields(DataInput in) throws IOException {
         counter = in.readInt();
         timestamp = in.readLong();
       }
       
       public int compareTo(MyWritableComparable o) {
         int thisValue = this.value;
         int thatValue = o.value;
         return (thisValue &lt; thatValue ? -1 : (thisValue==thatValue ? 0 : 1));
       }

       public int hashCode() {
         final int prime = 31;
         int result = 1;
         result = prime * result + counter;
         result = prime * result + (int) (timestamp ^ (timestamp &gt;&gt;&gt; 32));
         return result
       }
     }
 </pre></blockquote>]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.WritableComparable -->
  <!-- start class org.apache.hadoop.io.WritableComparator -->
  <class name="WritableComparator" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.RawComparator"/>
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="WritableComparator"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="WritableComparator" type="java.lang.Class"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct for a {@link WritableComparable} implementation.
 @param keyClass WritableComparable Class.]]>
      </doc>
    </constructor>
    <constructor name="WritableComparator" type="java.lang.Class, boolean"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="WritableComparator" type="java.lang.Class, org.apache.hadoop.conf.Configuration, boolean"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="org.apache.hadoop.io.WritableComparator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <doc>
      <![CDATA[For backwards compatibility.

 @param c WritableComparable Type.
 @return WritableComparator.]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.io.WritableComparator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get a comparator for a {@link WritableComparable} implementation.
 @param c class.
 @param conf configuration.
 @return WritableComparator.]]>
      </doc>
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="define"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="comparator" type="org.apache.hadoop.io.WritableComparator"/>
      <doc>
      <![CDATA[Register an optimized comparator for a {@link WritableComparable}
 implementation. Comparators registered with this method must be
 thread-safe.
 @param c class.
 @param comparator WritableComparator.]]>
      </doc>
    </method>
    <method name="getKeyClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the WritableComparable implementation class.
 @return WritableComparable.]]>
      </doc>
    </method>
    <method name="newKey" return="org.apache.hadoop.io.WritableComparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a new {@link WritableComparable} instance.
 @return WritableComparable.]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
      <doc>
      <![CDATA[Optimization hook.  Override this to make SequenceFile.Sorter's scream.

 <p>The default implementation reads the data into two {@link
 WritableComparable}s (using {@link
 Writable#readFields(DataInput)}, then calls {@link
 #compare(WritableComparable,WritableComparable)}.]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="b" type="org.apache.hadoop.io.WritableComparable"/>
      <doc>
      <![CDATA[Compare two WritableComparables.

 The default implementation uses the natural ordering, calling {@link
 Comparable#compareTo(Object)}.
 @param a the first object to be compared.
 @param b the second object to be compared.
 @return compare result.]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Object"/>
      <param name="b" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compare two Object.

 @param a the first object to be compared.
 @param b the second object to be compared.
 @return compare result.]]>
      </doc>
    </method>
    <method name="compareBytes" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
      <doc>
      <![CDATA[Lexicographic order of binary data.
 @param b1 b1.
 @param s1 s1.
 @param l1 l1.
 @param b2 b2.
 @param s2 s2.
 @param l2 l2.
 @return compare bytes.]]>
      </doc>
    </method>
    <method name="hashBytes" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Compute hash for binary data.
 @param bytes bytes.
 @param offset offset.
 @param length length.
 @return hash for binary data.]]>
      </doc>
    </method>
    <method name="hashBytes" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Compute hash for binary data.
 @param bytes bytes.
 @param length length.
 @return hash for binary data.]]>
      </doc>
    </method>
    <method name="readUnsignedShort" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Parse an unsigned short from a byte array.
 @param bytes bytes.
 @param start start.
 @return unsigned short from a byte array]]>
      </doc>
    </method>
    <method name="readInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Parse an integer from a byte array.
 @param bytes bytes.
 @param start start.
 @return integer from a byte array]]>
      </doc>
    </method>
    <method name="readFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Parse a float from a byte array.
 @param bytes bytes.
 @param start start.
 @return float from a byte array]]>
      </doc>
    </method>
    <method name="readLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Parse a long from a byte array.
 @param bytes bytes.
 @param start start.
 @return long from a byte array]]>
      </doc>
    </method>
    <method name="readDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Parse a double from a byte array.
 @param bytes bytes.
 @param start start.
 @return double from a byte array.]]>
      </doc>
    </method>
    <method name="readVLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a zero-compressed encoded long from a byte array and returns it.
 @param bytes byte array with decode long
 @param start starting index
 @throws IOException raised on errors performing I/O.
 @return deserialized long]]>
      </doc>
    </method>
    <method name="readVInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a zero-compressed encoded integer from a byte array and returns it.
 @param bytes byte array with the encoded integer
 @param start start index
 @throws IOException raised on errors performing I/O.
 @return deserialized integer]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A Comparator for {@link WritableComparable}s.

 <p>This base implementation uses the natural ordering.  To define alternate
 orderings, override {@link #compare(WritableComparable,WritableComparable)}.

 <p>One may optimize compare-intensive operations by overriding
 {@link #compare(byte[],int,int,byte[],int,int)}.  Static utility methods are
 provided to assist in optimized implementations of this method.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.WritableComparator -->
  <!-- start class org.apache.hadoop.io.WritableFactories -->
  <class name="WritableFactories" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setFactory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="factory" type="org.apache.hadoop.io.WritableFactory"/>
      <doc>
      <![CDATA[Define a factory for a class.
 @param c input c.
 @param factory input factory.]]>
      </doc>
    </method>
    <method name="getFactory" return="org.apache.hadoop.io.WritableFactory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <doc>
      <![CDATA[Define a factory for a class.
 @param c input c.
 @return a factory for a class.]]>
      </doc>
    </method>
    <method name="newInstance" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Create a new instance of a class with a defined factory.

 @param c input c.
 @param conf input configuration.
 @return a new instance of a class with a defined factory.]]>
      </doc>
    </method>
    <method name="newInstance" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <doc>
      <![CDATA[Create a new instance of a class with a defined factory.
 @param c input c.
 @return a new instance of a class with a defined factory.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factories for non-public writables.  Defining a factory permits {@link
 ObjectWritable} to be able to construct instances of non-public classes.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.WritableFactories -->
  <!-- start interface org.apache.hadoop.io.WritableFactory -->
  <interface name="WritableFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newInstance" return="org.apache.hadoop.io.Writable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Return a new instance.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A factory for a class of Writable.
 @see WritableFactories]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.WritableFactory -->
  <!-- start class org.apache.hadoop.io.WritableUtils -->
  <class name="WritableUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="WritableUtils"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="readCompressedByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skipCompressedByteArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCompressedByteArray" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="bytes" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readCompressedString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCompressedString" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="s" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="s" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeStringArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="s" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCompressedStringArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="s" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readStringArray" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readCompressedStringArray" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="displayByteArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="byte[]"/>
    </method>
    <method name="clone" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="orig" type="T"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Make a copy of a writable object using serialization to a buffer.

 @param <T> Generics Type T.
 @param orig The object to copy
 @param conf input Configuration.
 @return The copied object]]>
      </doc>
    </method>
    <method name="cloneInto"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use ReflectionUtils.cloneInto instead.">
      <param name="dst" type="org.apache.hadoop.io.Writable"/>
      <param name="src" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Make a copy of the writable object using serialization to a buffer.
 @param dst the object to copy from
 @param src the object to copy into, which is destroyed
 @throws IOException raised on errors performing I/O.
 @deprecated use ReflectionUtils.cloneInto instead.]]>
      </doc>
    </method>
    <method name="writeVInt"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.DataOutput"/>
      <param name="i" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serializes an integer to a binary stream with zero-compressed encoding.
 For -112 {@literal <=} i {@literal <=} 127, only one byte is used with the
 actual value.
 For other values of i, the first byte value indicates whether the
 integer is positive or negative, and the number of bytes that follow.
 If the first byte value v is between -113 and -116, the following integer
 is positive, with number of bytes that follow are -(v+112).
 If the first byte value v is between -121 and -124, the following integer
 is negative, with number of bytes that follow are -(v+120). Bytes are
 stored in the high-non-zero-byte-first order.

 @param stream Binary output stream
 @param i Integer to be serialized
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="writeVLong"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.DataOutput"/>
      <param name="i" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serializes a long to a binary stream with zero-compressed encoding.
 For -112 {@literal <=} i {@literal <=} 127, only one byte is used with the
 actual value.
 For other values of i, the first byte value indicates whether the
 long is positive or negative, and the number of bytes that follow.
 If the first byte value v is between -113 and -120, the following long
 is positive, with number of bytes that follow are -(v+112).
 If the first byte value v is between -121 and -128, the following long
 is negative, with number of bytes that follow are -(v+120). Bytes are
 stored in the high-non-zero-byte-first order.
 
 @param stream Binary output stream
 @param i Long to be serialized
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="readVLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a zero-compressed encoded long from input stream and returns it.
 @param stream Binary input stream
 @throws IOException raised on errors performing I/O.
 @return deserialized long from stream.]]>
      </doc>
    </method>
    <method name="readVInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a zero-compressed encoded integer from input stream and returns it.
 @param stream Binary input stream
 @throws IOException raised on errors performing I/O.
 @return deserialized integer from stream.]]>
      </doc>
    </method>
    <method name="readVIntInRange" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.DataInput"/>
      <param name="lower" type="int"/>
      <param name="upper" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads an integer from the input stream and returns it.

 This function validates that the integer is between [lower, upper],
 inclusive.

 @param stream Binary input stream
 @param lower input lower.
 @param upper input upper.
 @throws IOException raised on errors performing I/O.
 @return deserialized integer from stream.]]>
      </doc>
    </method>
    <method name="isNegativeVInt" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Given the first byte of a vint/vlong, determine the sign
 @param value the first byte
 @return is the value negative]]>
      </doc>
    </method>
    <method name="decodeVIntSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Parse the first byte of a vint/vlong to determine the number of bytes
 @param value the first byte of the vint/vlong
 @return the total number of bytes (1 to 9)]]>
      </doc>
    </method>
    <method name="getVIntSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="long"/>
      <doc>
      <![CDATA[Get the encoded length if an integer is stored in a variable-length format.
 @param i input i.
 @return the encoded length]]>
      </doc>
    </method>
    <method name="readEnum" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="enumType" type="java.lang.Class"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read an Enum value from DataInput, Enums are read and written 
 using String values. 
 @param <T> Enum type
 @param in DataInput to read from 
 @param enumType Class type of Enum
 @return Enum represented by String read from DataInput
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="writeEnum"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="enumVal" type="java.lang.Enum"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[writes String value of enum to DataOutput. 
 @param out Dataoutput stream
 @param enumVal enum value
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="skipFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Skip <i>len</i> number of bytes in input stream<i>in</i>
 @param in input stream
 @param len number of bytes to skip
 @throws IOException when skipped less number of bytes]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writables" type="org.apache.hadoop.io.Writable[]"/>
      <doc>
      <![CDATA[Convert writables to a byte array.
 @param writables input writables.
 @return ByteArray.]]>
      </doc>
    </method>
    <method name="readStringSafely" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="maxLength" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Read a string, but check it for sanity. The format consists of a vint
 followed by the given number of bytes.
 @param in the stream to read from
 @param maxLength the largest acceptable length of the encoded string
 @return the bytes as a string
 @throws IOException if reading from the DataInput fails
 @throws IllegalArgumentException if the encoded byte size for string 
             is negative or larger than maxSize. Only the vint is read.]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.io.WritableUtils -->
  <doc>
  <![CDATA[Generic i/o code for use when reading and writing data to the network,
to databases, and to files.]]>
  </doc>
</package>
<package name="org.apache.hadoop.io.compress">
  <!-- start class org.apache.hadoop.io.compress.BlockCompressorStream -->
  <class name="BlockCompressorStream" extends="org.apache.hadoop.io.compress.CompressorStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlockCompressorStream" type="java.io.OutputStream, org.apache.hadoop.io.compress.Compressor, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a {@link BlockCompressorStream}.
 
 @param out stream
 @param compressor compressor to be used
 @param bufferSize size of buffer
 @param compressionOverhead maximum 'overhead' of the compression 
                            algorithm with given bufferSize]]>
      </doc>
    </constructor>
    <constructor name="BlockCompressorStream" type="java.io.OutputStream, org.apache.hadoop.io.compress.Compressor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a {@link BlockCompressorStream} with given output-stream and 
 compressor.
 Use default of 512 as bufferSize and compressionOverhead of 
 (1% of bufferSize + 12 bytes) =  18 bytes (zlib algorithm).
 
 @param out stream
 @param compressor compressor to be used]]>
      </doc>
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write the data provided to the compression codec, compressing no more
 than the buffer size less the compression overhead as specified during
 construction for each block.

 Each block contains the uncompressed length for the block, followed by
 one or more length-prefixed blocks of compressed data.]]>
      </doc>
    </method>
    <method name="finish"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="compress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A {@link org.apache.hadoop.io.compress.CompressorStream} which works
 with 'block-based' based compression algorithms, as opposed to 
 'stream-based' compression algorithms.

 It should be noted that this wrapper does not guarantee that blocks will
 be sized for the compressor. If the
 {@link org.apache.hadoop.io.compress.Compressor} requires buffering to
 effect meaningful compression, it is responsible for it.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.BlockCompressorStream -->
  <!-- start class org.apache.hadoop.io.compress.BlockDecompressorStream -->
  <class name="BlockDecompressorStream" extends="org.apache.hadoop.io.compress.DecompressorStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlockDecompressorStream" type="java.io.InputStream, org.apache.hadoop.io.compress.Decompressor, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link BlockDecompressorStream}.
 
 @param in input stream
 @param decompressor decompressor to use
 @param bufferSize size of buffer
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </constructor>
    <constructor name="BlockDecompressorStream" type="java.io.InputStream, org.apache.hadoop.io.compress.Decompressor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link BlockDecompressorStream}.
 
 @param in input stream
 @param decompressor decompressor to use
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </constructor>
    <constructor name="BlockDecompressorStream" type="java.io.InputStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="decompress" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCompressedData" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="resetState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A {@link org.apache.hadoop.io.compress.DecompressorStream} which works
 with 'block-based' based compression algorithms, as opposed to 
 'stream-based' compression algorithms.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.BlockDecompressorStream -->
  <!-- start class org.apache.hadoop.io.compress.BZip2Codec -->
  <class name="BZip2Codec" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <implements name="org.apache.hadoop.io.compress.SplittableCompressionCodec"/>
    <constructor name="BZip2Codec"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of BZip2Codec.]]>
      </doc>
    </constructor>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Set the configuration to be used by this object.

 @param conf the configuration object.]]>
      </doc>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the configuration used by this object.

 @return the configuration object used by this objec.]]>
      </doc>
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionOutputStream} that will write to the given
 {@link OutputStream}.

 @param out        the location for the final output stream
 @return a stream the user can write uncompressed data to, to have it 
         compressed
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="compressor" type="org.apache.hadoop.io.compress.Compressor"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionOutputStream} that will write to the given
 {@link OutputStream} with the given {@link Compressor}.

 @param out        the location for the final output stream
 @param compressor compressor to use
 @return a stream the user can write uncompressed data to, to have it 
         compressed
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getCompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of {@link Compressor} needed by this {@link CompressionCodec}.

 @return the type of compressor needed by this codec.]]>
      </doc>
    </method>
    <method name="createCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link Compressor} for use by this {@link CompressionCodec}.

 @return a new compressor for use by this codec]]>
      </doc>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionInputStream} that will read from the given
 input stream and return a stream for uncompressed data.

 @param in the stream to read compressed bytes from
 @return a stream to read uncompressed bytes from
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionInputStream} that will read from the given
 {@link InputStream} with the given {@link Decompressor}, and return a 
 stream for uncompressed data.

 @param in           the stream to read compressed bytes from
 @param decompressor decompressor to use
 @return a stream to read uncompressed bytes from
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.SplitCompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seekableIn" type="java.io.InputStream"/>
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <param name="start" type="long"/>
      <param name="end" type="long"/>
      <param name="readMode" type="org.apache.hadoop.io.compress.SplittableCompressionCodec.READ_MODE"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates CompressionInputStream to be used to read off uncompressed data
 in one of the two reading modes. i.e. Continuous or Blocked reading modes

 @param seekableIn The InputStream
 @param start The start offset into the compressed stream
 @param end The end offset into the compressed stream
 @param readMode Controls whether progress is reported continuously or
                 only at block boundaries.

 @return CompressionInputStream for BZip2 aligned at block boundaries]]>
      </doc>
    </method>
    <method name="getDecompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of {@link Decompressor} needed by this {@link CompressionCodec}.

 @return the type of decompressor needed by this codec.]]>
      </doc>
    </method>
    <method name="createDecompressor" return="org.apache.hadoop.io.compress.Decompressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link Decompressor} for use by this {@link CompressionCodec}.

 @return a new decompressor for use by this codec]]>
      </doc>
    </method>
    <method name="getDefaultExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[.bz2 is recognized as the default extension for compressed BZip2 files

 @return A String telling the default bzip2 file extension]]>
      </doc>
    </method>
    <method name="writeHeader"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[This class provides output and input streams for bzip2 compression
 and decompression.  It uses the native bzip2 library on the system
 if possible, else it uses a pure-Java implementation of the bzip2
 algorithm.  The configuration parameter
 io.compression.codec.bzip2.library can be used to control this
 behavior.

 In the pure-Java mode, the Compressor and Decompressor interfaces
 are not implemented.  Therefore, in that mode, those methods of
 CompressionCodec which have a Compressor or Decompressor type
 argument, throw UnsupportedOperationException.

 Currently, support for splittability is available only in the
 pure-Java mode; therefore, if a SplitCompressionInputStream is
 requested, the pure-Java implementation is used, regardless of the
 setting of the configuration parameter mentioned above.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.BZip2Codec -->
  <!-- start class org.apache.hadoop.io.compress.CodecConstants -->
  <class name="CodecConstants" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <field name="DEFAULT_CODEC_EXTENSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default extension for {@link org.apache.hadoop.io.compress.DefaultCodec}.]]>
      </doc>
    </field>
    <field name="BZIP2_CODEC_EXTENSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default extension for {@link org.apache.hadoop.io.compress.BZip2Codec}.]]>
      </doc>
    </field>
    <field name="GZIP_CODEC_EXTENSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default extension for {@link org.apache.hadoop.io.compress.GzipCodec}.]]>
      </doc>
    </field>
    <field name="LZ4_CODEC_EXTENSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default extension for {@link org.apache.hadoop.io.compress.Lz4Codec}.]]>
      </doc>
    </field>
    <field name="PASSTHROUGH_CODEC_EXTENSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default extension for
 {@link org.apache.hadoop.io.compress.PassthroughCodec}.]]>
      </doc>
    </field>
    <field name="SNAPPY_CODEC_EXTENSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default extension for {@link org.apache.hadoop.io.compress.SnappyCodec}.]]>
      </doc>
    </field>
    <field name="ZSTANDARD_CODEC_EXTENSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default extension for {@link org.apache.hadoop.io.compress.ZStandardCodec}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Codec related constants.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.CodecConstants -->
  <!-- start class org.apache.hadoop.io.compress.CodecPool -->
  <class name="CodecPool" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CodecPool"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get a {@link Compressor} for the given {@link CompressionCodec} from the 
 pool or a new one.

 @param codec the <code>CompressionCodec</code> for which to get the 
              <code>Compressor</code>
 @param conf the <code>Configuration</code> object which contains confs for creating or reinit the compressor
 @return <code>Compressor</code> for the given 
         <code>CompressionCodec</code> from the pool or a new one]]>
      </doc>
    </method>
    <method name="getCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
    </method>
    <method name="getDecompressor" return="org.apache.hadoop.io.compress.Decompressor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <doc>
      <![CDATA[Get a {@link Decompressor} for the given {@link CompressionCodec} from the
 pool or a new one.
  
 @param codec the <code>CompressionCodec</code> for which to get the 
              <code>Decompressor</code>
 @return <code>Decompressor</code> for the given 
         <code>CompressionCodec</code> the pool or a new one]]>
      </doc>
    </method>
    <method name="returnCompressor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="compressor" type="org.apache.hadoop.io.compress.Compressor"/>
      <doc>
      <![CDATA[Return the {@link Compressor} to the pool.
 
 @param compressor the <code>Compressor</code> to be returned to the pool]]>
      </doc>
    </method>
    <method name="returnDecompressor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <doc>
      <![CDATA[Return the {@link Decompressor} to the pool.
 
 @param decompressor the <code>Decompressor</code> to be returned to the 
                     pool]]>
      </doc>
    </method>
    <method name="getLeasedCompressorsCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <doc>
      <![CDATA[Return the number of leased {@link Compressor}s for this
 {@link CompressionCodec}.

 @param codec codec.
 @return the number of leased.]]>
      </doc>
    </method>
    <method name="getLeasedDecompressorsCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <doc>
      <![CDATA[Return the number of leased {@link Decompressor}s for this
 {@link CompressionCodec}.

 @param codec codec.
 @return the number of leased]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A global compressor/decompressor pool used to save and reuse 
 (possibly native) compression/decompression codecs.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.CodecPool -->
  <!-- start interface org.apache.hadoop.io.compress.CompressionCodec -->
  <interface name="CompressionCodec"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionOutputStream} that will write to the given 
 {@link OutputStream}.
 
 @param out the location for the final output stream
 @return a stream the user can write uncompressed data to have it compressed
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="compressor" type="org.apache.hadoop.io.compress.Compressor"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionOutputStream} that will write to the given 
 {@link OutputStream} with the given {@link Compressor}.
 
 @param out the location for the final output stream
 @param compressor compressor to use
 @return a stream the user can write uncompressed data to have it compressed
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getCompressorType" return="java.lang.Class"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of {@link Compressor} needed by this {@link CompressionCodec}.
 
 @return the type of compressor needed by this codec.]]>
      </doc>
    </method>
    <method name="createCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link Compressor} for use by this {@link CompressionCodec}.
 
 @return a new compressor for use by this codec]]>
      </doc>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionInputStream} that will read from the given
 input stream.
 
 @param in the stream to read compressed bytes from
 @return a stream to read uncompressed bytes from
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionInputStream} that will read from the given 
 {@link InputStream} with the given {@link Decompressor}.
 
 @param in the stream to read compressed bytes from
 @param decompressor decompressor to use
 @return a stream to read uncompressed bytes from
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getDecompressorType" return="java.lang.Class"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of {@link Decompressor} needed by this {@link CompressionCodec}.
 
 @return the type of decompressor needed by this codec.]]>
      </doc>
    </method>
    <method name="createDecompressor" return="org.apache.hadoop.io.compress.Decompressor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link Decompressor} for use by this {@link CompressionCodec}.
 
 @return a new decompressor for use by this codec]]>
      </doc>
    </method>
    <method name="getDefaultExtension" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the default filename extension for this kind of compression.
 @return the extension including the '.']]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class encapsulates a streaming compression/decompression pair.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.compress.CompressionCodec -->
  <!-- start class org.apache.hadoop.io.compress.CompressionCodecFactory -->
  <class name="CompressionCodecFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CompressionCodecFactory" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Find the codecs specified in the config value io.compression.codecs 
 and register them. Defaults to gzip and deflate.

 @param conf configuration.]]>
      </doc>
    </constructor>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Print the extension map out as a string.]]>
      </doc>
    </method>
    <method name="getCodecClasses" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the list of codecs discovered via a Java ServiceLoader, or
 listed in the configuration. Codecs specified in configuration come
 later in the returned list, and are considered to override those
 from the ServiceLoader.
 @param conf the configuration to look in
 @return a list of the {@link CompressionCodec} classes]]>
      </doc>
    </method>
    <method name="setCodecClasses"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="classes" type="java.util.List"/>
      <doc>
      <![CDATA[Sets a list of codec classes in the configuration. In addition to any
 classes specified using this method, {@link CompressionCodec} classes on
 the classpath are discovered using a Java ServiceLoader.
 @param conf the configuration to modify
 @param classes the list of classes to set]]>
      </doc>
    </method>
    <method name="getCodec" return="org.apache.hadoop.io.compress.CompressionCodec"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Find the relevant compression codec for the given file based on its
 filename suffix.
 @param file the filename to check
 @return the codec object]]>
      </doc>
    </method>
    <method name="getCodecByClassName" return="org.apache.hadoop.io.compress.CompressionCodec"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classname" type="java.lang.String"/>
      <doc>
      <![CDATA[Find the relevant compression codec for the codec's canonical class name.
 @param classname the canonical class name of the codec
 @return the codec object]]>
      </doc>
    </method>
    <method name="getCodecByName" return="org.apache.hadoop.io.compress.CompressionCodec"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="codecName" type="java.lang.String"/>
      <doc>
      <![CDATA[Find the relevant compression codec for the codec's canonical class name
 or by codec alias.
 <p>
 Codec aliases are case insensitive.
 <p>
 The code alias is the short class name (without the package name).
 If the short class name ends with 'Codec', then there are two aliases for
 the codec, the complete short class name and the short class name without
 the 'Codec' ending. For example for the 'GzipCodec' codec class name the
 alias are 'gzip' and 'gzipcodec'.

 @param codecName the canonical class name of the codec
 @return the codec object]]>
      </doc>
    </method>
    <method name="getCodecClassByName" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="codecName" type="java.lang.String"/>
      <doc>
      <![CDATA[Find the relevant compression codec for the codec's canonical class name
 or by codec alias and returns its implemetation class.
 <p>
 Codec aliases are case insensitive.
 <p>
 The code alias is the short class name (without the package name).
 If the short class name ends with 'Codec', then there are two aliases for
 the codec, the complete short class name and the short class name without
 the 'Codec' ending. For example for the 'GzipCodec' codec class name the
 alias are 'gzip' and 'gzipcodec'.

 @param codecName the canonical class name of the codec
 @return the codec class]]>
      </doc>
    </method>
    <method name="removeSuffix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="java.lang.String"/>
      <param name="suffix" type="java.lang.String"/>
      <doc>
      <![CDATA[Removes a suffix from a filename, if it has it.
 @param filename the filename to strip
 @param suffix the suffix to remove
 @return the shortened filename]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[A little test program.
 @param args arguments.
 @throws Exception exception.]]>
      </doc>
    </method>
    <field name="LOG" type="org.slf4j.Logger"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A factory that will find the correct codec for a given filename.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.CompressionCodecFactory -->
  <!-- start class org.apache.hadoop.io.compress.CompressionInputStream -->
  <class name="CompressionInputStream" extends="java.io.InputStream"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.Seekable"/>
    <implements name="org.apache.hadoop.fs.statistics.IOStatisticsSource"/>
    <constructor name="CompressionInputStream" type="java.io.InputStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a compression input stream that reads
 the decompressed bytes from the given stream.
 
 @param in The input stream to be compressed.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getIOStatistics" return="org.apache.hadoop.fs.statistics.IOStatistics"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return any IOStatistics provided by the underlying stream.
 @return IO stats from the inner stream.]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read bytes from the stream.
 Made abstract to prevent leakage to underlying stream.]]>
      </doc>
    </method>
    <method name="resetState"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reset the decompressor to its initial state and discard any buffered data,
 as the underlying stream may have been repositioned.

 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getPos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This method returns the current position in the stream.

 @return Current position in stream as a long]]>
      </doc>
    </method>
    <method name="seek"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pos" type="long"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[This method is current not supported.

 @throws UnsupportedOperationException Unsupported Operation Exception.]]>
      </doc>
    </method>
    <method name="seekToNewSource" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetPos" type="long"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[This method is current not supported.

 @throws UnsupportedOperationException Unsupported Operation Exception.]]>
      </doc>
    </method>
    <field name="in" type="java.io.InputStream"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The input stream to be compressed.]]>
      </doc>
    </field>
    <field name="maxAvailableData" type="long"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A compression input stream.

 <p>Implementations are assumed to be buffered.  This permits clients to
 reposition the underlying input stream then call {@link #resetState()},
 without having to also synchronize client buffers.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.CompressionInputStream -->
  <!-- start class org.apache.hadoop.io.compress.CompressionOutputStream -->
  <class name="CompressionOutputStream" extends="java.io.OutputStream"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.statistics.IOStatisticsSource"/>
    <constructor name="CompressionOutputStream" type="java.io.OutputStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a compression output stream that writes
 the compressed bytes to the given stream.
 @param out out.]]>
      </doc>
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write compressed bytes to the stream.
 Made abstract to prevent leakage to underlying stream.]]>
      </doc>
    </method>
    <method name="finish"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Finishes writing compressed data to the output stream 
 without closing the underlying stream.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="resetState"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reset the compression to the initial state. 
 Does not reset the underlying stream.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getIOStatistics" return="org.apache.hadoop.fs.statistics.IOStatistics"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return any IOStatistics provided by the underlying stream.
 @return IO stats from the inner stream.]]>
      </doc>
    </method>
    <field name="out" type="java.io.OutputStream"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The output stream to be compressed.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A compression output stream.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.CompressionOutputStream -->
  <!-- start interface org.apache.hadoop.io.compress.Compressor -->
  <interface name="Compressor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setInput"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Sets input data for compression. 
 This should be called whenever #needsInput() returns 
 <code>true</code> indicating that more input data is required.
 
 @param b Input data
 @param off Start offset
 @param len Length]]>
      </doc>
    </method>
    <method name="needsInput" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the input data buffer is empty and 
 #setInput() should be called to provide more input. 
 
 @return <code>true</code> if the input data buffer is empty and 
 #setInput() should be called in order to provide more input.]]>
      </doc>
    </method>
    <method name="setDictionary"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Sets preset dictionary for compression. A preset dictionary 
 is used when the history buffer can be predetermined. 

 @param b Dictionary data bytes
 @param off Start offset
 @param len Length]]>
      </doc>
    </method>
    <method name="getBytesRead" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return number of uncompressed bytes input so far.
 @return bytes read.]]>
      </doc>
    </method>
    <method name="getBytesWritten" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return number of compressed bytes output so far.
 @return bytes written.]]>
      </doc>
    </method>
    <method name="finish"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When called, indicates that compression should end
 with the current contents of the input buffer.]]>
      </doc>
    </method>
    <method name="finished" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the end of the compressed 
 data output stream has been reached.
 @return <code>true</code> if the end of the compressed
 data output stream has been reached.]]>
      </doc>
    </method>
    <method name="compress" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fills specified buffer with compressed data. Returns actual number
 of bytes of compressed data. A return value of 0 indicates that
 needsInput() should be called in order to determine if more input
 data is required.
 
 @param b Buffer for the compressed data
 @param off Start offset of the data
 @param len Size of the buffer
 @return The actual number of bytes of compressed data.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="reset"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resets compressor so that a new set of input data can be processed.]]>
      </doc>
    </method>
    <method name="end"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Closes the compressor and discards any unprocessed input.]]>
      </doc>
    </method>
    <method name="reinit"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Prepare the compressor to be used in a new stream with settings defined in
 the given Configuration
 
 @param conf Configuration from which new setting are fetched]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Specification of a stream-based 'compressor' which can be  
 plugged into a {@link CompressionOutputStream} to compress data.
 This is modelled after {@link java.util.zip.Deflater}]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.compress.Compressor -->
  <!-- start class org.apache.hadoop.io.compress.CompressorStream -->
  <class name="CompressorStream" extends="org.apache.hadoop.io.compress.CompressionOutputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CompressorStream" type="java.io.OutputStream, org.apache.hadoop.io.compress.Compressor, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CompressorStream" type="java.io.OutputStream, org.apache.hadoop.io.compress.Compressor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CompressorStream" type="java.io.OutputStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Allow derived classes to directly set the underlying stream.
 
 @param out Underlying output stream.]]>
      </doc>
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="compress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="finish"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="resetState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="compressor" type="org.apache.hadoop.io.compress.Compressor"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="buffer" type="byte[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="closed" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.io.compress.CompressorStream -->
  <!-- start interface org.apache.hadoop.io.compress.Decompressor -->
  <interface name="Decompressor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setInput"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Sets input data for decompression. 
 This should be called if and only if {@link #needsInput()} returns 
 <code>true</code> indicating that more input data is required.
 (Both native and non-native versions of various Decompressors require
 that the data passed in via <code>b[]</code> remain unmodified until
 the caller is explicitly notified--via {@link #needsInput()}--that the
 buffer may be safely modified.  With this requirement, an extra
 buffer-copy can be avoided.)
 
 @param b Input data
 @param off Start offset
 @param len Length]]>
      </doc>
    </method>
    <method name="needsInput" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if the input data buffer is empty and 
 {@link #setInput(byte[], int, int)} should be called to
 provide more input. 
 
 @return <code>true</code> if the input data buffer is empty and 
 {@link #setInput(byte[], int, int)} should be called in
 order to provide more input.]]>
      </doc>
    </method>
    <method name="setDictionary"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Sets preset dictionary for compression. A preset dictionary
 is used when the history buffer can be predetermined. 

 @param b Dictionary data bytes
 @param off Start offset
 @param len Length]]>
      </doc>
    </method>
    <method name="needsDictionary" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if a preset dictionary is needed for decompression.
 @return <code>true</code> if a preset dictionary is needed for decompression]]>
      </doc>
    </method>
    <method name="finished" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if the end of the decompressed 
 data output stream has been reached. Indicates a concatenated data stream
 when finished() returns <code>true</code> and {@link #getRemaining()}
 returns a positive value. finished() will be reset with the
 {@link #reset()} method.
 @return <code>true</code> if the end of the decompressed
 data output stream has been reached.]]>
      </doc>
    </method>
    <method name="decompress" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fills specified buffer with uncompressed data. Returns actual number
 of bytes of uncompressed data. A return value of 0 indicates that
 {@link #needsInput()} should be called in order to determine if more
 input data is required.
 
 @param b Buffer for the uncompressed data
 @param off Start offset of the data
 @param len Size of the buffer
 @return The actual number of bytes of uncompressed data.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getRemaining" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of bytes remaining in the compressed data buffer.
 Indicates a concatenated data stream if {@link #finished()} returns
 <code>true</code> and getRemaining() returns a positive value. If
 {@link #finished()} returns <code>true</code> and getRemaining() returns
 a zero value, indicates that the end of data stream has been reached and
 is not a concatenated data stream. 
 @return The number of bytes remaining in the compressed data buffer.]]>
      </doc>
    </method>
    <method name="reset"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resets decompressor and input and output buffers so that a new set of
 input data can be processed. If {@link #finished()}} returns
 <code>true</code> and {@link #getRemaining()} returns a positive value,
 reset() is called before processing of the next data stream in the
 concatenated data stream. {@link #finished()} will be reset and will
 return <code>false</code> when reset() is called.]]>
      </doc>
    </method>
    <method name="end"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Closes the decompressor and discards any unprocessed input.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Specification of a stream-based 'de-compressor' which can be  
 plugged into a {@link CompressionInputStream} to compress data.
 This is modelled after {@link java.util.zip.Inflater}]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.compress.Decompressor -->
  <!-- start class org.apache.hadoop.io.compress.DecompressorStream -->
  <class name="DecompressorStream" extends="org.apache.hadoop.io.compress.CompressionInputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DecompressorStream" type="java.io.InputStream, org.apache.hadoop.io.compress.Decompressor, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="DecompressorStream" type="java.io.InputStream, org.apache.hadoop.io.compress.Decompressor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="DecompressorStream" type="java.io.InputStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Allow derived classes to directly set the underlying stream.
 
 @param in Underlying input stream.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </constructor>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="decompress" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCompressedData" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="checkStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="resetState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="available" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="markSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readlimit" type="int"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="buffer" type="byte[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="eof" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="closed" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.io.compress.DecompressorStream -->
  <!-- start class org.apache.hadoop.io.compress.DefaultCodec -->
  <class name="DefaultCodec" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <implements name="org.apache.hadoop.io.compress.CompressionCodec"/>
    <implements name="org.apache.hadoop.io.compress.DirectDecompressionCodec"/>
    <constructor name="DefaultCodec"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="compressor" type="org.apache.hadoop.io.compress.Compressor"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getDecompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createDecompressor" return="org.apache.hadoop.io.compress.Decompressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createDirectDecompressor" return="org.apache.hadoop.io.compress.DirectDecompressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="getDefaultExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.io.compress.DefaultCodec -->
  <!-- start interface org.apache.hadoop.io.compress.DirectDecompressionCodec -->
  <interface name="DirectDecompressionCodec"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.compress.CompressionCodec"/>
    <method name="createDirectDecompressor" return="org.apache.hadoop.io.compress.DirectDecompressor"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link DirectDecompressor} for use by this {@link DirectDecompressionCodec}.
 
 @return a new direct decompressor for use by this codec]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class encapsulates a codec which can decompress direct bytebuffers.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.compress.DirectDecompressionCodec -->
  <!-- start interface org.apache.hadoop.io.compress.DirectDecompressor -->
  <interface name="DirectDecompressor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="decompress"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="java.nio.ByteBuffer"/>
      <param name="dst" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Specification of a direct ByteBuffer 'de-compressor'.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.compress.DirectDecompressor -->
  <!-- start class org.apache.hadoop.io.compress.GzipCodec -->
  <class name="GzipCodec" extends="org.apache.hadoop.io.compress.DefaultCodec"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GzipCodec"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="compressor" type="org.apache.hadoop.io.compress.Compressor"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createDecompressor" return="org.apache.hadoop.io.compress.Decompressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDecompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createDirectDecompressor" return="org.apache.hadoop.io.compress.DirectDecompressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDefaultExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This class creates gzip compressors/decompressors.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.GzipCodec -->
  <!-- start class org.apache.hadoop.io.compress.PassthroughCodec -->
  <class name="PassthroughCodec" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <implements name="org.apache.hadoop.io.compress.CompressionCodec"/>
    <constructor name="PassthroughCodec"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getDefaultExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="compressor" type="org.apache.hadoop.io.compress.Compressor"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getDecompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createDecompressor" return="org.apache.hadoop.io.compress.Decompressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="CLASSNAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Classname of the codec: {@value}.]]>
      </doc>
    </field>
    <field name="OPT_EXTENSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Option to control the extension of the code: {@value}.]]>
      </doc>
    </field>
    <field name="DEFAULT_EXTENSION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This default extension is here so that if no extension has been defined,
 some value is still returned: {@value}..]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This is a special codec which does not transform the output.
 It can be declared as a codec in the option "io.compression.codecs",
 and then it will declare that it supports the file extension
 set in {@link #OPT_EXTENSION}.

 This allows decompression to be disabled on a job, even when there is
 a registered/discoverable decompression codec for a file extension
 -without having to change the standard codec binding mechanism.

 For example, to disable decompression for a gzipped files, set the
 options
 <pre>
   io.compression.codecs = org.apache.hadoop.io.compress.PassthroughCodec
   io.compress.passthrough.extension = .gz
 </pre>

 <i>Note:</i> this is not a Splittable codec: it doesn't know the
 capabilities of the passed in stream. It should be possible to
 extend this in a subclass: the inner classes are marked as protected
 to enable this. <i>Do not retrofit splitting to this class.</i>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.PassthroughCodec -->
  <!-- start class org.apache.hadoop.io.compress.SplitCompressionInputStream -->
  <class name="SplitCompressionInputStream" extends="org.apache.hadoop.io.compress.CompressionInputStream"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SplitCompressionInputStream" type="java.io.InputStream, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="setStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="start" type="long"/>
    </method>
    <method name="setEnd"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="end" type="long"/>
    </method>
    <method name="getAdjustedStart" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[After calling createInputStream, the values of start or end
 might change.  So this method can be used to get the new value of start.
 @return The changed value of start]]>
      </doc>
    </method>
    <method name="getAdjustedEnd" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[After calling createInputStream, the values of start or end
 might change.  So this method can be used to get the new value of end.
 @return The changed value of end]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An InputStream covering a range of compressed data. The start and end
 offsets requested by a client may be modified by the codec to fit block
 boundaries or other algorithm-dependent requirements.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.SplitCompressionInputStream -->
  <!-- start interface org.apache.hadoop.io.compress.SplittableCompressionCodec -->
  <interface name="SplittableCompressionCodec"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.compress.CompressionCodec"/>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.SplitCompressionInputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seekableIn" type="java.io.InputStream"/>
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <param name="start" type="long"/>
      <param name="end" type="long"/>
      <param name="readMode" type="org.apache.hadoop.io.compress.SplittableCompressionCodec.READ_MODE"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a stream as dictated by the readMode.  This method is used when
 the codecs wants the ability to work with the underlying stream positions.

 @param decompressor decompressor.
 @param seekableIn  The seekable input stream (seeks in compressed data)
 @param start The start offset into the compressed stream. May be changed
              by the underlying codec.
 @param end The end offset into the compressed stream. May be changed by
            the underlying codec.
 @param readMode Controls whether stream position is reported continuously
                 from the compressed stream only only at block boundaries.
 @return  a stream to read uncompressed bytes from
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This interface is meant to be implemented by those compression codecs
 which are capable to compress / de-compress a stream starting at any
 arbitrary position.

 Especially the process of de-compressing a stream starting at some arbitrary
 position is challenging.  Most of the codecs are only able to successfully
 de-compress a stream, if they start from the very beginning till the end.
 One of the reasons is the stored state at the beginning of the stream which
 is crucial for de-compression.

 Yet there are few codecs which do not save the whole state at the beginning
 of the stream and hence can be used to de-compress stream starting at any
 arbitrary points.  This interface is meant to be used by such codecs.  Such
 codecs are highly valuable, especially in the context of Hadoop, because
 an input compressed file can be split and hence can be worked on by multiple
 machines in parallel.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.compress.SplittableCompressionCodec -->
</package>
<package name="org.apache.hadoop.io.erasurecode">
  <!-- start class org.apache.hadoop.io.erasurecode.ECSchema -->
  <class name="ECSchema" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="ECSchema" type="java.util.Map"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with schema name and provided all options. Note the options may
 contain additional information for the erasure codec to interpret further.
 @param allOptions all schema options]]>
      </doc>
    </constructor>
    <constructor name="ECSchema" type="java.lang.String, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with key parameters provided.
 @param codecName codec name
 @param numDataUnits number of data units used in the schema
 @param numParityUnits number os parity units used in the schema]]>
      </doc>
    </constructor>
    <constructor name="ECSchema" type="java.lang.String, int, int, java.util.Map"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with key parameters provided. Note the extraOptions may contain
 additional information for the erasure codec to interpret further.
 @param codecName codec name
 @param numDataUnits number of data units used in the schema
 @param numParityUnits number os parity units used in the schema
 @param extraOptions extra options to configure the codec]]>
      </doc>
    </constructor>
    <method name="getCodecName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the codec name
 @return codec name]]>
      </doc>
    </method>
    <method name="getExtraOptions" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get extra options specific to a erasure code.
 @return extra options]]>
      </doc>
    </method>
    <method name="getNumDataUnits" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get required data units count in a coding group
 @return count of data units]]>
      </doc>
    </method>
    <method name="getNumParityUnits" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get required parity units count in a coding group
 @return count of parity units]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Make a meaningful string representation for log output.
 @return string representation]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="NUM_DATA_UNITS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NUM_PARITY_UNITS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CODEC_NAME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Erasure coding schema to housekeeper relevant information.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.erasurecode.ECSchema -->
</package>
<package name="org.apache.hadoop.io.erasurecode.coder.util">
</package>
<package name="org.apache.hadoop.io.erasurecode.grouper">
</package>
<package name="org.apache.hadoop.io.file.tfile">
  <!-- start class org.apache.hadoop.io.file.tfile.MetaBlockAlreadyExists -->
  <class name="MetaBlockAlreadyExists" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Exception - Meta Block with the same name already exists.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.file.tfile.MetaBlockAlreadyExists -->
  <!-- start class org.apache.hadoop.io.file.tfile.MetaBlockDoesNotExist -->
  <class name="MetaBlockDoesNotExist" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Exception - No such Meta Block with the given name.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.file.tfile.MetaBlockDoesNotExist -->
  <!-- start interface org.apache.hadoop.io.file.tfile.RawComparable -->
  <interface name="RawComparable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="buffer" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the underlying byte array.
 
 @return The underlying byte array.]]>
      </doc>
    </method>
    <method name="offset" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the offset of the first byte in the byte array.
 
 @return The offset of the first byte in the byte array.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the size of the byte range in the byte array.
 
 @return The size of the byte range in the byte array.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface for objects that can be compared through {@link RawComparator}.
 This is useful in places where we need a single object reference to specify a
 range of bytes in a byte array, such as {@link Comparable} or
 {@link Collections#binarySearch(java.util.List, Object, Comparator)}
 
 The actual comparison among RawComparable's requires an external
 RawComparator and it is applications' responsibility to ensure two
 RawComparable are supposed to be semantically comparable with the same
 RawComparator.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.file.tfile.RawComparable -->
  <!-- start class org.apache.hadoop.io.file.tfile.TFile -->
  <class name="TFile" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="makeComparator" return="java.util.Comparator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Make a raw comparator from a string name.
 
 @param name
          Comparator name
 @return A RawComparable comparator.]]>
      </doc>
    </method>
    <method name="getSupportedCompressionAlgorithms" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get names of supported compression algorithms. The names are acceptable by
 TFile.Writer.
 
 @return Array of strings, each represents a supported compression
         algorithm. Currently, the following compression algorithms are
         supported.
         <ul>
         <li>"none" - No compression.
         <li>"lzo" - LZO compression.
         <li>"gz" - GZIP compression.
         </ul>]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Dumping the TFile information.
 
 @param args
          A list of TFile paths.]]>
      </doc>
    </method>
    <field name="COMPRESSION_GZ" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[compression: gzip]]>
      </doc>
    </field>
    <field name="COMPRESSION_LZO" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[compression: lzo]]>
      </doc>
    </field>
    <field name="COMPRESSION_NONE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[compression: none]]>
      </doc>
    </field>
    <field name="COMPARATOR_MEMCMP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[comparator: memcmp]]>
      </doc>
    </field>
    <field name="COMPARATOR_JCLASS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[comparator prefix: java class]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A TFile is a container of key-value pairs. Both keys and values are type-less
 bytes. Keys are restricted to 64KB, value length is not restricted
 (practically limited to the available disk storage). TFile further provides
 the following features:
 <ul>
 <li>Block Compression.
 <li>Named meta data blocks.
 <li>Sorted or unsorted keys.
 <li>Seek by key or by file offset.
 </ul>
 The memory footprint of a TFile includes the following:
 <ul>
 <li>Some constant overhead of reading or writing a compressed block.
 <ul>
 <li>Each compressed block requires one compression/decompression codec for
 I/O.
 <li>Temporary space to buffer the key.
 <li>Temporary space to buffer the value (for TFile.Writer only). Values are
 chunk encoded, so that we buffer at most one chunk of user data. By default,
 the chunk buffer is 1MB. Reading chunked value does not require additional
 memory.
 </ul>
 <li>TFile index, which is proportional to the total number of Data Blocks.
 The total amount of memory needed to hold the index can be estimated as
 (56+AvgKeySize)*NumBlocks.
 <li>MetaBlock index, which is proportional to the total number of Meta
 Blocks.The total amount of memory needed to hold the index for Meta Blocks
 can be estimated as (40+AvgMetaBlockName)*NumMetaBlock.
 </ul>
 <p>
 The behavior of TFile can be customized by the following variables through
 Configuration:
 <ul>
 <li><b>tfile.io.chunk.size</b>: Value chunk size. Integer (in bytes). Default
 to 1MB. Values of the length less than the chunk size is guaranteed to have
 known value length in read time (See
 {@link TFile.Reader.Scanner.Entry#isValueLengthKnown()}).
 <li><b>tfile.fs.output.buffer.size</b>: Buffer size used for
 FSDataOutputStream. Integer (in bytes). Default to 256KB.
 <li><b>tfile.fs.input.buffer.size</b>: Buffer size used for
 FSDataInputStream. Integer (in bytes). Default to 256KB.
 </ul>
 <p>
 Suggestions on performance optimization.
 <ul>
 <li>Minimum block size. We recommend a setting of minimum block size between
 256KB to 1MB for general usage. Larger block size is preferred if files are
 primarily for sequential access. However, it would lead to inefficient random
 access (because there are more data to decompress). Smaller blocks are good
 for random access, but require more memory to hold the block index, and may
 be slower to create (because we must flush the compressor stream at the
 conclusion of each data block, which leads to an FS I/O flush). Further, due
 to the internal caching in Compression codec, the smallest possible block
 size would be around 20KB-30KB.
 <li>The current implementation does not offer true multi-threading for
 reading. The implementation uses FSDataInputStream seek()+read(), which is
 shown to be much faster than positioned-read call in single thread mode.
 However, it also means that if multiple threads attempt to access the same
 TFile (using multiple scanners) simultaneously, the actual I/O is carried out
 sequentially even if they access different DFS blocks.
 <li>Compression codec. Use "none" if the data is not very compressable (by
 compressable, I mean a compression ratio at least 2:1). Generally, use "lzo"
 as the starting point for experimenting. "gz" overs slightly better
 compression ratio over "lzo" but requires 4x CPU to compress and 2x CPU to
 decompress, comparing to "lzo".
 <li>File system buffering, if the underlying FSDataInputStream and
 FSDataOutputStream is already adequately buffered; or if applications
 reads/writes keys and values in large buffers, we can reduce the sizes of
 input/output buffering in TFile layer by setting the configuration parameters
 "tfile.fs.input.buffer.size" and "tfile.fs.output.buffer.size".
 </ul>
 
 Some design rationale behind TFile can be found at <a
 href=https://issues.apache.org/jira/browse/HADOOP-3315>Hadoop-3315</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.file.tfile.TFile -->
  <!-- start class org.apache.hadoop.io.file.tfile.Utils -->
  <class name="Utils" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="writeVInt"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="n" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Encoding an integer into a variable-length encoding format. Synonymous to
 <code>Utils#writeVLong(out, n)</code>.
 
 @param out
          output stream
 @param n
          The integer to be encoded
 @throws IOException raised on errors performing I/O.
 @see Utils#writeVLong(DataOutput, long)]]>
      </doc>
    </method>
    <method name="writeVLong"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Encoding a Long integer into a variable-length encoding format.
 <ul>
 <li>if n in [-32, 127): encode in one byte with the actual value.
 Otherwise,
 <li>if n in [-20*2^8, 20*2^8): encode in two bytes: byte[0] = n/256 - 52;
 byte[1]=n&amp;0xff. Otherwise,
 <li>if n IN [-16*2^16, 16*2^16): encode in three bytes: byte[0]=n/2^16 -
 88; byte[1]=(n&gt;&gt;8)&amp;0xff; byte[2]=n&amp;0xff. Otherwise,
 <li>if n in [-8*2^24, 8*2^24): encode in four bytes: byte[0]=n/2^24 - 112;
 byte[1] = (n&gt;&gt;16)&amp;0xff; byte[2] = (n&gt;&gt;8)&amp;0xff;
 byte[3]=n&amp;0xff.
 Otherwise:
 <li>if n in [-2^31, 2^31): encode in five bytes: byte[0]=-125; byte[1] =
 (n&gt;&gt;24)&amp;0xff; byte[2]=(n&gt;&gt;16)&amp;0xff;
 byte[3]=(n&gt;&gt;8)&amp;0xff; byte[4]=n&amp;0xff;
 <li>if n in [-2^39, 2^39): encode in six bytes: byte[0]=-124; byte[1] =
 (n&gt;&gt;32)&amp;0xff; byte[2]=(n&gt;&gt;24)&amp;0xff;
 byte[3]=(n&gt;&gt;16)&amp;0xff; byte[4]=(n&gt;&gt;8)&amp;0xff;
 byte[5]=n&amp;0xff
 <li>if n in [-2^47, 2^47): encode in seven bytes: byte[0]=-123; byte[1] =
 (n&gt;&gt;40)&amp;0xff; byte[2]=(n&gt;&gt;32)&amp;0xff;
 byte[3]=(n&gt;&gt;24)&amp;0xff; byte[4]=(n&gt;&gt;16)&amp;0xff;
 byte[5]=(n&gt;&gt;8)&amp;0xff; byte[6]=n&amp;0xff;
 <li>if n in [-2^55, 2^55): encode in eight bytes: byte[0]=-122; byte[1] =
 (n&gt;&gt;48)&amp;0xff; byte[2] = (n&gt;&gt;40)&amp;0xff;
 byte[3]=(n&gt;&gt;32)&amp;0xff; byte[4]=(n&gt;&gt;24)&amp;0xff; byte[5]=
 (n&gt;&gt;16)&amp;0xff; byte[6]=(n&gt;&gt;8)&amp;0xff; byte[7]=n&amp;0xff;
 <li>if n in [-2^63, 2^63): encode in nine bytes: byte[0]=-121; byte[1] =
 (n&gt;&gt;54)&amp;0xff; byte[2] = (n&gt;&gt;48)&amp;0xff;
 byte[3] = (n&gt;&gt;40)&amp;0xff; byte[4]=(n&gt;&gt;32)&amp;0xff;
 byte[5]=(n&gt;&gt;24)&amp;0xff; byte[6]=(n&gt;&gt;16)&amp;0xff; byte[7]=
 (n&gt;&gt;8)&amp;0xff; byte[8]=n&amp;0xff;
 </ul>
 
 @param out
          output stream
 @param n
          the integer number
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="readVInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Decoding the variable-length integer. Synonymous to
 <code>(int)Utils#readVLong(in)</code>.
 
 @param in
          input stream
 @return the decoded integer
 @throws IOException raised on errors performing I/O.
 
 @see Utils#readVLong(DataInput)]]>
      </doc>
    </method>
    <method name="readVLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Decoding the variable-length integer. Suppose the value of the first byte
 is FB, and the following bytes are NB[*].
 <ul>
 <li>if (FB &gt;= -32), return (long)FB;
 <li>if (FB in [-72, -33]), return (FB+52)&lt;&lt;8 + NB[0]&amp;0xff;
 <li>if (FB in [-104, -73]), return (FB+88)&lt;&lt;16 +
 (NB[0]&amp;0xff)&lt;&lt;8 + NB[1]&amp;0xff;
 <li>if (FB in [-120, -105]), return (FB+112)&lt;&lt;24 + (NB[0]&amp;0xff)
 &lt;&lt;16 + (NB[1]&amp;0xff)&lt;&lt;8 + NB[2]&amp;0xff;
 <li>if (FB in [-128, -121]), return interpret NB[FB+129] as a signed
 big-endian integer.
 </ul>
 @param in
          input stream
 @return the decoded long integer.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="writeString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="s" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a String as a VInt n, followed by n Bytes as in Text format.
 
 @param out out.
 @param s s.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a String as a VInt n, followed by n Bytes in Text format.
 
 @param in
          The input stream.
 @return The string
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="lowerBound" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="list" type="java.util.List"/>
      <param name="key" type="T"/>
      <param name="cmp" type="java.util.Comparator"/>
      <doc>
      <![CDATA[Lower bound binary search. Find the index to the first element in the list
 that compares greater than or equal to key.
 
 @param <T>
          Type of the input key.
 @param list
          The list
 @param key
          The input key.
 @param cmp
          Comparator for the key.
 @return The index to the desired element if it exists; or list.size()
         otherwise.]]>
      </doc>
    </method>
    <method name="upperBound" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="list" type="java.util.List"/>
      <param name="key" type="T"/>
      <param name="cmp" type="java.util.Comparator"/>
      <doc>
      <![CDATA[Upper bound binary search. Find the index to the first element in the list
 that compares greater than the input key.
 
 @param <T>
          Type of the input key.
 @param list
          The list
 @param key
          The input key.
 @param cmp
          Comparator for the key.
 @return The index to the desired element if it exists; or list.size()
         otherwise.]]>
      </doc>
    </method>
    <method name="lowerBound" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="list" type="java.util.List"/>
      <param name="key" type="T"/>
      <doc>
      <![CDATA[Lower bound binary search. Find the index to the first element in the list
 that compares greater than or equal to key.
 
 @param <T>
          Type of the input key.
 @param list
          The list
 @param key
          The input key.
 @return The index to the desired element if it exists; or list.size()
         otherwise.]]>
      </doc>
    </method>
    <method name="upperBound" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="list" type="java.util.List"/>
      <param name="key" type="T"/>
      <doc>
      <![CDATA[Upper bound binary search. Find the index to the first element in the list
 that compares greater than the input key.
 
 @param <T>
          Type of the input key.
 @param list
          The list
 @param key
          The input key.
 @return The index to the desired element if it exists; or list.size()
         otherwise.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Supporting Utility classes used by TFile, and shared by users of TFile.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.file.tfile.Utils -->
</package>
<package name="org.apache.hadoop.io.serializer">
  <!-- start class org.apache.hadoop.io.serializer.JavaSerialization -->
  <class name="JavaSerialization" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.serializer.Serialization"/>
    <constructor name="JavaSerialization"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[<p>
 An experimental {@link Serialization} for Java {@link Serializable} classes.
 </p>
 @see JavaSerializationComparator]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.serializer.JavaSerialization -->
  <!-- start class org.apache.hadoop.io.serializer.JavaSerializationComparator -->
  <class name="JavaSerializationComparator" extends="org.apache.hadoop.io.serializer.DeserializerComparator"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JavaSerializationComparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <doc>
    <![CDATA[<p>
 A {@link RawComparator} that uses a {@link JavaSerialization}
 {@link Deserializer} to deserialize objects that are then compared via
 their {@link Comparable} interfaces.
 </p>
 @param <T> generic type.
 @see JavaSerialization]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.serializer.JavaSerializationComparator -->
  <!-- start class org.apache.hadoop.io.serializer.WritableSerialization -->
  <class name="WritableSerialization" extends="org.apache.hadoop.conf.Configured"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.serializer.Serialization"/>
    <constructor name="WritableSerialization"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[A {@link Serialization} for {@link Writable}s that delegates to
 {@link Writable#write(java.io.DataOutput)} and
 {@link Writable#readFields(java.io.DataInput)}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.serializer.WritableSerialization -->
  <doc>
  <![CDATA[<p>
This package provides a mechanism for using different serialization frameworks
in Hadoop. The property "io.serializations" defines a list of
{@link org.apache.hadoop.io.serializer.Serialization}s that know how to create
{@link org.apache.hadoop.io.serializer.Serializer}s and
{@link org.apache.hadoop.io.serializer.Deserializer}s.
</p>

<p>
To add a new serialization framework write an implementation of
{@link org.apache.hadoop.io.serializer.Serialization} and add its name to the
"io.serializations" property.
</p>]]>
  </doc>
</package>
<package name="org.apache.hadoop.io.serializer.avro">
  <!-- start interface org.apache.hadoop.io.serializer.avro.AvroReflectSerializable -->
  <interface name="AvroReflectSerializable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Tag interface for Avro 'reflect' serializable classes. Classes implementing 
 this interface can be serialized/deserialized using 
 {@link AvroReflectSerialization}.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.serializer.avro.AvroReflectSerializable -->
  <!-- start class org.apache.hadoop.io.serializer.avro.AvroReflectSerialization -->
  <class name="AvroReflectSerialization" extends="org.apache.hadoop.io.serializer.avro.AvroSerialization"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AvroReflectSerialization"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="AVRO_REFLECT_PACKAGES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to configure packages that contain classes to be serialized and 
 deserialized using this class. Multiple packages can be specified using 
 comma-separated list.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serialization for Avro Reflect classes. For a class to be accepted by this 
 serialization, it must either be in the package list configured via 
 <code>avro.reflect.pkgs</code> or implement 
 {@link AvroReflectSerializable} interface.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.serializer.avro.AvroReflectSerialization -->
  <!-- start class org.apache.hadoop.io.serializer.avro.AvroSerialization -->
  <class name="AvroSerialization" extends="org.apache.hadoop.conf.Configured"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.serializer.Serialization"/>
    <constructor name="AvroSerialization"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="AVRO_SCHEMA_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Base class for providing serialization to Avro types.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.serializer.avro.AvroSerialization -->
  <!-- start class org.apache.hadoop.io.serializer.avro.AvroSpecificSerialization -->
  <class name="AvroSpecificSerialization" extends="org.apache.hadoop.io.serializer.avro.AvroSerialization"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AvroSpecificSerialization"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Serialization for Avro Specific classes. This serialization is to be used 
 for classes generated by Avro's 'specific' compiler.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.serializer.avro.AvroSpecificSerialization -->
  <doc>
  <![CDATA[<p>
This package provides Avro serialization in Hadoop. This can be used to 
serialize/deserialize Avro types in Hadoop.
</p>

<p>
Use {@link org.apache.hadoop.io.serializer.avro.AvroSpecificSerialization} for 
serialization of classes generated by Avro's 'specific' compiler.
</p>

<p>
Use {@link org.apache.hadoop.io.serializer.avro.AvroReflectSerialization} for 
other classes. 
{@link org.apache.hadoop.io.serializer.avro.AvroReflectSerialization} work for  
any class which is either in the package list configured via 
{@link org.apache.hadoop.io.serializer.avro.AvroReflectSerialization#AVRO_REFLECT_PACKAGES} 
or implement {@link org.apache.hadoop.io.serializer.avro.AvroReflectSerializable}
interface.
</p>]]>
  </doc>
</package>
<package name="org.apache.hadoop.ipc.protocolPB">
</package>
<package name="org.apache.hadoop.log">
</package>
<package name="org.apache.hadoop.log.metrics">
  <!-- start class org.apache.hadoop.log.metrics.EventCounter -->
  <class name="EventCounter" extends="org.apache.log4j.AppenderSkeleton"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EventCounter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="org.apache.log4j.spi.LoggingEvent"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="requiresLayout" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A log4J Appender that simply counts logging events in three levels:
 fatal, error and warn. The class name is used in log4j.properties]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.log.metrics.EventCounter -->
</package>
<package name="org.apache.hadoop.metrics2">
  <!-- start class org.apache.hadoop.metrics2.AbstractMetric -->
  <class name="AbstractMetric" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics2.MetricsInfo"/>
    <constructor name="AbstractMetric" type="org.apache.hadoop.metrics2.MetricsInfo"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the metric
 @param info  about the metric]]>
      </doc>
    </constructor>
    <method name="name" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="description" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="info" return="org.apache.hadoop.metrics2.MetricsInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="value" return="java.lang.Number"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the value of the metric
 @return the value of the metric]]>
      </doc>
    </method>
    <method name="type" return="org.apache.hadoop.metrics2.MetricType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of the metric
 @return the type of the metric]]>
      </doc>
    </method>
    <method name="visit"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="org.apache.hadoop.metrics2.MetricsVisitor"/>
      <doc>
      <![CDATA[Accept a visitor interface
 @param visitor of the metric]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[The immutable metric]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.AbstractMetric -->
  <!-- start interface org.apache.hadoop.metrics2.MetricsCollector -->
  <interface name="MetricsCollector"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="addRecord" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a metrics record
 @param name  of the record
 @return  a {@link MetricsRecordBuilder} for the record {@code name}]]>
      </doc>
    </method>
    <method name="addRecord" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <doc>
      <![CDATA[Add a metrics record
 @param info  of the record
 @return  a {@link MetricsRecordBuilder} for metrics {@code info}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The metrics collector interface]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.metrics2.MetricsCollector -->
  <!-- start class org.apache.hadoop.metrics2.MetricsException -->
  <class name="MetricsException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricsException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the exception with a message
 @param message for the exception]]>
      </doc>
    </constructor>
    <constructor name="MetricsException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the exception with a message and a cause
 @param message for the exception
 @param cause of the exception]]>
      </doc>
    </constructor>
    <constructor name="MetricsException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the exception with a cause
 @param cause of the exception]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A general metrics exception wrapper]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.MetricsException -->
  <!-- start class org.apache.hadoop.metrics2.MetricsFilter -->
  <class name="MetricsFilter" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics2.MetricsPlugin"/>
    <constructor name="MetricsFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="accepts" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Whether to accept the name
 @param name  to filter on
 @return  true to accept; false otherwise.]]>
      </doc>
    </method>
    <method name="accepts" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="org.apache.hadoop.metrics2.MetricsTag"/>
      <doc>
      <![CDATA[Whether to accept the tag
 @param tag to filter on
 @return  true to accept; false otherwise]]>
      </doc>
    </method>
    <method name="accepts" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tags" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[Whether to accept the tags
 @param tags to filter on
 @return  true to accept; false otherwise]]>
      </doc>
    </method>
    <method name="accepts" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics2.MetricsRecord"/>
      <doc>
      <![CDATA[Whether to accept the record
 @param record  to filter on
 @return  true to accept; false otherwise.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The metrics filter interface. The MetricsFilter objects can be used either to
 filter the metrics from {@link MetricsSource}s or to filter metrics per
 {@link MetricsSink}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.MetricsFilter -->
  <!-- start interface org.apache.hadoop.metrics2.MetricsInfo -->
  <interface name="MetricsInfo"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="name" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Typically name corresponds to annotation {@link Metric#value()} or
 the name of the class.
 @return the name of the metric/tag]]>
      </doc>
    </method>
    <method name="description" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Typically the description corresponds to annotation {@link Metric#about()}
 or the name of the class.
 @return the description of the metric/tag]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface to provide immutable metainfo for metrics.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.metrics2.MetricsInfo -->
  <!-- start class org.apache.hadoop.metrics2.MetricsJsonBuilder -->
  <class name="MetricsJsonBuilder" extends="org.apache.hadoop.metrics2.MetricsRecordBuilder"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricsJsonBuilder" type="org.apache.hadoop.metrics2.MetricsCollector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Build an instance.
 @param parent parent collector. Unused in this instance; only used for
 the {@link #parent()} method]]>
      </doc>
    </constructor>
    <method name="tag" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="add" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="org.apache.hadoop.metrics2.MetricsTag"/>
    </method>
    <method name="add" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metric" type="org.apache.hadoop.metrics2.AbstractMetric"/>
    </method>
    <method name="setContext" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="addCounter" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="int"/>
    </method>
    <method name="addCounter" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="long"/>
    </method>
    <method name="addGauge" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="int"/>
    </method>
    <method name="addGauge" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="long"/>
    </method>
    <method name="addGauge" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="float"/>
    </method>
    <method name="addGauge" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="double"/>
    </method>
    <method name="parent" return="org.apache.hadoop.metrics2.MetricsCollector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="LOG" type="org.slf4j.Logger"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Build a JSON dump of the metrics.

 The {@link #toString()} operator dumps out all values collected.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.MetricsJsonBuilder -->
  <!-- start interface org.apache.hadoop.metrics2.MetricsPlugin -->
  <interface name="MetricsPlugin"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="init"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.commons.configuration2.SubsetConfiguration"/>
      <doc>
      <![CDATA[Initialize the plugin
 @param conf  the configuration object for the plugin]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The plugin interface for the metrics framework]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.metrics2.MetricsPlugin -->
  <!-- start interface org.apache.hadoop.metrics2.MetricsRecord -->
  <interface name="MetricsRecord"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="timestamp" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the timestamp of the metrics
 @return  the timestamp]]>
      </doc>
    </method>
    <method name="name" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the metrics record name]]>
      </doc>
    </method>
    <method name="description" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the description of the metrics record]]>
      </doc>
    </method>
    <method name="context" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the context name of the metrics record]]>
      </doc>
    </method>
    <method name="tags" return="java.util.Collection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the tags of the record
 Note: returning a collection instead of iterable as we
 need to use tags as keys (hence Collection#hashCode etc.) in maps
 @return an unmodifiable collection of tags]]>
      </doc>
    </method>
    <method name="metrics" return="java.lang.Iterable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the metrics of the record
 @return an immutable iterable interface for metrics]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable snapshot of metrics with a timestamp]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.metrics2.MetricsRecord -->
  <!-- start class org.apache.hadoop.metrics2.MetricsRecordBuilder -->
  <class name="MetricsRecordBuilder" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricsRecordBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="tag" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a metrics value with metrics information
 @param info  metadata of the tag
 @param value of the tag
 @return self]]>
      </doc>
    </method>
    <method name="add" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="org.apache.hadoop.metrics2.MetricsTag"/>
      <doc>
      <![CDATA[Add an immutable metrics tag object
 @param tag a pre-made tag object (potentially save an object construction)
 @return self]]>
      </doc>
    </method>
    <method name="add" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metric" type="org.apache.hadoop.metrics2.AbstractMetric"/>
      <doc>
      <![CDATA[Add a pre-made immutable metric object
 @param metric  the pre-made metric to save an object construction
 @return self]]>
      </doc>
    </method>
    <method name="setContext" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the context tag
 @param value of the context
 @return self]]>
      </doc>
    </method>
    <method name="addCounter" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Add an integer metric
 @param info  metadata of the metric
 @param value of the metric
 @return self]]>
      </doc>
    </method>
    <method name="addCounter" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Add an long metric
 @param info  metadata of the metric
 @param value of the metric
 @return self]]>
      </doc>
    </method>
    <method name="addGauge" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Add a integer gauge metric
 @param info  metadata of the metric
 @param value of the metric
 @return self]]>
      </doc>
    </method>
    <method name="addGauge" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Add a long gauge metric
 @param info  metadata of the metric
 @param value of the metric
 @return self]]>
      </doc>
    </method>
    <method name="addGauge" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Add a float gauge metric
 @param info  metadata of the metric
 @param value of the metric
 @return self]]>
      </doc>
    </method>
    <method name="addGauge" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Add a double gauge metric
 @param info  metadata of the metric
 @param value of the metric
 @return self]]>
      </doc>
    </method>
    <method name="parent" return="org.apache.hadoop.metrics2.MetricsCollector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the parent metrics collector object]]>
      </doc>
    </method>
    <method name="endRecord" return="org.apache.hadoop.metrics2.MetricsCollector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Syntactic sugar to add multiple records in a collector in a one liner.
 @return the parent metrics collector object]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The metrics record builder interface]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.MetricsRecordBuilder -->
  <!-- start interface org.apache.hadoop.metrics2.MetricsSink -->
  <interface name="MetricsSink"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics2.MetricsPlugin"/>
    <method name="putMetrics"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics2.MetricsRecord"/>
      <doc>
      <![CDATA[Put a metrics record in the sink
 @param record  the record to put]]>
      </doc>
    </method>
    <method name="flush"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Flush any buffered metrics]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The metrics sink interface. <p>
 Implementations of this interface consume the {@link MetricsRecord} generated
 from {@link MetricsSource}. It registers with {@link MetricsSystem} which
 periodically pushes the {@link MetricsRecord} to the sink using
 {@link #putMetrics(MetricsRecord)} method.  If the implementing class also
 implements {@link Closeable}, then the MetricsSystem will close the sink when
 it is stopped.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.metrics2.MetricsSink -->
  <!-- start interface org.apache.hadoop.metrics2.MetricsSource -->
  <interface name="MetricsSource"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getMetrics"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collector" type="org.apache.hadoop.metrics2.MetricsCollector"/>
      <param name="all" type="boolean"/>
      <doc>
      <![CDATA[Get metrics from the metrics source
 @param collector to contain the resulting metrics snapshot
 @param all if true, return all metrics even if unchanged.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The source of metrics information. It generates and updates metrics. It
 registers with {@link MetricsSystem}, which periodically polls it to collect
 {@link MetricsRecord} and passes it to {@link MetricsSink}.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.metrics2.MetricsSource -->
  <!-- start class org.apache.hadoop.metrics2.MetricsSystem -->
  <class name="MetricsSystem" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics2.MetricsSystemMXBean"/>
    <constructor name="MetricsSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="unregisterSource"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Unregister a metrics source
 @param name of the source. This is the name you use to call register()]]>
      </doc>
    </method>
    <method name="register" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="T"/>
      <doc>
      <![CDATA[Register a metrics source (deriving name and description from the object)
 @param <T>   the actual type of the source object
 @param source  object to register
 @return  the source object
 @exception MetricsException Metrics Exception.]]>
      </doc>
    </method>
    <method name="register" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="source" type="T"/>
      <doc>
      <![CDATA[Register a metrics source
 @param <T>   the actual type of the source object
 @param source object to register
 @param name  of the source. Must be unique or null (then extracted from
              the annotations of the source object.)
 @param desc  the description of the source (or null. See above.)
 @return the source object
 @exception MetricsException Metrics Exception.]]>
      </doc>
    </method>
    <method name="register"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callback" type="org.apache.hadoop.metrics2.MetricsSystem.Callback"/>
      <doc>
      <![CDATA[Register a callback interface for JMX events
 @param callback  the callback object implementing the MBean interface.]]>
      </doc>
    </method>
    <method name="publishMetricsNow"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Requests an immediate publish of all metrics from sources to sinks.
 
 This is a "soft" request: the expectation is that a best effort will be
 done to synchronously snapshot the metrics from all the sources and put
 them in all the sinks (including flushing the sinks) before returning to
 the caller. If this can't be accomplished in reasonable time it's OK to
 return to the caller before everything is done.]]>
      </doc>
    </method>
    <method name="shutdown" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shutdown the metrics system completely (usually during server shutdown.)
 The MetricsSystemMXBean will be unregistered.
 @return true if shutdown completed]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The metrics system interface.
 
 The following components are used for metrics.
 <ul>
 <li>{@link MetricsSource} generate and update metrics information.</li>
 <li>{@link MetricsSink} consume the metrics information</li>
 </ul>
 
 {@link MetricsSource} and {@link MetricsSink} register with the metrics
 system. Implementations of {@link MetricsSystem} polls the
 {@link MetricsSource}s periodically and pass the {@link MetricsRecord}s to
 {@link MetricsSink}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.MetricsSystem -->
  <!-- start interface org.apache.hadoop.metrics2.MetricsSystemMXBean -->
  <interface name="MetricsSystemMXBean"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="start"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Start the metrics system
 @throws MetricsException Metrics Exception.]]>
      </doc>
    </method>
    <method name="stop"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stop the metrics system
 @throws MetricsException Metrics Exception.]]>
      </doc>
    </method>
    <method name="startMetricsMBeans"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Start metrics MBeans
 @throws MetricsException Metrics Exception.]]>
      </doc>
    </method>
    <method name="stopMetricsMBeans"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stop metrics MBeans.
 Note, it doesn't stop the metrics system control MBean,
 i.e this interface.
 @throws MetricsException Metrics Exception.]]>
      </doc>
    </method>
    <method name="currentConfig" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the current config
 Avoided getConfig, as it'll turn into a "Config" attribute,
 which doesn't support multiple line values in jconsole.
 @throws MetricsException Metrics Exception.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The JMX interface to the metrics system]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.metrics2.MetricsSystemMXBean -->
  <!-- start class org.apache.hadoop.metrics2.MetricsTag -->
  <class name="MetricsTag" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics2.MetricsInfo"/>
    <constructor name="MetricsTag" type="org.apache.hadoop.metrics2.MetricsInfo, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the tag with name, description and value
 @param info  of the tag
 @param value of the tag]]>
      </doc>
    </constructor>
    <method name="name" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="description" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="info" return="org.apache.hadoop.metrics2.MetricsInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the info object of the tag]]>
      </doc>
    </method>
    <method name="value" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the value of the tag
 @return  the value]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Immutable tag for metrics (for grouping on host/queue/username etc.)]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.MetricsTag -->
  <!-- start class org.apache.hadoop.metrics2.MetricStringBuilder -->
  <class name="MetricStringBuilder" extends="org.apache.hadoop.metrics2.MetricsRecordBuilder"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricStringBuilder" type="org.apache.hadoop.metrics2.MetricsCollector, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Build an instance.
 @param parent parent collector. Unused in this instance; only used for
 the {@link #parent()} method
 @param prefix string before each entry
 @param separator separator between name and value
 @param suffix suffix after each entry]]>
      </doc>
    </constructor>
    <method name="add" return="org.apache.hadoop.metrics2.MetricStringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="tuple" return="org.apache.hadoop.metrics2.MetricStringBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Add any key,val pair to the string, between the prefix and suffix,
 separated by the separator.
 @param key key
 @param value value
 @return this instance]]>
      </doc>
    </method>
    <method name="tag" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="add" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="org.apache.hadoop.metrics2.MetricsTag"/>
    </method>
    <method name="add" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metric" type="org.apache.hadoop.metrics2.AbstractMetric"/>
    </method>
    <method name="setContext" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="addCounter" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="int"/>
    </method>
    <method name="addCounter" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="long"/>
    </method>
    <method name="addGauge" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="int"/>
    </method>
    <method name="addGauge" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="long"/>
    </method>
    <method name="addGauge" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="float"/>
    </method>
    <method name="addGauge" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="double"/>
    </method>
    <method name="parent" return="org.apache.hadoop.metrics2.MetricsCollector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Build a string dump of the metrics.

 The {@link #toString()} operator dumps out all values collected.

 Every entry is formatted as
 {@code prefix + name + separator + value + suffix}]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.MetricStringBuilder -->
  <!-- start interface org.apache.hadoop.metrics2.MetricsVisitor -->
  <interface name="MetricsVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="gauge"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Callback for integer value gauges
 @param info  the metric info
 @param value of the metric]]>
      </doc>
    </method>
    <method name="gauge"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Callback for long value gauges
 @param info  the metric info
 @param value of the metric]]>
      </doc>
    </method>
    <method name="gauge"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Callback for float value gauges
 @param info  the metric info
 @param value of the metric]]>
      </doc>
    </method>
    <method name="gauge"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Callback for double value gauges
 @param info  the metric info
 @param value of the metric]]>
      </doc>
    </method>
    <method name="counter"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Callback for integer value counters
 @param info  the metric info
 @param value of the metric]]>
      </doc>
    </method>
    <method name="counter"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Callback for long value counters
 @param info  the metric info
 @param value of the metric]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A visitor interface for metrics]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.metrics2.MetricsVisitor -->
</package>
<package name="org.apache.hadoop.metrics2.annotation">
  <!-- start class org.apache.hadoop.metrics2.annotation.Metric -->
  <class name="Metric"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotation interface for a single metric used to annotate a field or a method
 in the class.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.annotation.Metric -->
  <!-- start class org.apache.hadoop.metrics2.annotation.Metrics -->
  <class name="Metrics"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotation interface for a group of metrics]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.annotation.Metrics -->
</package>
<package name="org.apache.hadoop.metrics2.filter">
  <!-- start class org.apache.hadoop.metrics2.filter.GlobFilter -->
  <class name="GlobFilter" extends="org.apache.hadoop.metrics2.filter.AbstractPatternFilter"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GlobFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compile" return="com.google.re2j.Pattern"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[A glob pattern filter for metrics.

 The class name is used in metrics config files]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.filter.GlobFilter -->
  <!-- start class org.apache.hadoop.metrics2.filter.RegexFilter -->
  <class name="RegexFilter" extends="org.apache.hadoop.metrics2.filter.AbstractPatternFilter"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RegexFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compile" return="com.google.re2j.Pattern"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[A regex pattern filter for metrics]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.filter.RegexFilter -->
</package>
<package name="org.apache.hadoop.metrics2.lib">
  <!-- start class org.apache.hadoop.metrics2.lib.DefaultMetricsSystem -->
  <class name="DefaultMetricsSystem" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.metrics2.lib.DefaultMetricsSystem[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.metrics2.lib.DefaultMetricsSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="initialize" return="org.apache.hadoop.metrics2.MetricsSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <doc>
      <![CDATA[Convenience method to initialize the metrics system
 @param prefix  for the metrics system configuration
 @return the metrics system instance]]>
      </doc>
    </method>
    <method name="instance" return="org.apache.hadoop.metrics2.MetricsSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the metrics system object]]>
      </doc>
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shutdown the metrics system]]>
      </doc>
    </method>
    <method name="setMiniClusterMode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="choice" type="boolean"/>
    </method>
    <method name="inMiniClusterMode" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[The default metrics system singleton. This class is used by all the daemon
 processes(such as NameNode, DataNode, JobTracker etc.). During daemon process
 initialization the processes call {@link DefaultMetricsSystem#init(String)}
 to initialize the {@link MetricsSystem}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.DefaultMetricsSystem -->
  <!-- start class org.apache.hadoop.metrics2.lib.Interns -->
  <class name="Interns" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Interns"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="info" return="org.apache.hadoop.metrics2.MetricsInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="description" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a metric info object.
 @param name Name of metric info object
 @param description Description of metric info object
 @return an interned metric info object]]>
      </doc>
    </method>
    <method name="tag" return="org.apache.hadoop.metrics2.MetricsTag"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a metrics tag.
 @param info  of the tag
 @param value of the tag
 @return an interned metrics tag]]>
      </doc>
    </method>
    <method name="tag" return="org.apache.hadoop.metrics2.MetricsTag"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="description" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a metrics tag.
 @param name  of the tag
 @param description of the tag
 @param value of the tag
 @return an interned metrics tag]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Helpers to create interned metrics info.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.Interns -->
  <!-- start class org.apache.hadoop.metrics2.lib.MetricsRegistry -->
  <class name="MetricsRegistry" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricsRegistry" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the registry with a record name
 @param name  of the record of the metrics]]>
      </doc>
    </constructor>
    <constructor name="MetricsRegistry" type="org.apache.hadoop.metrics2.MetricsInfo"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the registry with a metadata object
 @param info  the info object for the metrics record/group]]>
      </doc>
    </constructor>
    <method name="info" return="org.apache.hadoop.metrics2.MetricsInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the info object of the metrics registry]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.metrics2.lib.MutableMetric"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a metric by name
 @param name  of the metric
 @return the metric object]]>
      </doc>
    </method>
    <method name="getTag" return="org.apache.hadoop.metrics2.MetricsTag"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a tag by name
 @param name  of the tag
 @return the tag object]]>
      </doc>
    </method>
    <method name="newCounter" return="org.apache.hadoop.metrics2.lib.MutableCounterInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="iVal" type="int"/>
      <doc>
      <![CDATA[Create a mutable integer counter
 @param name  of the metric
 @param desc  metric description
 @param iVal  initial value
 @return a new counter object]]>
      </doc>
    </method>
    <method name="newCounter" return="org.apache.hadoop.metrics2.lib.MutableCounterInt"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="iVal" type="int"/>
      <doc>
      <![CDATA[Create a mutable integer counter
 @param info  metadata of the metric
 @param iVal  initial value
 @return a new counter object]]>
      </doc>
    </method>
    <method name="newCounter" return="org.apache.hadoop.metrics2.lib.MutableCounterLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="iVal" type="long"/>
      <doc>
      <![CDATA[Create a mutable long integer counter
 @param name  of the metric
 @param desc  metric description
 @param iVal  initial value
 @return a new counter object]]>
      </doc>
    </method>
    <method name="newCounter" return="org.apache.hadoop.metrics2.lib.MutableCounterLong"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="iVal" type="long"/>
      <doc>
      <![CDATA[Create a mutable long integer counter
 @param info  metadata of the metric
 @param iVal  initial value
 @return a new counter object]]>
      </doc>
    </method>
    <method name="newGauge" return="org.apache.hadoop.metrics2.lib.MutableGaugeInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="iVal" type="int"/>
      <doc>
      <![CDATA[Create a mutable integer gauge
 @param name  of the metric
 @param desc  metric description
 @param iVal  initial value
 @return a new gauge object]]>
      </doc>
    </method>
    <method name="newGauge" return="org.apache.hadoop.metrics2.lib.MutableGaugeInt"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="iVal" type="int"/>
      <doc>
      <![CDATA[Create a mutable integer gauge
 @param info  metadata of the metric
 @param iVal  initial value
 @return a new gauge object]]>
      </doc>
    </method>
    <method name="newGauge" return="org.apache.hadoop.metrics2.lib.MutableGaugeLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="iVal" type="long"/>
      <doc>
      <![CDATA[Create a mutable long integer gauge
 @param name  of the metric
 @param desc  metric description
 @param iVal  initial value
 @return a new gauge object]]>
      </doc>
    </method>
    <method name="newGauge" return="org.apache.hadoop.metrics2.lib.MutableGaugeLong"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="iVal" type="long"/>
      <doc>
      <![CDATA[Create a mutable long integer gauge
 @param info  metadata of the metric
 @param iVal  initial value
 @return a new gauge object]]>
      </doc>
    </method>
    <method name="newGauge" return="org.apache.hadoop.metrics2.lib.MutableGaugeFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="iVal" type="float"/>
      <doc>
      <![CDATA[Create a mutable float gauge
 @param name  of the metric
 @param desc  metric description
 @param iVal  initial value
 @return a new gauge object]]>
      </doc>
    </method>
    <method name="newGauge" return="org.apache.hadoop.metrics2.lib.MutableGaugeFloat"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="iVal" type="float"/>
      <doc>
      <![CDATA[Create a mutable float gauge
 @param info  metadata of the metric
 @param iVal  initial value
 @return a new gauge object]]>
      </doc>
    </method>
    <method name="newQuantiles" return="org.apache.hadoop.metrics2.lib.MutableQuantiles"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="sampleName" type="java.lang.String"/>
      <param name="valueName" type="java.lang.String"/>
      <param name="interval" type="int"/>
      <doc>
      <![CDATA[Create a mutable metric that estimates quantiles of a stream of values
 @param name of the metric
 @param desc metric description
 @param sampleName of the metric (e.g., "Ops")
 @param valueName of the metric (e.g., "Time" or "Latency")
 @param interval rollover interval of estimator in seconds
 @return a new quantile estimator object
 @throws MetricsException if interval is not a positive integer]]>
      </doc>
    </method>
    <method name="newStat" return="org.apache.hadoop.metrics2.lib.MutableStat"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="sampleName" type="java.lang.String"/>
      <param name="valueName" type="java.lang.String"/>
      <param name="extended" type="boolean"/>
      <doc>
      <![CDATA[Create a mutable metric with stats
 @param name  of the metric
 @param desc  metric description
 @param sampleName  of the metric (e.g., "Ops")
 @param valueName   of the metric (e.g., "Time" or "Latency")
 @param extended    produce extended stat (stdev, min/max etc.) if true.
 @return a new mutable stat metric object]]>
      </doc>
    </method>
    <method name="newStat" return="org.apache.hadoop.metrics2.lib.MutableStat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="sampleName" type="java.lang.String"/>
      <param name="valueName" type="java.lang.String"/>
      <doc>
      <![CDATA[Create a mutable metric with stats
 @param name  of the metric
 @param desc  metric description
 @param sampleName  of the metric (e.g., "Ops")
 @param valueName   of the metric (e.g., "Time" or "Latency")
 @return a new mutable metric object]]>
      </doc>
    </method>
    <method name="newRate" return="org.apache.hadoop.metrics2.lib.MutableRate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Create a mutable rate metric
 @param name  of the metric
 @return a new mutable metric object]]>
      </doc>
    </method>
    <method name="newRate" return="org.apache.hadoop.metrics2.lib.MutableRate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="description" type="java.lang.String"/>
      <doc>
      <![CDATA[Create a mutable rate metric
 @param name  of the metric
 @param description of the metric
 @return a new mutable rate metric object]]>
      </doc>
    </method>
    <method name="newRate" return="org.apache.hadoop.metrics2.lib.MutableRate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="extended" type="boolean"/>
      <doc>
      <![CDATA[Create a mutable rate metric (for throughput measurement)
 @param name  of the metric
 @param desc  description
 @param extended  produce extended stat (stdev/min/max etc.) if true
 @return a new mutable rate metric object]]>
      </doc>
    </method>
    <method name="newRatesWithAggregation" return="org.apache.hadoop.metrics2.lib.MutableRatesWithAggregation"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="newMutableRollingAverages" return="org.apache.hadoop.metrics2.lib.MutableRollingAverages"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="valueName" type="java.lang.String"/>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Add sample to a stat metric by name.
 @param name  of the metric
 @param value of the snapshot to add]]>
      </doc>
    </method>
    <method name="setContext" return="org.apache.hadoop.metrics2.lib.MetricsRegistry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the metrics context tag
 @param name of the context
 @return the registry itself as a convenience]]>
      </doc>
    </method>
    <method name="tag" return="org.apache.hadoop.metrics2.lib.MetricsRegistry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="description" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a tag to the metrics
 @param name  of the tag
 @param description of the tag
 @param value of the tag
 @return the registry (for keep adding tags)]]>
      </doc>
    </method>
    <method name="tag" return="org.apache.hadoop.metrics2.lib.MetricsRegistry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="description" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <param name="override" type="boolean"/>
      <doc>
      <![CDATA[Add a tag to the metrics
 @param name  of the tag
 @param description of the tag
 @param value of the tag
 @param override  existing tag if true
 @return the registry (for keep adding tags)]]>
      </doc>
    </method>
    <method name="tag" return="org.apache.hadoop.metrics2.lib.MetricsRegistry"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="java.lang.String"/>
      <param name="override" type="boolean"/>
      <doc>
      <![CDATA[Add a tag to the metrics
 @param info  metadata of the tag
 @param value of the tag
 @param override existing tag if true
 @return the registry (for keep adding tags etc.)]]>
      </doc>
    </method>
    <method name="tag" return="org.apache.hadoop.metrics2.lib.MetricsRegistry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="snapshot"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <param name="all" type="boolean"/>
      <doc>
      <![CDATA[Sample all the mutable metrics and put the snapshot in the builder
 @param builder to contain the metrics snapshot
 @param all get all the metrics even if the values are not changed.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An optional metrics registry class for creating and maintaining a
 collection of MetricsMutables, making writing metrics source easier.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MetricsRegistry -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableCounter -->
  <class name="MutableCounter" extends="org.apache.hadoop.metrics2.lib.MutableMetric"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MutableCounter" type="org.apache.hadoop.metrics2.MetricsInfo"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="info" return="org.apache.hadoop.metrics2.MetricsInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="incr"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increment the metric value by 1.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The mutable counter (monotonically increasing) metric interface]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableCounter -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableCounterInt -->
  <class name="MutableCounterInt" extends="org.apache.hadoop.metrics2.lib.MutableCounter"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="incr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="incr"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delta" type="int"/>
      <doc>
      <![CDATA[Increment the value by a delta
 @param delta of the increment]]>
      </doc>
    </method>
    <method name="value" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="snapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <param name="all" type="boolean"/>
    </method>
    <doc>
    <![CDATA[A mutable int counter for implementing metrics sources]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableCounterInt -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableCounterLong -->
  <class name="MutableCounterLong" extends="org.apache.hadoop.metrics2.lib.MutableCounter"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MutableCounterLong" type="org.apache.hadoop.metrics2.MetricsInfo, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="incr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="incr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delta" type="long"/>
      <doc>
      <![CDATA[Increment the value by a delta
 @param delta of the increment]]>
      </doc>
    </method>
    <method name="value" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="snapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <param name="all" type="boolean"/>
    </method>
    <doc>
    <![CDATA[A mutable long counter]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableCounterLong -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableGauge -->
  <class name="MutableGauge" extends="org.apache.hadoop.metrics2.lib.MutableMetric"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MutableGauge" type="org.apache.hadoop.metrics2.MetricsInfo"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="info" return="org.apache.hadoop.metrics2.MetricsInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="incr"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increment the value of the metric by 1]]>
      </doc>
    </method>
    <method name="decr"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Decrement the value of the metric by 1]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The mutable gauge metric interface]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableGauge -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableGaugeInt -->
  <class name="MutableGaugeInt" extends="org.apache.hadoop.metrics2.lib.MutableGauge"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="value" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="incr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="incr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delta" type="int"/>
      <doc>
      <![CDATA[Increment by delta
 @param delta of the increment]]>
      </doc>
    </method>
    <method name="decr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="decr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delta" type="int"/>
      <doc>
      <![CDATA[decrement by delta
 @param delta of the decrement]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Set the value of the metric
 @param value to set]]>
      </doc>
    </method>
    <method name="snapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <param name="all" type="boolean"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return  the value of the metric]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A mutable int gauge]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableGaugeInt -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableGaugeLong -->
  <class name="MutableGaugeLong" extends="org.apache.hadoop.metrics2.lib.MutableGauge"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="value" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="incr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="incr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delta" type="long"/>
      <doc>
      <![CDATA[Increment by delta
 @param delta of the increment]]>
      </doc>
    </method>
    <method name="decr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="decr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delta" type="long"/>
      <doc>
      <![CDATA[decrement by delta
 @param delta of the decrement]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Set the value of the metric
 @param value to set]]>
      </doc>
    </method>
    <method name="snapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <param name="all" type="boolean"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return  the value of the metric]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A mutable long gauge]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableGaugeLong -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableMetric -->
  <class name="MutableMetric" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MutableMetric"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="snapshot"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <param name="all" type="boolean"/>
      <doc>
      <![CDATA[Get a snapshot of the metric
 @param builder the metrics record builder
 @param all if true, snapshot unchanged metrics as well]]>
      </doc>
    </method>
    <method name="snapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <doc>
      <![CDATA[Get a snapshot of metric if changed
 @param builder the metrics record builder]]>
      </doc>
    </method>
    <method name="setChanged"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Set the changed flag in mutable operations]]>
      </doc>
    </method>
    <method name="clearChanged"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clear the changed flag in the snapshot operations]]>
      </doc>
    </method>
    <method name="changed" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return  true if metric is changed since last snapshot/snapshot]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The mutable metric interface]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableMetric -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableQuantiles -->
  <class name="MutableQuantiles" extends="org.apache.hadoop.metrics2.lib.MutableMetric"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MutableQuantiles" type="java.lang.String, java.lang.String, java.lang.String, java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instantiates a new {@link MutableQuantiles} for a metric that rolls itself
 over on the specified time interval.
 
 @param name
          of the metric
 @param description
          long-form textual description of the metric
 @param sampleName
          type of items in the stream (e.g., "Ops")
 @param valueName
          type of the values
 @param interval
          rollover interval (in seconds) of the estimator]]>
      </doc>
    </constructor>
    <method name="snapshot"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <param name="all" type="boolean"/>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
    </method>
    <method name="getInterval" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEstimator" return="org.apache.hadoop.metrics2.util.QuantileEstimator"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the quantile estimator.

 @return the quantile estimator]]>
      </doc>
    </method>
    <method name="setEstimator"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="quantileEstimator" type="org.apache.hadoop.metrics2.util.QuantileEstimator"/>
    </method>
    <field name="quantiles" type="org.apache.hadoop.metrics2.util.Quantile[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="previousSnapshot" type="java.util.Map"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Watches a stream of long values, maintaining online estimates of specific
 quantiles with provably low error bounds. This is particularly useful for
 accurate high-percentile (e.g. 95th, 99th) latency metrics.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableQuantiles -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableRate -->
  <class name="MutableRate" extends="org.apache.hadoop.metrics2.lib.MutableStat"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[A convenient mutable metric for throughput measurement]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableRate -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableRates -->
  <class name="MutableRates" extends="org.apache.hadoop.metrics2.lib.MutableMetric"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <doc>
      <![CDATA[Initialize the registry with all the methods in a protocol
 so they all show up in the first snapshot.
 Convenient for JMX implementations.
 @param protocol the protocol class]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="elapsed" type="long"/>
      <doc>
      <![CDATA[Add a rate sample for a rate metric
 @param name of the rate metric
 @param elapsed time]]>
      </doc>
    </method>
    <method name="snapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rb" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <param name="all" type="boolean"/>
    </method>
    <doc>
    <![CDATA[Helper class to manage a group of mutable rate metrics

 This class synchronizes all accesses to the metrics it
 contains, so it should not be used in situations where
 there is high contention on the metrics.
 {@link MutableRatesWithAggregation} is preferable in that
 situation.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableRates -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableRatesWithAggregation -->
  <class name="MutableRatesWithAggregation" extends="org.apache.hadoop.metrics2.lib.MutableMetric"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MutableRatesWithAggregation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <doc>
      <![CDATA[Initialize the registry with all the methods in a protocol
 so they all show up in the first snapshot.
 Convenient for JMX implementations.
 @param protocol the protocol class]]>
      </doc>
    </method>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Initialize the registry with all rate names passed in.
 This is an alternative to the above init function since this metric
 can be used more than just for rpc name.
 @param names the array of all rate names]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="elapsed" type="long"/>
      <doc>
      <![CDATA[Add a rate sample for a rate metric.
 @param name of the rate metric
 @param elapsed time]]>
      </doc>
    </method>
    <method name="snapshot"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rb" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <param name="all" type="boolean"/>
    </method>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="prefix" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Helper class to manage a group of mutable rate metrics.

 Each thread will maintain a local rate count, and upon snapshot,
 these values will be aggregated into a global rate. This class
 should only be used for long running threads, as any metrics
 produced between the last snapshot and the death of a thread
 will be lost. This allows for significantly higher concurrency
 than {@link MutableRates}. See HADOOP-24420.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableRatesWithAggregation -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableRollingAverages -->
  <class name="MutableRollingAverages" extends="org.apache.hadoop.metrics2.lib.MutableMetric"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="MutableRollingAverages" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for {@link MutableRollingAverages}.
 @param metricValueName input metricValueName.]]>
      </doc>
    </constructor>
    <method name="snapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <param name="all" type="boolean"/>
    </method>
    <method name="collectThreadLocalStates"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Collects states maintained in {@link ThreadLocal}, if any.]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="long"/>
      <doc>
      <![CDATA[@param name
          name of metric
 @param value
          value of metric]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getStats" return="java.util.Map"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="minSamples" type="long"/>
      <doc>
      <![CDATA[Retrieve a map of metric name {@literal ->} (aggregate).
 Filter out entries that don't have at least minSamples.

 @param minSamples input minSamples.
 @return a map of peer DataNode Id to the average latency to that
         node seen over the measurement period.]]>
      </doc>
    </method>
    <method name="setRecordValidityMs"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Use for test only.
 @param value input value.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 This class maintains a group of rolling average metrics. It implements the
 algorithm of rolling average, i.e. a number of sliding windows are kept to
 roll over and evict old subsets of samples. Each window has a subset of
 samples in a stream, where sub-sum and sub-total are collected. All sub-sums
 and sub-totals in all windows will be aggregated to final-sum and final-total
 used to compute final average, which is called rolling average.
 </p>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableRollingAverages -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableStat -->
  <class name="MutableStat" extends="org.apache.hadoop.metrics2.lib.MutableMetric"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MutableStat" type="java.lang.String, java.lang.String, java.lang.String, java.lang.String, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a sample statistics metric
 @param name        of the metric
 @param description of the metric
 @param sampleName  of the metric (e.g. "Ops")
 @param valueName   of the metric (e.g. "Time", "Latency")
 @param extended    create extended stats (stdev, min/max etc.) by default.]]>
      </doc>
    </constructor>
    <constructor name="MutableStat" type="java.lang.String, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a snapshot stat metric with extended stat off by default
 @param name        of the metric
 @param description of the metric
 @param sampleName  of the metric (e.g. "Ops")
 @param valueName   of the metric (e.g. "Time", "Latency")]]>
      </doc>
    </constructor>
    <method name="setExtended"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="extended" type="boolean"/>
      <doc>
      <![CDATA[Set whether to display the extended stats (stdev, min/max etc.) or not
 @param extended enable/disable displaying extended stats]]>
      </doc>
    </method>
    <method name="setUpdateTimeStamp"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="updateTimeStamp" type="boolean"/>
      <doc>
      <![CDATA[Set whether to update the snapshot time or not.
 @param updateTimeStamp enable update stats snapshot timestamp]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="numSamples" type="long"/>
      <param name="sum" type="long"/>
      <doc>
      <![CDATA[Add a number of samples and their sum to the running stat

 Note that although use of this method will preserve accurate mean values,
 large values for numSamples may result in inaccurate variance values due
 to the use of a single step of the Welford method for variance calculation.
 @param numSamples  number of samples
 @param sum of the samples]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Add a snapshot to the metric.
 @param value of the metric]]>
      </doc>
    </method>
    <method name="snapshot"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <param name="all" type="boolean"/>
    </method>
    <method name="lastStat" return="org.apache.hadoop.metrics2.util.SampleStat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a SampleStat object that supports
 calls like StdDev and Mean.
 @return SampleStat]]>
      </doc>
    </method>
    <method name="resetMinMax"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reset the all time min max of the metric]]>
      </doc>
    </method>
    <method name="getSnapshotTimeStamp" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Return the SampleStat snapshot timestamp.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A mutable metric with stats.

 Useful for keeping throughput/latency stats.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableStat -->
</package>
<package name="org.apache.hadoop.metrics2.sink">
  <!-- start class org.apache.hadoop.metrics2.sink.FileSink -->
  <class name="FileSink" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics2.MetricsSink"/>
    <implements name="java.io.Closeable"/>
    <constructor name="FileSink"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.commons.configuration2.SubsetConfiguration"/>
    </method>
    <method name="putMetrics"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics2.MetricsRecord"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A metrics sink that writes to a file]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.sink.FileSink -->
  <!-- start class org.apache.hadoop.metrics2.sink.GraphiteSink -->
  <class name="GraphiteSink" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics2.MetricsSink"/>
    <implements name="java.io.Closeable"/>
    <constructor name="GraphiteSink"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.commons.configuration2.SubsetConfiguration"/>
    </method>
    <method name="putMetrics"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics2.MetricsRecord"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A metrics sink that writes to a Graphite server]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.sink.GraphiteSink -->
  <!-- start class org.apache.hadoop.metrics2.sink.RollingFileSystemSink -->
  <class name="RollingFileSystemSink" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics2.MetricsSink"/>
    <implements name="java.io.Closeable"/>
    <constructor name="RollingFileSystemSink"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an empty instance.  Required for reflection.]]>
      </doc>
    </constructor>
    <constructor name="RollingFileSystemSink" type="long, long"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance for testing.

 @param flushIntervalMillis the roll interval in millis
 @param flushOffsetIntervalMillis the roll offset interval in millis]]>
      </doc>
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metrics2Properties" type="org.apache.commons.configuration2.SubsetConfiguration"/>
    </method>
    <method name="getRollInterval" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Extract the roll interval from the configuration and return it in
 milliseconds.

 @return the roll interval in millis]]>
      </doc>
    </method>
    <method name="updateFlushTime"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="now" type="java.util.Date"/>
      <doc>
      <![CDATA[Update the {@link #nextFlush} variable to the next flush time. Add
 an integer number of flush intervals, preserving the initial random offset.

 @param now the current time]]>
      </doc>
    </method>
    <method name="setInitialFlushTime"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="now" type="java.util.Date"/>
      <doc>
      <![CDATA[Set the {@link #nextFlush} variable to the initial flush time. The initial
 flush will be an integer number of flush intervals past the beginning of
 the current hour and will have a random offset added, up to
 {@link #rollOffsetIntervalMillis}. The initial flush will be a time in
 past that can be used from which to calculate future flush times.

 @param now the current time]]>
      </doc>
    </method>
    <method name="putMetrics"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics2.MetricsRecord"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="source" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="ignoreError" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="allowAppend" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="basePath" type="org.apache.hadoop.fs.Path"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="rollIntervalMillis" type="long"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="rollOffsetIntervalMillis" type="long"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="nextFlush" type="java.util.Calendar"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="forceFlush" type="boolean"
      transient="false" volatile="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="hasFlushed" type="boolean"
      transient="false" volatile="true"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="suppliedConf" type="org.apache.hadoop.conf.Configuration"
      transient="false" volatile="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="suppliedFilesystem" type="org.apache.hadoop.fs.FileSystem"
      transient="false" volatile="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[<p>This class is a metrics sink that uses
 {@link org.apache.hadoop.fs.FileSystem} to write the metrics logs.  Every
 roll interval a new directory will be created under the path specified by the
 <code>basepath</code> property. All metrics will be logged to a file in the
 current interval's directory in a file named &lt;hostname&gt;.log, where
 &lt;hostname&gt; is the name of the host on which the metrics logging
 process is running. The base path is set by the
 <code>&lt;prefix&gt;.sink.&lt;instance&gt;.basepath</code> property.  The
 time zone used to create the current interval's directory name is GMT.  If
 the <code>basepath</code> property isn't specified, it will default to
 &quot;/tmp&quot;, which is the temp directory on whatever default file
 system is configured for the cluster.</p>

 <p>The <code>&lt;prefix&gt;.sink.&lt;instance&gt;.ignore-error</code>
 property controls whether an exception is thrown when an error is encountered
 writing a log file.  The default value is <code>true</code>.  When set to
 <code>false</code>, file errors are quietly swallowed.</p>

 <p>The <code>roll-interval</code> property sets the amount of time before
 rolling the directory. The default value is 1 hour. The roll interval may
 not be less than 1 minute. The property's value should be given as
 <i>number unit</i>, where <i>number</i> is an integer value, and
 <i>unit</i> is a valid unit.  Valid units are <i>minute</i>, <i>hour</i>,
 and <i>day</i>.  The units are case insensitive and may be abbreviated or
 plural. If no units are specified, hours are assumed. For example,
 &quot;2&quot;, &quot;2h&quot;, &quot;2 hour&quot;, and
 &quot;2 hours&quot; are all valid ways to specify two hours.</p>

 <p>The <code>roll-offset-interval-millis</code> property sets the upper
 bound on a random time interval (in milliseconds) that is used to delay
 before the initial roll.  All subsequent rolls will happen an integer
 number of roll intervals after the initial roll, hence retaining the original
 offset. The purpose of this property is to insert some variance in the roll
 times so that large clusters using this sink on every node don't cause a
 performance impact on HDFS by rolling simultaneously.  The default value is
 30000 (30s).  When writing to HDFS, as a rule of thumb, the roll offset in
 millis should be no less than the number of sink instances times 5.

 <p>The primary use of this class is for logging to HDFS.  As it uses
 {@link org.apache.hadoop.fs.FileSystem} to access the target file system,
 however, it can be used to write to the local file system, Amazon S3, or any
 other supported file system.  The base path for the sink will determine the
 file system used.  An unqualified path will write to the default file system
 set by the configuration.</p>

 <p>Not all file systems support the ability to append to files.  In file
 systems without the ability to append to files, only one writer can write to
 a file at a time.  To allow for concurrent writes from multiple daemons on a
 single host, the <code>source</code> property is used to set unique headers
 for the log files.  The property should be set to the name of
 the source daemon, e.g. <i>namenode</i>.  The value of the
 <code>source</code> property should typically be the same as the property's
 prefix.  If this property is not set, the source is taken to be
 <i>unknown</i>.</p>

 <p>Instead of appending to an existing file, by default the sink
 will create a new file with a suffix of &quot;.&lt;n&gt;&quot;, where
 <i>n</i> is the next lowest integer that isn't already used in a file name,
 similar to the Hadoop daemon logs.  NOTE: the file with the <b>highest</b>
 sequence number is the <b>newest</b> file, unlike the Hadoop daemon logs.</p>

 <p>For file systems that allow append, the sink supports appending to the
 existing file instead. If the <code>allow-append</code> property is set to
 true, the sink will instead append to the existing file on file systems that
 support appends. By default, the <code>allow-append</code> property is
 false.</p>

 <p>Note that when writing to HDFS with <code>allow-append</code> set to true,
 there is a minimum acceptable number of data nodes.  If the number of data
 nodes drops below that minimum, the append will succeed, but reading the
 data will fail with an IOException in the DataStreamer class.  The minimum
 number of data nodes required for a successful append is generally 2 or
 3.</p>

 <p>Note also that when writing to HDFS, the file size information is not
 updated until the file is closed (at the end of the interval) even though
 the data is being written successfully. This is a known HDFS limitation that
 exists because of the performance cost of updating the metadata.  See
 <a href="https://issues.apache.org/jira/browse/HDFS-5478">HDFS-5478</a>.</p>

 <p>When using this sink in a secure (Kerberos) environment, two additional
 properties must be set: <code>keytab-key</code> and
 <code>principal-key</code>. <code>keytab-key</code> should contain the key by
 which the keytab file can be found in the configuration, for example,
 <code>yarn.nodemanager.keytab</code>. <code>principal-key</code> should
 contain the key by which the principal can be found in the configuration,
 for example, <code>yarn.nodemanager.principal</code>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.sink.RollingFileSystemSink -->
  <!-- start class org.apache.hadoop.metrics2.sink.StatsDSink -->
  <class name="StatsDSink" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics2.MetricsSink"/>
    <implements name="java.io.Closeable"/>
    <constructor name="StatsDSink"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.commons.configuration2.SubsetConfiguration"/>
    </method>
    <method name="putMetrics"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics2.MetricsRecord"/>
    </method>
    <method name="writeMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="line" type="java.lang.String"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A metrics sink that writes metrics to a StatsD daemon.
 This sink will produce metrics of the form
 '[hostname].servicename.context.name.metricname:value|type'
 where hostname is optional. This is useful when sending to
 a daemon that is running on the localhost and will add the
 hostname to the metric (such as the
 <a href="https://collectd.org/">CollectD</a> StatsD plugin).
 <br>
 To configure this plugin, you will need to add the following
 entries to your hadoop-metrics2.properties file:
 <br>
 <pre>
 *.sink.statsd.class=org.apache.hadoop.metrics2.sink.StatsDSink
 [prefix].sink.statsd.server.host=
 [prefix].sink.statsd.server.port=
 [prefix].sink.statsd.skip.hostname=true|false (optional)
 [prefix].sink.statsd.service.name=NameNode (name you want for service)
 </pre>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.sink.StatsDSink -->
</package>
<package name="org.apache.hadoop.metrics2.sink.ganglia">
</package>
<package name="org.apache.hadoop.metrics2.source">
</package>
<package name="org.apache.hadoop.metrics2.util">
  <!-- start class org.apache.hadoop.metrics2.util.MBeans -->
  <class name="MBeans" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="register" return="javax.management.ObjectName"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serviceName" type="java.lang.String"/>
      <param name="nameName" type="java.lang.String"/>
      <param name="theMbean" type="java.lang.Object"/>
      <doc>
      <![CDATA[Register the MBean using our standard MBeanName format
 "hadoop:service={@literal <serviceName>,name=<nameName>}"
 Where the {@literal <serviceName> and <nameName>} are the supplied
 parameters.

 @param serviceName serviceName.
 @param nameName nameName.
 @param theMbean - the MBean to register
 @return the named used to register the MBean]]>
      </doc>
    </method>
    <method name="register" return="javax.management.ObjectName"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serviceName" type="java.lang.String"/>
      <param name="nameName" type="java.lang.String"/>
      <param name="properties" type="java.util.Map"/>
      <param name="theMbean" type="java.lang.Object"/>
      <doc>
      <![CDATA[Register the MBean using our standard MBeanName format
 "hadoop:service={@literal <serviceName>,name=<nameName>}"
 Where the {@literal <serviceName> and <nameName>} are the supplied
 parameters.

 @param serviceName serviceName.
 @param nameName nameName.
 @param properties - Key value pairs to define additional JMX ObjectName
                     properties.
 @param theMbean    - the MBean to register
 @return the named used to register the MBean]]>
      </doc>
    </method>
    <method name="getMbeanNameService" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objectName" type="javax.management.ObjectName"/>
    </method>
    <method name="getMbeanNameName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objectName" type="javax.management.ObjectName"/>
    </method>
    <method name="unregister"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mbeanName" type="javax.management.ObjectName"/>
    </method>
    <doc>
    <![CDATA[This util class provides a method to register an MBean using
 our standard naming convention as described in the doc
  for {link {@link #register(String, String, Object)}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.util.MBeans -->
  <!-- start class org.apache.hadoop.metrics2.util.MetricsCache -->
  <class name="MetricsCache" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricsCache"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MetricsCache" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a metrics cache
 @param maxRecsPerName  limit of the number records per record name]]>
      </doc>
    </constructor>
    <method name="update" return="org.apache.hadoop.metrics2.util.MetricsCache.Record"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mr" type="org.apache.hadoop.metrics2.MetricsRecord"/>
      <param name="includingTags" type="boolean"/>
      <doc>
      <![CDATA[Update the cache and return the current cached record
 @param mr the update record
 @param includingTags cache tag values (for later lookup by name) if true
 @return the updated cache record]]>
      </doc>
    </method>
    <method name="update" return="org.apache.hadoop.metrics2.util.MetricsCache.Record"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mr" type="org.apache.hadoop.metrics2.MetricsRecord"/>
      <doc>
      <![CDATA[Update the cache and return the current cache record
 @param mr the update record
 @return the updated cache record]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.metrics2.util.MetricsCache.Record"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="tags" type="java.util.Collection"/>
      <doc>
      <![CDATA[Get the cached record
 @param name of the record
 @param tags of the record
 @return the cached record or null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A metrics cache for sinks that don't support sparse updates.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.util.MetricsCache -->
  <!-- start class org.apache.hadoop.metrics2.util.Servers -->
  <class name="Servers" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="parse" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="specs" type="java.lang.String"/>
      <param name="defaultPort" type="int"/>
      <doc>
      <![CDATA[Parses a space and/or comma separated sequence of server specifications
 of the form <i>hostname</i> or <i>hostname:port</i>.  If
 the specs string is null, defaults to localhost:defaultPort.

 @param specs   server specs (see description)
 @param defaultPort the default port if not specified
 @return a list of InetSocketAddress objects.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Helpers to handle server addresses]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.util.Servers -->
</package>
<package name="org.apache.hadoop.net">
  <!-- start class org.apache.hadoop.net.AbstractDNSToSwitchMapping -->
  <class name="AbstractDNSToSwitchMapping" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.net.DNSToSwitchMapping"/>
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="AbstractDNSToSwitchMapping"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an unconfigured instance]]>
      </doc>
    </constructor>
    <constructor name="AbstractDNSToSwitchMapping" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance, caching the configuration file.
 This constructor does not call {@link #setConf(Configuration)}; if
 a subclass extracts information in that method, it must call it explicitly.
 @param conf the configuration]]>
      </doc>
    </constructor>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="isSingleSwitch" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Predicate that indicates that the switch mapping is known to be
 single-switch. The base class returns false: it assumes all mappings are
 multi-rack. Subclasses may override this with methods that are more aware
 of their topologies.

 <p>

 This method is used when parts of Hadoop need know whether to apply
 single rack vs multi-rack policies, such as during block placement.
 Such algorithms behave differently if they are on multi-switch systems.
 </p>

 @return true if the mapping thinks that it is on a single switch]]>
      </doc>
    </method>
    <method name="getSwitchMap" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a copy of the map (for diagnostics)
 @return a clone of the map or null for none known]]>
      </doc>
    </method>
    <method name="dumpTopology" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Generate a string listing the switch mapping implementation,
 the mapping for every known node and the number of nodes and
 unique switches known about -each entry to a separate line.
 @return a string that can be presented to the ops team or used in
 debug messages.]]>
      </doc>
    </method>
    <method name="isSingleSwitchByScriptPolicy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="isMappingSingleSwitch" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mapping" type="org.apache.hadoop.net.DNSToSwitchMapping"/>
      <doc>
      <![CDATA[Query for a {@link DNSToSwitchMapping} instance being on a single
 switch.
 <p>
 This predicate simply assumes that all mappings not derived from
 this class are multi-switch.
 @param mapping the mapping to query
 @return true if the base class says it is single switch, or the mapping
 is not derived from this class.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This is a base class for DNS to Switch mappings. <p> It is not mandatory to
 derive {@link DNSToSwitchMapping} implementations from it, but it is strongly
 recommended, as it makes it easy for the Hadoop developers to add new methods
 to this base class that are automatically picked up by all implementations.
 <p>

 This class does not extend the <code>Configured</code>
 base class, and should not be changed to do so, as it causes problems
 for subclasses. The constructor of the <code>Configured</code> calls
 the  {@link #setConf(Configuration)} method, which will call into the
 subclasses before they have been fully constructed.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.AbstractDNSToSwitchMapping -->
  <!-- start class org.apache.hadoop.net.CachedDNSToSwitchMapping -->
  <class name="CachedDNSToSwitchMapping" extends="org.apache.hadoop.net.AbstractDNSToSwitchMapping"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CachedDNSToSwitchMapping" type="org.apache.hadoop.net.DNSToSwitchMapping"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[cache a raw DNS mapping
 @param rawMapping the raw mapping to cache]]>
      </doc>
    </constructor>
    <method name="resolve" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.util.List"/>
    </method>
    <method name="getSwitchMap" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the (host x switch) map.
 @return a copy of the cached map of hosts to rack]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isSingleSwitch" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Delegate the switch topology query to the raw mapping, via
 {@link AbstractDNSToSwitchMapping#isMappingSingleSwitch(DNSToSwitchMapping)}
 @return true iff the raw mapper is considered single-switch.]]>
      </doc>
    </method>
    <method name="reloadCachedMappings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reloadCachedMappings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.util.List"/>
    </method>
    <field name="rawMapping" type="org.apache.hadoop.net.DNSToSwitchMapping"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The uncached mapping]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A cached implementation of DNSToSwitchMapping that takes an
 raw DNSToSwitchMapping and stores the resolved network location in 
 a cache. The following calls to a resolved network location
 will get its location from the cache.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.CachedDNSToSwitchMapping -->
  <!-- start class org.apache.hadoop.net.ConnectTimeoutException -->
  <class name="ConnectTimeoutException" extends="java.net.SocketTimeoutException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConnectTimeoutException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Thrown by {@link NetUtils#connect(java.net.Socket, java.net.SocketAddress, int)}
 if it times out while connecting to the remote host.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.ConnectTimeoutException -->
  <!-- start interface org.apache.hadoop.net.DNSToSwitchMapping -->
  <interface name="DNSToSwitchMapping"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="resolve" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.util.List"/>
      <doc>
      <![CDATA[Resolves a list of DNS-names/IP-addresses and returns back a list of
 switch information (network paths). One-to-one correspondence must be 
 maintained between the elements in the lists. 
 Consider an element in the argument list - x.y.com. The switch information
 that is returned must be a network path of the form /foo/rack, 
 where / is the root, and 'foo' is the switch where 'rack' is connected.
 Note the hostname/ip-address is not part of the returned path.
 The network topology of the cluster would determine the number of
 components in the network path.
 <p>

 If a name cannot be resolved to a rack, the implementation
 should return {@link NetworkTopology#DEFAULT_RACK}. This
 is what the bundled implementations do, though it is not a formal requirement

 @param names the list of hosts to resolve (can be empty)
 @return list of resolved network paths.
 If <i>names</i> is empty, the returned list is also empty]]>
      </doc>
    </method>
    <method name="reloadCachedMappings"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reload all of the cached mappings.

 If there is a cache, this method will clear it, so that future accesses
 will get a chance to see the new data.]]>
      </doc>
    </method>
    <method name="reloadCachedMappings"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.util.List"/>
      <doc>
      <![CDATA[Reload cached mappings on specific nodes.

 If there is a cache on these nodes, this method will clear it, so that 
 future accesses will see updated data.

 @param names input names.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An interface that must be implemented to allow pluggable
 DNS-name/IP-address to RackID resolvers.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.net.DNSToSwitchMapping -->
  <!-- start class org.apache.hadoop.net.ScriptBasedMapping -->
  <class name="ScriptBasedMapping" extends="org.apache.hadoop.net.CachedDNSToSwitchMapping"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ScriptBasedMapping"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance with the default configuration.
 <p>
 Calling {@link #setConf(Configuration)} will trigger a
 re-evaluation of the configuration settings and so be used to
 set up the mapping script.]]>
      </doc>
    </constructor>
    <constructor name="ScriptBasedMapping" type="org.apache.hadoop.net.DNSToSwitchMapping"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance from the given raw mapping
 @param rawMap raw DNSTOSwithMapping]]>
      </doc>
    </constructor>
    <constructor name="ScriptBasedMapping" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance from the given configuration
 @param conf configuration]]>
      </doc>
    </constructor>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[{@inheritDoc}.
 <p>
 This will get called in the superclass constructor, so a check is needed
 to ensure that the raw mapping is defined before trying to relaying a null
 configuration.
 </p>
 @param conf input Configuration.]]>
      </doc>
    </method>
    <field name="NO_SCRIPT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Text used in the {@link #toString()} method if there is no string
 {@value}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This class implements the {@link DNSToSwitchMapping} interface using a 
 script configured via the
 {@link CommonConfigurationKeys#NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY} option.
 <p>
 It contains a static class <code>RawScriptBasedMapping</code> that performs
 the work: reading the configuration parameters, executing any defined
 script, handling errors and such like. The outer
 class extends {@link CachedDNSToSwitchMapping} to cache the delegated
 queries.
 <p>
 This DNS mapper's {@link #isSingleSwitch()} predicate returns
 true if and only if a script is defined.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.ScriptBasedMapping -->
  <!-- start class org.apache.hadoop.net.SocksSocketFactory -->
  <class name="SocksSocketFactory" extends="javax.net.SocketFactory"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="SocksSocketFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default empty constructor (for use with the reflection API).]]>
      </doc>
    </constructor>
    <constructor name="SocksSocketFactory" type="java.net.Proxy"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with a supplied Proxy
 
 @param proxy the proxy to use to create sockets]]>
      </doc>
    </constructor>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addr" type="java.net.InetAddress"/>
      <param name="port" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addr" type="java.net.InetAddress"/>
      <param name="port" type="int"/>
      <param name="localHostAddr" type="java.net.InetAddress"/>
      <param name="localPort" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="port" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="port" type="int"/>
      <param name="localHostAddr" type="java.net.InetAddress"/>
      <param name="localPort" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <doc>
    <![CDATA[Specialized SocketFactory to create sockets with a SOCKS proxy]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.SocksSocketFactory -->
  <!-- start class org.apache.hadoop.net.StandardSocketFactory -->
  <class name="StandardSocketFactory" extends="javax.net.SocketFactory"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="StandardSocketFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default empty constructor (for use with the reflection API).]]>
      </doc>
    </constructor>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addr" type="java.net.InetAddress"/>
      <param name="port" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addr" type="java.net.InetAddress"/>
      <param name="port" type="int"/>
      <param name="localHostAddr" type="java.net.InetAddress"/>
      <param name="localPort" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="port" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="port" type="int"/>
      <param name="localHostAddr" type="java.net.InetAddress"/>
      <param name="localPort" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Specialized SocketFactory to create sockets with a SOCKS proxy]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.StandardSocketFactory -->
  <!-- start class org.apache.hadoop.net.TableMapping -->
  <class name="TableMapping" extends="org.apache.hadoop.net.CachedDNSToSwitchMapping"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TableMapping"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="reloadCachedMappings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 Simple {@link DNSToSwitchMapping} implementation that reads a 2 column text
 file. The columns are separated by whitespace. The first column is a DNS or
 IP address and the second column specifies the rack where the address maps.
 </p>
 <p>
 This class uses the configuration parameter {@code
 net.topology.table.file.name} to locate the mapping file.
 </p>
 <p>
 Calls to {@link #resolve(List)} will look up the address as defined in the
 mapping file. If no entry corresponding to the address is found, the value
 {@code /default-rack} is returned.
 </p>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.TableMapping -->
</package>
<package name="org.apache.hadoop.net.unix">
</package>
<package name="org.apache.hadoop.security">
  <!-- start class org.apache.hadoop.security.AccessControlException -->
  <class name="AccessControlException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AccessControlException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor is needed for unwrapping from 
 {@link org.apache.hadoop.ipc.RemoteException}.]]>
      </doc>
    </constructor>
    <constructor name="AccessControlException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an {@link AccessControlException}
 with the specified detail message.
 @param s the detail message.]]>
      </doc>
    </constructor>
    <constructor name="AccessControlException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new exception with the specified cause and a detail
 message of <tt>(cause==null ? null : cause.toString())</tt> (which
 typically contains the class and detail message of <tt>cause</tt>).
 @param  cause the cause (which is saved for later retrieval by the
         {@link #getCause()} method).  (A <tt>null</tt> value is
         permitted, and indicates that the cause is nonexistent or
         unknown.)]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[An exception class for access control related issues.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.AccessControlException -->
  <!-- start class org.apache.hadoop.security.Credentials -->
  <class name="Credentials" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="Credentials"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an empty credentials instance.]]>
      </doc>
    </constructor>
    <constructor name="Credentials" type="org.apache.hadoop.security.Credentials"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a copy of the given credentials.
 @param credentials to copy]]>
      </doc>
    </constructor>
    <method name="getToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="alias" type="org.apache.hadoop.io.Text"/>
      <doc>
      <![CDATA[Returns the Token object for the alias.
 @param alias the alias for the Token
 @return token for this alias]]>
      </doc>
    </method>
    <method name="addToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="alias" type="org.apache.hadoop.io.Text"/>
      <param name="t" type="org.apache.hadoop.security.token.Token"/>
      <doc>
      <![CDATA[Add a token in the storage (in memory).
 @param alias the alias for the key
 @param t the token object]]>
      </doc>
    </method>
    <method name="getAllTokens" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return all the tokens in the in-memory map.

 @return all the tokens in the in-memory map.]]>
      </doc>
    </method>
    <method name="getTokenMap" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable version of the full map of aliases to Tokens.

 @return TokenMap.]]>
      </doc>
    </method>
    <method name="numberOfTokens" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return number of Tokens in the in-memory map]]>
      </doc>
    </method>
    <method name="getSecretKey" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="alias" type="org.apache.hadoop.io.Text"/>
      <doc>
      <![CDATA[Returns the key bytes for the alias.
 @param alias the alias for the key
 @return key for this alias]]>
      </doc>
    </method>
    <method name="numberOfSecretKeys" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return number of keys in the in-memory map]]>
      </doc>
    </method>
    <method name="addSecretKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="alias" type="org.apache.hadoop.io.Text"/>
      <param name="key" type="byte[]"/>
      <doc>
      <![CDATA[Set the key for an alias.
 @param alias the alias for the key
 @param key the key bytes]]>
      </doc>
    </method>
    <method name="removeSecretKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="alias" type="org.apache.hadoop.io.Text"/>
      <doc>
      <![CDATA[Remove the key for a given alias.
 @param alias the alias for the key]]>
      </doc>
    </method>
    <method name="getAllSecretKeys" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return all the secret key entries in the in-memory map.

 @return Text List.]]>
      </doc>
    </method>
    <method name="getSecretKeyMap" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an unmodifiable version of the full map of aliases to secret keys.

 @return SecretKeyMap.]]>
      </doc>
    </method>
    <method name="readTokenStorageFile" return="org.apache.hadoop.security.Credentials"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="org.apache.hadoop.fs.Path"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Convenience method for reading a token storage file and loading its Tokens.
 @param filename filename.
 @param conf configuration.
 @throws IOException  raised on errors performing I/O.
 @return Credentials.]]>
      </doc>
    </method>
    <method name="readTokenStorageFile" return="org.apache.hadoop.security.Credentials"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="java.io.File"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Convenience method for reading a token storage file and loading its Tokens.
 @param filename filename.
 @param conf configuration.
 @throws IOException raised on errors performing I/O.
 @return Token.]]>
      </doc>
    </method>
    <method name="readTokenStorageStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Convenience method for reading a token from a DataInputStream.

 @param in DataInputStream.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="writeTokenStorageToStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="os" type="java.io.DataOutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeTokenStorageToStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="os" type="java.io.DataOutputStream"/>
      <param name="format" type="org.apache.hadoop.security.Credentials.SerializedFormat"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeTokenStorageFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="org.apache.hadoop.fs.Path"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeTokenStorageFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="org.apache.hadoop.fs.Path"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="format" type="org.apache.hadoop.security.Credentials.SerializedFormat"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Stores all the keys to DataOutput.
 @param out DataOutput.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Loads all the keys.
 @param in DataInput.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="addAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.security.Credentials"/>
      <doc>
      <![CDATA[Copy all of the credentials from one credential object into another.
 Existing secrets and tokens are overwritten.
 @param other the credentials to copy]]>
      </doc>
    </method>
    <method name="mergeAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.security.Credentials"/>
      <doc>
      <![CDATA[Copy all of the credentials from one credential object into another.
 Existing secrets and tokens are not overwritten.
 @param other the credentials to copy]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A class that provides the facilities of reading and writing
 secret keys and Tokens.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.Credentials -->
  <!-- start interface org.apache.hadoop.security.GroupMappingServiceProvider -->
  <interface name="GroupMappingServiceProvider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getGroups" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all various group memberships of a given user.
 Returns EMPTY list in case of non-existing user
 @param user User's name
 @return group memberships of user
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="cacheGroupsRefresh"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Refresh the cache of groups and user mapping
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="cacheGroupsAdd"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="groups" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Caches the group user information
 @param groups list of groups to add to cache
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <field name="GROUP_MAPPING_CONFIG_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[An interface for the implementation of a user-to-groups mapping service
 used by {@link Groups}.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.security.GroupMappingServiceProvider -->
  <!-- start interface org.apache.hadoop.security.IdMappingServiceProvider -->
  <interface name="IdMappingServiceProvider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getUid" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getGid" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="group" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getUserName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uid" type="int"/>
      <param name="unknown" type="java.lang.String"/>
    </method>
    <method name="getGroupName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="gid" type="int"/>
      <param name="unknown" type="java.lang.String"/>
    </method>
    <method name="getUidAllowingUnknown" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
    </method>
    <method name="getGidAllowingUnknown" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="group" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An interface for the implementation of {@literal <}userId,
 userName{@literal >} mapping and {@literal <}groupId, groupName{@literal >}
 mapping.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.security.IdMappingServiceProvider -->
  <!-- start class org.apache.hadoop.security.KerberosAuthException -->
  <class name="KerberosAuthException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KerberosAuthException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="KerberosAuthException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="KerberosAuthException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setUser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="u" type="java.lang.String"/>
    </method>
    <method name="setPrincipal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="java.lang.String"/>
    </method>
    <method name="setKeytabFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k" type="java.lang.String"/>
    </method>
    <method name="setTicketCacheFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.String"/>
    </method>
    <method name="getInitialMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The initial message, or null if not set.]]>
      </doc>
    </method>
    <method name="getKeytabFile" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The keytab file path, or null if not set.]]>
      </doc>
    </method>
    <method name="getPrincipal" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The principal, or null if not set.]]>
      </doc>
    </method>
    <method name="getTicketCacheFile" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The ticket cache file path, or null if not set.]]>
      </doc>
    </method>
    <method name="getUser" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The user, or null if not set.]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown when {@link UserGroupInformation} failed with an unrecoverable error,
 such as failure in kerberos login/logout, invalid subject etc.

 Caller should not retry when catching this exception.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.KerberosAuthException -->
  <!-- start class org.apache.hadoop.security.SecurityUtil -->
  <class name="SecurityUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="setConfiguration"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="isOriginalTGT" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="ticket" type="javax.security.auth.kerberos.KerberosTicket"/>
      <doc>
      <![CDATA[Check whether the server principal is the TGS's principal
 @param ticket the original TGT (the ticket that is obtained when a 
 kinit is done)
 @return true or false]]>
      </doc>
    </method>
    <method name="getServerPrincipal" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="principalConfig" type="java.lang.String"/>
      <param name="hostname" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Convert Kerberos principal name pattern to valid Kerberos principal
 names. It replaces hostname pattern with hostname, which should be
 fully-qualified domain name. If hostname is null or "0.0.0.0", it uses
 dynamically looked-up fqdn of the current host instead.
 
 @param principalConfig
          the Kerberos principal name conf value to convert
 @param hostname
          the fully-qualified domain name used for substitution
 @return converted Kerberos principal name
 @throws IOException if the client address cannot be determined]]>
      </doc>
    </method>
    <method name="getServerPrincipal" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="principalConfig" type="java.lang.String"/>
      <param name="addr" type="java.net.InetAddress"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Convert Kerberos principal name pattern to valid Kerberos principal names.
 This method is similar to {@link #getServerPrincipal(String, String)},
 except 1) the reverse DNS lookup from addr to hostname is done only when
 necessary, 2) param addr can't be null (no default behavior of using local
 hostname when addr is null).
 
 @param principalConfig
          Kerberos principal name pattern to convert
 @param addr
          InetAddress of the host used for substitution
 @return converted Kerberos principal name
 @throws IOException if the client address cannot be determined]]>
      </doc>
    </method>
    <method name="login"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="keytabFileKey" type="java.lang.String"/>
      <param name="userNameKey" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Login as a principal specified in config. Substitute $host in
 user's Kerberos principal name with a dynamically looked-up fully-qualified
 domain name of the current host.
 
 @param conf
          conf to use
 @param keytabFileKey
          the key to look for keytab file in conf
 @param userNameKey
          the key to look for user's Kerberos principal name in conf
 @throws IOException if login fails]]>
      </doc>
    </method>
    <method name="login"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="keytabFileKey" type="java.lang.String"/>
      <param name="userNameKey" type="java.lang.String"/>
      <param name="hostname" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Login as a principal specified in config. Substitute $host in user's Kerberos principal 
 name with hostname. If non-secure mode - return. If no keytab available -
 bail out with an exception
 
 @param conf
          conf to use
 @param keytabFileKey
          the key to look for keytab file in conf
 @param userNameKey
          the key to look for user's Kerberos principal name in conf
 @param hostname
          hostname to use for substitution
 @throws IOException if the config doesn't specify a keytab]]>
      </doc>
    </method>
    <method name="buildDTServiceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="defPort" type="int"/>
      <doc>
      <![CDATA[create the service name for a Delegation token
 @param uri of the service
 @param defPort is used if the uri lacks a port
 @return the token service, or null if no authority
 @see #buildTokenService(InetSocketAddress)]]>
      </doc>
    </method>
    <method name="getHostFromPrincipal" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="principalName" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the host name from the principal name of format {@literal <}service
 {@literal >}/host@realm.
 @param principalName principal name of format as described above
 @return host name if the the string conforms to the above format, else null]]>
      </doc>
    </method>
    <method name="getKerberosInfo" return="org.apache.hadoop.security.KerberosInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Look up the KerberosInfo for a given protocol. It searches all known
 SecurityInfo providers.
 @param protocol the protocol class to get the information for
 @param conf configuration object
 @return the KerberosInfo or null if it has no KerberosInfo defined]]>
      </doc>
    </method>
    <method name="getClientPrincipal" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Look up the client principal for a given protocol. It searches all known
 SecurityInfo providers.
 @param protocol the protocol class to get the information for
 @param conf configuration object
 @return client principal or null if it has no client principal defined.]]>
      </doc>
    </method>
    <method name="getTokenInfo" return="org.apache.hadoop.security.token.TokenInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Look up the TokenInfo for a given protocol. It searches all known
 SecurityInfo providers.
 @param protocol The protocol class to get the information for.
 @param conf Configuration object
 @return the TokenInfo or null if it has no KerberosInfo defined]]>
      </doc>
    </method>
    <method name="getTokenServiceAddr" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="token" type="org.apache.hadoop.security.token.Token"/>
      <doc>
      <![CDATA[Decode the given token's service field into an InetAddress
 @param token from which to obtain the service
 @return InetAddress for the service]]>
      </doc>
    </method>
    <method name="setTokenService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="token" type="org.apache.hadoop.security.token.Token"/>
      <param name="addr" type="java.net.InetSocketAddress"/>
      <doc>
      <![CDATA[Set the given token's service to the format expected by the RPC client 
 @param token a delegation token
 @param addr the socket for the rpc connection]]>
      </doc>
    </method>
    <method name="buildTokenService" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addr" type="java.net.InetSocketAddress"/>
      <doc>
      <![CDATA[Construct the service key for a token
 @param addr InetSocketAddress of remote connection with a token
 @return "ip:port" or "host:port" depending on the value of
          hadoop.security.token.service.use_ip]]>
      </doc>
    </method>
    <method name="buildTokenService" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Construct the service key for a token
 @param uri of remote connection with a token
 @return "ip:port" or "host:port" depending on the value of
          hadoop.security.token.service.use_ip]]>
      </doc>
    </method>
    <method name="doAsLoginUserOrFatal" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="java.security.PrivilegedAction"/>
      <doc>
      <![CDATA[Perform the given action as the daemon's login user. If the login
 user cannot be determined, this will log a FATAL error and exit
 the whole JVM.

 @param action action.
 @param <T> generic type T.
 @return generic type T.]]>
      </doc>
    </method>
    <method name="doAsLoginUser" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="java.security.PrivilegedExceptionAction"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Perform the given action as the daemon's login user. If an
 InterruptedException is thrown, it is converted to an IOException.

 @param action the action to perform
 @param <T> Generics Type T.
 @return the result of the action
 @throws IOException in the event of error]]>
      </doc>
    </method>
    <method name="doAsCurrentUser" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="java.security.PrivilegedExceptionAction"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Perform the given action as the daemon's current user. If an
 InterruptedException is thrown, it is converted to an IOException.

 @param action the action to perform
 @param <T> generic type T.
 @return the result of the action
 @throws IOException in the event of error]]>
      </doc>
    </method>
    <method name="getAuthenticationMethod" return="org.apache.hadoop.security.UserGroupInformation.AuthenticationMethod"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="setAuthenticationMethod"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="authenticationMethod" type="org.apache.hadoop.security.UserGroupInformation.AuthenticationMethod"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="isPrivilegedPort" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="port" type="int"/>
    </method>
    <method name="getZKAuthInfos" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="configKey" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Utility method to fetch ZK auth info from the configuration.

 @param conf configuration.
 @param configKey config key.
 @throws java.io.IOException if the Zookeeper ACLs configuration file
 cannot be read
 @throws ZKUtil.BadAuthFormatException if the auth format is invalid
 @return ZKAuthInfo List.]]>
      </doc>
    </method>
    <field name="LOG" type="org.slf4j.Logger"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HOSTNAME_PATTERN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FAILED_TO_GET_UGI_MSG_HEADER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Security Utils.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.SecurityUtil -->
  <!-- start class org.apache.hadoop.security.UserGroupInformation -->
  <class name="UserGroupInformation" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setShouldRenewImmediatelyForTests"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="immediate" type="boolean"/>
      <doc>
      <![CDATA[For the purposes of unit tests, we want to test login
 from keytab and don't want to wait until the renew
 window (controlled by TICKET_RENEW_WINDOW).
 @param immediate true if we should login without waiting for ticket window]]>
      </doc>
    </method>
    <method name="reattachMetrics"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reattach the class's metrics to a new metric system.]]>
      </doc>
    </method>
    <method name="isInitialized" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConfiguration"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Set the static configuration for UGI.
 In particular, set the security authentication mechanism and the
 group look up service.
 @param conf the configuration to use]]>
      </doc>
    </method>
    <method name="isSecurityEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Determine if UserGroupInformation is using Kerberos to determine
 user identities or is relying on simple authentication
 
 @return true if UGI is working in a secure environment]]>
      </doc>
    </method>
    <method name="hasKerberosCredentials" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[checks if logged in using kerberos
 @return true if the subject logged via keytab or has a Kerberos TGT]]>
      </doc>
    </method>
    <method name="getCurrentUser" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the current user, including any doAs in the current stack.
 @return the current user
 @throws IOException if login fails]]>
      </doc>
    </method>
    <method name="getBestUGI" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticketCachePath" type="java.lang.String"/>
      <param name="user" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Find the most appropriate UserGroupInformation to use

 @param ticketCachePath    The Kerberos ticket cache path, or NULL
                           if none is specfied
 @param user               The user name, or NULL if none is specified.

 @return                   The most appropriate UserGroupInformation
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getUGIFromTicketCache" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ticketCache" type="java.lang.String"/>
      <param name="user" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a UserGroupInformation from a Kerberos ticket cache.
 
 @param user                The principal name to load from the ticket
                            cache
 @param ticketCache     the path to the ticket cache file

 @throws IOException        if the kerberos login fails
 @return UserGroupInformation.]]>
      </doc>
    </method>
    <method name="getUGIFromSubject" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="subject" type="javax.security.auth.Subject"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a UserGroupInformation from a Subject with Kerberos principal.

 @param subject             The KerberosPrincipal to use in UGI.
                            The creator of subject is responsible for
                            renewing credentials.

 @throws IOException raised on errors performing I/O.
 @throws KerberosAuthException if the kerberos login fails
 @return UserGroupInformation.]]>
      </doc>
    </method>
    <method name="getLoginUser" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the currently logged in user.  If no explicit login has occurred,
 the user will automatically be logged in with either kerberos credentials
 if available, or as the local OS user, based on security settings.
 @return the logged in user
 @throws IOException if login fails]]>
      </doc>
    </method>
    <method name="trimLoginMethod" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="userName" type="java.lang.String"/>
      <doc>
      <![CDATA[remove the login method that is followed by a space from the username
 e.g. "jack (auth:SIMPLE)" {@literal ->} "jack"

 @param userName input userName.
 @return userName without login method]]>
      </doc>
    </method>
    <method name="loginUserFromSubject"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="subject" type="javax.security.auth.Subject"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Log in a user using the given subject
 @param subject the subject to use when logging in a user, or null to
 create a new subject.

 If subject is not null, the creator of subject is responsible for renewing
 credentials.

 @throws IOException if login fails]]>
      </doc>
    </method>
    <method name="isFromKeytab" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Is this user logged in from a keytab file managed by the UGI?
 @return true if the credentials are from a keytab file.]]>
      </doc>
    </method>
    <method name="loginUserFromKeytab"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <param name="path" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Log a user in from a keytab file. Loads a user identity from a keytab
 file and logs them in. They become the currently logged-in user.
 @param user the principal name to load from the keytab
 @param path the path to the keytab file
 @throws IOException raised on errors performing I/O.
 @throws KerberosAuthException if it's a kerberos login exception.]]>
      </doc>
    </method>
    <method name="logoutUserFromKeytab"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Log the current user out who previously logged in using keytab.
 This method assumes that the user logged in by calling
 {@link #loginUserFromKeytab(String, String)}.

 @throws IOException raised on errors performing I/O.
 @throws KerberosAuthException if a failure occurred in logout,
 or if the user did not log in by invoking loginUserFromKeyTab() before.]]>
      </doc>
    </method>
    <method name="checkTGTAndReloginFromKeytab"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Re-login a user from keytab if TGT is expired or is close to expiry.
 
 @throws IOException raised on errors performing I/O.
 @throws KerberosAuthException if it's a kerberos login exception.]]>
      </doc>
    </method>
    <method name="reloginFromKeytab"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Re-Login a user in from a keytab file. Loads a user identity from a keytab
 file and logs them in. They become the currently logged-in user. This
 method assumes that {@link #loginUserFromKeytab(String, String)} had
 happened already.
 The Subject field of this UserGroupInformation object is updated to have
 the new credentials.
 @throws IOException raised on errors performing I/O.
 @throws KerberosAuthException on a failure]]>
      </doc>
    </method>
    <method name="forceReloginFromKeytab"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Force re-Login a user in from a keytab file irrespective of the last login
 time. Loads a user identity from a keytab file and logs them in. They
 become the currently logged-in user. This method assumes that
 {@link #loginUserFromKeytab(String, String)} had happened already. The
 Subject field of this UserGroupInformation object is updated to have the
 new credentials.

 @throws IOException raised on errors performing I/O.
 @throws KerberosAuthException on a failure]]>
      </doc>
    </method>
    <method name="reloginFromTicketCache"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Re-Login a user in from the ticket cache.  This
 method assumes that login had happened already.
 The Subject field of this UserGroupInformation object is updated to have
 the new credentials.
 @throws IOException raised on errors performing I/O.
 @throws KerberosAuthException on a failure]]>
      </doc>
    </method>
    <method name="loginUserFromKeytabAndReturnUGI" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <param name="path" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Log a user in from a keytab file. Loads a user identity from a keytab
 file and login them in. This new user does not affect the currently
 logged-in user.
 @param user the principal name to load from the keytab
 @param path the path to the keytab file
 @throws IOException if the keytab file can't be read
 @return UserGroupInformation.]]>
      </doc>
    </method>
    <method name="isLoginKeytabBased" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Did the login happen via keytab.
 @return true or false
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="isLoginTicketBased" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Did the login happen via ticket cache.
 @return true or false
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="createRemoteUser" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <doc>
      <![CDATA[Create a user from a login name. It is intended to be used for remote
 users in RPC, since it won't have any credentials.
 @param user the full user principal name, must not be empty or null
 @return the UserGroupInformation for the remote user.]]>
      </doc>
    </method>
    <method name="createRemoteUser" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <param name="authMethod" type="org.apache.hadoop.security.SaslRpcServer.AuthMethod"/>
      <doc>
      <![CDATA[Create a user from a login name. It is intended to be used for remote
 users in RPC, since it won't have any credentials.

 @param user the full user principal name, must not be empty or null
 @param authMethod input authMethod.
 @return the UserGroupInformation for the remote user.]]>
      </doc>
    </method>
    <method name="createProxyUser" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <param name="realUser" type="org.apache.hadoop.security.UserGroupInformation"/>
      <doc>
      <![CDATA[Create a proxy user using username of the effective user and the ugi of the
 real user.

 @param user input user.
 @param realUser input realUser.
 @return proxyUser ugi]]>
      </doc>
    </method>
    <method name="getRealUser" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get RealUser (vs. EffectiveUser)
 @return realUser running over proxy user]]>
      </doc>
    </method>
    <method name="getRealUserOrSelf" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="org.apache.hadoop.security.UserGroupInformation"/>
      <doc>
      <![CDATA[If this is a proxy user, get the real user. Otherwise, return
 this user.
 @param user the user to check
 @return the real user or self]]>
      </doc>
    </method>
    <method name="createUserForTesting" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <param name="userGroups" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Create a UGI for testing HDFS and MapReduce
 @param user the full user principal name
 @param userGroups the names of the groups that the user belongs to
 @return a fake user for running unit tests]]>
      </doc>
    </method>
    <method name="createProxyUserForTesting" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <param name="realUser" type="org.apache.hadoop.security.UserGroupInformation"/>
      <param name="userGroups" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Create a proxy user UGI for testing HDFS and MapReduce
 
 @param user
          the full user principal name for effective user
 @param realUser
          UGI of the real user
 @param userGroups
          the names of the groups that the user belongs to
 @return a fake user for running unit tests]]>
      </doc>
    </method>
    <method name="getShortUserName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the user's login name.
 @return the user's name up to the first '/' or '@'.]]>
      </doc>
    </method>
    <method name="getPrimaryGroupName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getUserName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the user's full principal name.
 @return the user's full principal name.]]>
      </doc>
    </method>
    <method name="addTokenIdentifier" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tokenId" type="org.apache.hadoop.security.token.TokenIdentifier"/>
      <doc>
      <![CDATA[Add a TokenIdentifier to this UGI. The TokenIdentifier has typically been
 authenticated by the RPC layer as belonging to the user represented by this
 UGI.
 
 @param tokenId
          tokenIdentifier to be added
 @return true on successful add of new tokenIdentifier]]>
      </doc>
    </method>
    <method name="getTokenIdentifiers" return="java.util.Set"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the set of TokenIdentifiers belonging to this UGI
 
 @return the set of TokenIdentifiers belonging to this UGI]]>
      </doc>
    </method>
    <method name="addToken" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="token" type="org.apache.hadoop.security.token.Token"/>
      <doc>
      <![CDATA[Add a token to this UGI
 
 @param token Token to be added
 @return true on successful add of new token]]>
      </doc>
    </method>
    <method name="addToken" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="alias" type="org.apache.hadoop.io.Text"/>
      <param name="token" type="org.apache.hadoop.security.token.Token"/>
      <doc>
      <![CDATA[Add a named token to this UGI
 
 @param alias Name of the token
 @param token Token to be added
 @return true on successful add of new token]]>
      </doc>
    </method>
    <method name="getTokens" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain the collection of tokens associated with this user.
 
 @return an unmodifiable collection of tokens associated with user]]>
      </doc>
    </method>
    <method name="getCredentials" return="org.apache.hadoop.security.Credentials"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain the tokens in credentials form associated with this user.
 
 @return Credentials of tokens associated with this user]]>
      </doc>
    </method>
    <method name="addCredentials"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="credentials" type="org.apache.hadoop.security.Credentials"/>
      <doc>
      <![CDATA[Add the given Credentials to this user.
 @param credentials of tokens and secrets]]>
      </doc>
    </method>
    <method name="getGroupNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the group names for this user. {@link #getGroups()} is less
 expensive alternative when checking for a contained element.
 @return the list of users with the primary group first. If the command
    fails, it returns an empty list.]]>
      </doc>
    </method>
    <method name="getGroups" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the group names for this user.
 @return the list of users with the primary group first. If the command
    fails, it returns an empty list.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the username.]]>
      </doc>
    </method>
    <method name="setAuthenticationMethod"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="authMethod" type="org.apache.hadoop.security.UserGroupInformation.AuthenticationMethod"/>
      <doc>
      <![CDATA[Sets the authentication method in the subject.
 
 @param authMethod input authMethod.]]>
      </doc>
    </method>
    <method name="setAuthenticationMethod"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="authMethod" type="org.apache.hadoop.security.SaslRpcServer.AuthMethod"/>
      <doc>
      <![CDATA[Sets the authentication method in the subject.
 
 @param authMethod input authMethod.]]>
      </doc>
    </method>
    <method name="getAuthenticationMethod" return="org.apache.hadoop.security.UserGroupInformation.AuthenticationMethod"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the authentication method from the subject
 
 @return AuthenticationMethod in the subject, null if not present.]]>
      </doc>
    </method>
    <method name="getRealAuthenticationMethod" return="org.apache.hadoop.security.UserGroupInformation.AuthenticationMethod"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the authentication method from the real user's subject.  If there
 is no real user, return the given user's authentication method.
 
 @return AuthenticationMethod in the subject, null if not present.]]>
      </doc>
    </method>
    <method name="getRealAuthenticationMethod" return="org.apache.hadoop.security.UserGroupInformation.AuthenticationMethod"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ugi" type="org.apache.hadoop.security.UserGroupInformation"/>
      <doc>
      <![CDATA[Returns the authentication method of a ugi. If the authentication method is
 PROXY, returns the authentication method of the real user.
 
 @param ugi input ugi.
 @return AuthenticationMethod]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compare the subjects to see if they are equal to each other.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the hash of the subject.]]>
      </doc>
    </method>
    <method name="getSubject" return="javax.security.auth.Subject"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the underlying subject from this ugi.
 @return the subject that represents this user.]]>
      </doc>
    </method>
    <method name="doAs" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="java.security.PrivilegedAction"/>
      <doc>
      <![CDATA[Run the given action as the user.
 @param <T> the return type of the run method
 @param action the method to execute
 @return the value from the run method]]>
      </doc>
    </method>
    <method name="doAs" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="java.security.PrivilegedExceptionAction"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Run the given action as the user, potentially throwing an exception.
 @param <T> the return type of the run method
 @param action the method to execute
 @return the value from the run method
 @throws IOException if the action throws an IOException
 @throws Error if the action throws an Error
 @throws RuntimeException if the action throws a RuntimeException
 @throws InterruptedException if the action throws an InterruptedException
 @throws UndeclaredThrowableException if the action throws something else]]>
      </doc>
    </method>
    <method name="logAllUserInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ugi" type="org.apache.hadoop.security.UserGroupInformation"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Log all (current, real, login) UGI and token info into UGI debug log.
 @param ugi - UGI
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[A test method to print out the current user's UGI.
 @param args if there are two arguments, read the user from the keytab
 and print it out.
 @throws Exception if any error occurs.]]>
      </doc>
    </method>
    <field name="HADOOP_TOKEN_FILE_LOCATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Environment variable pointing to the token cache file]]>
      </doc>
    </field>
    <field name="HADOOP_TOKEN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Environment variable pointing to the base64 tokens.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[User and group information for Hadoop.
 This class wraps around a JAAS Subject and provides methods to determine the
 user's username and groups. It supports both the Windows, Unix and Kerberos 
 login modules.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.UserGroupInformation -->
  <!-- start class org.apache.hadoop.security.UserGroupInformation.AuthenticationMethod -->
  <class name="UserGroupInformation.AuthenticationMethod" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.security.UserGroupInformation.AuthenticationMethod[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.security.UserGroupInformation.AuthenticationMethod"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getAuthMethod" return="org.apache.hadoop.security.SaslRpcServer.AuthMethod"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.security.UserGroupInformation.AuthenticationMethod"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="authMethod" type="org.apache.hadoop.security.SaslRpcServer.AuthMethod"/>
    </method>
    <doc>
    <![CDATA[existing types of authentications' methods]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.UserGroupInformation.AuthenticationMethod -->
</package>
<package name="org.apache.hadoop.security.alias">
  <!-- start class org.apache.hadoop.security.alias.CredentialProvider -->
  <class name="CredentialProvider" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CredentialProvider"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isTransient" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this provider represents a store
 that is intended for transient use - such as the UserProvider
 is. These providers are generally used to provide job access to
 passwords rather than for long term storage.
 @return true if transient, false otherwise]]>
      </doc>
    </method>
    <method name="flush"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Ensures that any changes to the credentials are written to persistent
 store.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getCredentialEntry" return="org.apache.hadoop.security.alias.CredentialProvider.CredentialEntry"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="alias" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the credential entry for a specific alias.
 @param alias the name of a specific credential
 @return the credentialEntry
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getAliases" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the aliases for all credentials.
 @return the list of alias names
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="createCredentialEntry" return="org.apache.hadoop.security.alias.CredentialProvider.CredentialEntry"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="credential" type="char[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a new credential. The given alias must not already exist.
 @param name the alias of the credential
 @param credential the credential value for the alias.
 @throws IOException raised on errors performing I/O.
 @return CredentialEntry.]]>
      </doc>
    </method>
    <method name="deleteCredentialEntry"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete the given credential.
 @param name the alias of the credential to delete
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="needsPassword" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Does this provider require a password? This means that a password is
 required for normal operation, and it has not been found through normal
 means. If true, the password should be provided by the caller using
 setPassword().
 @return Whether or not the provider requires a password
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="noPasswordWarning" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If a password for the provider is needed, but is not provided, this will
 return a warning and instructions for supplying said password to the
 provider.
 @return A warning and instructions for supplying the password]]>
      </doc>
    </method>
    <method name="noPasswordError" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If a password for the provider is needed, but is not provided, this will
 return an error message and instructions for supplying said password to
 the provider.
 @return An error message and instructions for supplying the password]]>
      </doc>
    </method>
    <field name="CLEAR_TEXT_FALLBACK" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A provider of credentials or password for Hadoop applications. Provides an
 abstraction to separate credential storage from users of them. It
 is intended to support getting or storing passwords in a variety of ways,
 including third party bindings.
 
 <code>CredentialProvider</code> implementations must be thread safe.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.alias.CredentialProvider -->
  <!-- start class org.apache.hadoop.security.alias.CredentialProviderFactory -->
  <class name="CredentialProviderFactory" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CredentialProviderFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createProvider" return="org.apache.hadoop.security.alias.CredentialProvider"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerName" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getProviders" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="CREDENTIAL_PROVIDER_PATH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A factory to create a list of CredentialProvider based on the path given in a
 Configuration. It uses a service loader interface to find the available
 CredentialProviders and create them based on the list of URIs.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.alias.CredentialProviderFactory -->
</package>
<package name="org.apache.hadoop.security.authentication.server">
</package>
<package name="org.apache.hadoop.security.authorize">
  <!-- start class org.apache.hadoop.security.authorize.AccessControlList -->
  <class name="AccessControlList" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="AccessControlList"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This constructor exists primarily for AccessControlList to be Writable.]]>
      </doc>
    </constructor>
    <constructor name="AccessControlList" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a new ACL from a String representation of the same.
 
 The String is a a comma separated list of users and groups.
 The user list comes first and is separated by a space followed 
 by the group list. For e.g. "user1,user2 group1,group2"
 
 @param aclString String representation of the ACL]]>
      </doc>
    </constructor>
    <constructor name="AccessControlList" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a new ACL from String representation of users and groups
 
 The arguments are comma separated lists
 
 @param users comma separated list of users
 @param groups comma separated list of groups]]>
      </doc>
    </constructor>
    <method name="isAllAllowed" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addUser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <doc>
      <![CDATA[Add user to the names of users allowed for this service.
 
 @param user
          The user name]]>
      </doc>
    </method>
    <method name="addGroup"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="group" type="java.lang.String"/>
      <doc>
      <![CDATA[Add group to the names of groups allowed for this service.
 
 @param group
          The group name]]>
      </doc>
    </method>
    <method name="removeUser"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <doc>
      <![CDATA[Remove user from the names of users allowed for this service.
 
 @param user
          The user name]]>
      </doc>
    </method>
    <method name="removeGroup"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="group" type="java.lang.String"/>
      <doc>
      <![CDATA[Remove group from the names of groups allowed for this service.
 
 @param group
          The group name]]>
      </doc>
    </method>
    <method name="getUsers" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the names of users allowed for this service.
 @return the set of user names. the set must not be modified.]]>
      </doc>
    </method>
    <method name="getGroups" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the names of user groups allowed for this service.
 @return the set of group names. the set must not be modified.]]>
      </doc>
    </method>
    <method name="isUserInList" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="ugi" type="org.apache.hadoop.security.UserGroupInformation"/>
      <doc>
      <![CDATA[Checks if a user represented by the provided {@link UserGroupInformation}
 is a member of the Access Control List. If user was proxied and
 USE_REAL_ACLS + the real user name is in the control list, then treat this
 case as if user were in the ACL list.
 @param ugi UserGroupInformation to check if contained in the ACL
 @return true if ugi is member of the list or if USE_REAL_ACLS + real user
 is in the list]]>
      </doc>
    </method>
    <method name="isUserAllowed" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ugi" type="org.apache.hadoop.security.UserGroupInformation"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns descriptive way of users and groups that are part of this ACL.
 Use {@link #getAclString()} to get the exact String that can be given to
 the constructor of AccessControlList to create a new instance.]]>
      </doc>
    </method>
    <method name="getAclString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the access control list as a String that can be used for building a
 new instance by sending it to the constructor of {@link AccessControlList}.
 @return acl string.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serializes the AccessControlList object]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deserializes the AccessControlList object]]>
      </doc>
    </method>
    <field name="WILDCARD_ACL_VALUE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="USE_REAL_ACLS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Class representing a configured access control list.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.authorize.AccessControlList -->
  <!-- start class org.apache.hadoop.security.authorize.AuthorizationException -->
  <class name="AuthorizationException" extends="org.apache.hadoop.security.AccessControlException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AuthorizationException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AuthorizationException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AuthorizationException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new exception with the specified cause and a detail
 message of <tt>(cause==null ? null : cause.toString())</tt> (which
 typically contains the class and detail message of <tt>cause</tt>).
 @param  cause the cause (which is saved for later retrieval by the
         {@link #getCause()} method).  (A <tt>null</tt> value is
         permitted, and indicates that the cause is nonexistent or
         unknown.)]]>
      </doc>
    </constructor>
    <method name="getStackTrace" return="java.lang.StackTraceElement[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="printStackTrace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="printStackTrace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.io.PrintStream"/>
    </method>
    <method name="printStackTrace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.io.PrintWriter"/>
    </method>
    <doc>
    <![CDATA[An exception class for authorization-related issues.
 
 This class <em>does not</em> provide the stack trace for security purposes.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.authorize.AuthorizationException -->
  <!-- start class org.apache.hadoop.security.authorize.DefaultImpersonationProvider -->
  <class name="DefaultImpersonationProvider" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.security.authorize.ImpersonationProvider"/>
    <constructor name="DefaultImpersonationProvider"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTestProvider" return="org.apache.hadoop.security.authorize.DefaultImpersonationProvider"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="configurationPrefix" type="java.lang.String"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="authorize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="org.apache.hadoop.security.UserGroupInformation"/>
      <param name="remoteAddress" type="java.net.InetAddress"/>
      <exception name="AuthorizationException" type="org.apache.hadoop.security.authorize.AuthorizationException"/>
    </method>
    <method name="getProxySuperuserUserConfKey" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="userName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns configuration key for effective usergroups allowed for a superuser
 
 @param userName name of the superuser
 @return configuration key for superuser usergroups]]>
      </doc>
    </method>
    <method name="getProxySuperuserGroupConfKey" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="userName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns configuration key for effective groups allowed for a superuser
 
 @param userName name of the superuser
 @return configuration key for superuser groups]]>
      </doc>
    </method>
    <method name="getProxySuperuserIpConfKey" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="userName" type="java.lang.String"/>
      <doc>
      <![CDATA[Return configuration key for superuser ip addresses
 
 @param userName name of the superuser
 @return configuration key for superuser ip-addresses]]>
      </doc>
    </method>
    <method name="getProxyGroups" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getProxyHosts" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.security.authorize.DefaultImpersonationProvider -->
  <!-- start interface org.apache.hadoop.security.authorize.ImpersonationProvider -->
  <interface name="ImpersonationProvider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <method name="init"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="configurationPrefix" type="java.lang.String"/>
      <doc>
      <![CDATA[Specifies the configuration prefix for the proxy user properties and
 initializes the provider.

 @param configurationPrefix the configuration prefix for the proxy user
 properties]]>
      </doc>
    </method>
    <method name="authorize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="org.apache.hadoop.security.UserGroupInformation"/>
      <param name="remoteAddress" type="java.lang.String"/>
      <exception name="AuthorizationException" type="org.apache.hadoop.security.authorize.AuthorizationException"/>
      <doc>
      <![CDATA[Authorize the superuser which is doing doAs.
 {@link #authorize(UserGroupInformation, InetAddress)} should
             be preferred to avoid possibly re-resolving the ip address.
 @param user ugi of the effective or proxy user which contains a real user.
 @param remoteAddress the ip address of client.
 @throws AuthorizationException Authorization Exception.]]>
      </doc>
    </method>
    <method name="authorize"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="org.apache.hadoop.security.UserGroupInformation"/>
      <param name="remoteAddress" type="java.net.InetAddress"/>
      <exception name="AuthorizationException" type="org.apache.hadoop.security.authorize.AuthorizationException"/>
      <doc>
      <![CDATA[Authorize the superuser which is doing doAs.

 @param user ugi of the effective or proxy user which contains a real user
 @param remoteAddress the ip address of client
 @throws AuthorizationException Authorization Exception.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.security.authorize.ImpersonationProvider -->
</package>
<package name="org.apache.hadoop.security.http">
  <!-- start class org.apache.hadoop.security.http.RestCsrfPreventionFilter -->
  <class name="RestCsrfPreventionFilter" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.servlet.Filter"/>
    <constructor name="RestCsrfPreventionFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filterConfig" type="javax.servlet.FilterConfig"/>
      <exception name="ServletException" type="javax.servlet.ServletException"/>
    </method>
    <method name="isBrowser" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="userAgent" type="java.lang.String"/>
      <doc>
      <![CDATA[This method interrogates the User-Agent String and returns whether it
 refers to a browser.  If its not a browser, then the requirement for the
 CSRF header will not be enforced; if it is a browser, the requirement will
 be enforced.
 <p>
 A User-Agent String is considered to be a browser if it matches
 any of the regex patterns from browser-useragent-regex; the default
 behavior is to consider everything a browser that matches the following:
 "^Mozilla.*,^Opera.*".  Subclasses can optionally override
 this method to use different behavior.

 @param userAgent The User-Agent String, or null if there isn't one
 @return true if the User-Agent String refers to a browser, false if not]]>
      </doc>
    </method>
    <method name="handleHttpInteraction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="httpInteraction" type="org.apache.hadoop.security.http.RestCsrfPreventionFilter.HttpInteraction"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ServletException" type="javax.servlet.ServletException"/>
      <doc>
      <![CDATA[Handles an {@link HttpInteraction} by applying the filtering logic.

 @param httpInteraction caller's HTTP interaction
 @throws IOException if there is an I/O error
 @throws ServletException if the implementation relies on the servlet API
     and a servlet API call has failed]]>
      </doc>
    </method>
    <method name="doFilter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="javax.servlet.ServletRequest"/>
      <param name="response" type="javax.servlet.ServletResponse"/>
      <param name="chain" type="javax.servlet.FilterChain"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ServletException" type="javax.servlet.ServletException"/>
    </method>
    <method name="destroy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFilterParams" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="confPrefix" type="java.lang.String"/>
      <doc>
      <![CDATA[Constructs a mapping of configuration properties to be used for filter
 initialization.  The mapping includes all properties that start with the
 specified configuration prefix.  Property names in the mapping are trimmed
 to remove the configuration prefix.

 @param conf configuration to read
 @param confPrefix configuration prefix
 @return mapping of configuration properties to be used for filter
     initialization]]>
      </doc>
    </method>
    <field name="HEADER_USER_AGENT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BROWSER_USER_AGENT_PARAM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CUSTOM_HEADER_PARAM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CUSTOM_METHODS_TO_IGNORE_PARAM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HEADER_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This filter provides protection against cross site request forgery (CSRF)
 attacks for REST APIs. Enabling this filter on an endpoint results in the
 requirement of all client to send a particular (configurable) HTTP header
 with every request. In the absense of this header the filter will reject the
 attempt as a bad request.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.http.RestCsrfPreventionFilter -->
  <!-- start class org.apache.hadoop.security.http.XFrameOptionsFilter -->
  <class name="XFrameOptionsFilter" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.servlet.Filter"/>
    <constructor name="XFrameOptionsFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="destroy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="doFilter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="req" type="javax.servlet.ServletRequest"/>
      <param name="res" type="javax.servlet.ServletResponse"/>
      <param name="chain" type="javax.servlet.FilterChain"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ServletException" type="javax.servlet.ServletException"/>
    </method>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="javax.servlet.FilterConfig"/>
      <exception name="ServletException" type="javax.servlet.ServletException"/>
    </method>
    <method name="getFilterParams" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="confPrefix" type="java.lang.String"/>
      <doc>
      <![CDATA[Constructs a mapping of configuration properties to be used for filter
 initialization.  The mapping includes all properties that start with the
 specified configuration prefix.  Property names in the mapping are trimmed
 to remove the configuration prefix.

 @param conf configuration to read
 @param confPrefix configuration prefix
 @return mapping of configuration properties to be used for filter
     initialization]]>
      </doc>
    </method>
    <field name="X_FRAME_OPTIONS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CUSTOM_HEADER_PARAM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This filter protects webapps from clickjacking attacks that
 are possible through use of Frames to embed the resources in another
 application and intercept clicks to accomplish nefarious things.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.http.XFrameOptionsFilter -->
</package>
<package name="org.apache.hadoop.security.protocolPB">
</package>
<package name="org.apache.hadoop.security.ssl">
</package>
<package name="org.apache.hadoop.security.token">
  <!-- start class org.apache.hadoop.security.token.SecretManager -->
  <class name="SecretManager" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SecretManager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createPassword" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="identifier" type="T"/>
      <doc>
      <![CDATA[Create the password for the given identifier.
 identifier may be modified inside this method.
 @param identifier the identifier to use
 @return the new password]]>
      </doc>
    </method>
    <method name="retrievePassword" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="identifier" type="T"/>
      <exception name="SecretManager.InvalidToken" type="org.apache.hadoop.security.token.SecretManager.InvalidToken"/>
      <doc>
      <![CDATA[Retrieve the password for the given token identifier. Should check the date
 or registry to make sure the token hasn't expired or been revoked. Returns 
 the relevant password.
 @param identifier the identifier to validate
 @return the password to use
 @throws InvalidToken the token was invalid]]>
      </doc>
    </method>
    <method name="retriableRetrievePassword" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="identifier" type="T"/>
      <exception name="SecretManager.InvalidToken" type="org.apache.hadoop.security.token.SecretManager.InvalidToken"/>
      <exception name="StandbyException" type="org.apache.hadoop.ipc.StandbyException"/>
      <exception name="RetriableException" type="org.apache.hadoop.ipc.RetriableException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The same functionality with {@link #retrievePassword}, except that this 
 method can throw a {@link RetriableException} or a {@link StandbyException}
 to indicate that client can retry/failover the same operation because of 
 temporary issue on the server side.
 
 @param identifier the identifier to validate
 @return the password to use
 @throws InvalidToken the token was invalid
 @throws StandbyException the server is in standby state, the client can
         try other servers
 @throws RetriableException the token was invalid, and the server thinks 
         this may be a temporary issue and suggests the client to retry
 @throws IOException to allow future exceptions to be added without breaking
         compatibility]]>
      </doc>
    </method>
    <method name="createIdentifier" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an empty token identifier.
 @return the newly created empty token identifier]]>
      </doc>
    </method>
    <method name="checkAvailableForRead"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="StandbyException" type="org.apache.hadoop.ipc.StandbyException"/>
      <doc>
      <![CDATA[No-op if the secret manager is available for reading tokens, throw a
 StandbyException otherwise.
 
 @throws StandbyException if the secret manager is not available to read
         tokens]]>
      </doc>
    </method>
    <method name="generateSecret" return="javax.crypto.SecretKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Generate a new random secret key.
 @return the new key]]>
      </doc>
    </method>
    <method name="createPassword" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="identifier" type="byte[]"/>
      <param name="key" type="javax.crypto.SecretKey"/>
      <doc>
      <![CDATA[Compute HMAC of the identifier using the secret key and return the 
 output as password
 @param identifier the bytes of the identifier
 @param key the secret key
 @return the bytes of the generated password]]>
      </doc>
    </method>
    <method name="createSecretKey" return="javax.crypto.SecretKey"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="key" type="byte[]"/>
      <doc>
      <![CDATA[Convert the byte[] to a secret key
 @param key the byte[] to create a secret key from
 @return the secret key]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The server-side secret manager for each token type.
 @param <T> The type of the token identifier]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.token.SecretManager -->
  <!-- start class org.apache.hadoop.security.token.Token -->
  <class name="Token" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="Token" type="T, org.apache.hadoop.security.token.SecretManager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a token given a token identifier and a secret manager for the
 type of the token identifier.
 @param id the token identifier
 @param mgr the secret manager]]>
      </doc>
    </constructor>
    <constructor name="Token" type="byte[], byte[], org.apache.hadoop.io.Text, org.apache.hadoop.io.Text"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a token from the components.
 @param identifier the token identifier
 @param password the token's password
 @param kind the kind of token
 @param service the service for this token]]>
      </doc>
    </constructor>
    <constructor name="Token"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.]]>
      </doc>
    </constructor>
    <constructor name="Token" type="org.apache.hadoop.security.token.Token"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clone a token.
 @param other the token to clone]]>
      </doc>
    </constructor>
    <method name="setID"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
    </method>
    <method name="setPassword"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newPassword" type="byte[]"/>
    </method>
    <method name="copyToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIdentifier" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the token identifier's byte representation.
 @return the token identifier's byte representation]]>
      </doc>
    </method>
    <method name="decodeIdentifier" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the token identifier object, or null if it could not be constructed
 (because the class could not be loaded, for example).
 @return the token identifier, or null if there was no class found for it
 @throws IOException failure to unmarshall the data
 @throws RuntimeException if the token class could not be instantiated.]]>
      </doc>
    </method>
    <method name="getPassword" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the token password/secret.
 @return the token password/secret]]>
      </doc>
    </method>
    <method name="getKind" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the token kind.
 @return the kind of the token]]>
      </doc>
    </method>
    <method name="getService" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the service on which the token is supposed to be used.
 @return the service name]]>
      </doc>
    </method>
    <method name="setService"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newService" type="org.apache.hadoop.io.Text"/>
      <doc>
      <![CDATA[Set the service on which the token is supposed to be used.
 @param newService the service name]]>
      </doc>
    </method>
    <method name="isPrivate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Whether this is a private token.
 @return false always for non-private tokens]]>
      </doc>
    </method>
    <method name="isPrivateCloneOf" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="thePublicService" type="org.apache.hadoop.io.Text"/>
      <doc>
      <![CDATA[Whether this is a private clone of a public token.
 @param thePublicService the public service name
 @return false always for non-private tokens]]>
      </doc>
    </method>
    <method name="privateClone" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newService" type="org.apache.hadoop.io.Text"/>
      <doc>
      <![CDATA[Create a private clone of a public token.
 @param newService the new service name
 @return a private token]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="encodeToUrlString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Encode this token as a url safe string.
 @return the encoded string
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="decodeFromUrlString"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newValue" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Decode the given url safe string into this token.
 @param newValue the encoded string
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="right" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="buildCacheKey" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isManaged" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Is this token managed so that it can be renewed or cancelled?
 @return true, if it can be renewed and cancelled.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="renew" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Renew this delegation token.
 @param conf configuration.
 @return the new expiration time
 @throws IOException raised on errors performing I/O.
 @throws InterruptedException if the thread is interrupted.]]>
      </doc>
    </method>
    <method name="cancel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Cancel this delegation token.

 @param conf configuration.
 @throws IOException raised on errors performing I/O.
 @throws InterruptedException if the thread is interrupted.]]>
      </doc>
    </method>
    <field name="LOG" type="org.slf4j.Logger"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[The client-side form of the token.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.token.Token -->
  <!-- start class org.apache.hadoop.security.token.Token.TrivialRenewer -->
  <class name="Token.TrivialRenewer" extends="org.apache.hadoop.security.token.TokenRenewer"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TrivialRenewer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKind" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="handleKind" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="kind" type="org.apache.hadoop.io.Text"/>
    </method>
    <method name="isManaged" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="token" type="org.apache.hadoop.security.token.Token"/>
    </method>
    <method name="renew" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="token" type="org.apache.hadoop.security.token.Token"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="cancel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="token" type="org.apache.hadoop.security.token.Token"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <doc>
    <![CDATA[A trivial renewer for token kinds that aren't managed. Sub-classes need
 to implement getKind for their token kind.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.token.Token.TrivialRenewer -->
  <!-- start class org.apache.hadoop.security.token.TokenIdentifier -->
  <class name="TokenIdentifier" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="TokenIdentifier"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKind" return="org.apache.hadoop.io.Text"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the token kind
 @return the kind of the token]]>
      </doc>
    </method>
    <method name="getUser" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the Ugi with the username encoded in the token identifier
 
 @return the username. null is returned if username in the identifier is
         empty or null.]]>
      </doc>
    </method>
    <method name="getBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the bytes for the token identifier
 @return the bytes of the identifier]]>
      </doc>
    </method>
    <method name="getTrackingId" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a tracking identifier that can be used to associate usages of a
 token across multiple client sessions.

 Currently, this function just returns an MD5 of {{@link #getBytes()}.

 @return tracking identifier]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An identifier that identifies a token, may contain public information 
 about a token, including its kind (or type).]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.token.TokenIdentifier -->
  <!-- start class org.apache.hadoop.security.token.TokenInfo -->
  <class name="TokenInfo"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Indicates Token related information to be used]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.token.TokenInfo -->
  <!-- start class org.apache.hadoop.security.token.TokenRenewer -->
  <class name="TokenRenewer" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TokenRenewer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="handleKind" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="kind" type="org.apache.hadoop.io.Text"/>
      <doc>
      <![CDATA[Does this renewer handle this kind of token?
 @param kind the kind of the token
 @return true if this renewer can renew it]]>
      </doc>
    </method>
    <method name="isManaged" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="token" type="org.apache.hadoop.security.token.Token"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Is the given token managed? Only managed tokens may be renewed or
 cancelled.
 @param token the token being checked
 @return true if the token may be renewed or cancelled
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="renew" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="token" type="org.apache.hadoop.security.token.Token"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Renew the given token.

 @param token the token being checked.
 @param conf configuration.

 @return the new expiration time.
 @throws IOException raised on errors performing I/O.
 @throws InterruptedException thrown when a thread is waiting, sleeping,
                              or otherwise occupied, and the thread is interrupted,
                              either before or during the activity.]]>
      </doc>
    </method>
    <method name="cancel"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="token" type="org.apache.hadoop.security.token.Token"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Cancel the given token.

 @param token the token being checked.
 @param conf configuration.

 @throws IOException raised on errors performing I/O.
 @throws InterruptedException thrown when a thread is waiting, sleeping,
                              or otherwise occupied, and the thread is interrupted,
                              either before or during the activity.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This is the interface for plugins that handle tokens.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.token.TokenRenewer -->
  <!-- start interface org.apache.hadoop.security.token.TokenSelector -->
  <interface name="TokenSelector"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="selectToken" return="org.apache.hadoop.security.token.Token"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.io.Text"/>
      <param name="tokens" type="java.util.Collection"/>
    </method>
    <doc>
    <![CDATA[Select token of type T from tokens for use with named service
 
 @param <T>
          T extends TokenIdentifier]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.security.token.TokenSelector -->
</package>
<package name="org.apache.hadoop.security.token.delegation.web">
  <!-- start class org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL -->
  <class name="DelegationTokenAuthenticatedURL" extends="org.apache.hadoop.security.authentication.client.AuthenticatedURL"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DelegationTokenAuthenticatedURL"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an <code>DelegationTokenAuthenticatedURL</code>.
 <p>
 An instance of the default {@link DelegationTokenAuthenticator} will be
 used.]]>
      </doc>
    </constructor>
    <constructor name="DelegationTokenAuthenticatedURL" type="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an <code>DelegationTokenAuthenticatedURL</code>.

 @param authenticator the {@link DelegationTokenAuthenticator} instance to
 use, if <code>null</code> the default one will be used.]]>
      </doc>
    </constructor>
    <constructor name="DelegationTokenAuthenticatedURL" type="org.apache.hadoop.security.authentication.client.ConnectionConfigurator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an <code>DelegationTokenAuthenticatedURL</code> using the default
 {@link DelegationTokenAuthenticator} class.

 @param connConfigurator a connection configurator.]]>
      </doc>
    </constructor>
    <constructor name="DelegationTokenAuthenticatedURL" type="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticator, org.apache.hadoop.security.authentication.client.ConnectionConfigurator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an <code>DelegationTokenAuthenticatedURL</code>.

 @param authenticator the {@link DelegationTokenAuthenticator} instance to
 use, if <code>null</code> the default one will be used.
 @param connConfigurator a connection configurator.]]>
      </doc>
    </constructor>
    <method name="setDefaultDelegationTokenAuthenticator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="authenticator" type="java.lang.Class"/>
      <doc>
      <![CDATA[Sets the default {@link DelegationTokenAuthenticator} class to use when an
 {@link DelegationTokenAuthenticatedURL} instance is created without
 specifying one.

 The default class is {@link KerberosDelegationTokenAuthenticator}

 @param authenticator the authenticator class to use as default.]]>
      </doc>
    </method>
    <method name="getDefaultDelegationTokenAuthenticator" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the default {@link DelegationTokenAuthenticator} class to use when
 an {@link DelegationTokenAuthenticatedURL} instance is created without
 specifying one.
 <p>
 The default class is {@link KerberosDelegationTokenAuthenticator}

 @return the delegation token authenticator class to use as default.]]>
      </doc>
    </method>
    <method name="setUseQueryStringForDelegationToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="useQueryString" type="boolean"/>
      <doc>
      <![CDATA[Sets if delegation token should be transmitted in the URL query string.
 By default it is transmitted using the
 {@link DelegationTokenAuthenticator#DELEGATION_TOKEN_HEADER} HTTP header.
 <p>
 This method is provided to enable WebHDFS backwards compatibility.

 @param useQueryString  <code>TRUE</code> if the token is transmitted in the
 URL query string, <code>FALSE</code> if the delegation token is transmitted
 using the {@link DelegationTokenAuthenticator#DELEGATION_TOKEN_HEADER} HTTP
 header.]]>
      </doc>
    </method>
    <method name="useQueryStringForDelegationToken" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns if delegation token is transmitted as a HTTP header.

 @return <code>TRUE</code> if the token is transmitted in the URL query
 string, <code>FALSE</code> if the delegation token is transmitted using the
 {@link DelegationTokenAuthenticator#DELEGATION_TOKEN_HEADER} HTTP header.]]>
      </doc>
    </method>
    <method name="openConnection" return="java.net.HttpURLConnection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.authentication.client.AuthenticatedURL.Token"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Returns an authenticated {@link HttpURLConnection}, it uses a Delegation
 Token only if the given auth token is an instance of {@link Token} and
 it contains a Delegation Token, otherwise use the configured
 {@link DelegationTokenAuthenticator} to authenticate the connection.

 @param url the URL to connect to. Only HTTP/S URLs are supported.
 @param token the authentication token being used for the user.
 @return an authenticated {@link HttpURLConnection}.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.]]>
      </doc>
    </method>
    <method name="openConnection" return="java.net.HttpURLConnection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL.Token"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Returns an authenticated {@link HttpURLConnection}. If the Delegation
 Token is present, it will be used taking precedence over the configured
 <code>Authenticator</code>.

 @param url the URL to connect to. Only HTTP/S URLs are supported.
 @param token the authentication token being used for the user.
 @return an authenticated {@link HttpURLConnection}.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.]]>
      </doc>
    </method>
    <method name="openConnection" return="java.net.HttpURLConnection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL.Token"/>
      <param name="doAs" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Returns an authenticated {@link HttpURLConnection}. If the Delegation
 Token is present, it will be used taking precedence over the configured
 <code>Authenticator</code>. If the <code>doAs</code> parameter is not NULL,
 the request will be done on behalf of the specified <code>doAs</code> user.

 @param url the URL to connect to. Only HTTP/S URLs are supported.
 @param token the authentication token being used for the user.
 @param doAs user to do the the request on behalf of, if NULL the request is
 as self.
 @return an authenticated {@link HttpURLConnection}.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.]]>
      </doc>
    </method>
    <method name="getDelegationToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL.Token"/>
      <param name="renewer" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Requests a delegation token using the configured <code>Authenticator</code>
 for authentication.

 @param url the URL to get the delegation token from. Only HTTP/S URLs are
 supported.
 @param token the authentication token being used for the user where the
 Delegation token will be stored.
 @param renewer the renewer user.
 @return a delegation token.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.]]>
      </doc>
    </method>
    <method name="getDelegationToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL.Token"/>
      <param name="renewer" type="java.lang.String"/>
      <param name="doAsUser" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Requests a delegation token using the configured <code>Authenticator</code>
 for authentication.

 @param url the URL to get the delegation token from. Only HTTP/S URLs are
 supported.
 @param token the authentication token being used for the user where the
 Delegation token will be stored.
 @param renewer the renewer user.
 @param doAsUser the user to do as, which will be the token owner.
 @return a delegation token.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.]]>
      </doc>
    </method>
    <method name="renewDelegationToken" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL.Token"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Renews a delegation token from the server end-point using the
 configured <code>Authenticator</code> for authentication.

 @param url the URL to renew the delegation token from. Only HTTP/S URLs are
 supported.
 @param token the authentication token with the Delegation Token to renew.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.
 @return delegation token long value.]]>
      </doc>
    </method>
    <method name="renewDelegationToken" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL.Token"/>
      <param name="doAsUser" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Renews a delegation token from the server end-point using the
 configured <code>Authenticator</code> for authentication.

 @param url the URL to renew the delegation token from. Only HTTP/S URLs are
 supported.
 @param token the authentication token with the Delegation Token to renew.
 @param doAsUser the user to do as, which will be the token owner.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.
 @return delegation token long value.]]>
      </doc>
    </method>
    <method name="cancelDelegationToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL.Token"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Cancels a delegation token from the server end-point. It does not require
 being authenticated by the configured <code>Authenticator</code>.

 @param url the URL to cancel the delegation token from. Only HTTP/S URLs
 are supported.
 @param token the authentication token with the Delegation Token to cancel.
 @throws IOException if an IO error occurred.]]>
      </doc>
    </method>
    <method name="cancelDelegationToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL.Token"/>
      <param name="doAsUser" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Cancels a delegation token from the server end-point. It does not require
 being authenticated by the configured <code>Authenticator</code>.

 @param url the URL to cancel the delegation token from. Only HTTP/S URLs
 are supported.
 @param token the authentication token with the Delegation Token to cancel.
 @param doAsUser the user to do as, which will be the token owner.
 @throws IOException if an IO error occurred.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The <code>DelegationTokenAuthenticatedURL</code> is a
 {@link AuthenticatedURL} sub-class with built-in Hadoop Delegation Token
 functionality.
 <p>
 The authentication mechanisms supported by default are Hadoop Simple
 authentication (also known as pseudo authentication) and Kerberos SPNEGO
 authentication.
 <p>
 Additional authentication mechanisms can be supported via {@link
 DelegationTokenAuthenticator} implementations.
 <p>
 The default {@link DelegationTokenAuthenticator} is the {@link
 KerberosDelegationTokenAuthenticator} class which supports
 automatic fallback from Kerberos SPNEGO to Hadoop Simple authentication via
 the {@link PseudoDelegationTokenAuthenticator} class.
 <p>
 <code>AuthenticatedURL</code> instances are not thread-safe.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL -->
  <!-- start class org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL.Token -->
  <class name="DelegationTokenAuthenticatedURL.Token" extends="org.apache.hadoop.security.authentication.client.AuthenticatedURL.Token"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Token"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getDelegationToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setDelegationToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegationToken" type="org.apache.hadoop.security.token.Token"/>
    </method>
    <doc>
    <![CDATA[Client side authentication token that handles Delegation Tokens.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL.Token -->
  <!-- start class org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticator -->
  <class name="DelegationTokenAuthenticator" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.security.authentication.client.Authenticator"/>
    <constructor name="DelegationTokenAuthenticator" type="org.apache.hadoop.security.authentication.client.Authenticator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setConnectionConfigurator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="configurator" type="org.apache.hadoop.security.authentication.client.ConnectionConfigurator"/>
    </method>
    <method name="authenticate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.authentication.client.AuthenticatedURL.Token"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
    </method>
    <method name="getDelegationToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.authentication.client.AuthenticatedURL.Token"/>
      <param name="renewer" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Requests a delegation token using the configured <code>Authenticator</code>
 for authentication.

 @param url the URL to get the delegation token from. Only HTTP/S URLs are
 supported.
 @param token the authentication token being used for the user where the
 Delegation token will be stored.
 @param renewer the renewer user.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.
 @return abstract delegation token identifier.]]>
      </doc>
    </method>
    <method name="getDelegationToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.authentication.client.AuthenticatedURL.Token"/>
      <param name="renewer" type="java.lang.String"/>
      <param name="doAsUser" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Requests a delegation token using the configured <code>Authenticator</code>
 for authentication.

 @param url the URL to get the delegation token from. Only HTTP/S URLs are
 supported.
 @param token the authentication token being used for the user where the
 Delegation token will be stored.
 @param renewer the renewer user.
 @param doAsUser the user to do as, which will be the token owner.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.
 @return abstract delegation token identifier.]]>
      </doc>
    </method>
    <method name="renewDelegationToken" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.authentication.client.AuthenticatedURL.Token"/>
      <param name="dToken" type="org.apache.hadoop.security.token.Token"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Renews a delegation token from the server end-point using the
 configured <code>Authenticator</code> for authentication.

 @param url the URL to renew the delegation token from. Only HTTP/S URLs are
 supported.
 @param token the authentication token with the Delegation Token to renew.
 @param dToken abstract delegation token identifier.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.
 @return delegation token long value.]]>
      </doc>
    </method>
    <method name="renewDelegationToken" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.authentication.client.AuthenticatedURL.Token"/>
      <param name="dToken" type="org.apache.hadoop.security.token.Token"/>
      <param name="doAsUser" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Renews a delegation token from the server end-point using the
 configured <code>Authenticator</code> for authentication.

 @param url the URL to renew the delegation token from. Only HTTP/S URLs are
 supported.
 @param token the authentication token with the Delegation Token to renew.
 @param doAsUser the user to do as, which will be the token owner.
 @param dToken abstract delegation token identifier.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.
 @return delegation token long value.]]>
      </doc>
    </method>
    <method name="cancelDelegationToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.authentication.client.AuthenticatedURL.Token"/>
      <param name="dToken" type="org.apache.hadoop.security.token.Token"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Cancels a delegation token from the server end-point. It does not require
 being authenticated by the configured <code>Authenticator</code>.

 @param url the URL to cancel the delegation token from. Only HTTP/S URLs
 are supported.
 @param token the authentication token with the Delegation Token to cancel.
 @param dToken abstract delegation token identifier.
 @throws IOException if an IO error occurred.]]>
      </doc>
    </method>
    <method name="cancelDelegationToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.authentication.client.AuthenticatedURL.Token"/>
      <param name="dToken" type="org.apache.hadoop.security.token.Token"/>
      <param name="doAsUser" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Cancels a delegation token from the server end-point. It does not require
 being authenticated by the configured <code>Authenticator</code>.

 @param url the URL to cancel the delegation token from. Only HTTP/S URLs
 are supported.
 @param token the authentication token with the Delegation Token to cancel.
 @param dToken abstract delegation token identifier.
 @param doAsUser the user to do as, which will be the token owner.
 @throws IOException if an IO error occurred.]]>
      </doc>
    </method>
    <field name="OP_PARAM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DELEGATION_TOKEN_HEADER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DELEGATION_PARAM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TOKEN_PARAM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RENEWER_PARAM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SERVICE_PARAM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DELEGATION_TOKEN_JSON" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DELEGATION_TOKEN_URL_STRING_JSON" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RENEW_DELEGATION_TOKEN_JSON" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[{@link Authenticator} wrapper that enhances an {@link Authenticator} with
 Delegation Token support.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticator -->
  <!-- start class org.apache.hadoop.security.token.delegation.web.KerberosDelegationTokenAuthenticator -->
  <class name="KerberosDelegationTokenAuthenticator" extends="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticator"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KerberosDelegationTokenAuthenticator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[The <code>KerberosDelegationTokenAuthenticator</code> provides support for
 Kerberos SPNEGO authentication mechanism and support for Hadoop Delegation
 Token operations.
 <p>
 It falls back to the {@link PseudoDelegationTokenAuthenticator} if the HTTP
 endpoint does not trigger a SPNEGO authentication]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.token.delegation.web.KerberosDelegationTokenAuthenticator -->
  <!-- start class org.apache.hadoop.security.token.delegation.web.PseudoDelegationTokenAuthenticator -->
  <class name="PseudoDelegationTokenAuthenticator" extends="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticator"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PseudoDelegationTokenAuthenticator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[The <code>PseudoDelegationTokenAuthenticator</code> provides support for
 Hadoop's pseudo authentication mechanism that accepts
 the user name specified as a query string parameter and support for Hadoop
 Delegation Token operations.
 <p>
 This mimics the model of Hadoop Simple authentication trusting the
 {@link UserGroupInformation#getCurrentUser()} value.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.token.delegation.web.PseudoDelegationTokenAuthenticator -->
</package>
<package name="org.apache.hadoop.service">
  <!-- start class org.apache.hadoop.service.AbstractService -->
  <class name="AbstractService" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.service.Service"/>
    <constructor name="AbstractService" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the service.
 @param name service name]]>
      </doc>
    </constructor>
    <method name="getServiceState" return="org.apache.hadoop.service.Service.STATE"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFailureCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFailureState" return="org.apache.hadoop.service.Service.STATE"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConfig"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Set the configuration for this service.
 This method is called during {@link #init(Configuration)}
 and should only be needed if for some reason a service implementation
 needs to override that initial setting -for example replacing
 it with a new subclass of {@link Configuration}
 @param conf new configuration.]]>
      </doc>
    </method>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[{@inheritDoc}
 This invokes {@link #serviceInit}
 @param conf the configuration of the service. This must not be null
 @throws ServiceStateException if the configuration was null,
 the state change not permitted, or something else went wrong]]>
      </doc>
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}
 @throws ServiceStateException if the current service state does not permit
 this action]]>
      </doc>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Relay to {@link #stop()}
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="noteFailure"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Failure handling: record the exception
 that triggered it -if there was not one already.
 Services are free to call this themselves.
 @param exception the exception]]>
      </doc>
    </method>
    <method name="waitForServiceToStop" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
    </method>
    <method name="serviceInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[All initialization code needed by a service.

 This method will only ever be called once during the lifecycle of
 a specific service instance.

 Implementations do not need to be synchronized as the logic
 in {@link #init(Configuration)} prevents re-entrancy.

 The base implementation checks to see if the subclass has created
 a new configuration instance, and if so, updates the base class value
 @param conf configuration
 @throws Exception on a failure -these will be caught,
 possibly wrapped, and will trigger a service stop]]>
      </doc>
    </method>
    <method name="serviceStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Actions called during the INITED to STARTED transition.

 This method will only ever be called once during the lifecycle of
 a specific service instance.

 Implementations do not need to be synchronized as the logic
 in {@link #start()} prevents re-entrancy.

 @throws Exception if needed -these will be caught,
 wrapped, and trigger a service stop]]>
      </doc>
    </method>
    <method name="serviceStop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Actions called during the transition to the STOPPED state.

 This method will only ever be called once during the lifecycle of
 a specific service instance.

 Implementations do not need to be synchronized as the logic
 in {@link #stop()} prevents re-entrancy.

 Implementations MUST write this to be robust against failures, including
 checks for null references -and for the first failure to not stop other
 attempts to shut down parts of the service.

 @throws Exception if needed -these will be caught and logged.]]>
      </doc>
    </method>
    <method name="registerServiceListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="org.apache.hadoop.service.ServiceStateChangeListener"/>
    </method>
    <method name="unregisterServiceListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="org.apache.hadoop.service.ServiceStateChangeListener"/>
    </method>
    <method name="registerGlobalListener"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="org.apache.hadoop.service.ServiceStateChangeListener"/>
      <doc>
      <![CDATA[Register a global listener, which receives notifications
 from the state change events of all services in the JVM
 @param l listener]]>
      </doc>
    </method>
    <method name="unregisterGlobalListener" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="org.apache.hadoop.service.ServiceStateChangeListener"/>
      <doc>
      <![CDATA[unregister a global listener.
 @param l listener to unregister
 @return true if the listener was found (and then deleted)]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getConfig" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStartTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLifecycleHistory" return="java.util.List"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isInState" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="expected" type="org.apache.hadoop.service.Service.STATE"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="putBlocker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="details" type="java.lang.String"/>
      <doc>
      <![CDATA[Put a blocker to the blocker map -replacing any
 with the same name.
 @param name blocker name
 @param details any specifics on the block. This must be non-null.]]>
      </doc>
    </method>
    <method name="removeBlocker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Remove a blocker from the blocker map -
 this is a no-op if the blocker is not present
 @param name the name of the blocker]]>
      </doc>
    </method>
    <method name="getBlockers" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This is the base implementation class for services.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.service.AbstractService -->
  <!-- start class org.apache.hadoop.service.CompositeService -->
  <class name="CompositeService" extends="org.apache.hadoop.service.AbstractService"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CompositeService" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getServices" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a cloned list of services
 @return a list of child services at the time of invocation -
 added services will not be picked up.]]>
      </doc>
    </method>
    <method name="addService"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.service.Service"/>
      <doc>
      <![CDATA[Add the passed {@link Service} to the list of services managed by this
 {@link CompositeService}
 @param service the {@link Service} to be added]]>
      </doc>
    </method>
    <method name="addIfService" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[If the passed object is an instance of {@link Service},
 add it to the list of services managed by this {@link CompositeService}
 @param object object.
 @return true if a service is added, false otherwise.]]>
      </doc>
    </method>
    <method name="removeService" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.service.Service"/>
    </method>
    <method name="serviceInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="serviceStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="serviceStop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <field name="STOP_ONLY_STARTED_SERVICES" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Policy on shutdown: attempt to close everything (purest) or
 only try to close started services (which assumes
 that the service implementations may not handle the stop() operation
 except when started.
 Irrespective of this policy, if a child service fails during
 its init() or start() operations, it will have stop() called on it.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Composition of services.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.service.CompositeService -->
  <!-- start class org.apache.hadoop.service.LifecycleEvent -->
  <class name="LifecycleEvent" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="LifecycleEvent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="time" type="long"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Local time in milliseconds when the event occurred]]>
      </doc>
    </field>
    <field name="state" type="org.apache.hadoop.service.Service.STATE"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[new state]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A serializable lifecycle event: the time a state
 transition occurred, and what state was entered.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.service.LifecycleEvent -->
  <!-- start class org.apache.hadoop.service.LoggingStateChangeListener -->
  <class name="LoggingStateChangeListener" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.service.ServiceStateChangeListener"/>
    <constructor name="LoggingStateChangeListener" type="org.slf4j.Logger"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Log events to the given log
 @param log destination for events]]>
      </doc>
    </constructor>
    <constructor name="LoggingStateChangeListener"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Log events to the static log for this class]]>
      </doc>
    </constructor>
    <method name="stateChanged"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.service.Service"/>
      <doc>
      <![CDATA[Callback for a state change event: log it
 @param service the service that has changed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This is a state change listener that logs events at INFO level]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.service.LoggingStateChangeListener -->
  <!-- start interface org.apache.hadoop.service.Service -->
  <interface name="Service"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <method name="init"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Initialize the service.

 The transition MUST be from {@link STATE#NOTINITED} to {@link STATE#INITED}
 unless the operation failed and an exception was raised, in which case
 {@link #stop()} MUST be invoked and the service enter the state
 {@link STATE#STOPPED}.
 @param config the configuration of the service
 @throws RuntimeException on any failure during the operation]]>
      </doc>
    </method>
    <method name="start"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Start the service.

 The transition MUST be from {@link STATE#INITED} to {@link STATE#STARTED}
 unless the operation failed and an exception was raised, in which case
 {@link #stop()} MUST be invoked and the service enter the state
 {@link STATE#STOPPED}.
 @throws RuntimeException on any failure during the operation]]>
      </doc>
    </method>
    <method name="stop"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stop the service. This MUST be a no-op if the service is already
 in the {@link STATE#STOPPED} state. It SHOULD be a best-effort attempt
 to stop all parts of the service.

 The implementation must be designed to complete regardless of the service
 state, including the initialized/uninitialized state of all its internal
 fields.
 @throws RuntimeException on any failure during the stop operation]]>
      </doc>
    </method>
    <method name="close"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A version of stop() that is designed to be usable in Java7 closure
 clauses.
 Implementation classes MUST relay this directly to {@link #stop()}
 @throws IOException never
 @throws RuntimeException on any failure during the stop operation]]>
      </doc>
    </method>
    <method name="registerServiceListener"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="org.apache.hadoop.service.ServiceStateChangeListener"/>
      <doc>
      <![CDATA[Register a listener to the service state change events.
 If the supplied listener is already listening to this service,
 this method is a no-op.
 @param listener a new listener]]>
      </doc>
    </method>
    <method name="unregisterServiceListener"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="org.apache.hadoop.service.ServiceStateChangeListener"/>
      <doc>
      <![CDATA[Unregister a previously registered listener of the service state
 change events. No-op if the listener is already unregistered.
 @param listener the listener to unregister.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the name of this service.
 @return the service name]]>
      </doc>
    </method>
    <method name="getConfig" return="org.apache.hadoop.conf.Configuration"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the configuration of this service.
 This is normally not a clone and may be manipulated, though there are no
 guarantees as to what the consequences of such actions may be
 @return the current configuration, unless a specific implentation chooses
 otherwise.]]>
      </doc>
    </method>
    <method name="getServiceState" return="org.apache.hadoop.service.Service.STATE"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current service state
 @return the state of the service]]>
      </doc>
    </method>
    <method name="getStartTime" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the service start time
 @return the start time of the service. This will be zero if the service
 has not yet been started.]]>
      </doc>
    </method>
    <method name="isInState" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="state" type="org.apache.hadoop.service.Service.STATE"/>
      <doc>
      <![CDATA[Query to see if the service is in a specific state.
 In a multi-threaded system, the state may not hold for very long.
 @param state the expected state
 @return true if, at the time of invocation, the service was in that state.]]>
      </doc>
    </method>
    <method name="getFailureCause" return="java.lang.Throwable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the first exception raised during the service failure. If null,
 no exception was logged
 @return the failure logged during a transition to the stopped state]]>
      </doc>
    </method>
    <method name="getFailureState" return="org.apache.hadoop.service.Service.STATE"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the state in which the failure in {@link #getFailureCause()} occurred.
 @return the state or null if there was no failure]]>
      </doc>
    </method>
    <method name="waitForServiceToStop" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <doc>
      <![CDATA[Block waiting for the service to stop; uses the termination notification
 object to do so.

 This method will only return after all the service stop actions
 have been executed (to success or failure), or the timeout elapsed
 This method can be called before the service is inited or started; this is
 to eliminate any race condition with the service stopping before
 this event occurs.
 @param timeout timeout in milliseconds. A value of zero means "forever"
 @return true iff the service stopped in the time period]]>
      </doc>
    </method>
    <method name="getLifecycleHistory" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a snapshot of the lifecycle history; it is a static list
 @return a possibly empty but never null list of lifecycle events.]]>
      </doc>
    </method>
    <method name="getBlockers" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the blockers on a service -remote dependencies
 that are stopping the service from being <i>live</i>.
 @return a (snapshotted) map of blocker name-&gt;description values]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Service LifeCycle.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.service.Service -->
  <!-- start class org.apache.hadoop.service.ServiceOperations -->
  <class name="ServiceOperations" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="stop"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.service.Service"/>
      <doc>
      <![CDATA[Stop a service.
 <p>Do nothing if the service is null or not
 in a state in which it can be/needs to be stopped.
 <p>
 The service state is checked <i>before</i> the operation begins.
 This process is <i>not</i> thread safe.
 @param service a service or null]]>
      </doc>
    </method>
    <method name="stopQuietly" return="java.lang.Exception"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.service.Service"/>
      <doc>
      <![CDATA[Stop a service; if it is null do nothing. Exceptions are caught and
 logged at warn level. (but not Throwables). This operation is intended to
 be used in cleanup operations

 @param service a service; may be null
 @return any exception that was caught; null if none was.]]>
      </doc>
    </method>
    <method name="stopQuietly" return="java.lang.Exception"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="log" type="org.apache.commons.logging.Log"/>
      <param name="service" type="org.apache.hadoop.service.Service"/>
      <doc>
      <![CDATA[Stop a service; if it is null do nothing. Exceptions are caught and
 logged at warn level. (but not Throwables). This operation is intended to
 be used in cleanup operations

 @param log the log to warn at
 @param service a service; may be null
 @return any exception that was caught; null if none was.
 @see ServiceOperations#stopQuietly(Service)]]>
      </doc>
    </method>
    <method name="stopQuietly" return="java.lang.Exception"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="log" type="org.slf4j.Logger"/>
      <param name="service" type="org.apache.hadoop.service.Service"/>
      <doc>
      <![CDATA[Stop a service; if it is null do nothing. Exceptions are caught and
 logged at warn level. (but not Throwables). This operation is intended to
 be used in cleanup operations

 @param log the log to warn at
 @param service a service; may be null
 @return any exception that was caught; null if none was.
 @see ServiceOperations#stopQuietly(Service)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class contains a set of methods to work with services, especially
 to walk them through their lifecycle.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.service.ServiceOperations -->
  <!-- start interface org.apache.hadoop.service.ServiceStateChangeListener -->
  <interface name="ServiceStateChangeListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="stateChanged"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.service.Service"/>
      <doc>
      <![CDATA[Callback to notify of a state change. The service will already
 have changed state before this callback is invoked.

 This operation is invoked on the thread that initiated the state change,
 while the service itself in in a sychronized section.
 <ol>
   <li>Any long-lived operation here will prevent the service state
   change from completing in a timely manner.</li>
   <li>If another thread is somehow invoked from the listener, and
   that thread invokes the methods of the service (including
   subclass-specific methods), there is a risk of a deadlock.</li>
 </ol>


 @param service the service that has changed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface to notify state changes of a service.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.service.ServiceStateChangeListener -->
  <!-- start class org.apache.hadoop.service.ServiceStateException -->
  <class name="ServiceStateException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.ExitCodeProvider"/>
    <constructor name="ServiceStateException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instantiate
 @param message error message]]>
      </doc>
    </constructor>
    <constructor name="ServiceStateException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instantiate with a message and cause; if the cause has an exit code
 then it is used, otherwise the generic
 {@link LauncherExitCodes#EXIT_SERVICE_LIFECYCLE_EXCEPTION} exit code
 is used.
 @param message exception message
 @param cause optional inner cause]]>
      </doc>
    </constructor>
    <constructor name="ServiceStateException" type="int, java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instantiate, using the specified exit code as the exit code
 of the exception, irrespetive of any exit code supplied by any inner
 cause.

 @param exitCode exit code to declare
 @param message exception message
 @param cause inner cause]]>
      </doc>
    </constructor>
    <constructor name="ServiceStateException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getExitCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="convert" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fault" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Convert any exception into a {@link RuntimeException}.
 All other exception types are wrapped in a new instance of
 {@code ServiceStateException}.
 @param fault exception or throwable
 @return a {@link RuntimeException} to rethrow]]>
      </doc>
    </method>
    <method name="convert" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.String"/>
      <param name="fault" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Convert any exception into a {@link RuntimeException}.
 If the caught exception is already of that type, it is typecast to a
 {@link RuntimeException} and returned.

 All other exception types are wrapped in a new instance of
 {@code ServiceStateException}.
 @param text text to use if a new exception is created
 @param fault exception or throwable
 @return a {@link RuntimeException} to rethrow]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Exception that can be raised on state change operations, whose
 exit code can be explicitly set, determined from that of any nested
 cause, or a default value of
 {@link  LauncherExitCodes#EXIT_SERVICE_LIFECYCLE_EXCEPTION}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.service.ServiceStateException -->
  <!-- start class org.apache.hadoop.service.ServiceStateModel -->
  <class name="ServiceStateModel" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServiceStateModel" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create the service state model in the {@link Service.STATE#NOTINITED}
 state.

 @param name input name.]]>
      </doc>
    </constructor>
    <constructor name="ServiceStateModel" type="java.lang.String, org.apache.hadoop.service.Service.STATE"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a service state model instance in the chosen state
 @param state the starting state
 @param name input name.]]>
      </doc>
    </constructor>
    <method name="getState" return="org.apache.hadoop.service.Service.STATE"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Query the service state. This is a non-blocking operation.
 @return the state]]>
      </doc>
    </method>
    <method name="isInState" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="proposed" type="org.apache.hadoop.service.Service.STATE"/>
      <doc>
      <![CDATA[Query that the state is in a specific state
 @param proposed proposed new state
 @return the state]]>
      </doc>
    </method>
    <method name="ensureCurrentState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedState" type="org.apache.hadoop.service.Service.STATE"/>
      <doc>
      <![CDATA[Verify that that a service is in a given state.
 @param expectedState the desired state
 @throws ServiceStateException if the service state is different from
 the desired state]]>
      </doc>
    </method>
    <method name="enterState" return="org.apache.hadoop.service.Service.STATE"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="proposed" type="org.apache.hadoop.service.Service.STATE"/>
      <doc>
      <![CDATA[Enter a state -thread safe.

 @param proposed proposed new state
 @return the original state
 @throws ServiceStateException if the transition is not permitted]]>
      </doc>
    </method>
    <method name="checkStateTransition"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="state" type="org.apache.hadoop.service.Service.STATE"/>
      <param name="proposed" type="org.apache.hadoop.service.Service.STATE"/>
      <doc>
      <![CDATA[Check that a state tansition is valid and
 throw an exception if not
 @param name name of the service (can be null)
 @param state current state
 @param proposed proposed new state]]>
      </doc>
    </method>
    <method name="isValidStateTransition" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="current" type="org.apache.hadoop.service.Service.STATE"/>
      <param name="proposed" type="org.apache.hadoop.service.Service.STATE"/>
      <doc>
      <![CDATA[Is a state transition valid?
 There are no checks for current==proposed
 as that is considered a non-transition.

 using an array kills off all branch misprediction costs, at the expense
 of cache line misses.

 @param current current state
 @param proposed proposed new state
 @return true if the transition to a new state is valid]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[return the state text as the toString() value
 @return the current state's description]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implements the service state model.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.service.ServiceStateModel -->
</package>
<package name="org.apache.hadoop.service.launcher">
  <!-- start class org.apache.hadoop.service.launcher.AbstractLaunchableService -->
  <class name="AbstractLaunchableService" extends="org.apache.hadoop.service.AbstractService"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.service.launcher.LaunchableService"/>
    <constructor name="AbstractLaunchableService" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct an instance with the given name.

 @param name input name.]]>
      </doc>
    </constructor>
    <method name="bindArgs" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="org.apache.hadoop.conf.Configuration"/>
      <param name="args" type="java.util.List"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[{@inheritDoc}
 <p>
 The base implementation logs all arguments at the debug level,
 then returns the passed in config unchanged.]]>
      </doc>
    </method>
    <method name="execute" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[{@inheritDoc}
 <p>
 The action is to signal success by returning the exit code 0.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Subclass of {@link AbstractService} that provides basic implementations
 of the {@link LaunchableService} methods.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.service.launcher.AbstractLaunchableService -->
  <!-- start class org.apache.hadoop.service.launcher.HadoopUncaughtExceptionHandler -->
  <class name="HadoopUncaughtExceptionHandler" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Thread.UncaughtExceptionHandler"/>
    <constructor name="HadoopUncaughtExceptionHandler" type="java.lang.Thread.UncaughtExceptionHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance delegating to the supplied handler if
 the exception is considered "simple".
 @param delegate a delegate exception handler.]]>
      </doc>
    </constructor>
    <constructor name="HadoopUncaughtExceptionHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Basic exception handler -logs simple exceptions, then continues.]]>
      </doc>
    </constructor>
    <method name="uncaughtException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="thread" type="java.lang.Thread"/>
      <param name="exception" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Uncaught exception handler.
 If an error is raised: shutdown
 The state of the system is unknown at this point -attempting
 a clean shutdown is dangerous. Instead: exit
 @param thread thread that failed
 @param exception the raised exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class is intended to be installed by calling 
 {@link Thread#setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler)}
 in the main entry point. 

 The base class will always attempt to shut down the process if an Error
 was raised; the behavior on a standard Exception, raised outside 
 process shutdown, is simply to log it. 

 (Based on the class {@code YarnUncaughtExceptionHandler})]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.service.launcher.HadoopUncaughtExceptionHandler -->
  <!-- start interface org.apache.hadoop.service.launcher.LaunchableService -->
  <interface name="LaunchableService"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.service.Service"/>
    <method name="bindArgs" return="org.apache.hadoop.conf.Configuration"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="org.apache.hadoop.conf.Configuration"/>
      <param name="args" type="java.util.List"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Propagate the command line arguments.
 <p>
 This method is called before {@link #init(Configuration)};
 Any non-null configuration that is returned from this operation
 becomes the one that is passed on to that {@link #init(Configuration)}
 operation.
 <p>
 This permits implementations to change the configuration before
 the init operation. As the ServiceLauncher only creates
 an instance of the base {@link Configuration} class, it is
 recommended to instantiate any subclass (such as YarnConfiguration)
 that injects new resources.
 <p>
 @param config the initial configuration build up by the
 service launcher.
 @param args list of arguments passed to the command line
 after any launcher-specific commands have been stripped.
 @return the configuration to init the service with.
 Recommended: pass down the config parameter with any changes
 @throws Exception any problem]]>
      </doc>
    </method>
    <method name="execute" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Run a service. This method is called after {@link Service#start()}.
 <p>
 The return value becomes the exit code of the launched process.
 <p>
 If an exception is raised, the policy is:
 <ol>
   <li>Any subset of {@link org.apache.hadoop.util.ExitUtil.ExitException}:
   the exception is passed up unmodified.
   </li>
   <li>Any exception which implements
   {@link org.apache.hadoop.util.ExitCodeProvider}:
   A new {@link ServiceLaunchException} is created with the exit code
   and message of the thrown exception; the thrown exception becomes the
   cause.</li>
   <li>Any other exception: a new {@link ServiceLaunchException} is created
   with the exit code {@link LauncherExitCodes#EXIT_EXCEPTION_THROWN} and
   the message of the original exception (which becomes the cause).</li>
 </ol>
 @return the exit code
 @throws org.apache.hadoop.util.ExitUtil.ExitException an exception passed
  up as the exit code and error text.
 @throws Exception any exception to report. If it provides an exit code
 this is used in a wrapping exception.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An interface which services can implement to have their
 execution managed by the ServiceLauncher.
 <p>
 The command line options will be passed down before the 
 {@link Service#init(Configuration)} operation is invoked via an
 invocation of {@link LaunchableService#bindArgs(Configuration, List)}
 After the service has been successfully started via {@link Service#start()}
 the {@link LaunchableService#execute()} method is called to execute the 
 service. When this method returns, the service launcher will exit, using
 the return code from the method as its exit option.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.service.launcher.LaunchableService -->
  <!-- start interface org.apache.hadoop.service.launcher.LauncherExitCodes -->
  <interface name="LauncherExitCodes"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="EXIT_SUCCESS" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Success: {@value}.]]>
      </doc>
    </field>
    <field name="EXIT_FAIL" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Generic "false/fail" response: {@value}.
 The operation worked but the result was not "true" from the viewpoint
 of the executed code.]]>
      </doc>
    </field>
    <field name="EXIT_CLIENT_INITIATED_SHUTDOWN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Exit code when a client requested service termination: {@value}.]]>
      </doc>
    </field>
    <field name="EXIT_TASK_LAUNCH_FAILURE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Exit code when targets could not be launched: {@value}.]]>
      </doc>
    </field>
    <field name="EXIT_INTERRUPTED" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Exit code when a control-C, kill -3, signal was picked up: {@value}.]]>
      </doc>
    </field>
    <field name="EXIT_OTHER_FAILURE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Exit code when something happened but we can't be specific: {@value}.]]>
      </doc>
    </field>
    <field name="EXIT_COMMAND_ARGUMENT_ERROR" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Exit code when the command line doesn't parse: {@value}, or
 when it is otherwise invalid.
 <p>
 Approximate HTTP equivalent: {@code 400 Bad Request}]]>
      </doc>
    </field>
    <field name="EXIT_UNAUTHORIZED" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The request requires user authentication: {@value}.
 <p>
 approximate HTTP equivalent: Approximate HTTP equivalent: {@code 401 Unauthorized}]]>
      </doc>
    </field>
    <field name="EXIT_USAGE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Exit code when a usage message was printed: {@value}.]]>
      </doc>
    </field>
    <field name="EXIT_FORBIDDEN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Forbidden action: {@value}.
 <p>
 Approximate HTTP equivalent: Approximate HTTP equivalent: {@code 403: Forbidden}]]>
      </doc>
    </field>
    <field name="EXIT_NOT_FOUND" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Something was not found: {@value}.
 <p>
 Approximate HTTP equivalent: {@code 404: Not Found}]]>
      </doc>
    </field>
    <field name="EXIT_OPERATION_NOT_ALLOWED" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The operation is not allowed: {@value}.
 <p>
 Approximate HTTP equivalent: {@code 405: Not allowed}]]>
      </doc>
    </field>
    <field name="EXIT_NOT_ACCEPTABLE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The command is somehow not acceptable: {@value}.
 <p>
 Approximate HTTP equivalent: {@code 406: Not Acceptable}]]>
      </doc>
    </field>
    <field name="EXIT_CONNECTIVITY_PROBLEM" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Exit code on connectivity problems: {@value}.
 <p>
 Approximate HTTP equivalent: {@code 408: Request Timeout}]]>
      </doc>
    </field>
    <field name="EXIT_BAD_CONFIGURATION" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Exit code when the configurations in valid/incomplete: {@value}.
 <p>
 Approximate HTTP equivalent: {@code 409: Conflict}]]>
      </doc>
    </field>
    <field name="EXIT_EXCEPTION_THROWN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Exit code when an exception was thrown from the service: {@value}.
 <p>
 Approximate HTTP equivalent: {@code 500 Internal Server Error}]]>
      </doc>
    </field>
    <field name="EXIT_UNIMPLEMENTED" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Unimplemented feature: {@value}.
 <p>
 Approximate HTTP equivalent: {@code 501: Not Implemented}]]>
      </doc>
    </field>
    <field name="EXIT_SERVICE_UNAVAILABLE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Service Unavailable; it may be available later: {@value}.
 <p>
 Approximate HTTP equivalent: {@code 503 Service Unavailable}]]>
      </doc>
    </field>
    <field name="EXIT_UNSUPPORTED_VERSION" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The application does not support, or refuses to support this
 version: {@value}.
 <p>
 If raised, this is expected to be raised server-side and likely due
 to client/server version incompatibilities.
 <p>
 Approximate HTTP equivalent: {@code 505: Version Not Supported}]]>
      </doc>
    </field>
    <field name="EXIT_SERVICE_CREATION_FAILURE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The service instance could not be created: {@value}.]]>
      </doc>
    </field>
    <field name="EXIT_SERVICE_LIFECYCLE_EXCEPTION" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The service instance could not be created: {@value}.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Common Exit codes.
 <p>
 Codes with a YARN prefix are YARN-related.
 <p>
 Many of the exit codes are designed to resemble HTTP error codes,
 squashed into a single byte. e.g 44 , "not found" is the equivalent
 of 404. The various 2XX HTTP error codes aren't followed;
 the Unix standard of "0" for success is used.
 <pre>
    0-10: general command issues
   30-39: equivalent to the 3XX responses, where those responses are
          considered errors by the application.
   40-49: client-side/CLI/config problems
   50-59: service-side problems.
   60+  : application specific error codes
 </pre>]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.service.launcher.LauncherExitCodes -->
  <!-- start class org.apache.hadoop.service.launcher.ServiceLaunchException -->
  <class name="ServiceLaunchException" extends="org.apache.hadoop.util.ExitUtil.ExitException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.ExitCodeProvider"/>
    <implements name="org.apache.hadoop.service.launcher.LauncherExitCodes"/>
    <constructor name="ServiceLaunchException" type="int, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an exception with the specific exit code.
 @param exitCode exit code
 @param cause cause of the exception]]>
      </doc>
    </constructor>
    <constructor name="ServiceLaunchException" type="int, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an exception with the specific exit code and text.
 @param exitCode exit code
 @param message message to use in exception]]>
      </doc>
    </constructor>
    <constructor name="ServiceLaunchException" type="int, java.lang.String, java.lang.Object[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a formatted exception.
 <p>
 This uses {@link String#format(String, Object...)}
 to build the formatted exception in the ENGLISH locale.
 <p>
 If the last argument is a throwable, it becomes the cause of the exception.
 It will also be used as a parameter for the format.
 @param exitCode exit code
 @param format format for message to use in exception
 @param args list of arguments]]>
      </doc>
    </constructor>
    <constructor name="ServiceLaunchException" type="int, java.lang.Throwable, java.lang.String, java.lang.Object[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a formatted exception.
 <p>
 This uses {@link String#format(String, Object...)}
 to build the formatted exception in the ENGLISH locale.
 @param exitCode exit code
 @param cause inner cause
 @param format format for message to use in exception
 @param args list of arguments]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A service launch exception that includes an exit code.
 <p>
 When caught by the ServiceLauncher, it will convert that
 into a process exit code.
 
 The {@link #ServiceLaunchException(int, String, Object...)} constructor
 generates formatted exceptions.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.service.launcher.ServiceLaunchException -->
</package>
<package name="org.apache.hadoop.tools">
</package>
<package name="org.apache.hadoop.tools.protocolPB">
</package>
<package name="org.apache.hadoop.tracing">
</package>
<package name="org.apache.hadoop.util">
  <!-- start class org.apache.hadoop.util.ApplicationClassLoader -->
  <class name="ApplicationClassLoader" extends="java.net.URLClassLoader"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ApplicationClassLoader" type="java.net.URL[], java.lang.ClassLoader, java.util.List"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ApplicationClassLoader" type="java.lang.String, java.lang.ClassLoader, java.util.List"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="MalformedURLException" type="java.net.MalformedURLException"/>
    </constructor>
    <method name="getResource" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="loadClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
    </method>
    <method name="loadClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="resolve" type="boolean"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
    </method>
    <method name="isSystemClass" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="systemClasses" type="java.util.List"/>
      <doc>
      <![CDATA[Checks if a class should be included as a system class.

 A class is a system class if and only if it matches one of the positive
 patterns and none of the negative ones.

 @param name the class name to check
 @param systemClasses a list of system class configurations.
 @return true if the class is a system class]]>
      </doc>
    </method>
    <field name="SYSTEM_CLASSES_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value of the system classes if the user did not override them.
 JDK classes, hadoop classes and resources, and some select third-party
 classes are considered system classes, and are not loaded by the
 application classloader.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A {@link URLClassLoader} for application isolation. Classes from the
 application JARs are loaded in preference to the parent loader.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.ApplicationClassLoader -->
  <!-- start class org.apache.hadoop.util.DurationInfo -->
  <class name="DurationInfo" extends="org.apache.hadoop.util.OperationDuration"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.AutoCloseable"/>
    <constructor name="DurationInfo" type="org.slf4j.Logger, java.lang.String, java.lang.Object[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create the duration text from a {@code String.format()} code call;
 log output at info level.
 @param log log to write to
 @param format format string
 @param args list of arguments]]>
      </doc>
    </constructor>
    <constructor name="DurationInfo" type="org.slf4j.Logger, boolean, java.lang.String, java.lang.Object[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create the duration text from a {@code String.format()} code call
 and log either at info or debug.
 @param log log to write to
 @param logAtInfo should the log be at info, rather than debug
 @param format format string
 @param args list of arguments]]>
      </doc>
    </constructor>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A duration with logging of final state at info or debug
 in the {@code close()} call.
 This allows it to be used in a try-with-resources clause, and have the
 duration automatically logged.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.DurationInfo -->
  <!-- start interface org.apache.hadoop.util.IPList -->
  <interface name="IPList"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isIn" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ipAddress" type="java.lang.String"/>
      <doc>
      <![CDATA[returns true if the ipAddress is in the IPList.
 @param ipAddress ipAddress.
 @return boolean value indicating whether the ipAddress is in the IPList]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.util.IPList -->
  <!-- start class org.apache.hadoop.util.OperationDuration -->
  <class name="OperationDuration" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="OperationDuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instantiate.
 The start time and finished time are both set
 to the current clock time.]]>
      </doc>
    </constructor>
    <method name="time" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Evaluate the system time.
 @return the current clock time.]]>
      </doc>
    </method>
    <method name="finished"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Update the finished time with the current system time.]]>
      </doc>
    </method>
    <method name="getDurationString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the duration as {@link #humanTime(long)}.
 @return a printable duration.]]>
      </doc>
    </method>
    <method name="humanTime" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="time" type="long"/>
      <doc>
      <![CDATA[Convert to a human time of minutes:seconds.millis.
 @param time time to humanize.
 @return a printable value.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the duration as {@link #humanTime(long)}.
 @return a printable duration.]]>
      </doc>
    </method>
    <method name="value" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the duration in milliseconds.

 <p>
 This will be 0 until a call
 to {@link #finished()} has been made.
 </p>
 @return the currently recorded duration.]]>
      </doc>
    </method>
    <method name="asDuration" return="java.time.Duration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the duration of an operation as a java Duration
 instance.
 @return a duration.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Little duration counter.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.OperationDuration -->
  <!-- start interface org.apache.hadoop.util.Progressable -->
  <interface name="Progressable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="progress"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Report progress to the Hadoop framework.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A facility for reporting progress.
 
 <p>Clients and/or applications can use the provided <code>Progressable</code>
 to explicitly report progress to the Hadoop framework. This is especially
 important for operations which take significant amount of time since,
 in-lieu of the reported progress, the framework has to assume that an error
 has occurred and time-out the operation.</p>]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.util.Progressable -->
  <!-- start class org.apache.hadoop.util.PureJavaCrc32 -->
  <class name="PureJavaCrc32" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.zip.Checksum"/>
    <constructor name="PureJavaCrc32"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new PureJavaCrc32 object.]]>
      </doc>
    </constructor>
    <method name="getValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
    </method>
    <doc>
    <![CDATA[A pure-java implementation of the CRC32 checksum that uses
 the same polynomial as the built-in native CRC32.

 This is to avoid the JNI overhead for certain uses of Checksumming
 where many small pieces of data are checksummed in succession.

 The current version is ~10x to 1.8x as fast as Sun's native
 java.util.zip.CRC32 in Java 1.6

 @see java.util.zip.CRC32]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.PureJavaCrc32 -->
  <!-- start class org.apache.hadoop.util.PureJavaCrc32C -->
  <class name="PureJavaCrc32C" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.zip.Checksum"/>
    <constructor name="PureJavaCrc32C"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new PureJavaCrc32 object.]]>
      </doc>
    </constructor>
    <method name="getValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
    </method>
    <doc>
    <![CDATA[A pure-java implementation of the CRC32 checksum that uses
 the CRC32-C polynomial, the same polynomial used by iSCSI
 and implemented on many Intel chipsets supporting SSE4.2.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.PureJavaCrc32C -->
  <!-- start class org.apache.hadoop.util.ReflectionUtils -->
  <class name="ReflectionUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ReflectionUtils"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="theObject" type="java.lang.Object"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Check and set 'configuration' if necessary.
 
 @param theObject object for which to set configuration
 @param conf Configuration]]>
      </doc>
    </method>
    <method name="newInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="theClass" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Create an object for the given class and initialize it from conf.

 @param <T> Generics Type.
 @param theClass class of which an object is created
 @param conf Configuration
 @return a new object]]>
      </doc>
    </method>
    <method name="setContentionTracing"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="boolean"/>
    </method>
    <method name="printThreadInfo"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.PrintStream"/>
      <param name="title" type="java.lang.String"/>
      <doc>
      <![CDATA[Print all of the thread's information and stack traces.
 
 @param stream the stream to
 @param title a string title for the stack trace]]>
      </doc>
    </method>
    <method name="logThreadInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="log" type="org.apache.commons.logging.Log"/>
      <param name="title" type="java.lang.String"/>
      <param name="minInterval" type="long"/>
      <doc>
      <![CDATA[Log the current thread stacks at INFO level.
 @param log the logger that logs the stack trace
 @param title a descriptive title for the call stacks
 @param minInterval the minimum time from the last]]>
      </doc>
    </method>
    <method name="logThreadInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="log" type="org.slf4j.Logger"/>
      <param name="title" type="java.lang.String"/>
      <param name="minInterval" type="long"/>
      <doc>
      <![CDATA[Log the current thread stacks at INFO level.
 @param log the logger that logs the stack trace
 @param title a descriptive title for the call stacks
 @param minInterval the minimum time from the last]]>
      </doc>
    </method>
    <method name="getClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="T"/>
      <doc>
      <![CDATA[Return the correctly-typed {@link Class} of the given object.

 @param <T> Generics Type T
 @param o object whose correctly-typed <code>Class</code> is to be obtained
 @return the correctly typed <code>Class</code> of the given object.]]>
      </doc>
    </method>
    <method name="copy" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="src" type="T"/>
      <param name="dst" type="T"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Make a copy of the writable object using serialization to a buffer.

 @param <T> Generics Type.
 @param conf input Configuration.
 @param src the object to copy from
 @param dst the object to copy into, which is destroyed
 @return dst param (the copy)
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="cloneWritableInto"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dst" type="org.apache.hadoop.io.Writable"/>
      <param name="src" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getDeclaredFieldsIncludingInherited" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <doc>
      <![CDATA[@return Gets all the declared fields of a class including fields declared in
 superclasses.
 @param clazz input clazz.]]>
      </doc>
    </method>
    <method name="getDeclaredMethodsIncludingInherited" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <doc>
      <![CDATA[@return Gets all the declared methods of a class including methods declared in
 superclasses.
 @param clazz input clazz.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[General reflection utils]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.ReflectionUtils -->
  <!-- start class org.apache.hadoop.util.Shell -->
  <class name="Shell" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Shell"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance with no minimum interval between runs; stderr is
 not merged with stdout.]]>
      </doc>
    </constructor>
    <constructor name="Shell" type="long"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance with a minimum interval between executions; stderr is
 not merged with stdout.
 @param interval interval in milliseconds between command executions.]]>
      </doc>
    </constructor>
    <constructor name="Shell" type="long, boolean"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a shell instance which can be re-executed when the {@link #run()}
 method is invoked with a given elapsed time between calls.

 @param interval the minimum duration in milliseconds to wait before
        re-executing the command. If set to 0, there is no minimum.
 @param redirectErrorStream should the error stream be merged with
        the normal output stream?]]>
      </doc>
    </constructor>
    <method name="isJava7OrAbove" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="This call isn't needed any more: please remove uses of it.">
      <doc>
      <![CDATA[query to see if system is Java 7 or later.
 Now that Hadoop requires Java 7 or later, this always returns true.
 @deprecated This call isn't needed any more: please remove uses of it.
 @return true, always.]]>
      </doc>
    </method>
    <method name="isJavaVersionAtLeast" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="version" type="int"/>
      <doc>
      <![CDATA[Query to see if major version of Java specification of the system
 is equal or greater than the parameter.

 @param version 8, 9, 10 etc.
 @return comparison with system property, always true for 8]]>
      </doc>
    </method>
    <method name="checkWindowsCommandLineLength"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="commands" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Checks if a given command (String[]) fits in the Windows maximum command
 line length Note that the input is expected to already include space
 delimiters, no extra count will be added for delimiters.

 @param commands command parts, including any space delimiters
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getGroupsCommand" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[a Unix command to get the current user's groups list.

 @return group command array.]]>
      </doc>
    </method>
    <method name="getGroupsForUserCommand" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <doc>
      <![CDATA[A command to get a given user's groups list.
 If the OS is not WINDOWS, the command will get the user's primary group
 first and finally get the groups list which includes the primary group.
 i.e. the user's primary group will be included twice.

 @param user user.
 @return groups for user command.]]>
      </doc>
    </method>
    <method name="getGroupsIDForUserCommand" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <doc>
      <![CDATA[A command to get a given user's group id list.
 The command will get the user's primary group
 first and finally get the groups list which includes the primary group.
 i.e. the user's primary group will be included twice.
 This command does not support Windows and will only return group names.

 @param user user.
 @return groups id for user command.]]>
      </doc>
    </method>
    <method name="getUsersForNetgroupCommand" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="netgroup" type="java.lang.String"/>
      <doc>
      <![CDATA[A command to get a given netgroup's user list.

 @param netgroup net group.
 @return users for net group command.]]>
      </doc>
    </method>
    <method name="getGetPermissionCommand" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a command to get permission information.

 @return permission command.]]>
      </doc>
    </method>
    <method name="getSetPermissionCommand" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="java.lang.String"/>
      <param name="recursive" type="boolean"/>
      <doc>
      <![CDATA[Return a command to set permission.

 @param perm permission.
 @param recursive recursive.
 @return set permission command.]]>
      </doc>
    </method>
    <method name="getSetPermissionCommand" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="java.lang.String"/>
      <param name="recursive" type="boolean"/>
      <param name="file" type="java.lang.String"/>
      <doc>
      <![CDATA[Return a command to set permission for specific file.

 @param perm String permission to set
 @param recursive boolean true to apply to all sub-directories recursively
 @param file String file to set
 @return String[] containing command and arguments]]>
      </doc>
    </method>
    <method name="getSetOwnerCommand" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="owner" type="java.lang.String"/>
      <doc>
      <![CDATA[Return a command to set owner.

 @param owner owner.
 @return set owner command.]]>
      </doc>
    </method>
    <method name="getSymlinkCommand" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="java.lang.String"/>
      <param name="link" type="java.lang.String"/>
      <doc>
      <![CDATA[Return a command to create symbolic links.

 @param target target.
 @param link link.
 @return symlink command.]]>
      </doc>
    </method>
    <method name="getReadlinkCommand" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="link" type="java.lang.String"/>
      <doc>
      <![CDATA[Return a command to read the target of the a symbolic link.

 @param link link.
 @return read link command.]]>
      </doc>
    </method>
    <method name="getCheckProcessIsAliveCommand" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pid" type="java.lang.String"/>
      <doc>
      <![CDATA[Return a command for determining if process with specified pid is alive.
 @param pid process ID
 @return a <code>kill -0</code> command or equivalent]]>
      </doc>
    </method>
    <method name="getSignalKillCommand" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="code" type="int"/>
      <param name="pid" type="java.lang.String"/>
      <doc>
      <![CDATA[Return a command to send a signal to a given pid.

 @param code code.
 @param pid pid.
 @return signal kill command.]]>
      </doc>
    </method>
    <method name="getEnvironmentVariableRegex" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a regular expression string that match environment variables.

 @return environment variable regex.]]>
      </doc>
    </method>
    <method name="appendScriptExtension" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parent" type="java.io.File"/>
      <param name="basename" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a File referencing a script with the given basename, inside the
 given parent directory.  The file extension is inferred by platform:
 <code>".cmd"</code> on Windows, or <code>".sh"</code> otherwise.

 @param parent File parent directory
 @param basename String script file basename
 @return File referencing the script in the directory]]>
      </doc>
    </method>
    <method name="appendScriptExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="basename" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a script file name with the given basename.

 The file extension is inferred by platform:
 <code>".cmd"</code> on Windows, or <code>".sh"</code> otherwise.

 @param basename String script file basename
 @return String script file name]]>
      </doc>
    </method>
    <method name="getRunScriptCommand" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="script" type="java.io.File"/>
      <doc>
      <![CDATA[Returns a command to run the given script.  The script interpreter is
 inferred by platform: cmd on Windows or bash otherwise.

 @param script File script to run
 @return String[] command to run the script]]>
      </doc>
    </method>
    <method name="getHadoopHome" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the Hadoop home directory. Raises an exception if not found
 @return the home dir
 @throws IOException if the home directory cannot be located.]]>
      </doc>
    </method>
    <method name="getQualifiedBin" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executable" type="java.lang.String"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <doc>
      <![CDATA[Fully qualify the path to a binary that should be in a known hadoop
  bin location. This is primarily useful for disambiguating call-outs
  to executable sub-components of Hadoop to avoid clashes with other
  executables that may be in the path.  Caveat:  this call doesn't
  just format the path to the bin directory.  It also checks for file
  existence of the composed path. The output of this call should be
  cached by callers.

 @param executable executable
 @return executable file reference
 @throws FileNotFoundException if the path does not exist]]>
      </doc>
    </method>
    <method name="getQualifiedBinPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="executable" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fully qualify the path to a binary that should be in a known hadoop
  bin location. This is primarily useful for disambiguating call-outs
  to executable sub-components of Hadoop to avoid clashes with other
  executables that may be in the path.  Caveat:  this call doesn't
  just format the path to the bin directory.  It also checks for file
  existence of the composed path. The output of this call should be
  cached by callers.

 @param executable executable
 @return executable file reference
 @throws FileNotFoundException if the path does not exist
 @throws IOException on path canonicalization failures]]>
      </doc>
    </method>
    <method name="hasWinutilsPath" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Predicate to indicate whether or not the path to winutils is known.

 If true, then {@link #WINUTILS} is non-null, and both
 {@link #getWinUtilsPath()} and {@link #getWinUtilsFile()}
 will successfully return this value. Always false on non-windows systems.
 @return true if there is a valid path to the binary]]>
      </doc>
    </method>
    <method name="getWinUtilsPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Locate the winutils binary, or fail with a meaningful
 exception and stack trace as an RTE.
 This method is for use in methods which don't explicitly throw
 an <code>IOException</code>.
 @return the path to {@link #WINUTILS_EXE}
 @throws RuntimeException if the path is not resolvable]]>
      </doc>
    </method>
    <method name="getWinUtilsFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <doc>
      <![CDATA[Get a file reference to winutils.
 Always raises an exception if there isn't one
 @return the file instance referring to the winutils bin.
 @throws FileNotFoundException on any failure to locate that file.]]>
      </doc>
    </method>
    <method name="checkIsBashSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedIOException" type="java.io.InterruptedIOException"/>
    </method>
    <method name="setEnvironment"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="env" type="java.util.Map"/>
      <doc>
      <![CDATA[Set the environment for the command.
 @param env Mapping of environment variables]]>
      </doc>
    </method>
    <method name="setWorkingDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <doc>
      <![CDATA[Set the working directory.
 @param dir The directory where the command will be executed]]>
      </doc>
    </method>
    <method name="run"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Check to see if a command needs to be executed and execute if needed.

 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getExecString" return="java.lang.String[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[return an array containing the command name and its parameters.

 @return exec string array.]]>
      </doc>
    </method>
    <method name="parseExecResult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="lines" type="java.io.BufferedReader"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse the execution result.

 @param lines lines.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="getEnvironment" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="env" type="java.lang.String"/>
      <doc>
      <![CDATA[Get an environment variable.
 @param env the environment var
 @return the value or null if it was unset.]]>
      </doc>
    </method>
    <method name="getProcess" return="java.lang.Process"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the current sub-process executing the given command.
 @return process executing the command]]>
      </doc>
    </method>
    <method name="getExitCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the exit code.
 @return the exit code of the process]]>
      </doc>
    </method>
    <method name="getWaitingThread" return="java.lang.Thread"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the thread that is waiting on this instance of <code>Shell</code>.
 @return the thread that ran runCommand() that spawned this shell
 or null if no thread is waiting for this shell to complete]]>
      </doc>
    </method>
    <method name="isTimedOut" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[To check if the passed script to shell command executor timed out or
 not.

 @return if the script timed out.]]>
      </doc>
    </method>
    <method name="execCommand" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cmd" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Static method to execute a shell command.
 Covers most of the simple cases without requiring the user to implement
 the <code>Shell</code> interface.
 @param cmd shell command to execute.
 @return the output of the executed command.
 @throws IOException raised on errors performing I/O.]]>
      </doc>
    </method>
    <method name="execCommand" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="env" type="java.util.Map"/>
      <param name="cmd" type="java.lang.String[]"/>
      <param name="timeout" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Static method to execute a shell command.
 Covers most of the simple cases without requiring the user to implement
 the <code>Shell</code> interface.
 @param env the map of environment key=value
 @param cmd shell command to execute.
 @param timeout time in milliseconds after which script should be marked timeout
 @return the output of the executed command.
 @throws IOException on any problem.]]>
      </doc>
    </method>
    <method name="execCommand" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="env" type="java.util.Map"/>
      <param name="cmd" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Static method to execute a shell command.
 Covers most of the simple cases without requiring the user to implement
 the <code>Shell</code> interface.
 @param env the map of environment key=value
 @param cmd shell command to execute.
 @return the output of the executed command.
 @throws IOException on any problem.]]>
      </doc>
    </method>
    <method name="destroyAllShellProcesses"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Static method to destroy all running <code>Shell</code> processes.
 Iterates through a map of all currently running <code>Shell</code>
 processes and destroys them one by one. This method is thread safe]]>
      </doc>
    </method>
    <method name="getAllShells" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Static method to return a Set of all <code>Shell</code> objects.

 @return all shells set.]]>
      </doc>
    </method>
    <method name="getMemlockLimit" return="java.lang.Long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ulimit" type="java.lang.Long"/>
      <doc>
      <![CDATA[Static method to return the memory lock limit for datanode.
 @param ulimit max value at which memory locked should be capped.
 @return long value specifying the memory lock limit.]]>
      </doc>
    </method>
    <field name="LOG" type="org.slf4j.Logger"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SYSPROP_HADOOP_HOME_DIR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[System property for the Hadoop home directory: {@value}.]]>
      </doc>
    </field>
    <field name="ENV_HADOOP_HOME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Environment variable for Hadoop's home dir: {@value}.]]>
      </doc>
    </field>
    <field name="WINDOWS_MAX_SHELL_LENGTH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Maximum command line length in Windows
 KB830473 documents this as 8191]]>
      </doc>
    </field>
    <field name="WINDOWS_MAX_SHELL_LENGHT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="use the correctly spelled constant.">
      <doc>
      <![CDATA[mis-spelling of {@link #WINDOWS_MAX_SHELL_LENGTH}.
 @deprecated use the correctly spelled constant.]]>
      </doc>
    </field>
    <field name="USER_NAME_COMMAND" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[a Unix command to get the current user's name: {@value}.]]>
      </doc>
    </field>
    <field name="WindowsProcessLaunchLock" type="java.lang.Object"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Windows <code>CreateProcess</code> synchronization object.]]>
      </doc>
    </field>
    <field name="osType" type="org.apache.hadoop.util.Shell.OSType"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of the operating system, as determined from parsing
 the <code>os.name</code> property.]]>
      </doc>
    </field>
    <field name="WINDOWS" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SOLARIS" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MAC" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FREEBSD" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LINUX" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="OTHER" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PPC_64" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ENV_NAME_REGEX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Regular expression for environment variables: {@value}.]]>
      </doc>
    </field>
    <field name="SET_PERMISSION_COMMAND" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[a Unix command to set permission: {@value}.]]>
      </doc>
    </field>
    <field name="SET_OWNER_COMMAND" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[a Unix command to set owner: {@value}.]]>
      </doc>
    </field>
    <field name="SET_GROUP_COMMAND" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[a Unix command to set the change user's groups list: {@value}.]]>
      </doc>
    </field>
    <field name="LINK_COMMAND" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[a Unix command to create a link: {@value}.]]>
      </doc>
    </field>
    <field name="READ_LINK_COMMAND" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[a Unix command to get a link target: {@value}.]]>
      </doc>
    </field>
    <field name="timeOutInterval" type="long"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Time after which the executing script would be timedout.]]>
      </doc>
    </field>
    <field name="inheritParentEnv" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates if the parent env vars should be inherited or not]]>
      </doc>
    </field>
    <field name="WINUTILS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="use one of the exception-raising getter methods,
 specifically {@link #getWinUtilsPath()} or {@link #getWinUtilsFile()}">
      <doc>
      <![CDATA[Location of winutils as a string; null if not found.
 <p>
 <i>Important: caller must check for this value being null</i>.
 The lack of such checks has led to many support issues being raised.
 <p>
 @deprecated use one of the exception-raising getter methods,
 specifically {@link #getWinUtilsPath()} or {@link #getWinUtilsFile()}]]>
      </doc>
    </field>
    <field name="isSetsidAvailable" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Flag which is true if setsid exists.]]>
      </doc>
    </field>
    <field name="TOKEN_SEPARATOR_REGEX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Token separator regex used to parse Shell tool outputs.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A base class for running a Shell command.

 <code>Shell</code> can be used to run shell commands like <code>du</code> or
 <code>df</code>. It also offers facilities to gate commands by
 time-intervals.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.Shell -->
  <!-- start class org.apache.hadoop.util.ShutdownHookManager -->
  <class name="ShutdownHookManager" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="org.apache.hadoop.util.ShutdownHookManager"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return <code>ShutdownHookManager</code> singleton.

 @return <code>ShutdownHookManager</code> singleton.]]>
      </doc>
    </method>
    <method name="addShutdownHook"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shutdownHook" type="java.lang.Runnable"/>
      <param name="priority" type="int"/>
      <doc>
      <![CDATA[Adds a shutdownHook with a priority, the higher the priority
 the earlier will run. ShutdownHooks with same priority run
 in a non-deterministic order.

 @param shutdownHook shutdownHook <code>Runnable</code>
 @param priority priority of the shutdownHook.]]>
      </doc>
    </method>
    <method name="addShutdownHook"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shutdownHook" type="java.lang.Runnable"/>
      <param name="priority" type="int"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Adds a shutdownHook with a priority and timeout the higher the priority
 the earlier will run. ShutdownHooks with same priority run
 in a non-deterministic order. The shutdown hook will be terminated if it
 has not been finished in the specified period of time.

 @param shutdownHook shutdownHook <code>Runnable</code>
 @param priority priority of the shutdownHook
 @param timeout timeout of the shutdownHook
 @param unit unit of the timeout <code>TimeUnit</code>]]>
      </doc>
    </method>
    <method name="removeShutdownHook" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shutdownHook" type="java.lang.Runnable"/>
      <doc>
      <![CDATA[Removes a shutdownHook.

 @param shutdownHook shutdownHook to remove.
 @return TRUE if the shutdownHook was registered and removed,
 FALSE otherwise.]]>
      </doc>
    </method>
    <method name="hasShutdownHook" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shutdownHook" type="java.lang.Runnable"/>
      <doc>
      <![CDATA[Indicates if a shutdownHook is registered or not.

 @param shutdownHook shutdownHook to check if registered.
 @return TRUE/FALSE depending if the shutdownHook is is registered.]]>
      </doc>
    </method>
    <method name="isShutdownInProgress" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates if shutdown is in progress or not.
 
 @return TRUE if the shutdown is in progress, otherwise FALSE.]]>
      </doc>
    </method>
    <method name="clearShutdownHooks"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[clear all registered shutdownHooks.]]>
      </doc>
    </method>
    <field name="TIMEOUT_MINIMUM" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Minimum shutdown timeout: {@value} second(s).]]>
      </doc>
    </field>
    <field name="TIME_UNIT_DEFAULT" type="java.util.concurrent.TimeUnit"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The default time unit used: seconds.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[The <code>ShutdownHookManager</code> enables running shutdownHook
 in a deterministic order, higher priority first.
 <p>
 The JVM runs ShutdownHooks in a non-deterministic order or in parallel.
 This class registers a single JVM shutdownHook and run all the
 shutdownHooks registered to it (to this class) in order based on their
 priority.

 Unless a hook was registered with a shutdown explicitly set through
 {@link #addShutdownHook(Runnable, int, long, TimeUnit)},
 the shutdown time allocated to it is set by the configuration option
 {@link CommonConfigurationKeysPublic#SERVICE_SHUTDOWN_TIMEOUT} in
 {@code core-site.xml}, with a default value of
 {@link CommonConfigurationKeysPublic#SERVICE_SHUTDOWN_TIMEOUT_DEFAULT}
 seconds.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.ShutdownHookManager -->
  <!-- start class org.apache.hadoop.util.StringInterner -->
  <class name="StringInterner" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="StringInterner"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="strongIntern" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sample" type="java.lang.String"/>
      <doc>
      <![CDATA[Interns and returns a reference to the representative instance 
 for any of a collection of string instances that are equal to each other.
 Retains strong reference to the instance, 
 thus preventing it from being garbage-collected. 
 
 @param sample string instance to be interned
 @return strong reference to interned string instance]]>
      </doc>
    </method>
    <method name="weakIntern" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sample" type="java.lang.String"/>
      <doc>
      <![CDATA[Interns and returns a reference to the representative instance 
 for any of a collection of string instances that are equal to each other.
 Retains weak reference to the instance, 
 and so does not prevent it from being garbage-collected.
 
 @param sample string instance to be interned
 @return weak reference to interned string instance]]>
      </doc>
    </method>
    <method name="internStringsInArray" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="strings" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Interns all the strings in the given array in place,
 returning the same array.

 @param strings strings.
 @return internStringsInArray.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides string interning utility methods. For weak interning,
 we use the standard String.intern() call, that performs very well
 (no problems with PermGen overflowing, etc.) starting from JDK 7.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.StringInterner -->
  <!-- start class org.apache.hadoop.util.SysInfo -->
  <class name="SysInfo" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SysInfo"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newInstance" return="org.apache.hadoop.util.SysInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return default OS instance.
 @throws UnsupportedOperationException If cannot determine OS.
 @return Default instance for the detected OS.]]>
      </doc>
    </method>
    <method name="getVirtualMemorySize" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain the total size of the virtual memory present in the system.

 @return virtual memory size in bytes.]]>
      </doc>
    </method>
    <method name="getPhysicalMemorySize" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain the total size of the physical memory present in the system.

 @return physical memory size bytes.]]>
      </doc>
    </method>
    <method name="getAvailableVirtualMemorySize" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain the total size of the available virtual memory present
 in the system.

 @return available virtual memory size in bytes.]]>
      </doc>
    </method>
    <method name="getAvailablePhysicalMemorySize" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain the total size of the available physical memory present
 in the system.

 @return available physical memory size bytes.]]>
      </doc>
    </method>
    <method name="getNumProcessors" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain the total number of logical processors present on the system.

 @return number of logical processors]]>
      </doc>
    </method>
    <method name="getNumCores" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain total number of physical cores present on the system.

 @return number of physical cores]]>
      </doc>
    </method>
    <method name="getCpuFrequency" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain the CPU frequency of on the system.

 @return CPU frequency in kHz]]>
      </doc>
    </method>
    <method name="getCumulativeCpuTime" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain the cumulative CPU time since the system is on.

 @return cumulative CPU time in milliseconds]]>
      </doc>
    </method>
    <method name="getCpuUsagePercentage" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain the CPU usage % of the machine. Return -1 if it is unavailable

 @return CPU usage as a percentage (from 0 to 100) of available cycles.]]>
      </doc>
    </method>
    <method name="getNumVCoresUsed" return="float"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain the number of VCores used. Return -1 if it is unavailable

 @return Number of VCores used a percentage (from 0 to #VCores).]]>
      </doc>
    </method>
    <method name="getNetworkBytesRead" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain the aggregated number of bytes read over the network.
 @return total number of bytes read.]]>
      </doc>
    </method>
    <method name="getNetworkBytesWritten" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain the aggregated number of bytes written to the network.
 @return total number of bytes written.]]>
      </doc>
    </method>
    <method name="getStorageBytesRead" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain the aggregated number of bytes read from disks.

 @return total number of bytes read.]]>
      </doc>
    </method>
    <method name="getStorageBytesWritten" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Obtain the aggregated number of bytes written to disks.

 @return total number of bytes written.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Plugin to calculate resource information on the system.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.SysInfo -->
  <!-- start interface org.apache.hadoop.util.Tool -->
  <interface name="Tool"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <method name="run" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Execute the command with the given arguments.
 
 @param args command specific arguments.
 @return exit code.
 @throws Exception command exception.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A tool interface that supports handling of generic command-line options.
 
 <p><code>Tool</code>, is the standard for any Map-Reduce tool/application. 
 The tool/application should delegate the handling of 
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/CommandsManual.html#Generic_Options">
 standard command-line options</a> to {@link ToolRunner#run(Tool, String[])} 
 and only handle its custom arguments.</p>
 
 <p>Here is how a typical <code>Tool</code> is implemented:</p>
 <blockquote><pre>
     public class MyApp extends Configured implements Tool {
     
       public int run(String[] args) throws Exception {
         // <code>Configuration</code> processed by <code>ToolRunner</code>
         Configuration conf = getConf();
         
         // Create a JobConf using the processed <code>conf</code>
         JobConf job = new JobConf(conf, MyApp.class);
         
         // Process custom command-line options
         Path in = new Path(args[1]);
         Path out = new Path(args[2]);
         
         // Specify various job-specific parameters     
         job.setJobName("my-app");
         job.setInputPath(in);
         job.setOutputPath(out);
         job.setMapperClass(MyMapper.class);
         job.setReducerClass(MyReducer.class);

         // Submit the job, then poll for progress until the job is complete
         RunningJob runningJob = JobClient.runJob(job);
         if (runningJob.isSuccessful()) {
           return 0;
         } else {
           return 1;
         }
       }
       
       public static void main(String[] args) throws Exception {
         // Let <code>ToolRunner</code> handle generic command-line options 
         int res = ToolRunner.run(new Configuration(), new MyApp(), args);
         
         System.exit(res);
       }
     }
 </pre></blockquote>
 
 @see GenericOptionsParser
 @see ToolRunner]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.util.Tool -->
  <!-- start class org.apache.hadoop.util.ToolRunner -->
  <class name="ToolRunner" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ToolRunner"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="tool" type="org.apache.hadoop.util.Tool"/>
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Runs the given <code>Tool</code> by {@link Tool#run(String[])}, after 
 parsing with the given generic arguments. Uses the given 
 <code>Configuration</code>, or builds one if null.
 
 Sets the <code>Tool</code>'s configuration with the possibly modified 
 version of the <code>conf</code>.  
 
 @param conf <code>Configuration</code> for the <code>Tool</code>.
 @param tool <code>Tool</code> to run.
 @param args command-line arguments to the tool.
 @return exit code of the {@link Tool#run(String[])} method.
 @throws Exception Exception.]]>
      </doc>
    </method>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tool" type="org.apache.hadoop.util.Tool"/>
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Runs the <code>Tool</code> with its <code>Configuration</code>.
 
 Equivalent to <code>run(tool.getConf(), tool, args)</code>.
 
 @param tool <code>Tool</code> to run.
 @param args command-line arguments to the tool.
 @return exit code of the {@link Tool#run(String[])} method.
 @throws Exception exception.]]>
      </doc>
    </method>
    <method name="printGenericCommandUsage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.PrintStream"/>
      <doc>
      <![CDATA[Prints generic command-line argurments and usage information.
 
  @param out stream to write usage information to.]]>
      </doc>
    </method>
    <method name="confirmPrompt" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prompt" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Print out a prompt to the user, and return true if the user
 responds with "y" or "yes". (case insensitive).

 @param prompt prompt.
 @throws IOException raised on errors performing I/O.
 @return if the user
         responds with "y" or "yes". (case insensitive) true,
         not false.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A utility to help run {@link Tool}s.
 
 <p><code>ToolRunner</code> can be used to run classes implementing 
 <code>Tool</code> interface. It works in conjunction with 
 {@link GenericOptionsParser} to parse the 
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/CommandsManual.html#Generic_Options">
 generic hadoop command line arguments</a> and modifies the 
 <code>Configuration</code> of the <code>Tool</code>. The 
 application-specific options are passed along without being modified.
 </p>
 
 @see Tool
 @see GenericOptionsParser]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.ToolRunner -->
  <!-- start class org.apache.hadoop.util.VersionInfo -->
  <class name="VersionInfo" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="VersionInfo" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="_getVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="_getRevision" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="_getBranch" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="_getDate" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="_getUser" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="_getUrl" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="_getSrcChecksum" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="_getBuildVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="_getProtocVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the Hadoop version.
 @return the Hadoop version string, eg. "0.6.3-dev"]]>
      </doc>
    </method>
    <method name="getRevision" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the Git commit hash of the repository when compiled.
 @return the commit hash, eg. "18f64065d5db6208daf50b02c1b5ed4ee3ce547a"]]>
      </doc>
    </method>
    <method name="getBranch" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the branch on which this originated.
 @return The branch name, e.g. "trunk" or "branches/branch-0.20"]]>
      </doc>
    </method>
    <method name="getDate" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The date that Hadoop was compiled.
 @return the compilation date in unix date format]]>
      </doc>
    </method>
    <method name="getUser" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The user that compiled Hadoop.
 @return the username of the user]]>
      </doc>
    </method>
    <method name="getUrl" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the URL for the Hadoop repository.
 @return the URL of the Hadoop repository]]>
      </doc>
    </method>
    <method name="getSrcChecksum" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the checksum of the source files from which Hadoop was built.
 @return the checksum of the source files]]>
      </doc>
    </method>
    <method name="getBuildVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the buildVersion which includes version,
 revision, user and date.
 @return the buildVersion]]>
      </doc>
    </method>
    <method name="getProtocVersion" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the protoc version used for the build.
 @return the protoc version]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
    </method>
    <doc>
    <![CDATA[This class returns build information about Hadoop components.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.VersionInfo -->
  <doc>
  <![CDATA[Common utilities.]]>
  </doc>
</package>
<package name="org.apache.hadoop.util.bloom">
  <!-- start class org.apache.hadoop.util.bloom.BloomFilter -->
  <class name="BloomFilter" extends="org.apache.hadoop.util.bloom.Filter"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BloomFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor - use with readFields]]>
      </doc>
    </constructor>
    <constructor name="BloomFilter" type="int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor
 @param vectorSize The vector size of <i>this</i> filter.
 @param nbHash The number of hash function to consider.
 @param hashType type of the hashing function (see
 {@link org.apache.hadoop.util.hash.Hash}).]]>
      </doc>
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="and"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="membershipTest" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="not"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="or"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="xor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getVectorSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return size of the the bloomfilter]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Implements a <i>Bloom filter</i>, as defined by Bloom in 1970.
 <p>
 The Bloom filter is a data structure that was introduced in 1970 and that has been adopted by 
 the networking research community in the past decade thanks to the bandwidth efficiencies that it
 offers for the transmission of set membership information between networked hosts.  A sender encodes 
 the information into a bit vector, the Bloom filter, that is more compact than a conventional 
 representation. Computation and space costs for construction are linear in the number of elements.  
 The receiver uses the filter to test whether various elements are members of the set. Though the 
 filter will occasionally return a false positive, it will never return a false negative. When creating 
 the filter, the sender can choose its desired point in a trade-off between the false positive rate and the size. 
 
 <p>
 Originally created by
 <a href="http://www.one-lab.org">European Commission One-Lab Project 034819</a>.
 
 @see Filter The general behavior of a filter
 
 @see <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/Time Trade-Offs in Hash Coding with Allowable Errors</a>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.bloom.BloomFilter -->
  <!-- start class org.apache.hadoop.util.bloom.CountingBloomFilter -->
  <class name="CountingBloomFilter" extends="org.apache.hadoop.util.bloom.Filter"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="CountingBloomFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor - use with readFields]]>
      </doc>
    </constructor>
    <constructor name="CountingBloomFilter" type="int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor
 @param vectorSize The vector size of <i>this</i> filter.
 @param nbHash The number of hash function to consider.
 @param hashType type of the hashing function (see
 {@link org.apache.hadoop.util.hash.Hash}).]]>
      </doc>
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="delete"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
      <doc>
      <![CDATA[Removes a specified key from <i>this</i> counting Bloom filter.
 <p>
 <b>Invariant</b>: nothing happens if the specified key does not belong to <i>this</i> counter Bloom filter.
 @param key The key to remove.]]>
      </doc>
    </method>
    <method name="and"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="membershipTest" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="approximateCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
      <doc>
      <![CDATA[This method calculates an approximate count of the key, i.e. how many
 times the key was added to the filter. This allows the filter to be
 used as an approximate <code>key -&gt; count</code> map.
 <p>NOTE: due to the bucket size of this filter, inserting the same
 key more than 15 times will cause an overflow at all filter positions
 associated with this key, and it will significantly increase the error
 rate for this and other keys. For this reason the filter can only be
 used to store small count values <code>0 &lt;= N &lt;&lt; 15</code>.
 @param key key to be tested
 @return 0 if the key is not present. Otherwise, a positive value v will
 be returned such that <code>v == count</code> with probability equal to the
 error rate of this filter, and <code>v &gt; count</code> otherwise.
 Additionally, if the filter experienced an underflow as a result of
 {@link #delete(Key)} operation, the return value may be lower than the
 <code>count</code> with the probability of the false negative rate of such
 filter.]]>
      </doc>
    </method>
    <method name="not"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="or"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="xor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Implements a <i>counting Bloom filter</i>, as defined by Fan et al. in a ToN
 2000 paper.
 <p>
 A counting Bloom filter is an improvement to standard a Bloom filter as it
 allows dynamic additions and deletions of set membership information.  This 
 is achieved through the use of a counting vector instead of a bit vector.
 <p>
 Originally created by
 <a href="http://www.one-lab.org">European Commission One-Lab Project 034819</a>.

 @see Filter The general behavior of a filter
 
 @see <a href="http://portal.acm.org/citation.cfm?id=343571.343572">Summary cache: a scalable wide-area web cache sharing protocol</a>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.bloom.CountingBloomFilter -->
  <!-- start class org.apache.hadoop.util.bloom.DynamicBloomFilter -->
  <class name="DynamicBloomFilter" extends="org.apache.hadoop.util.bloom.Filter"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DynamicBloomFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Zero-args constructor for the serialization.]]>
      </doc>
    </constructor>
    <constructor name="DynamicBloomFilter" type="int, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor.
 <p>
 Builds an empty Dynamic Bloom filter.
 @param vectorSize The number of bits in the vector.
 @param nbHash The number of hash function to consider.
 @param hashType type of the hashing function (see
 {@link org.apache.hadoop.util.hash.Hash}).
 @param nr The threshold for the maximum number of keys to record in a
 dynamic Bloom filter row.]]>
      </doc>
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="and"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="membershipTest" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="not"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="or"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="xor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Implements a <i>dynamic Bloom filter</i>, as defined in the INFOCOM 2006 paper.
 <p>
 A dynamic Bloom filter (DBF) makes use of a <code>s * m</code> bit matrix but
 each of the <code>s</code> rows is a standard Bloom filter. The creation 
 process of a DBF is iterative. At the start, the DBF is a <code>1 * m</code>
 bit matrix, i.e., it is composed of a single standard Bloom filter.
 It assumes that <code>n<sub>r</sub></code> elements are recorded in the 
 initial bit vector, where <code>n<sub>r</sub> {@literal <=} n</code>
 (<code>n</code> is the cardinality of the set <code>A</code> to record in
 the filter).
 <p>
 As the size of <code>A</code> grows during the execution of the application,
 several keys must be inserted in the DBF.  When inserting a key into the DBF,
 one must first get an active Bloom filter in the matrix.  A Bloom filter is
 active when the number of recorded keys, <code>n<sub>r</sub></code>, is 
 strictly less than the current cardinality of <code>A</code>, <code>n</code>.
 If an active Bloom filter is found, the key is inserted and 
 <code>n<sub>r</sub></code> is incremented by one. On the other hand, if there
 is no active Bloom filter, a new one is created (i.e., a new row is added to
 the matrix) according to the current size of <code>A</code> and the element
 is added in this new Bloom filter and the <code>n<sub>r</sub></code> value of
 this new Bloom filter is set to one.  A given key is said to belong to the
 DBF if the <code>k</code> positions are set to one in one of the matrix rows.
 <p>
 Originally created by
 <a href="http://www.one-lab.org">European Commission One-Lab Project 034819</a>.

 @see Filter The general behavior of a filter
 @see BloomFilter A Bloom filter
 
 @see <a href="http://www.cse.fau.edu/~jie/research/publications/Publication_files/infocom2006.pdf">Theory and Network Applications of Dynamic Bloom Filters</a>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.bloom.DynamicBloomFilter -->
  <!-- start class org.apache.hadoop.util.bloom.HashFunction -->
  <class name="HashFunction" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="HashFunction" type="int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor.
 <p>
 Builds a hash function that must obey to a given maximum number of returned values and a highest value.
 @param maxValue The maximum highest returned value.
 @param nbHash The number of resulting hashed values.
 @param hashType type of the hashing function (see {@link Hash}).]]>
      </doc>
    </constructor>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears <i>this</i> hash function. A NOOP]]>
      </doc>
    </method>
    <method name="hash" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k" type="org.apache.hadoop.util.bloom.Key"/>
      <doc>
      <![CDATA[Hashes a specified key into several integers.
 @param k The specified key.
 @return The array of hashed values.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implements a hash object that returns a certain number of hashed values.
 
 @see Key The general behavior of a key being stored in a filter
 @see Filter The general behavior of a filter]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.bloom.HashFunction -->
  <!-- start interface org.apache.hadoop.util.bloom.RemoveScheme -->
  <interface name="RemoveScheme"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="RANDOM" type="short"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Random selection.
 <p>
 The idea is to randomly select a bit to reset.]]>
      </doc>
    </field>
    <field name="MINIMUM_FN" type="short"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[MinimumFN Selection.
 <p>
 The idea is to select the bit to reset that will generate the minimum
 number of false negative.]]>
      </doc>
    </field>
    <field name="MAXIMUM_FP" type="short"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[MaximumFP Selection.
 <p>
 The idea is to select the bit to reset that will remove the maximum number
 of false positive.]]>
      </doc>
    </field>
    <field name="RATIO" type="short"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Ratio Selection.
 <p>
 The idea is to select the bit to reset that will, at the same time, remove
 the maximum number of false positve while minimizing the amount of false
 negative generated.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Defines the different remove scheme for retouched Bloom filters.
 <p>
 Originally created by
 <a href="http://www.one-lab.org">European Commission One-Lab Project 034819</a>.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.util.bloom.RemoveScheme -->
  <!-- start class org.apache.hadoop.util.bloom.RetouchedBloomFilter -->
  <class name="RetouchedBloomFilter" extends="org.apache.hadoop.util.bloom.BloomFilter"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.bloom.RemoveScheme"/>
    <constructor name="RetouchedBloomFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor - use with readFields]]>
      </doc>
    </constructor>
    <constructor name="RetouchedBloomFilter" type="int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor
 @param vectorSize The vector size of <i>this</i> filter.
 @param nbHash The number of hash function to consider.
 @param hashType type of the hashing function (see
 {@link org.apache.hadoop.util.hash.Hash}).]]>
      </doc>
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="addFalsePositive"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
      <doc>
      <![CDATA[Adds a false positive information to <i>this</i> retouched Bloom filter.
 <p>
 <b>Invariant</b>: if the false positive is <code>null</code>, nothing happens.
 @param key The false positive key to add.]]>
      </doc>
    </method>
    <method name="addFalsePositive"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="coll" type="java.util.Collection"/>
      <doc>
      <![CDATA[Adds a collection of false positive information to <i>this</i> retouched Bloom filter.
 @param coll The collection of false positive.]]>
      </doc>
    </method>
    <method name="addFalsePositive"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.util.List"/>
      <doc>
      <![CDATA[Adds a list of false positive information to <i>this</i> retouched Bloom filter.
 @param keys The list of false positive.]]>
      </doc>
    </method>
    <method name="addFalsePositive"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="org.apache.hadoop.util.bloom.Key[]"/>
      <doc>
      <![CDATA[Adds an array of false positive information to <i>this</i> retouched Bloom filter.
 @param keys The array of false positive.]]>
      </doc>
    </method>
    <method name="selectiveClearing"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k" type="org.apache.hadoop.util.bloom.Key"/>
      <param name="scheme" type="short"/>
      <doc>
      <![CDATA[Performs the selective clearing for a given key.
 @param k The false positive key to remove from <i>this</i> retouched Bloom filter.
 @param scheme The selective clearing scheme to apply.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Implements a <i>retouched Bloom filter</i>, as defined in the CoNEXT 2006 paper.
 <p>
 It allows the removal of selected false positives at the cost of introducing
 random false negatives, and with the benefit of eliminating some random false
 positives at the same time.
 
 <p>
 Originally created by
 <a href="http://www.one-lab.org">European Commission One-Lab Project 034819</a>.
 
 @see Filter The general behavior of a filter
 @see BloomFilter A Bloom filter
 @see RemoveScheme The different selective clearing algorithms
 
 @see <a href="http://www-rp.lip6.fr/site_npa/site_rp/_publications/740-rbf_cameraready.pdf">Retouched Bloom Filters: Allowing Networked Applications to Trade Off Selected False Positives Against False Negatives</a>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.bloom.RetouchedBloomFilter -->
</package>
<package name="org.apache.hadoop.util.curator">
</package>
<package name="org.apache.hadoop.util.functional">
  <!-- start class org.apache.hadoop.util.functional.CloseableTaskPoolSubmitter -->
  <class name="CloseableTaskPoolSubmitter" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.functional.TaskPool.Submitter"/>
    <implements name="java.io.Closeable"/>
    <constructor name="CloseableTaskPoolSubmitter" type="java.util.concurrent.ExecutorService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor.
 @param pool non-null executor.]]>
      </doc>
    </constructor>
    <method name="getPool" return="java.util.concurrent.ExecutorService"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the pool.
 @return the pool.]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shut down the pool.]]>
      </doc>
    </method>
    <method name="submit" return="java.util.concurrent.Future"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="task" type="java.lang.Runnable"/>
    </method>
    <doc>
    <![CDATA[A task submitter which is closeable, and whose close() call
 shuts down the pool. This can help manage
 thread pool lifecycles.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.functional.CloseableTaskPoolSubmitter -->
  <!-- start class org.apache.hadoop.util.functional.FutureIO -->
  <class name="FutureIO" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="awaitFuture" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future"/>
      <exception name="InterruptedIOException" type="java.io.InterruptedIOException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="RuntimeException" type="java.lang.RuntimeException"/>
      <doc>
      <![CDATA[Given a future, evaluate it.
 <p>
 Any exception generated in the future is
 extracted and rethrown.
 </p>
 @param future future to evaluate
 @param <T> type of the result.
 @return the result, if all went well.
 @throws InterruptedIOException future was interrupted
 @throws IOException if something went wrong
 @throws RuntimeException any nested RTE thrown]]>
      </doc>
    </method>
    <method name="awaitFuture" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="future" type="java.util.concurrent.Future"/>
      <param name="timeout" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="InterruptedIOException" type="java.io.InterruptedIOException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="RuntimeException" type="java.lang.RuntimeException"/>
      <exception name="TimeoutException" type="java.util.concurrent.TimeoutException"/>
      <doc>
      <![CDATA[Given a future, evaluate it.
 <p>
 Any exception generated in the future is
 extracted and rethrown.
 </p>
 @param future future to evaluate
 @param timeout timeout to wait
 @param unit time unit.
 @param <T> type of the result.
 @return the result, if all went well.
 @throws InterruptedIOException future was interrupted
 @throws IOException if something went wrong
 @throws RuntimeException any nested RTE thrown
 @throws TimeoutException the future timed out.]]>
      </doc>
    </method>
    <method name="raiseInnerCause" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.util.concurrent.ExecutionException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[From the inner cause of an execution exception, extract the inner cause
 if it is an IOE or RTE.
 This will always raise an exception, either the inner IOException,
 an inner RuntimeException, or a new IOException wrapping the raised
 exception.

 @param e exception.
 @param <T> type of return value.
 @return nothing, ever.
 @throws IOException either the inner IOException, or a wrapper around
 any non-Runtime-Exception
 @throws RuntimeException if that is the inner cause.]]>
      </doc>
    </method>
    <method name="raiseInnerCause" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.util.concurrent.CompletionException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Extract the cause of a completion failure and rethrow it if an IOE
 or RTE.
 @param e exception.
 @param <T> type of return value.
 @return nothing, ever.
 @throws IOException either the inner IOException, or a wrapper around
 any non-Runtime-Exception
 @throws RuntimeException if that is the inner cause.]]>
      </doc>
    </method>
    <method name="unwrapInnerException" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[From the inner cause of an execution exception, extract the inner cause
 to an IOException, raising RuntimeExceptions and Errors immediately.
 <ol>
   <li> If it is an IOE: Return.</li>
   <li> If it is a {@link UncheckedIOException}: return the cause</li>
   <li> Completion/Execution Exceptions: extract and repeat</li>
   <li> If it is an RTE or Error: throw.</li>
   <li> Any other type: wrap in an IOE</li>
 </ol>

 Recursively handles wrapped Execution and Completion Exceptions in
 case something very complicated has happened.
 @param e exception.
 @return an IOException extracted or built from the cause.
 @throws RuntimeException if that is the inner cause.
 @throws Error if that is the inner cause.]]>
      </doc>
    </method>
    <method name="propagateOptions" return="org.apache.hadoop.fs.FSBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.fs.FSBuilder"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="optionalPrefix" type="java.lang.String"/>
      <param name="mandatoryPrefix" type="java.lang.String"/>
      <doc>
      <![CDATA[Propagate options to any builder, converting everything with the
 prefix to an option where, if there were 2+ dot-separated elements,
 it is converted to a schema.
 See {@link #propagateOptions(FSBuilder, Configuration, String, boolean)}.
 @param builder builder to modify
 @param conf configuration to read
 @param optionalPrefix prefix for optional settings
 @param mandatoryPrefix prefix for mandatory settings
 @param <T> type of result
 @param <U> type of builder
 @return the builder passed in.]]>
      </doc>
    </method>
    <method name="propagateOptions"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.fs.FSBuilder"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="prefix" type="java.lang.String"/>
      <param name="mandatory" type="boolean"/>
      <doc>
      <![CDATA[Propagate options to any builder, converting everything with the
 prefix to an option where, if there were 2+ dot-separated elements,
 it is converted to a schema.
 <pre>
   fs.example.s3a.option becomes "s3a.option"
   fs.example.fs.io.policy becomes "fs.io.policy"
   fs.example.something becomes "something"
 </pre>
 @param builder builder to modify
 @param conf configuration to read
 @param prefix prefix to scan/strip
 @param mandatory are the options to be mandatory or optional?]]>
      </doc>
    </method>
    <method name="eval" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callable" type="org.apache.hadoop.util.functional.CallableRaisingIOE"/>
      <doc>
      <![CDATA[Evaluate a CallableRaisingIOE in the current thread,
 converting IOEs to RTEs and propagating.
 @param callable callable to invoke
 @param <T> Return type.
 @return the evaluated result.
 @throws UnsupportedOperationException fail fast if unsupported
 @throws IllegalArgumentException invalid argument]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Future IO Helper methods.
 <p>
 Contains methods promoted from
 {@link org.apache.hadoop.fs.impl.FutureIOSupport} because they
 are a key part of integrating async IO in application code.
 </p>
 <p>
 One key feature is that the {@link #awaitFuture(Future)} and
 {@link #awaitFuture(Future, long, TimeUnit)} calls will
 extract and rethrow exceptions raised in the future's execution,
 including extracting the inner IOException of any
 {@code UncheckedIOException} raised in the future.
 This makes it somewhat easier to execute IOException-raising
 code inside futures.
 </p>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.functional.FutureIO -->
  <!-- start class org.apache.hadoop.util.functional.RemoteIterators -->
  <class name="RemoteIterators" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="remoteIteratorFromSingleton" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="singleton" type="T"/>
      <doc>
      <![CDATA[Create an iterator from a singleton.
 @param singleton instance
 @param <T> type
 @return a remote iterator]]>
      </doc>
    </method>
    <method name="remoteIteratorFromIterator" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="java.util.Iterator"/>
      <doc>
      <![CDATA[Create a remote iterator from a java.util.Iterator.
 @param <T> type
 @param iterator iterator.
 @return a remote iterator]]>
      </doc>
    </method>
    <method name="remoteIteratorFromIterable" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterable" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[Create a remote iterator from a java.util.Iterable -e.g. a list
 or other collection.
 @param <T> type
 @param iterable iterable.
 @return a remote iterator]]>
      </doc>
    </method>
    <method name="remoteIteratorFromArray" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="array" type="T[]"/>
      <doc>
      <![CDATA[Create a remote iterator from an array.
 @param <T> type
 @param array array.
 @return a remote iterator]]>
      </doc>
    </method>
    <method name="mappingRemoteIterator" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="org.apache.hadoop.fs.RemoteIterator"/>
      <param name="mapper" type="org.apache.hadoop.util.functional.FunctionRaisingIOE"/>
      <doc>
      <![CDATA[Create an iterator from an iterator and a transformation function.
 @param <S> source type
 @param <T> result type
 @param iterator source
 @param mapper transformation
 @return a remote iterator]]>
      </doc>
    </method>
    <method name="typeCastingRemoteIterator" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="org.apache.hadoop.fs.RemoteIterator"/>
      <doc>
      <![CDATA[Create a RemoteIterator from a RemoteIterator, casting the
 type in the process. This is to help with filesystem API
 calls where overloading causes confusion (e.g. listStatusIterator())
 @param <S> source type
 @param <T> result type
 @param iterator source
 @return a remote iterator]]>
      </doc>
    </method>
    <method name="filteringRemoteIterator" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="org.apache.hadoop.fs.RemoteIterator"/>
      <param name="filter" type="org.apache.hadoop.util.functional.FunctionRaisingIOE"/>
      <doc>
      <![CDATA[Create a RemoteIterator from a RemoteIterator and a filter
 function which returns true for every element to be passed
 through.
 <p>
 Elements are filtered in the hasNext() method; if not used
 the filtering will be done on demand in the {@code next()}
 call.
 </p>
 @param <S> type
 @param iterator source
 @param filter filter
 @return a remote iterator]]>
      </doc>
    </method>
    <method name="closingRemoteIterator" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="iterator" type="org.apache.hadoop.fs.RemoteIterator"/>
      <param name="toClose" type="java.io.Closeable"/>
      <doc>
      <![CDATA[This adds an extra close operation alongside the passthrough
 to any Closeable.close() method supported by the source iterator.
 @param iterator source
 @param toClose extra object to close.
 @param <S> source type.
 @return a new iterator]]>
      </doc>
    </method>
    <method name="toList" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.apache.hadoop.fs.RemoteIterator"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Build a list from a RemoteIterator.
 @param source source iterator
 @param <T> type
 @return a list of the values.
 @throws IOException if the source RemoteIterator raises it.]]>
      </doc>
    </method>
    <method name="toArray" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.apache.hadoop.fs.RemoteIterator"/>
      <param name="a" type="T[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Build an array from a RemoteIterator.
 @param source source iterator
 @param a destination array; if too small a new array
 of the same type is created
 @param <T> type
 @return an array of the values.
 @throws IOException if the source RemoteIterator raises it.]]>
      </doc>
    </method>
    <method name="foreach" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.apache.hadoop.fs.RemoteIterator"/>
      <param name="consumer" type="org.apache.hadoop.util.functional.ConsumerRaisingIOE"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Apply an operation to all values of a RemoteIterator.

 If the iterator is an IOStatisticsSource returning a non-null
 set of statistics, <i>and</i> this classes log is set to DEBUG,
 then the statistics of the operation are evaluated and logged at
 debug.
 <p>
 The number of entries processed is returned, as it is useful to
 know this, especially during tests or when reporting values
 to users.
 </p>
 This does not close the iterator afterwards.
 @param source iterator source
 @param consumer consumer of the values.
 @return the number of elements processed
 @param <T> type of source
 @throws IOException if the source RemoteIterator or the consumer raise one.]]>
      </doc>
    </method>
    <method name="cleanupRemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="org.apache.hadoop.fs.RemoteIterator"/>
      <doc>
      <![CDATA[Clean up after an iteration.
 If the log is at debug, calculate and log the IOStatistics.
 If the iterator is closeable, cast and then cleanup the iterator
 @param source iterator source
 @param <T> type of source]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A set of remote iterators supporting transformation and filtering,
 with IOStatisticsSource passthrough, and of conversions of
 the iterators to lists/arrays and of performing actions
 on the values.
 <p>
 This aims to make it straightforward to use lambda-expressions to
 transform the results of an iterator, without losing the statistics
 in the process, and to chain the operations together.
 </p>
 The closeable operation will be passed through RemoteIterators which
 wrap other RemoteIterators. This is to support any iterator which
 can be closed to release held connections, file handles etc.
 Unless client code is written to assume that RemoteIterator instances
 may be closed, this is not likely to be broadly used. It is added
 to make it possible to adopt this feature in a managed way.
 <p>
 One notable feature is that the
 {@link #foreach(RemoteIterator, ConsumerRaisingIOE)} method will
 LOG at debug any IOStatistics provided by the iterator, if such
 statistics are provided. There's no attempt at retrieval and logging
 if the LOG is not set to debug, so it is a zero cost feature unless
 the logger {@code org.apache.hadoop.fs.functional.RemoteIterators}
 is at DEBUG.
 </p>
 Based on the S3A Listing code, and some some work on moving other code
 to using iterative listings so as to pick up the statistics.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.functional.RemoteIterators -->
</package>
<package name="org.apache.hadoop.util.hash">
</package>

</api>
