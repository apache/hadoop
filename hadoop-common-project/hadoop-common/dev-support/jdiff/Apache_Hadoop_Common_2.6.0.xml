<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Mon Mar 30 15:27:52 PDT 2015 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="hadoop-core 2.6.0"
  jdversion="1.0.9">

<!--  Command line arguments =  -doclet org.apache.hadoop.classification.tools.ExcludePrivateAnnotationsJDiffDoclet -docletpath /Users/llu/hadoop-common/hadoop-common-project/hadoop-common/target/hadoop-annotations.jar:/Users/llu/hadoop-common/hadoop-common-project/hadoop-common/target/jdiff.jar -verbose -classpath /Users/llu/hadoop-common/hadoop-common-project/hadoop-common/target/classes:/Users/llu/hadoop-common/hadoop-common-project/hadoop-annotations/target/hadoop-annotations-2.6.0.jar:/Library/Java/JavaVirtualMachines/jdk1.7.0_67.jdk/Contents/Home/lib/tools.jar:/Users/llu/.m2/repository/com/google/guava/guava/11.0.2/guava-11.0.2.jar:/Users/llu/.m2/repository/commons-cli/commons-cli/1.2/commons-cli-1.2.jar:/Users/llu/.m2/repository/org/apache/commons/commons-math3/3.1.1/commons-math3-3.1.1.jar:/Users/llu/.m2/repository/xmlenc/xmlenc/0.52/xmlenc-0.52.jar:/Users/llu/.m2/repository/commons-httpclient/commons-httpclient/3.1/commons-httpclient-3.1.jar:/Users/llu/.m2/repository/commons-codec/commons-codec/1.4/commons-codec-1.4.jar:/Users/llu/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/Users/llu/.m2/repository/commons-net/commons-net/3.1/commons-net-3.1.jar:/Users/llu/.m2/repository/commons-collections/commons-collections/3.2.1/commons-collections-3.2.1.jar:/Users/llu/.m2/repository/javax/servlet/servlet-api/2.5/servlet-api-2.5.jar:/Users/llu/.m2/repository/org/mortbay/jetty/jetty/6.1.26/jetty-6.1.26.jar:/Users/llu/.m2/repository/org/mortbay/jetty/jetty-util/6.1.26/jetty-util-6.1.26.jar:/Users/llu/.m2/repository/com/sun/jersey/jersey-core/1.9/jersey-core-1.9.jar:/Users/llu/.m2/repository/com/sun/jersey/jersey-json/1.9/jersey-json-1.9.jar:/Users/llu/.m2/repository/org/codehaus/jettison/jettison/1.1/jettison-1.1.jar:/Users/llu/.m2/repository/com/sun/xml/bind/jaxb-impl/2.2.3-1/jaxb-impl-2.2.3-1.jar:/Users/llu/.m2/repository/javax/xml/bind/jaxb-api/2.2.2/jaxb-api-2.2.2.jar:/Users/llu/.m2/repository/javax/xml/stream/stax-api/1.0-2/stax-api-1.0-2.jar:/Users/llu/.m2/repository/javax/activation/activation/1.1/activation-1.1.jar:/Users/llu/.m2/repository/org/codehaus/jackson/jackson-jaxrs/1.9.13/jackson-jaxrs-1.9.13.jar:/Users/llu/.m2/repository/org/codehaus/jackson/jackson-xc/1.9.13/jackson-xc-1.9.13.jar:/Users/llu/.m2/repository/com/sun/jersey/jersey-server/1.9/jersey-server-1.9.jar:/Users/llu/.m2/repository/asm/asm/3.2/asm-3.2.jar:/Users/llu/.m2/repository/commons-logging/commons-logging/1.1.3/commons-logging-1.1.3.jar:/Users/llu/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar:/Users/llu/.m2/repository/net/java/dev/jets3t/jets3t/0.9.0/jets3t-0.9.0.jar:/Users/llu/.m2/repository/org/apache/httpcomponents/httpclient/4.2.5/httpclient-4.2.5.jar:/Users/llu/.m2/repository/org/apache/httpcomponents/httpcore/4.2.5/httpcore-4.2.5.jar:/Users/llu/.m2/repository/com/jamesmurty/utils/java-xmlbuilder/0.4/java-xmlbuilder-0.4.jar:/Users/llu/.m2/repository/commons-lang/commons-lang/2.6/commons-lang-2.6.jar:/Users/llu/.m2/repository/commons-configuration/commons-configuration/1.6/commons-configuration-1.6.jar:/Users/llu/.m2/repository/commons-digester/commons-digester/1.8/commons-digester-1.8.jar:/Users/llu/.m2/repository/commons-beanutils/commons-beanutils/1.7.0/commons-beanutils-1.7.0.jar:/Users/llu/.m2/repository/commons-beanutils/commons-beanutils-core/1.8.0/commons-beanutils-core-1.8.0.jar:/Users/llu/.m2/repository/org/slf4j/slf4j-api/1.7.5/slf4j-api-1.7.5.jar:/Users/llu/.m2/repository/org/codehaus/jackson/jackson-core-asl/1.9.13/jackson-core-asl-1.9.13.jar:/Users/llu/.m2/repository/org/codehaus/jackson/jackson-mapper-asl/1.9.13/jackson-mapper-asl-1.9.13.jar:/Users/llu/.m2/repository/org/apache/avro/avro/1.7.4/avro-1.7.4.jar:/Users/llu/.m2/repository/com/thoughtworks/paranamer/paranamer/2.3/paranamer-2.3.jar:/Users/llu/.m2/repository/org/xerial/snappy/snappy-java/1.0.4.1/snappy-java-1.0.4.1.jar:/Users/llu/.m2/repository/org/apache/ant/ant/1.8.1/ant-1.8.1.jar:/Users/llu/.m2/repository/org/apache/ant/ant-launcher/1.8.1/ant-launcher-1.8.1.jar:/Users/llu/.m2/repository/com/google/protobuf/protobuf-java/2.5.0/protobuf-java-2.5.0.jar:/Users/llu/.m2/repository/com/google/code/gson/gson/2.2.4/gson-2.2.4.jar:/Users/llu/hadoop-common/hadoop-common-project/hadoop-auth/target/hadoop-auth-2.6.0.jar:/Users/llu/.m2/repository/org/apache/directory/server/apacheds-kerberos-codec/2.0.0-M15/apacheds-kerberos-codec-2.0.0-M15.jar:/Users/llu/.m2/repository/org/apache/directory/server/apacheds-i18n/2.0.0-M15/apacheds-i18n-2.0.0-M15.jar:/Users/llu/.m2/repository/org/apache/directory/api/api-asn1-api/1.0.0-M20/api-asn1-api-1.0.0-M20.jar:/Users/llu/.m2/repository/org/apache/directory/api/api-util/1.0.0-M20/api-util-1.0.0-M20.jar:/Users/llu/.m2/repository/org/apache/curator/curator-framework/2.6.0/curator-framework-2.6.0.jar:/Users/llu/.m2/repository/com/jcraft/jsch/0.1.42/jsch-0.1.42.jar:/Users/llu/.m2/repository/org/apache/curator/curator-client/2.6.0/curator-client-2.6.0.jar:/Users/llu/.m2/repository/org/apache/curator/curator-recipes/2.6.0/curator-recipes-2.6.0.jar:/Users/llu/.m2/repository/com/google/code/findbugs/jsr305/1.3.9/jsr305-1.3.9.jar:/Users/llu/.m2/repository/org/htrace/htrace-core/3.0.4/htrace-core-3.0.4.jar:/Users/llu/.m2/repository/org/apache/zookeeper/zookeeper/3.4.6/zookeeper-3.4.6.jar:/Users/llu/.m2/repository/io/netty/netty/3.6.2.Final/netty-3.6.2.Final.jar:/Users/llu/.m2/repository/org/apache/commons/commons-compress/1.4.1/commons-compress-1.4.1.jar:/Users/llu/.m2/repository/org/tukaani/xz/1.0/xz-1.0.jar -sourcepath /Users/llu/hadoop-common/hadoop-common-project/hadoop-common/src/main/java -apidir /Users/llu/hadoop-common/hadoop-common-project/hadoop-common/target/site/jdiff/xml -apiname hadoop-core 2.6.0 -->
<package name="org.apache.hadoop">
  <!-- start class org.apache.hadoop.HadoopIllegalArgumentException -->
  <class name="HadoopIllegalArgumentException" extends="java.lang.IllegalArgumentException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HadoopIllegalArgumentException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs exception with the specified detail message. 
 @param message detailed message.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Indicates that a method has been passed illegal or invalid argument. This
 exception is thrown instead of IllegalArgumentException to differentiate the
 exception thrown in Hadoop implementation from the one thrown in JDK.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.HadoopIllegalArgumentException -->
</package>
<package name="org.apache.hadoop.conf">
  <!-- start interface org.apache.hadoop.conf.Configurable -->
  <interface name="Configurable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Set the configuration to be used by this object.]]>
      </doc>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the configuration used by this object.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Something that may be configured with a {@link Configuration}.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.conf.Configurable -->
  <!-- start class org.apache.hadoop.conf.Configuration -->
  <class name="Configuration" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Iterable"/>
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A new configuration.]]>
      </doc>
    </constructor>
    <constructor name="Configuration" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A new configuration where the behavior of reading from the default 
 resources can be turned off.
 
 If the parameter {@code loadDefaults} is false, the new instance
 will not load resources from the default files. 
 @param loadDefaults specifies whether to load from the default files]]>
      </doc>
    </constructor>
    <constructor name="Configuration" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A new configuration with the same settings cloned from another.
 
 @param other the configuration from which to clone settings.]]>
      </doc>
    </constructor>
    <method name="addDeprecations"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deltas" type="org.apache.hadoop.conf.Configuration.DeprecationDelta[]"/>
      <doc>
      <![CDATA[Adds a set of deprecated keys to the global deprecations.

 This method is lockless.  It works by means of creating a new
 DeprecationContext based on the old one, and then atomically swapping in
 the new context.  If someone else updated the context in between us reading
 the old context and swapping in the new one, we try again until we win the
 race.

 @param deltas   The deprecations to add.]]>
      </doc>
    </method>
    <method name="addDeprecation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use {@link #addDeprecation(String key, String newKey,
      String customMessage)} instead">
      <param name="key" type="java.lang.String"/>
      <param name="newKeys" type="java.lang.String[]"/>
      <param name="customMessage" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds the deprecated key to the global deprecation map.
 It does not override any existing entries in the deprecation map.
 This is to be used only by the developers in order to add deprecation of
 keys, and attempts to call this method after loading resources once,
 would lead to <tt>UnsupportedOperationException</tt>
 
 If a key is deprecated in favor of multiple keys, they are all treated as 
 aliases of each other, and setting any one of them resets all the others 
 to the new value.

 If you have multiple deprecation entries to add, it is more efficient to
 use #addDeprecations(DeprecationDelta[] deltas) instead.
 
 @param key
 @param newKeys
 @param customMessage
 @deprecated use {@link #addDeprecation(String key, String newKey,
      String customMessage)} instead]]>
      </doc>
    </method>
    <method name="addDeprecation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="newKey" type="java.lang.String"/>
      <param name="customMessage" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds the deprecated key to the global deprecation map.
 It does not override any existing entries in the deprecation map.
 This is to be used only by the developers in order to add deprecation of
 keys, and attempts to call this method after loading resources once,
 would lead to <tt>UnsupportedOperationException</tt>
 
 If you have multiple deprecation entries to add, it is more efficient to
 use #addDeprecations(DeprecationDelta[] deltas) instead.

 @param key
 @param newKey
 @param customMessage]]>
      </doc>
    </method>
    <method name="addDeprecation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use {@link #addDeprecation(String key, String newKey)} instead">
      <param name="key" type="java.lang.String"/>
      <param name="newKeys" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Adds the deprecated key to the global deprecation map when no custom
 message is provided.
 It does not override any existing entries in the deprecation map.
 This is to be used only by the developers in order to add deprecation of
 keys, and attempts to call this method after loading resources once,
 would lead to <tt>UnsupportedOperationException</tt>
 
 If a key is deprecated in favor of multiple keys, they are all treated as 
 aliases of each other, and setting any one of them resets all the others 
 to the new value.
 
 If you have multiple deprecation entries to add, it is more efficient to
 use #addDeprecations(DeprecationDelta[] deltas) instead.

 @param key Key that is to be deprecated
 @param newKeys list of keys that take up the values of deprecated key
 @deprecated use {@link #addDeprecation(String key, String newKey)} instead]]>
      </doc>
    </method>
    <method name="addDeprecation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="newKey" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds the deprecated key to the global deprecation map when no custom
 message is provided.
 It does not override any existing entries in the deprecation map.
 This is to be used only by the developers in order to add deprecation of
 keys, and attempts to call this method after loading resources once,
 would lead to <tt>UnsupportedOperationException</tt>
 
 If you have multiple deprecation entries to add, it is more efficient to
 use #addDeprecations(DeprecationDelta[] deltas) instead.

 @param key Key that is to be deprecated
 @param newKey key that takes up the value of deprecated key]]>
      </doc>
    </method>
    <method name="isDeprecated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[checks whether the given <code>key</code> is deprecated.
 
 @param key the parameter which is to be checked for deprecation
 @return <code>true</code> if the key is deprecated and 
         <code>false</code> otherwise.]]>
      </doc>
    </method>
    <method name="setDeprecatedProperties"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sets all deprecated properties that are not currently set but have a
 corresponding new property that is set. Useful for iterating the
 properties when all deprecated properties for currently set properties
 need to be present.]]>
      </doc>
    </method>
    <method name="addDefaultResource"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a default resource. Resources are loaded in the order of the resources 
 added.
 @param name file name. File should be present in the classpath.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 @param name resource to be added, the classpath is examined for a file 
             with that name.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 @param url url of the resource to be added, the local filesystem is 
            examined directly to find the resource, without referring to 
            the classpath.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 @param file file-path of resource to be added, the local filesystem is
             examined directly to find the resource, without referring to 
             the classpath.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 WARNING: The contents of the InputStream will be cached, by this method. 
 So use this sparingly because it does increase the memory consumption.
 
 @param in InputStream to deserialize the object from. In will be read from
 when a get or set is called next.  After it is read the stream will be
 closed.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 @param in InputStream to deserialize the object from.
 @param name the name of the resource because InputStream.toString is not
 very descriptive some times.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Add a configuration resource.

 The properties of this resource will override properties of previously
 added resources, unless they were marked <a href="#Final">final</a>.

 @param conf Configuration object from which to load properties]]>
      </doc>
    </method>
    <method name="reloadConfiguration"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reload configuration from previously added resources.

 This method will clear all the configuration read from the added 
 resources, and final parameters. This will make the resources to 
 be read again before accessing the values. Values that are added
 via set methods will overlay values read from the resources.]]>
      </doc>
    </method>
    <method name="get" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property, <code>null</code> if
 no such property exists. If the key is deprecated, it returns the value of
 the first key which replaces the deprecated key and is not null.
 
 Values are processed for <a href="#VariableExpansion">variable expansion</a> 
 before being returned. 
 
 @param name the property name, will be trimmed before get value.
 @return the value of the <code>name</code> or its replacing property, 
         or null if no such property exists.]]>
      </doc>
    </method>
    <method name="getTrimmed" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a trimmed <code>String</code>, 
 <code>null</code> if no such property exists. 
 If the key is deprecated, it returns the value of
 the first key which replaces the deprecated key and is not null
 
 Values are processed for <a href="#VariableExpansion">variable expansion</a> 
 before being returned. 
 
 @param name the property name.
 @return the value of the <code>name</code> or its replacing property, 
         or null if no such property exists.]]>
      </doc>
    </method>
    <method name="getTrimmed" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a trimmed <code>String</code>, 
 <code>defaultValue</code> if no such property exists. 
 See @{Configuration#getTrimmed} for more details.
 
 @param name          the property name.
 @param defaultValue  the property default value.
 @return              the value of the <code>name</code> or defaultValue
                      if it is not set.]]>
      </doc>
    </method>
    <method name="getRaw" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property, without doing
 <a href="#VariableExpansion">variable expansion</a>.If the key is 
 deprecated, it returns the value of the first key which replaces 
 the deprecated key and is not null.
 
 @param name the property name.
 @return the value of the <code>name</code> property or 
         its replacing property and null if no such property exists.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the <code>value</code> of the <code>name</code> property. If 
 <code>name</code> is deprecated or there is a deprecated name associated to it,
 it sets the value to both names. Name will be trimmed before put into
 configuration.
 
 @param name property name.
 @param value property value.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <param name="source" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the <code>value</code> of the <code>name</code> property. If 
 <code>name</code> is deprecated, it also sets the <code>value</code> to
 the keys that replace the deprecated key. Name will be trimmed before put
 into configuration.

 @param name property name.
 @param value property value.
 @param source the place that this configuration value came from 
 (For debugging).
 @throws IllegalArgumentException when the value or name is null.]]>
      </doc>
    </method>
    <method name="unset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Unset a previously set property.]]>
      </doc>
    </method>
    <method name="setIfUnset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets a property if it is currently unset.
 @param name the property name
 @param value the new value]]>
      </doc>
    </method>
    <method name="get" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code>. If the key is deprecated,
 it returns the value of the first key which replaces the deprecated key
 and is not null.
 If no such property exists,
 then <code>defaultValue</code> is returned.
 
 @param name property name, will be trimmed before get value.
 @param defaultValue default value.
 @return property value, or <code>defaultValue</code> if the property 
         doesn't exist.]]>
      </doc>
    </method>
    <method name="getInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="int"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as an <code>int</code>.
   
 If no such property exists, the provided default value is returned,
 or if the specified value is not a valid <code>int</code>,
 then an error is thrown.
 
 @param name property name.
 @param defaultValue default value.
 @throws NumberFormatException when the value is invalid
 @return property value as an <code>int</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getInts" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a set of comma-delimited
 <code>int</code> values.
 
 If no such property exists, an empty array is returned.
 
 @param name property name
 @return property value interpreted as an array of comma-delimited
         <code>int</code> values]]>
      </doc>
    </method>
    <method name="setInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to an <code>int</code>.
 
 @param name property name.
 @param value <code>int</code> value of the property.]]>
      </doc>
    </method>
    <method name="getLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="long"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>long</code>.  
 If no such property exists, the provided default value is returned,
 or if the specified value is not a valid <code>long</code>,
 then an error is thrown.
 
 @param name property name.
 @param defaultValue default value.
 @throws NumberFormatException when the value is invalid
 @return property value as a <code>long</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getLongBytes" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="long"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>long</code> or
 human readable format. If no such property exists, the provided default
 value is returned, or if the specified value is not a valid
 <code>long</code> or human readable format, then an error is thrown. You
 can use the following suffix (case insensitive): k(kilo), m(mega), g(giga),
 t(tera), p(peta), e(exa)

 @param name property name.
 @param defaultValue default value.
 @throws NumberFormatException when the value is invalid
 @return property value as a <code>long</code>,
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to a <code>long</code>.
 
 @param name property name.
 @param value <code>long</code> value of the property.]]>
      </doc>
    </method>
    <method name="getFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="float"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>float</code>.  
 If no such property exists, the provided default value is returned,
 or if the specified value is not a valid <code>float</code>,
 then an error is thrown.

 @param name property name.
 @param defaultValue default value.
 @throws NumberFormatException when the value is invalid
 @return property value as a <code>float</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to a <code>float</code>.
 
 @param name property name.
 @param value property value.]]>
      </doc>
    </method>
    <method name="getDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="double"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>double</code>.  
 If no such property exists, the provided default value is returned,
 or if the specified value is not a valid <code>double</code>,
 then an error is thrown.

 @param name property name.
 @param defaultValue default value.
 @throws NumberFormatException when the value is invalid
 @return property value as a <code>double</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setDouble"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to a <code>double</code>.
 
 @param name property name.
 @param value property value.]]>
      </doc>
    </method>
    <method name="getBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="boolean"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>boolean</code>.  
 If no such property is specified, or if the specified value is not a valid
 <code>boolean</code>, then <code>defaultValue</code> is returned.
 
 @param name property name.
 @param defaultValue default value.
 @return property value as a <code>boolean</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setBoolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to a <code>boolean</code>.
 
 @param name property name.
 @param value <code>boolean</code> value of the property.]]>
      </doc>
    </method>
    <method name="setBooleanIfUnset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Set the given property, if it is currently unset.
 @param name property name
 @param value new value]]>
      </doc>
    </method>
    <method name="setEnum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="T"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to the given type. This
 is equivalent to <code>set(&lt;name&gt;, value.toString())</code>.
 @param name property name
 @param value new value]]>
      </doc>
    </method>
    <method name="getEnum" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Return value matching this enumerated type.
 @param name Property name
 @param defaultValue Value returned if no mapping exists
 @throws IllegalArgumentException If mapping is illegal for the type
 provided]]>
      </doc>
    </method>
    <method name="setTimeDuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Set the value of <code>name</code> to the given time duration. This
 is equivalent to <code>set(&lt;name&gt;, value + &lt;time suffix&gt;)</code>.
 @param name Property name
 @param value Time duration
 @param unit Unit of time]]>
      </doc>
    </method>
    <method name="getTimeDuration" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Return time duration in the given time unit. Valid units are encoded in
 properties as suffixes: nanoseconds (ns), microseconds (us), milliseconds
 (ms), seconds (s), minutes (m), hours (h), and days (d).
 @param name Property name
 @param defaultValue Value returned if no mapping exists.
 @param unit Unit to convert the stored property, if it exists.
 @throws NumberFormatException If the property stripped of its unit is not
         a number]]>
      </doc>
    </method>
    <method name="getPattern" return="java.util.regex.Pattern"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.util.regex.Pattern"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>Pattern</code>.
 If no such property is specified, or if the specified value is not a valid
 <code>Pattern</code>, then <code>DefaultValue</code> is returned.

 @param name property name
 @param defaultValue default value
 @return property value as a compiled Pattern, or defaultValue]]>
      </doc>
    </method>
    <method name="setPattern"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="pattern" type="java.util.regex.Pattern"/>
      <doc>
      <![CDATA[Set the given property to <code>Pattern</code>.
 If the pattern is passed as null, sets the empty pattern which results in
 further calls to getPattern(...) returning the default value.

 @param name property name
 @param pattern new value]]>
      </doc>
    </method>
    <method name="getPropertySources" return="java.lang.String[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets information about why a property was set.  Typically this is the 
 path to the resource objects (file, URL, etc.) the property came from, but
 it can also indicate that it was set programatically, or because of the
 command line.

 @param name - The property name to get the source of.
 @return null - If the property or its source wasn't found. Otherwise, 
 returns a list of the sources of the resource.  The older sources are
 the first ones in the list.  So for example if a configuration is set from
 the command line, and then written out to a file that is read back in the
 first entry would indicate that it was set from the command line, while
 the second one would indicate the file that the new configuration was read
 in from.]]>
      </doc>
    </method>
    <method name="getRange" return="org.apache.hadoop.conf.Configuration.IntegerRanges"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Parse the given attribute as a set of integer ranges
 @param name the attribute name
 @param defaultValue the default value if it is not set
 @return a new set of ranges from the configured value]]>
      </doc>
    </method>
    <method name="getStringCollection" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 a collection of <code>String</code>s.  
 If no such property is specified then empty collection is returned.
 <p>
 This is an optimized version of {@link #getStrings(String)}
 
 @param name property name.
 @return property value as a collection of <code>String</code>s.]]>
      </doc>
    </method>
    <method name="getStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 an array of <code>String</code>s.  
 If no such property is specified then <code>null</code> is returned.
 
 @param name property name.
 @return property value as an array of <code>String</code>s, 
         or <code>null</code>.]]>
      </doc>
    </method>
    <method name="getStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 an array of <code>String</code>s.  
 If no such property is specified then default value is returned.
 
 @param name property name.
 @param defaultValue The default value
 @return property value as an array of <code>String</code>s, 
         or default value.]]>
      </doc>
    </method>
    <method name="getTrimmedStringCollection" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 a collection of <code>String</code>s, trimmed of the leading and trailing whitespace.  
 If no such property is specified then empty <code>Collection</code> is returned.

 @param name property name.
 @return property value as a collection of <code>String</code>s, or empty <code>Collection</code>]]>
      </doc>
    </method>
    <method name="getTrimmedStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 an array of <code>String</code>s, trimmed of the leading and trailing whitespace.
 If no such property is specified then an empty array is returned.
 
 @param name property name.
 @return property value as an array of trimmed <code>String</code>s, 
         or empty array.]]>
      </doc>
    </method>
    <method name="getTrimmedStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 an array of <code>String</code>s, trimmed of the leading and trailing whitespace.
 If no such property is specified then default value is returned.
 
 @param name property name.
 @param defaultValue The default value
 @return property value as an array of trimmed <code>String</code>s, 
         or default value.]]>
      </doc>
    </method>
    <method name="setStrings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="values" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Set the array of string values for the <code>name</code> property as 
 as comma delimited values.  
 
 @param name property name.
 @param values The values]]>
      </doc>
    </method>
    <method name="getPassword" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the value for a known password configuration element.
 In order to enable the elimination of clear text passwords in config,
 this method attempts to resolve the property name as an alias through
 the CredentialProvider API and conditionally fallsback to config.
 @param name property name
 @return password]]>
      </doc>
    </method>
    <method name="getPasswordFromCredentialProviders" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Try and resolve the provided element name as a credential provider
 alias.
 @param name alias of the provisioned credential
 @return password or null if not found
 @throws IOException]]>
      </doc>
    </method>
    <method name="getPasswordFromConfig" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Fallback to clear text passwords in configuration.
 @param name
 @return clear text password or null]]>
      </doc>
    </method>
    <method name="getSocketAddr" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hostProperty" type="java.lang.String"/>
      <param name="addressProperty" type="java.lang.String"/>
      <param name="defaultAddressValue" type="java.lang.String"/>
      <param name="defaultPort" type="int"/>
      <doc>
      <![CDATA[Get the socket address for <code>hostProperty</code> as a
 <code>InetSocketAddress</code>. If <code>hostProperty</code> is
 <code>null</code>, <code>addressProperty</code> will be used. This
 is useful for cases where we want to differentiate between host
 bind address and address clients should use to establish connection.

 @param hostProperty bind host property name.
 @param addressProperty address property name.
 @param defaultAddressValue the default value
 @param defaultPort the default port
 @return InetSocketAddress]]>
      </doc>
    </method>
    <method name="getSocketAddr" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultAddress" type="java.lang.String"/>
      <param name="defaultPort" type="int"/>
      <doc>
      <![CDATA[Get the socket address for <code>name</code> property as a
 <code>InetSocketAddress</code>.
 @param name property name.
 @param defaultAddress the default value
 @param defaultPort the default port
 @return InetSocketAddress]]>
      </doc>
    </method>
    <method name="setSocketAddr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="addr" type="java.net.InetSocketAddress"/>
      <doc>
      <![CDATA[Set the socket address for the <code>name</code> property as
 a <code>host:port</code>.]]>
      </doc>
    </method>
    <method name="updateConnectAddr" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hostProperty" type="java.lang.String"/>
      <param name="addressProperty" type="java.lang.String"/>
      <param name="defaultAddressValue" type="java.lang.String"/>
      <param name="addr" type="java.net.InetSocketAddress"/>
      <doc>
      <![CDATA[Set the socket address a client can use to connect for the
 <code>name</code> property as a <code>host:port</code>.  The wildcard
 address is replaced with the local host's address. If the host and address
 properties are configured the host component of the address will be combined
 with the port component of the addr to generate the address.  This is to allow
 optional control over which host name is used in multi-home bind-host
 cases where a host can have multiple names
 @param hostProperty the bind-host configuration name
 @param addressProperty the service address configuration name
 @param defaultAddressValue the service default address configuration value
 @param addr InetSocketAddress of the service listener
 @return InetSocketAddress for clients to connect]]>
      </doc>
    </method>
    <method name="updateConnectAddr" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="addr" type="java.net.InetSocketAddress"/>
      <doc>
      <![CDATA[Set the socket address a client can use to connect for the
 <code>name</code> property as a <code>host:port</code>.  The wildcard
 address is replaced with the local host's address.
 @param name property name.
 @param addr InetSocketAddress of a listener to store in the given property
 @return InetSocketAddress for clients to connect]]>
      </doc>
    </method>
    <method name="getClassByName" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
      <doc>
      <![CDATA[Load a class by name.
 
 @param name the class name.
 @return the class object.
 @throws ClassNotFoundException if the class is not found.]]>
      </doc>
    </method>
    <method name="getClassByNameOrNull" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Load a class by name, returning null rather than throwing an exception
 if it couldn't be loaded. This is to avoid the overhead of creating
 an exception.
 
 @param name the class name
 @return the class object, or null if it could not be found.]]>
      </doc>
    </method>
    <method name="getClasses" return="java.lang.Class[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property
 as an array of <code>Class</code>.
 The value of the property specifies a list of comma separated class names.  
 If no such property is specified, then <code>defaultValue</code> is 
 returned.
 
 @param name the property name.
 @param defaultValue default value.
 @return property value as a <code>Class[]</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.Class"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>Class</code>.  
 If no such property is specified, then <code>defaultValue</code> is 
 returned.
 
 @param name the class name.
 @param defaultValue default value.
 @return property value as a <code>Class</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.Class"/>
      <param name="xface" type="java.lang.Class"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>Class</code>
 implementing the interface specified by <code>xface</code>.
   
 If no such property is specified, then <code>defaultValue</code> is 
 returned.
 
 An exception is thrown if the returned class does not implement the named
 interface. 
 
 @param name the class name.
 @param defaultValue default value.
 @param xface the interface implemented by the named class.
 @return property value as a <code>Class</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getInstances" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="xface" type="java.lang.Class"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>List</code>
 of objects implementing the interface specified by <code>xface</code>.
 
 An exception is thrown if any of the classes does not exist, or if it does
 not implement the named interface.
 
 @param name the property name.
 @param xface the interface implemented by the classes named by
        <code>name</code>.
 @return a <code>List</code> of objects implementing <code>xface</code>.]]>
      </doc>
    </method>
    <method name="setClass"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="theClass" type="java.lang.Class"/>
      <param name="xface" type="java.lang.Class"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to the name of a 
 <code>theClass</code> implementing the given interface <code>xface</code>.
 
 An exception is thrown if <code>theClass</code> does not implement the 
 interface <code>xface</code>. 
 
 @param name property name.
 @param theClass property value.
 @param xface the interface implemented by the named class.]]>
      </doc>
    </method>
    <method name="getLocalPath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dirsProp" type="java.lang.String"/>
      <param name="path" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a local file under a directory named by <i>dirsProp</i> with
 the given <i>path</i>.  If <i>dirsProp</i> contains multiple directories,
 then one is chosen based on <i>path</i>'s hash code.  If the selected
 directory does not exist, an attempt is made to create it.
 
 @param dirsProp directory in which to locate the file.
 @param path file-path.
 @return local file under the directory with the given path.]]>
      </doc>
    </method>
    <method name="getFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dirsProp" type="java.lang.String"/>
      <param name="path" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a local file name under a directory named in <i>dirsProp</i> with
 the given <i>path</i>.  If <i>dirsProp</i> contains multiple directories,
 then one is chosen based on <i>path</i>'s hash code.  If the selected
 directory does not exist, an attempt is made to create it.
 
 @param dirsProp directory in which to locate the file.
 @param path file-path.
 @return local file under the directory with the given path.]]>
      </doc>
    </method>
    <method name="getResource" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the {@link URL} for the named resource.
 
 @param name resource name.
 @return the url for the named resource.]]>
      </doc>
    </method>
    <method name="getConfResourceAsInputStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get an input stream attached to the configuration resource with the
 given <code>name</code>.
 
 @param name configuration resource name.
 @return an input stream attached to the resource.]]>
      </doc>
    </method>
    <method name="getConfResourceAsReader" return="java.io.Reader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a {@link Reader} attached to the configuration resource with the
 given <code>name</code>.
 
 @param name configuration resource name.
 @return a reader attached to the resource.]]>
      </doc>
    </method>
    <method name="getFinalParameters" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the set of parameters marked final.

 @return final parameter set.]]>
      </doc>
    </method>
    <method name="getProps" return="java.util.Properties"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the number of keys in the configuration.

 @return number of keys in the configuration.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears all keys from the configuration.]]>
      </doc>
    </method>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an {@link Iterator} to go through the list of <code>String</code> 
 key-value pairs in the configuration.
 
 @return an iterator over the entries.]]>
      </doc>
    </method>
    <method name="writeXml"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write out the non-default properties in this configuration to the given
 {@link OutputStream} using UTF-8 encoding.
 
 @param out the output stream to write to.]]>
      </doc>
    </method>
    <method name="writeXml"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write out the non-default properties in this configuration to the given
 {@link Writer}.
 
 @param out the writer to write to.]]>
      </doc>
    </method>
    <method name="dumpConfiguration"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="org.apache.hadoop.conf.Configuration"/>
      <param name="out" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes out all the parameters and their properties (final and resource) to
  the given {@link Writer}
  The format of the output would be 
  { "properties" : [ {key1,value1,key1.isFinal,key1.resource}, {key2,value2,
  key2.isFinal,key2.resource}... ] } 
  It does not output the parameters of the configuration object which is 
  loaded from an input stream.
 @param out the Writer to write to
 @throws IOException]]>
      </doc>
    </method>
    <method name="getClassLoader" return="java.lang.ClassLoader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link ClassLoader} for this job.
 
 @return the correct class loader.]]>
      </doc>
    </method>
    <method name="setClassLoader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classLoader" type="java.lang.ClassLoader"/>
      <doc>
      <![CDATA[Set the class loader that will be used to load the various objects.
 
 @param classLoader the new class loader.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setQuietMode"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="quietmode" type="boolean"/>
      <doc>
      <![CDATA[Set the quietness-mode. 
 
 In the quiet-mode, error and informational messages might not be logged.
 
 @param quietmode <code>true</code> to set quiet-mode on, <code>false</code>
              to turn it off.]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[For debugging.  List non-default properties to the terminal and exit.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getValByRegex" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="regex" type="java.lang.String"/>
      <doc>
      <![CDATA[get keys matching the the regex 
 @param regex
 @return Map<String,String> with matching keys]]>
      </doc>
    </method>
    <method name="dumpDeprecatedKeys"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasWarnedDeprecation" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns whether or not a deprecated name has been warned. If the name is not
 deprecated then always return false]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides access to configuration parameters.

 <h4 id="Resources">Resources</h4>

 <p>Configurations are specified by resources. A resource contains a set of
 name/value pairs as XML data. Each resource is named by either a 
 <code>String</code> or by a {@link Path}. If named by a <code>String</code>, 
 then the classpath is examined for a file with that name.  If named by a 
 <code>Path</code>, then the local filesystem is examined directly, without 
 referring to the classpath.

 <p>Unless explicitly turned off, Hadoop by default specifies two 
 resources, loaded in-order from the classpath: <ol>
 <li><tt>
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a></tt>: Read-only defaults for hadoop.</li>
 <li><tt>core-site.xml</tt>: Site-specific configuration for a given hadoop
 installation.</li>
 </ol>
 Applications may add additional resources, which are loaded
 subsequent to these resources in the order they are added.
 
 <h4 id="FinalParams">Final Parameters</h4>

 <p>Configuration parameters may be declared <i>final</i>. 
 Once a resource declares a value final, no subsequently-loaded 
 resource can alter that value.  
 For example, one might define a final parameter with:
 <tt><pre>
  &lt;property&gt;
    &lt;name&gt;dfs.hosts.include&lt;/name&gt;
    &lt;value&gt;/etc/hadoop/conf/hosts.include&lt;/value&gt;
    <b>&lt;final&gt;true&lt;/final&gt;</b>
  &lt;/property&gt;</pre></tt>

 Administrators typically define parameters as final in 
 <tt>core-site.xml</tt> for values that user applications may not alter.

 <h4 id="VariableExpansion">Variable Expansion</h4>

 <p>Value strings are first processed for <i>variable expansion</i>. The
 available properties are:<ol>
 <li>Other properties defined in this Configuration; and, if a name is
 undefined here,</li>
 <li>Properties in {@link System#getProperties()}.</li>
 </ol>

 <p>For example, if a configuration resource contains the following property
 definitions: 
 <tt><pre>
  &lt;property&gt;
    &lt;name&gt;basedir&lt;/name&gt;
    &lt;value&gt;/user/${<i>user.name</i>}&lt;/value&gt;
  &lt;/property&gt;
  
  &lt;property&gt;
    &lt;name&gt;tempdir&lt;/name&gt;
    &lt;value&gt;${<i>basedir</i>}/tmp&lt;/value&gt;
  &lt;/property&gt;</pre></tt>

 When <tt>conf.get("tempdir")</tt> is called, then <tt>${<i>basedir</i>}</tt>
 will be resolved to another property in this Configuration, while
 <tt>${<i>user.name</i>}</tt> would then ordinarily be resolved to the value
 of the System property with that name.
 By default, warnings will be given to any deprecated configuration 
 parameters and these are suppressible by configuring
 <tt>log4j.logger.org.apache.hadoop.conf.Configuration.deprecation</tt> in
 log4j.properties file.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.Configuration -->
  <!-- start class org.apache.hadoop.conf.Configuration.DeprecationDelta -->
  <class name="Configuration.DeprecationDelta" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Configuration.DeprecationDelta" type="java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Configuration.DeprecationDelta" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKey" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNewKeys" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCustomMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A pending addition to the global set of deprecated keys.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.Configuration.DeprecationDelta -->
  <!-- start class org.apache.hadoop.conf.Configuration.IntegerRanges -->
  <class name="Configuration.IntegerRanges" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Iterable"/>
    <constructor name="Configuration.IntegerRanges"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Configuration.IntegerRanges" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isIncluded" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Is the given value in the set of ranges
 @param value the value to check
 @return is the value in the ranges?]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return true if there are no values in this range, else false.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A class that represents a set of positive integer ranges. It parses 
 strings of the form: "2-3,5,7-" where ranges are separated by comma and 
 the lower/upper bounds are separated by dash. Either the lower or upper 
 bound may be omitted meaning all values up to or over. So the string 
 above means 2, 3, 5, and 7, 8, 9, ...]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.Configuration.IntegerRanges -->
  <!-- start class org.apache.hadoop.conf.Configured -->
  <class name="Configured" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="Configured"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a Configured.]]>
      </doc>
    </constructor>
    <constructor name="Configured" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a Configured.]]>
      </doc>
    </constructor>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Base class for things that may be configured with a {@link Configuration}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.Configured -->
  <!-- start class org.apache.hadoop.conf.ConfServlet.BadFormatException -->
  <class name="ConfServlet.BadFormatException" extends="java.lang.Exception"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConfServlet.BadFormatException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.conf.ConfServlet.BadFormatException -->
  <!-- start interface org.apache.hadoop.conf.Reconfigurable -->
  <interface name="Reconfigurable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <method name="reconfigureProperty" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="property" type="java.lang.String"/>
      <param name="newVal" type="java.lang.String"/>
      <exception name="ReconfigurationException" type="org.apache.hadoop.conf.ReconfigurationException"/>
      <doc>
      <![CDATA[Change a configuration property on this object to the value specified.

 Change a configuration property on this object to the value specified 
 and return the previous value that the configuration property was set to
 (or null if it was not previously set). If newVal is null, set the property
 to its default value;

 If the property cannot be changed, throw a 
 {@link ReconfigurationException}.]]>
      </doc>
    </method>
    <method name="isPropertyReconfigurable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="property" type="java.lang.String"/>
      <doc>
      <![CDATA[Return whether a given property is changeable at run time.

 If isPropertyReconfigurable returns true for a property,
 then changeConf should not throw an exception when changing
 this property.]]>
      </doc>
    </method>
    <method name="getReconfigurableProperties" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return all the properties that can be changed at run time.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Something whose {@link Configuration} can be changed at run time.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.conf.Reconfigurable -->
  <!-- start class org.apache.hadoop.conf.ReconfigurableBase -->
  <class name="ReconfigurableBase" extends="org.apache.hadoop.conf.Configured"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Reconfigurable"/>
    <constructor name="ReconfigurableBase"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a ReconfigurableBase.]]>
      </doc>
    </constructor>
    <constructor name="ReconfigurableBase" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a ReconfigurableBase with the {@link Configuration}
 conf.]]>
      </doc>
    </constructor>
    <method name="setReconfigurationUtil"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ru" type="org.apache.hadoop.conf.ReconfigurationUtil"/>
    </method>
    <method name="getChangedProperties" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newConf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="oldConf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="startReconfigurationTask"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Start a reconfiguration task to reload configuration in background.]]>
      </doc>
    </method>
    <method name="getReconfigurationTaskStatus" return="org.apache.hadoop.conf.ReconfigurationTaskStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="shutdownReconfigurationTask"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reconfigureProperty" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="property" type="java.lang.String"/>
      <param name="newVal" type="java.lang.String"/>
      <exception name="ReconfigurationException" type="org.apache.hadoop.conf.ReconfigurationException"/>
      <doc>
      <![CDATA[{@inheritDoc}

 This method makes the change to this objects {@link Configuration}
 and calls reconfigurePropertyImpl to update internal data structures.
 This method cannot be overridden, subclasses should instead override
 reconfigureProperty.]]>
      </doc>
    </method>
    <method name="getReconfigurableProperties" return="java.util.Collection"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}

 Subclasses must override this.]]>
      </doc>
    </method>
    <method name="isPropertyReconfigurable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="property" type="java.lang.String"/>
      <doc>
      <![CDATA[{@inheritDoc}

 Subclasses may wish to override this with a more efficient implementation.]]>
      </doc>
    </method>
    <method name="reconfigurePropertyImpl"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="property" type="java.lang.String"/>
      <param name="newVal" type="java.lang.String"/>
      <exception name="ReconfigurationException" type="org.apache.hadoop.conf.ReconfigurationException"/>
      <doc>
      <![CDATA[Change a configuration property.

 Subclasses must override this. This method applies the change to
 all internal data structures derived from the configuration property
 that is being changed. If this object owns other Reconfigurable objects
 reconfigureProperty should be called recursively to make sure that
 to make sure that the configuration of these objects is updated.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility base class for implementing the Reconfigurable interface.

 Subclasses should override reconfigurePropertyImpl to change individual
 properties and getReconfigurableProperties to get all properties that
 can be changed at run time.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.ReconfigurableBase -->
  <!-- start class org.apache.hadoop.conf.ReconfigurationException -->
  <class name="ReconfigurationException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ReconfigurationException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new instance of {@link ReconfigurationException}.]]>
      </doc>
    </constructor>
    <constructor name="ReconfigurationException" type="java.lang.String, java.lang.String, java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new instance of {@link ReconfigurationException}.]]>
      </doc>
    </constructor>
    <constructor name="ReconfigurationException" type="java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new instance of {@link ReconfigurationException}.]]>
      </doc>
    </constructor>
    <method name="getProperty" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get property that cannot be changed.]]>
      </doc>
    </method>
    <method name="getNewValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get value to which property was supposed to be changed.]]>
      </doc>
    </method>
    <method name="getOldValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get old value of property that cannot be changed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Exception indicating that configuration property cannot be changed
 at run time.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.ReconfigurationException -->
  <!-- start class org.apache.hadoop.conf.ReconfigurationServlet -->
  <class name="ReconfigurationServlet" extends="javax.servlet.http.HttpServlet"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ReconfigurationServlet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ServletException" type="javax.servlet.ServletException"/>
    </method>
    <method name="doGet"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="req" type="javax.servlet.http.HttpServletRequest"/>
      <param name="resp" type="javax.servlet.http.HttpServletResponse"/>
      <exception name="ServletException" type="javax.servlet.ServletException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="doPost"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="req" type="javax.servlet.http.HttpServletRequest"/>
      <param name="resp" type="javax.servlet.http.HttpServletResponse"/>
      <exception name="ServletException" type="javax.servlet.ServletException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="CONF_SERVLET_RECONFIGURABLE_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A servlet for changing a node's configuration.

 Reloads the configuration file, verifies whether changes are
 possible and asks the admin to approve the change.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.ReconfigurationServlet -->
  <!-- start class org.apache.hadoop.conf.ReconfigurationTaskStatus -->
  <class name="ReconfigurationTaskStatus" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ReconfigurationTaskStatus" type="long, long, java.util.Map"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="hasTask" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return true if
   - A reconfiguration task has finished or
   - an active reconfiguration task is running]]>
      </doc>
    </method>
    <method name="stopped" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return true if the latest reconfiguration task has finished and there is
 no another active task running.]]>
      </doc>
    </method>
    <method name="getStartTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEndTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStatus" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.conf.ReconfigurationTaskStatus -->
  <!-- start class org.apache.hadoop.conf.ReconfigurationUtil -->
  <class name="ReconfigurationUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ReconfigurationUtil"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getChangedProperties" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newConf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="oldConf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="parseChangedProperties" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newConf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="oldConf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.conf.ReconfigurationUtil -->
  <!-- start class org.apache.hadoop.conf.ReconfigurationUtil.PropertyChange -->
  <class name="ReconfigurationUtil.PropertyChange" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ReconfigurationUtil.PropertyChange" type="java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="prop" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="oldVal" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="newVal" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.conf.ReconfigurationUtil.PropertyChange -->
  <doc>
  <![CDATA[Configuration of system parameters.]]>
  </doc>
</package>
<package name="org.apache.hadoop.crypto">
</package>
<package name="org.apache.hadoop.crypto.key">
  <!-- start class org.apache.hadoop.crypto.key.CachingKeyProvider -->
  <class name="CachingKeyProvider" extends="org.apache.hadoop.crypto.key.KeyProviderExtension"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CachingKeyProvider" type="org.apache.hadoop.crypto.key.KeyProvider, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCurrentKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getKeyVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="deleteKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="rollNewVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="material" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="rollNewVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="NoSuchAlgorithmException" type="java.security.NoSuchAlgorithmException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getMetadata" return="org.apache.hadoop.crypto.key.KeyProvider.Metadata"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A <code>KeyProviderExtension</code> implementation providing a short lived
 cache for <code>KeyVersions</code> and <code>Metadata</code>to avoid burst
 of requests to hit the underlying <code>KeyProvider</code>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.CachingKeyProvider -->
  <!-- start class org.apache.hadoop.crypto.key.JavaKeyStoreProvider.Factory -->
  <class name="JavaKeyStoreProvider.Factory" extends="org.apache.hadoop.crypto.key.KeyProviderFactory"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JavaKeyStoreProvider.Factory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createProvider" return="org.apache.hadoop.crypto.key.KeyProvider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerName" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[The factory to create JksProviders, which is used by the ServiceLoader.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.JavaKeyStoreProvider.Factory -->
  <!-- start class org.apache.hadoop.crypto.key.JavaKeyStoreProvider.KeyMetadata -->
  <class name="JavaKeyStoreProvider.KeyMetadata" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.security.Key"/>
    <implements name="java.io.Serializable"/>
    <method name="getAlgorithm" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFormat" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEncoded" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An adapter between a KeyStore Key and our Metadata. This is used to store
 the metadata in a KeyStore even though isn't really a key.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.JavaKeyStoreProvider.KeyMetadata -->
  <!-- start class org.apache.hadoop.crypto.key.KeyProvider -->
  <class name="KeyProvider" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KeyProvider" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor.
 
 @param conf configuration for the provider]]>
      </doc>
    </constructor>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the provider configuration.
 
 @return the provider configuration]]>
      </doc>
    </method>
    <method name="options" return="org.apache.hadoop.crypto.key.KeyProvider.Options"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[A helper function to create an options object.
 @param conf the configuration to use
 @return a new options object]]>
      </doc>
    </method>
    <method name="isTransient" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this provider represents a store
 that is intended for transient use - such as the UserProvider
 is. These providers are generally used to provide access to
 keying material rather than for long term storage.
 @return true if transient, false otherwise]]>
      </doc>
    </method>
    <method name="getKeyVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the key material for a specific version of the key. This method is used
 when decrypting data.
 @param versionName the name of a specific version of the key
 @return the key material
 @throws IOException]]>
      </doc>
    </method>
    <method name="getKeys" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the key names for all keys.
 @return the list of key names
 @throws IOException]]>
      </doc>
    </method>
    <method name="getKeysMetadata" return="org.apache.hadoop.crypto.key.KeyProvider.Metadata[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get key metadata in bulk.
 @param names the names of the keys to get
 @throws IOException]]>
      </doc>
    </method>
    <method name="getKeyVersions" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the key material for all versions of a specific key name.
 @return the list of key material
 @throws IOException]]>
      </doc>
    </method>
    <method name="getCurrentKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the current version of the key, which should be used for encrypting new
 data.
 @param name the base name of the key
 @return the version name of the current version of the key or null if the
    key version doesn't exist
 @throws IOException]]>
      </doc>
    </method>
    <method name="getMetadata" return="org.apache.hadoop.crypto.key.KeyProvider.Metadata"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get metadata about the key.
 @param name the basename of the key
 @return the key's metadata or null if the key doesn't exist
 @throws IOException]]>
      </doc>
    </method>
    <method name="createKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="material" type="byte[]"/>
      <param name="options" type="org.apache.hadoop.crypto.key.KeyProvider.Options"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a new key. The given key must not already exist.
 @param name the base name of the key
 @param material the key material for the first version of the key.
 @param options the options for the new key.
 @return the version name of the first version of the key.
 @throws IOException]]>
      </doc>
    </method>
    <method name="generateKey" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="size" type="int"/>
      <param name="algorithm" type="java.lang.String"/>
      <exception name="NoSuchAlgorithmException" type="java.security.NoSuchAlgorithmException"/>
      <doc>
      <![CDATA[Generates a key material.

 @param size length of the key.
 @param algorithm algorithm to use for generating the key.
 @return the generated key.
 @throws NoSuchAlgorithmException]]>
      </doc>
    </method>
    <method name="createKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="options" type="org.apache.hadoop.crypto.key.KeyProvider.Options"/>
      <exception name="NoSuchAlgorithmException" type="java.security.NoSuchAlgorithmException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a new key generating the material for it.
 The given key must not already exist.
 <p/>
 This implementation generates the key material and calls the
 {@link #createKey(String, byte[], Options)} method.

 @param name the base name of the key
 @param options the options for the new key.
 @return the version name of the first version of the key.
 @throws IOException
 @throws NoSuchAlgorithmException]]>
      </doc>
    </method>
    <method name="deleteKey"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete the given key.
 @param name the name of the key to delete
 @throws IOException]]>
      </doc>
    </method>
    <method name="rollNewVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="material" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Roll a new version of the given key.
 @param name the basename of the key
 @param material the new key material
 @return the name of the new version of the key
 @throws IOException]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Can be used by implementing classes to close any resources
 that require closing]]>
      </doc>
    </method>
    <method name="rollNewVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="NoSuchAlgorithmException" type="java.security.NoSuchAlgorithmException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Roll a new version of the given key generating the material for it.
 <p/>
 This implementation generates the key material and calls the
 {@link #rollNewVersion(String, byte[])} method.

 @param name the basename of the key
 @return the name of the new version of the key
 @throws IOException]]>
      </doc>
    </method>
    <method name="flush"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Ensures that any changes to the keys are written to persistent store.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getBaseName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Split the versionName in to a base name. Converts "/aaa/bbb/3" to
 "/aaa/bbb".
 @param versionName the version name to split
 @return the base name of the key
 @throws IOException]]>
      </doc>
    </method>
    <method name="buildVersionName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="version" type="int"/>
      <doc>
      <![CDATA[Build a version string from a basename and version number. Converts
 "/aaa/bbb" and 3 to "/aaa/bbb@3".
 @param name the basename of the key
 @param version the version of the key
 @return the versionName of the key.]]>
      </doc>
    </method>
    <method name="findProvider" return="org.apache.hadoop.crypto.key.KeyProvider"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerList" type="java.util.List"/>
      <param name="keyName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Find the provider with the given key.
 @param providerList the list of providers
 @param keyName the key name we are looking for
 @return the KeyProvider that has the key]]>
      </doc>
    </method>
    <field name="DEFAULT_CIPHER_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_CIPHER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_BITLENGTH_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_BITLENGTH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A provider of secret key material for Hadoop applications. Provides an
 abstraction to separate key storage from users of encryption. It
 is intended to support getting or storing keys in a variety of ways,
 including third party bindings.
 <P/>
 <code>KeyProvider</code> implementations must be thread safe.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyProvider -->
  <!-- start class org.apache.hadoop.crypto.key.KeyProvider.KeyVersion -->
  <class name="KeyProvider.KeyVersion" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KeyProvider.KeyVersion" type="java.lang.String, java.lang.String, byte[]"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getVersionName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMaterial" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[The combination of both the key version name and the key material.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyProvider.KeyVersion -->
  <!-- start class org.apache.hadoop.crypto.key.KeyProvider.Metadata -->
  <class name="KeyProvider.Metadata" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KeyProvider.Metadata" type="java.lang.String, int, java.lang.String, java.util.Map, java.util.Date, int"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="KeyProvider.Metadata" type="byte[]"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deserialize a new metadata object from a set of bytes.
 @param bytes the serialized metadata
 @throws IOException]]>
      </doc>
    </constructor>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCreated" return="java.util.Date"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCipher" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAttributes" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAlgorithm" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the algorithm from the cipher.
 @return the algorithm name]]>
      </doc>
    </method>
    <method name="getBitLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getVersions" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addVersion" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="serialize" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serialize the metadata to a set of bytes.
 @return the serialized bytes
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Key metadata that is associated with the key.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyProvider.Metadata -->
  <!-- start class org.apache.hadoop.crypto.key.KeyProvider.Options -->
  <class name="KeyProvider.Options" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KeyProvider.Options" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setCipher" return="org.apache.hadoop.crypto.key.KeyProvider.Options"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cipher" type="java.lang.String"/>
    </method>
    <method name="setBitLength" return="org.apache.hadoop.crypto.key.KeyProvider.Options"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bitLength" type="int"/>
    </method>
    <method name="setDescription" return="org.apache.hadoop.crypto.key.KeyProvider.Options"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="description" type="java.lang.String"/>
    </method>
    <method name="setAttributes" return="org.apache.hadoop.crypto.key.KeyProvider.Options"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attributes" type="java.util.Map"/>
    </method>
    <method name="getCipher" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBitLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDescription" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAttributes" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Options when creating key objects.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyProvider.Options -->
  <!-- start interface org.apache.hadoop.crypto.key.KeyProviderCryptoExtension.CryptoExtension -->
  <interface name="KeyProviderCryptoExtension.CryptoExtension"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.crypto.key.KeyProviderExtension.Extension"/>
    <method name="warmUpEncryptedKeys"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyNames" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Calls to this method allows the underlying KeyProvider to warm-up any
 implementation specific caches used to store the Encrypted Keys.
 @param keyNames Array of Key Names]]>
      </doc>
    </method>
    <method name="drain"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyName" type="java.lang.String"/>
      <doc>
      <![CDATA[Drains the Queue for the provided key.

 @param keyName the key to drain the Queue for]]>
      </doc>
    </method>
    <method name="generateEncryptedKey" return="org.apache.hadoop.crypto.key.KeyProviderCryptoExtension.EncryptedKeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encryptionKeyName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Generates a key material and encrypts it using the given key version name
 and initialization vector. The generated key material is of the same
 length as the <code>KeyVersion</code> material of the latest key version
 of the key and is encrypted using the same cipher.
 <p/>
 NOTE: The generated key is not stored by the <code>KeyProvider</code>

 @param encryptionKeyName
          The latest KeyVersion of this key's material will be encrypted.
 @return EncryptedKeyVersion with the generated key material, the version
         name is 'EEK' (for Encrypted Encryption Key)
 @throws IOException
           thrown if the key material could not be generated
 @throws GeneralSecurityException
           thrown if the key material could not be encrypted because of a
           cryptographic issue.]]>
      </doc>
    </method>
    <method name="decryptEncryptedKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="encryptedKeyVersion" type="org.apache.hadoop.crypto.key.KeyProviderCryptoExtension.EncryptedKeyVersion"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="GeneralSecurityException" type="java.security.GeneralSecurityException"/>
      <doc>
      <![CDATA[Decrypts an encrypted byte[] key material using the given a key version
 name and initialization vector.

 @param encryptedKeyVersion
          contains keyVersionName and IV to decrypt the encrypted key
          material
 @return a KeyVersion with the decrypted key material, the version name is
         'EK' (For Encryption Key)
 @throws IOException
           thrown if the key material could not be decrypted
 @throws GeneralSecurityException
           thrown if the key material could not be decrypted because of a
           cryptographic issue.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[CryptoExtension is a type of Extension that exposes methods to generate
 EncryptedKeys and to decrypt the same.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.crypto.key.KeyProviderCryptoExtension.CryptoExtension -->
  <!-- start class org.apache.hadoop.crypto.key.KeyProviderCryptoExtension.EncryptedKeyVersion -->
  <class name="KeyProviderCryptoExtension.EncryptedKeyVersion" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KeyProviderCryptoExtension.EncryptedKeyVersion" type="java.lang.String, java.lang.String, byte[], org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new EncryptedKeyVersion.

 @param keyName                  Name of the encryption key used to
                                 encrypt the encrypted key.
 @param encryptionKeyVersionName Version name of the encryption key used
                                 to encrypt the encrypted key.
 @param encryptedKeyIv           Initialization vector of the encrypted
                                 key. The IV of the encryption key used to
                                 encrypt the encrypted key is derived from
                                 this IV.
 @param encryptedKeyVersion      The encrypted encryption key version.]]>
      </doc>
    </constructor>
    <method name="createForDecryption" return="org.apache.hadoop.crypto.key.KeyProviderCryptoExtension.EncryptedKeyVersion"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyName" type="java.lang.String"/>
      <param name="encryptionKeyVersionName" type="java.lang.String"/>
      <param name="encryptedKeyIv" type="byte[]"/>
      <param name="encryptedKeyMaterial" type="byte[]"/>
      <doc>
      <![CDATA[Factory method to create a new EncryptedKeyVersion that can then be
 passed into {@link #decryptEncryptedKey}. Note that the fields of the
 returned EncryptedKeyVersion will only partially be populated; it is not
 necessarily suitable for operations besides decryption.

 @param keyName Key name of the encryption key use to encrypt the
                encrypted key.
 @param encryptionKeyVersionName Version name of the encryption key used
                                 to encrypt the encrypted key.
 @param encryptedKeyIv           Initialization vector of the encrypted
                                 key. The IV of the encryption key used to
                                 encrypt the encrypted key is derived from
                                 this IV.
 @param encryptedKeyMaterial     Key material of the encrypted key.
 @return EncryptedKeyVersion suitable for decryption.]]>
      </doc>
    </method>
    <method name="getEncryptionKeyName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Name of the encryption key used to encrypt the encrypted key.]]>
      </doc>
    </method>
    <method name="getEncryptionKeyVersionName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Version name of the encryption key used to encrypt the encrypted
 key.]]>
      </doc>
    </method>
    <method name="getEncryptedKeyIv" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Initialization vector of the encrypted key. The IV of the
 encryption key used to encrypt the encrypted key is derived from this
 IV.]]>
      </doc>
    </method>
    <method name="getEncryptedKeyVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The encrypted encryption key version.]]>
      </doc>
    </method>
    <method name="deriveIV" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="encryptedKeyIV" type="byte[]"/>
      <doc>
      <![CDATA[Derive the initialization vector (IV) for the encryption key from the IV
 of the encrypted key. This derived IV is used with the encryption key to
 decrypt the encrypted key.
 <p/>
 The alternative to this is using the same IV for both the encryption key
 and the encrypted key. Even a simple symmetric transformation like this
 improves security by avoiding IV re-use. IVs will also be fairly unique
 among different EEKs.

 @param encryptedKeyIV of the encrypted key (i.e. {@link
 #getEncryptedKeyIv()})
 @return IV for the encryption key]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An encrypted encryption key (EEK) and related information. An EEK must be
 decrypted using the key's encryption key before it can be used.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyProviderCryptoExtension.EncryptedKeyVersion -->
  <!-- start class org.apache.hadoop.crypto.key.KeyProviderDelegationTokenExtension -->
  <class name="KeyProviderDelegationTokenExtension" extends="org.apache.hadoop.crypto.key.KeyProviderExtension"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="addDelegationTokens" return="org.apache.hadoop.security.token.Token[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="renewer" type="java.lang.String"/>
      <param name="credentials" type="org.apache.hadoop.security.Credentials"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Passes the renewer and Credentials object to the underlying
 {@link DelegationTokenExtension}
 @param renewer the user allowed to renew the delegation tokens
 @param credentials cache in which to add new delegation tokens
 @return list of new delegation tokens
 @throws IOException thrown if IOException if an IO error occurs.]]>
      </doc>
    </method>
    <method name="createKeyProviderDelegationTokenExtension" return="org.apache.hadoop.crypto.key.KeyProviderDelegationTokenExtension"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyProvider" type="org.apache.hadoop.crypto.key.KeyProvider"/>
      <doc>
      <![CDATA[Creates a <code>KeyProviderDelegationTokenExtension</code> using a given
 {@link KeyProvider}.
 <p/>
 If the given <code>KeyProvider</code> implements the
 {@link DelegationTokenExtension} interface the <code>KeyProvider</code>
 itself will provide the extension functionality, otherwise a default
 extension implementation will be used.

 @param keyProvider <code>KeyProvider</code> to use to create the
 <code>KeyProviderDelegationTokenExtension</code> extension.
 @return a <code>KeyProviderDelegationTokenExtension</code> instance
 using the given <code>KeyProvider</code>.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A KeyProvider extension with the ability to add a renewer's Delegation
 Tokens to the provided Credentials.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyProviderDelegationTokenExtension -->
  <!-- start interface org.apache.hadoop.crypto.key.KeyProviderDelegationTokenExtension.DelegationTokenExtension -->
  <interface name="KeyProviderDelegationTokenExtension.DelegationTokenExtension"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.crypto.key.KeyProviderExtension.Extension"/>
    <method name="addDelegationTokens" return="org.apache.hadoop.security.token.Token[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="renewer" type="java.lang.String"/>
      <param name="credentials" type="org.apache.hadoop.security.Credentials"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The implementer of this class will take a renewer and add all
 delegation tokens associated with the renewer to the
 <code>Credentials</code> object if it is not already present,
 @param renewer the user allowed to renew the delegation tokens
 @param credentials cache in which to add new delegation tokens
 @return list of new delegation tokens
 @throws IOException thrown if IOException if an IO error occurs.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[DelegationTokenExtension is a type of Extension that exposes methods to
 needed to work with Delegation Tokens.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.crypto.key.KeyProviderDelegationTokenExtension.DelegationTokenExtension -->
  <!-- start class org.apache.hadoop.crypto.key.KeyProviderExtension -->
  <class name="KeyProviderExtension" extends="org.apache.hadoop.crypto.key.KeyProvider"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KeyProviderExtension" type="org.apache.hadoop.crypto.key.KeyProvider, E"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getExtension" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getKeyProvider" return="org.apache.hadoop.crypto.key.KeyProvider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="isTransient" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getKeysMetadata" return="org.apache.hadoop.crypto.key.KeyProvider.Metadata[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCurrentKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="options" type="org.apache.hadoop.crypto.key.KeyProvider.Options"/>
      <exception name="NoSuchAlgorithmException" type="java.security.NoSuchAlgorithmException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="rollNewVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="NoSuchAlgorithmException" type="java.security.NoSuchAlgorithmException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getKeyVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getKeys" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getKeyVersions" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getMetadata" return="org.apache.hadoop.crypto.key.KeyProvider.Metadata"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="material" type="byte[]"/>
      <param name="options" type="org.apache.hadoop.crypto.key.KeyProvider.Options"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="deleteKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="rollNewVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="material" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This is a utility class used to extend the functionality of KeyProvider, that
 takes a KeyProvider and an Extension. It implements all the required methods
 of the KeyProvider by delegating it to the provided KeyProvider.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyProviderExtension -->
  <!-- start interface org.apache.hadoop.crypto.key.KeyProviderExtension.Extension -->
  <interface name="KeyProviderExtension.Extension"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[A marker interface for the KeyProviderExtension subclass implement.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.crypto.key.KeyProviderExtension.Extension -->
  <!-- start class org.apache.hadoop.crypto.key.KeyProviderFactory -->
  <class name="KeyProviderFactory" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KeyProviderFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createProvider" return="org.apache.hadoop.crypto.key.KeyProvider"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerName" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getProviders" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="get" return="org.apache.hadoop.crypto.key.KeyProvider"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a KeyProvider based on a provided URI.

 @param uri key provider URI
 @param conf configuration to initialize the key provider
 @return the key provider for the specified URI, or <code>NULL</code> if
         a provider for the specified URI scheme could not be found.
 @throws IOException thrown if the provider failed to initialize.]]>
      </doc>
    </method>
    <field name="KEY_PROVIDER_PATH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A factory to create a list of KeyProvider based on the path given in a
 Configuration. It uses a service loader interface to find the available
 KeyProviders and create them based on the list of URIs.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyProviderFactory -->
  <!-- start class org.apache.hadoop.crypto.key.KeyShell -->
  <class name="KeyShell" extends="org.apache.hadoop.conf.Configured"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.Tool"/>
    <constructor name="KeyShell"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Primary entry point for the KeyShell; called via main().

 @param args Command line arguments.
 @return 0 on success and 1 on failure.  This value is passed back to
 the unix shell, so we must follow shell return code conventions:
 the return code is an unsigned character, and 0 means success, and
 small positive integers mean failure.
 @throws Exception]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[main() entry point for the KeyShell.  While strictly speaking the
 return is void, it will System.exit() with a return code: 0 is for
 success and 1 for failure.

 @param args Command line arguments.
 @throws Exception]]>
      </doc>
    </method>
    <field name="out" type="java.io.PrintStream"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[allows stdout to be captured if necessary]]>
      </doc>
    </field>
    <field name="err" type="java.io.PrintStream"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[allows stderr to be captured if necessary]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This program is the CLI utility for the KeyProvider facilities in Hadoop.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyShell -->
  <!-- start class org.apache.hadoop.crypto.key.UserProvider.Factory -->
  <class name="UserProvider.Factory" extends="org.apache.hadoop.crypto.key.KeyProviderFactory"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UserProvider.Factory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createProvider" return="org.apache.hadoop.crypto.key.KeyProvider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerName" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.UserProvider.Factory -->
</package>
<package name="org.apache.hadoop.crypto.key.kms">
  <!-- start class org.apache.hadoop.crypto.key.kms.KMSClientProvider.Factory -->
  <class name="KMSClientProvider.Factory" extends="org.apache.hadoop.crypto.key.KeyProviderFactory"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KMSClientProvider.Factory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createProvider" return="org.apache.hadoop.crypto.key.KeyProvider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerName" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[The factory to create KMSClientProvider, which is used by the
 ServiceLoader.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.kms.KMSClientProvider.Factory -->
  <!-- start class org.apache.hadoop.crypto.key.kms.KMSClientProvider.KMSEncryptedKeyVersion -->
  <class name="KMSClientProvider.KMSEncryptedKeyVersion" extends="org.apache.hadoop.crypto.key.KeyProviderCryptoExtension.EncryptedKeyVersion"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KMSClientProvider.KMSEncryptedKeyVersion" type="java.lang.String, java.lang.String, byte[], java.lang.String, byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.kms.KMSClientProvider.KMSEncryptedKeyVersion -->
  <!-- start class org.apache.hadoop.crypto.key.kms.KMSClientProvider.KMSKeyVersion -->
  <class name="KMSClientProvider.KMSKeyVersion" extends="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KMSClientProvider.KMSKeyVersion" type="java.lang.String, java.lang.String, byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.kms.KMSClientProvider.KMSKeyVersion -->
  <!-- start class org.apache.hadoop.crypto.key.kms.KMSClientProvider.KMSMetadata -->
  <class name="KMSClientProvider.KMSMetadata" extends="org.apache.hadoop.crypto.key.KeyProvider.Metadata"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KMSClientProvider.KMSMetadata" type="java.lang.String, int, java.lang.String, java.util.Map, java.util.Date, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.kms.KMSClientProvider.KMSMetadata -->
  <!-- start interface org.apache.hadoop.crypto.key.kms.ValueQueue.QueueRefiller -->
  <interface name="ValueQueue.QueueRefiller"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="fillQueueForKey"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyName" type="java.lang.String"/>
      <param name="keyQueue" type="java.util.Queue"/>
      <param name="numValues" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Method that has to be implemented by implementing classes to fill the
 Queue.
 @param keyName Key name
 @param keyQueue Queue that needs to be filled
 @param numValues number of Values to be added to the queue.
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[QueueRefiller interface a client must implement to use this class]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.crypto.key.kms.ValueQueue.QueueRefiller -->
  <!-- start class org.apache.hadoop.crypto.key.kms.ValueQueue.SyncGenerationPolicy -->
  <class name="ValueQueue.SyncGenerationPolicy" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.crypto.key.kms.ValueQueue.SyncGenerationPolicy[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.crypto.key.kms.ValueQueue.SyncGenerationPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Policy to decide how many values to return to client when client asks for
 "n" values and Queue is empty.
 This decides how many values to return when client calls "getAtMost"]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.kms.ValueQueue.SyncGenerationPolicy -->
</package>
<package name="org.apache.hadoop.crypto.random">
</package>
<package name="org.apache.hadoop.fs">
  <!-- start class org.apache.hadoop.fs.AbstractFileSystem -->
  <class name="AbstractFileSystem" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractFileSystem" type="java.net.URI, java.lang.String, boolean, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="URISyntaxException" type="java.net.URISyntaxException"/>
      <doc>
      <![CDATA[Constructor to be called by subclasses.
 
 @param uri for this file system.
 @param supportedScheme the scheme supported by the implementor
 @param authorityNeeded if true then theURI must have authority, if false
          then the URI must have null authority.

 @throws URISyntaxException <code>uri</code> has syntax error]]>
      </doc>
    </constructor>
    <method name="getStatistics" return="org.apache.hadoop.fs.FileSystem.Statistics"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isValidName" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns true if the specified string is considered valid in the path part
 of a URI by this file system.  The default implementation enforces the rules
 of HDFS, but subclasses may override this method to implement specific
 validation rules for specific file systems.
 
 @param src String source filename to check, path part of the URI
 @return boolean true if the specified string is considered valid]]>
      </doc>
    </method>
    <method name="createFileSystem" return="org.apache.hadoop.fs.AbstractFileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <doc>
      <![CDATA[Create a file system instance for the specified uri using the conf. The
 conf is used to find the class name that implements the file system. The
 conf is also passed to the file system for its configuration.

 @param uri URI of the file system
 @param conf Configuration for the file system
 
 @return Returns the file system for the given URI

 @throws UnsupportedFileSystemException file system for <code>uri</code> is
           not found]]>
      </doc>
    </method>
    <method name="getStatistics" return="org.apache.hadoop.fs.FileSystem.Statistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Get the statistics for a particular file system.
 
 @param uri
          used as key to lookup STATISTICS_TABLE. Only scheme and authority
          part of the uri are used.
 @return a statistics object]]>
      </doc>
    </method>
    <method name="clearStatistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="printStatistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Prints statistics for all file systems.]]>
      </doc>
    </method>
    <method name="getAllStatistics" return="java.util.Map"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="get" return="org.apache.hadoop.fs.AbstractFileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <doc>
      <![CDATA[The main factory method for creating a file system. Get a file system for
 the URI's scheme and authority. The scheme of the <code>uri</code>
 determines a configuration property name,
 <tt>fs.AbstractFileSystem.<i>scheme</i>.impl</tt> whose value names the
 AbstractFileSystem class.
 
 The entire URI and conf is passed to the AbstractFileSystem factory method.
 
 @param uri for the file system to be created.
 @param conf which is passed to the file system impl.
 
 @return file system for the given URI.
 
 @throws UnsupportedFileSystemException if the file system for
           <code>uri</code> is not supported.]]>
      </doc>
    </method>
    <method name="checkScheme"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="supportedScheme" type="java.lang.String"/>
      <doc>
      <![CDATA[Check that the Uri's scheme matches
 @param uri
 @param supportedScheme]]>
      </doc>
    </method>
    <method name="getUriDefaultPort" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The default port of this file system.
 
 @return default port of this file system's Uri scheme
         A uri with a port of -1 => default port;]]>
      </doc>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a URI whose scheme and authority identify this FileSystem.
 
 @return the uri of this file system.]]>
      </doc>
    </method>
    <method name="checkPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Check that a Path belongs to this FileSystem.
 
 If the path is fully qualified URI, then its scheme and authority
 matches that of this file system. Otherwise the path must be 
 slash-relative name.
 
 @throws InvalidPathException if the path is invalid]]>
      </doc>
    </method>
    <method name="getUriPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Get the path-part of a pathname. Checks that URI matches this file system
 and that the path-part is a valid name.
 
 @param p path
 
 @return path-part of the Path p]]>
      </doc>
    </method>
    <method name="makeQualified" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Make the path fully qualified to this file system
 @param path
 @return the qualified path]]>
      </doc>
    </method>
    <method name="getInitialWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Some file systems like LocalFileSystem have an initial workingDir
 that is used as the starting workingDir. For other file systems
 like HDFS there is no built in notion of an initial workingDir.
 
 @return the initial workingDir if the file system has such a notion
         otherwise return a null.]]>
      </doc>
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the current user's home directory in this file system.
 The default implementation returns "/user/$USER/".
 
 @return current user's home directory.]]>
      </doc>
    </method>
    <method name="getServerDefaults" return="org.apache.hadoop.fs.FsServerDefaults"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a set of server default configuration values.
 
 @return server default configuration values
 
 @throws IOException an I/O error occurred]]>
      </doc>
    </method>
    <method name="resolvePath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the fully-qualified path of path f resolving the path
 through any internal symlinks or mount point
 @param p path to be resolved
 @return fully qualified path 
 @throws FileNotFoundException, AccessControlException, IOException
         UnresolvedLinkException if symbolic link on path cannot be resolved
          internally]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="createFlag" type="java.util.EnumSet"/>
      <param name="opts" type="org.apache.hadoop.fs.Options.CreateOpts[]"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#create(Path, EnumSet, Options.CreateOpts...)} except
 that the Path f must be fully qualified and the permission is absolute
 (i.e. umask has been applied).]]>
      </doc>
    </method>
    <method name="createInternal" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="flag" type="java.util.EnumSet"/>
      <param name="absolutePermission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="checksumOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
      <param name="createParent" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link #create(Path, EnumSet, Options.CreateOpts...)} except that the opts
 have been declared explicitly.]]>
      </doc>
    </method>
    <method name="mkdir"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="createParent" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#mkdir(Path, FsPermission, boolean)} except that the Path
 f must be fully qualified and the permission is absolute (i.e. 
 umask has been applied).]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#delete(Path, boolean)} except that Path f must be for
 this file system.]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#open(Path)} except that Path f must be for this
 file system.]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#open(Path, int)} except that Path f must be for this
 file system.]]>
      </doc>
    </method>
    <method name="setReplication" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#setReplication(Path, short)} except that Path f must be
 for this file system.]]>
      </doc>
    </method>
    <method name="rename"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="options" type="org.apache.hadoop.fs.Options.Rename[]"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#rename(Path, Path, Options.Rename...)} except that Path
 f must be for this file system.]]>
      </doc>
    </method>
    <method name="renameInternal"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#rename(Path, Path, Options.Rename...)} except that Path
 f must be for this file system and NO OVERWRITE is performed.
 
 File systems that do not have a built in overwrite need implement only this
 method and can take advantage of the default impl of the other
 {@link #renameInternal(Path, Path, boolean)}]]>
      </doc>
    </method>
    <method name="renameInternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#rename(Path, Path, Options.Rename...)} except that Path
 f must be for this file system.]]>
      </doc>
    </method>
    <method name="supportsSymlinks" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the file system supports symlinks, false otherwise.
 @return true if filesystem supports symlinks]]>
      </doc>
    </method>
    <method name="createSymlink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.apache.hadoop.fs.Path"/>
      <param name="link" type="org.apache.hadoop.fs.Path"/>
      <param name="createParent" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <doc>
      <![CDATA[The specification of this method matches that of  
 {@link FileContext#createSymlink(Path, Path, boolean)};]]>
      </doc>
    </method>
    <method name="getLinkTarget" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Partially resolves the path. This is used during symlink resolution in
 {@link FSLinkResolver}, and differs from the similarly named method
 {@link FileContext#getLinkTarget(Path)}.
 @throws IOException subclass implementations may throw IOException]]>
      </doc>
    </method>
    <method name="setPermission"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#setPermission(Path, FsPermission)} except that Path f
 must be for this file system.]]>
      </doc>
    </method>
    <method name="setOwner"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#setOwner(Path, String, String)} except that Path f must
 be for this file system.]]>
      </doc>
    </method>
    <method name="setTimes"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="mtime" type="long"/>
      <param name="atime" type="long"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#setTimes(Path, long, long)} except that Path f must be
 for this file system.]]>
      </doc>
    </method>
    <method name="getFileChecksum" return="org.apache.hadoop.fs.FileChecksum"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFileChecksum(Path)} except that Path f must be for
 this file system.]]>
      </doc>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFileStatus(Path)} 
 except that an UnresolvedLinkException may be thrown if a symlink is 
 encountered in the path.]]>
      </doc>
    </method>
    <method name="access"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="mode" type="org.apache.hadoop.fs.permission.FsAction"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#access(Path, FsAction)}
 except that an UnresolvedLinkException may be thrown if a symlink is
 encountered in the path.]]>
      </doc>
    </method>
    <method name="getFileLinkStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFileLinkStatus(Path)}
 except that an UnresolvedLinkException may be thrown if a symlink is  
 encountered in the path leading up to the final path component.
 If the file system does not support symlinks then the behavior is
 equivalent to {@link AbstractFileSystem#getFileStatus(Path)}.]]>
      </doc>
    </method>
    <method name="getFileBlockLocations" return="org.apache.hadoop.fs.BlockLocation[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="start" type="long"/>
      <param name="len" type="long"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFileBlockLocations(Path, long, long)} except that
 Path f must be for this file system.]]>
      </doc>
    </method>
    <method name="getFsStatus" return="org.apache.hadoop.fs.FsStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFsStatus(Path)} except that Path f must be for this
 file system.]]>
      </doc>
    </method>
    <method name="getFsStatus" return="org.apache.hadoop.fs.FsStatus"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFsStatus(Path)}.]]>
      </doc>
    </method>
    <method name="listStatusIterator" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#listStatus(Path)} except that Path f must be for this
 file system.]]>
      </doc>
    </method>
    <method name="listLocatedStatus" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#listLocatedStatus(Path)} except that Path f 
 must be for this file system.]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext.Util#listStatus(Path)} except that Path f must be 
 for this file system.]]>
      </doc>
    </method>
    <method name="listCorruptFileBlocks" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@return an iterator over the corrupt files under the given path
 (may contain duplicates if a file has more than one corrupt block)
 @throws IOException]]>
      </doc>
    </method>
    <method name="setVerifyChecksum"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="verifyChecksum" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#setVerifyChecksum(boolean, Path)} except that Path f
 must be for this file system.]]>
      </doc>
    </method>
    <method name="getCanonicalServiceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a canonical name for this file system.
 @return a URI string that uniquely identifies this file system]]>
      </doc>
    </method>
    <method name="getDelegationTokens" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="renewer" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get one or more delegation tokens associated with the filesystem. Normally
 a file system returns a single delegation token. A file system that manages
 multiple file systems underneath, could return set of delegation tokens for
 all the file systems it manages
 
 @param renewer the account name that is allowed to renew the token.
 @return List of delegation tokens.
   If delegation tokens not supported then return a list of size zero.
 @throws IOException]]>
      </doc>
    </method>
    <method name="modifyAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Modifies ACL entries of files and directories.  This method can add new ACL
 entries or modify the permissions on existing ACL entries.  All existing
 ACL entries that are not specified in this call are retained without
 changes.  (Modifications are merged into the current ACL.)

 @param path Path to modify
 @param aclSpec List<AclEntry> describing modifications
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes ACL entries from files and directories.  Other ACL entries are
 retained.

 @param path Path to modify
 @param aclSpec List<AclEntry> describing entries to remove
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeDefaultAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes all default ACL entries from files and directories.

 @param path Path to modify
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes all but the base ACL entries of files and directories.  The entries
 for user, group, and others are retained for compatibility with permission
 bits.

 @param path Path to modify
 @throws IOException if an ACL could not be removed]]>
      </doc>
    </method>
    <method name="setAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fully replaces ACL of files and directories, discarding all existing
 entries.

 @param path Path to modify
 @param aclSpec List<AclEntry> describing modifications, must include entries
   for user, group, and others for compatibility with permission bits.
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="getAclStatus" return="org.apache.hadoop.fs.permission.AclStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets the ACLs of files and directories.

 @param path Path to get
 @return RemoteIterator<AclStatus> which returns each AclStatus
 @throws IOException if an ACL could not be read]]>
      </doc>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to modify
 @param name xattr name.
 @param value xattr value.
 @throws IOException]]>
      </doc>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <param name="flag" type="java.util.EnumSet"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to modify
 @param name xattr name.
 @param value xattr value.
 @param flag xattr set flag
 @throws IOException]]>
      </doc>
    </method>
    <method name="getXAttr" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get an xattr for a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attribute
 @param name xattr name.
 @return byte[] xattr value.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattrs for a file or directory.
 Only those xattrs for which the logged-in user has permissions to view
 are returned.
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @return Map<String, byte[]> describing the XAttrs of the file or directory
 @throws IOException]]>
      </doc>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="names" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattrs for a file or directory.
 Only those xattrs for which the logged-in user has permissions to view
 are returned.
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @param names XAttr names.
 @return Map<String, byte[]> describing the XAttrs of the file or directory
 @throws IOException]]>
      </doc>
    </method>
    <method name="listXAttrs" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattr names for a file or directory.
 Only the xattr names for which the logged-in user has permissions to view
 are returned.
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @return Map<String, byte[]> describing the XAttrs of the file or directory
 @throws IOException]]>
      </doc>
    </method>
    <method name="removeXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Remove an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to remove extended attribute
 @param name xattr name
 @throws IOException]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <field name="statistics" type="org.apache.hadoop.fs.FileSystem.Statistics"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The statistics for this file system.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This class provides an interface for implementors of a Hadoop file system
 (analogous to the VFS of Unix). Applications do not access this class;
 instead they access files across all file systems using {@link FileContext}.
 
 Pathnames passed to AbstractFileSystem can be fully qualified URI that
 matches the "this" file system (ie same scheme and authority) 
 or a Slash-relative name that is assumed to be relative
 to the root of the "this" file system .]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.AbstractFileSystem -->
  <!-- start class org.apache.hadoop.fs.AvroFSInput -->
  <class name="AvroFSInput" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <implements name="org.apache.avro.file.SeekableInput"/>
    <constructor name="AvroFSInput" type="org.apache.hadoop.fs.FSDataInputStream, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct given an {@link FSDataInputStream} and its length.]]>
      </doc>
    </constructor>
    <constructor name="AvroFSInput" type="org.apache.hadoop.fs.FileContext, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct given a {@link FileContext} and a {@link Path}.]]>
      </doc>
    </constructor>
    <method name="length" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="seek"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="tell" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Adapts an {@link FSDataInputStream} to Avro's SeekableInput interface.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.AvroFSInput -->
  <!-- start class org.apache.hadoop.fs.BatchedRemoteIterator -->
  <class name="BatchedRemoteIterator" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.RemoteIterator"/>
    <constructor name="BatchedRemoteIterator" type="K"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="makeRequest" return="org.apache.hadoop.fs.BatchedRemoteIterator.BatchedEntries"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prevKey" type="K"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Perform the actual remote request.
 
 @param prevKey The key to send.
 @return A list of replies.]]>
      </doc>
    </method>
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="elementToPrevKey" return="K"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="E"/>
      <doc>
      <![CDATA[Return the next list key associated with an element.]]>
      </doc>
    </method>
    <method name="next" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A RemoteIterator that fetches elements in batches.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.BatchedRemoteIterator -->
  <!-- start interface org.apache.hadoop.fs.BatchedRemoteIterator.BatchedEntries -->
  <interface name="BatchedRemoteIterator.BatchedEntries"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasMore" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.fs.BatchedRemoteIterator.BatchedEntries -->
  <!-- start class org.apache.hadoop.fs.BatchedRemoteIterator.BatchedListEntries -->
  <class name="BatchedRemoteIterator.BatchedListEntries" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.BatchedRemoteIterator.BatchedEntries"/>
    <constructor name="BatchedRemoteIterator.BatchedListEntries" type="java.util.List, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasMore" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.fs.BatchedRemoteIterator.BatchedListEntries -->
  <!-- start class org.apache.hadoop.fs.BlockLocation -->
  <class name="BlockLocation" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlockLocation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default Constructor]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="org.apache.hadoop.fs.BlockLocation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Copy constructor]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with host, name, offset and length]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], long, long, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with host, name, offset, length and corrupt flag]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], java.lang.String[], long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with host, name, network topology, offset and length]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], java.lang.String[], long, long, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with host, name, network topology, offset, length 
 and corrupt flag]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], java.lang.String[], java.lang.String[], long, long, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHosts" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the list of hosts (hostname) hosting this block]]>
      </doc>
    </method>
    <method name="getCachedHosts" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the list of hosts (hostname) hosting a cached replica of the block]]>
      </doc>
    </method>
    <method name="getNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the list of names (IP:xferPort) hosting this block]]>
      </doc>
    </method>
    <method name="getTopologyPaths" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the list of network topology paths for each of the hosts.
 The last component of the path is the "name" (IP:xferPort).]]>
      </doc>
    </method>
    <method name="getOffset" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the start offset of file associated with this block]]>
      </doc>
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the length of the block]]>
      </doc>
    </method>
    <method name="isCorrupt" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the corrupt flag.]]>
      </doc>
    </method>
    <method name="setOffset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="offset" type="long"/>
      <doc>
      <![CDATA[Set the start offset of file associated with this block]]>
      </doc>
    </method>
    <method name="setLength"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="length" type="long"/>
      <doc>
      <![CDATA[Set the length of block]]>
      </doc>
    </method>
    <method name="setCorrupt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="corrupt" type="boolean"/>
      <doc>
      <![CDATA[Set the corrupt flag.]]>
      </doc>
    </method>
    <method name="setHosts"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hosts" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the hosts hosting this block]]>
      </doc>
    </method>
    <method name="setCachedHosts"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cachedHosts" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Set the hosts hosting a cached replica of this block]]>
      </doc>
    </method>
    <method name="setNames"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the names (host:port) hosting this block]]>
      </doc>
    </method>
    <method name="setTopologyPaths"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="topologyPaths" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the network topology paths of the hosts]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents the network location of a block, information about the hosts
 that contain block replicas, and other block metadata (E.g. the file
 offset associated with the block, length, whether it is corrupt, etc).]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.BlockLocation -->
  <!-- start interface org.apache.hadoop.fs.ByteBufferReadable -->
  <interface name="ByteBufferReadable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads up to buf.remaining() bytes into buf. Callers should use
 buf.limit(..) to control the size of the desired read.
 <p/>
 After a successful call, buf.position() and buf.limit() should be
 unchanged, and therefore any data can be immediately read from buf.
 buf.mark() may be cleared or updated.
 <p/>
 In the case of an exception, the values of buf.position() and buf.limit()
 are undefined, and callers should be prepared to recover from this
 eventuality.
 <p/>
 Many implementations will throw {@link UnsupportedOperationException}, so
 callers that are not confident in support for this method from the
 underlying filesystem should be prepared to handle that exception.
 <p/>
 Implementations should treat 0-length requests as legitimate, and must not
 signal an error upon their receipt.

 @param buf
          the ByteBuffer to receive the results of the read operation. Up to
          buf.limit() - buf.position() bytes may be read.
 @return the number of bytes available to read from buf
 @throws IOException
           if there is some error performing the read]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementers of this interface provide a read API that writes to a
 ByteBuffer, not a byte[].]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.ByteBufferReadable -->
  <!-- start interface org.apache.hadoop.fs.CanSetDropBehind -->
  <interface name="CanSetDropBehind"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setDropBehind"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dropCache" type="java.lang.Boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Configure whether the stream should drop the cache.

 @param dropCache     Whether to drop the cache.  null means to use the
                      default value.
 @throws IOException  If there was an error changing the dropBehind
                      setting.
         UnsupportedOperationException  If this stream doesn't support
                                        setting the drop-behind.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.fs.CanSetDropBehind -->
  <!-- start interface org.apache.hadoop.fs.CanSetReadahead -->
  <interface name="CanSetReadahead"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setReadahead"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readahead" type="java.lang.Long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Set the readahead on this stream.

 @param readahead     The readahead to use.  null means to use the default.
 @throws IOException  If there was an error changing the dropBehind
                      setting.
         UnsupportedOperationException  If this stream doesn't support
                                        setting readahead.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.fs.CanSetReadahead -->
  <!-- start class org.apache.hadoop.fs.ChecksumException -->
  <class name="ChecksumException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ChecksumException" type="java.lang.String, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown for checksum errors.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ChecksumException -->
  <!-- start class org.apache.hadoop.fs.ChecksumFileSystem -->
  <class name="ChecksumFileSystem" extends="org.apache.hadoop.fs.FilterFileSystem"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ChecksumFileSystem" type="org.apache.hadoop.fs.FileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getApproxChkSumLength" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="long"/>
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="setVerifyChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="verifyChecksum" type="boolean"/>
      <doc>
      <![CDATA[Set whether to verify checksum.]]>
      </doc>
    </method>
    <method name="setWriteChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writeChecksum" type="boolean"/>
    </method>
    <method name="getRawFileSystem" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the raw file system]]>
      </doc>
    </method>
    <method name="getChecksumFile" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Return the name of the checksum file associated with a file.]]>
      </doc>
    </method>
    <method name="isChecksumFile" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Return true iff file is a checksum file name.]]>
      </doc>
    </method>
    <method name="getChecksumFileLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="fileSize" type="long"/>
      <doc>
      <![CDATA[Return the length of the checksum file given the size of the 
 actual file.]]>
      </doc>
    </method>
    <method name="getBytesPerSum" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the bytes Per Checksum]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataInputStream at the indicated Path.
 @param f the file name to open
 @param bufferSize the size of the buffer to be used.]]>
      </doc>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getChecksumLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="long"/>
      <param name="bytesPerSum" type="int"/>
      <doc>
      <![CDATA[Calculated the length of the checksum file in bytes.
 @param size the length of the data file in bytes
 @param bytesPerSum the number of bytes in a checksum block
 @return the number of bytes in the checksum file]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createNonRecursive" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setReplication" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set replication for an existing file.
 Implement the abstract <tt>setReplication</tt> of <tt>FileSystem</tt>
 @param src file name
 @param replication new replication
 @throws IOException
 @return true if successful;
         false if file does not exist or is a directory]]>
      </doc>
    </method>
    <method name="rename" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Rename files/dirs]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Implement the delete(Path, boolean) in checksum
 file system.]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses of the files/directories in the given path if the path is
 a directory.
 
 @param f
          given path
 @return the statuses of the files/directories in the given path
 @throws IOException]]>
      </doc>
    </method>
    <method name="listLocatedStatus" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses of the files/directories in the given path if the path is
 a directory.
 
 @param f
          given path
 @return the statuses of the files/directories in the given patch
 @throws IOException]]>
      </doc>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under FS, and the dst is on the local disk.
 Copy it from FS control to the local dst name.]]>
      </doc>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="copyCrc" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under FS, and the dst is on the local disk.
 Copy it from FS control to the local dst name.
 If src and dst are directories, the copyCrc parameter
 determines whether to copy CRC files.]]>
      </doc>
    </method>
    <method name="startLocalOutput" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="completeLocalOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="reportChecksumFailure" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="in" type="org.apache.hadoop.fs.FSDataInputStream"/>
      <param name="inPos" type="long"/>
      <param name="sums" type="org.apache.hadoop.fs.FSDataInputStream"/>
      <param name="sumsPos" type="long"/>
      <doc>
      <![CDATA[Report a checksum error to the file system.
 @param f the file name containing the error
 @param in the stream open on the file
 @param inPos the position of the beginning of the bad data in the file
 @param sums the stream open on the checksum file
 @param sumsPos the position of the beginning of the bad data in the checksum file
 @return if retry is neccessary]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstract Checksumed FileSystem.
 It provide a basic implementation of a Checksumed FileSystem,
 which creates a checksum file for each raw file.
 It generates & verifies checksums at the client side.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ChecksumFileSystem -->
  <!-- start class org.apache.hadoop.fs.CommonConfigurationKeysPublic -->
  <class name="CommonConfigurationKeysPublic" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CommonConfigurationKeysPublic"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="IO_NATIVE_LIB_AVAILABLE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_NATIVE_LIB_AVAILABLE_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_NATIVE_LIB_AVAILABLE_KEY]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_SCRIPT_NUMBER_ARGS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_SCRIPT_NUMBER_ARGS_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for NET_TOPOLOGY_SCRIPT_NUMBER_ARGS_KEY]]>
      </doc>
    </field>
    <field name="FS_DEFAULT_NAME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_DEFAULT_NAME_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_DEFAULT_NAME_KEY]]>
      </doc>
    </field>
    <field name="FS_DF_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_DF_INTERVAL_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_DF_INTERVAL_KEY]]>
      </doc>
    </field>
    <field name="FS_DU_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_DU_INTERVAL_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_DU_INTERVAL_KEY]]>
      </doc>
    </field>
    <field name="FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_KEY]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_NODE_SWITCH_MAPPING_IMPL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_IMPL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_TABLE_MAPPING_FILE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="NET_DEPENDENCY_SCRIPT_FILE_NAME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FS_TRASH_CHECKPOINT_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_TRASH_CHECKPOINT_INTERVAL_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_TRASH_CHECKPOINT_INTERVAL_KEY]]>
      </doc>
    </field>
    <field name="FS_LOCAL_BLOCK_SIZE_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Not used anywhere, looks like default value for FS_LOCAL_BLOCK_SIZE]]>
      </doc>
    </field>
    <field name="FS_AUTOMATIC_CLOSE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_AUTOMATIC_CLOSE_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_AUTOMATIC_CLOSE_KEY]]>
      </doc>
    </field>
    <field name="FS_FILE_IMPL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_FTP_HOST_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_FTP_HOST_PORT_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_TRASH_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_TRASH_INTERVAL_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_TRASH_INTERVAL_KEY]]>
      </doc>
    </field>
    <field name="IO_MAPFILE_BLOOM_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_MAPFILE_BLOOM_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_MAPFILE_BLOOM_SIZE_KEY]]>
      </doc>
    </field>
    <field name="IO_MAPFILE_BLOOM_ERROR_RATE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_MAPFILE_BLOOM_ERROR_RATE_DEFAULT" type="float"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_MAPFILE_BLOOM_ERROR_RATE_KEY]]>
      </doc>
    </field>
    <field name="IO_COMPRESSION_CODEC_LZO_CLASS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Codec class that implements Lzo compression algorithm]]>
      </doc>
    </field>
    <field name="IO_MAP_INDEX_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_MAP_INDEX_INTERVAL_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_MAP_INDEX_INTERVAL_DEFAULT]]>
      </doc>
    </field>
    <field name="IO_MAP_INDEX_SKIP_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_MAP_INDEX_SKIP_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_MAP_INDEX_SKIP_KEY]]>
      </doc>
    </field>
    <field name="IO_SEQFILE_COMPRESS_BLOCKSIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_SEQFILE_COMPRESS_BLOCKSIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_SEQFILE_COMPRESS_BLOCKSIZE_KEY]]>
      </doc>
    </field>
    <field name="IO_FILE_BUFFER_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_FILE_BUFFER_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_FILE_BUFFER_SIZE_KEY]]>
      </doc>
    </field>
    <field name="IO_SKIP_CHECKSUM_ERRORS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_SKIP_CHECKSUM_ERRORS_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_SKIP_CHECKSUM_ERRORS_KEY]]>
      </doc>
    </field>
    <field name="IO_SORT_MB_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Moved to mapreduce, see mapreduce.task.io.sort.mb
 in mapred-default.xml
 See https://issues.apache.org/jira/browse/HADOOP-6801">
      <doc>
      <![CDATA[@deprecated Moved to mapreduce, see mapreduce.task.io.sort.mb
 in mapred-default.xml
 See https://issues.apache.org/jira/browse/HADOOP-6801]]>
      </doc>
    </field>
    <field name="IO_SORT_MB_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_SORT_MB_DEFAULT]]>
      </doc>
    </field>
    <field name="IO_SORT_FACTOR_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Moved to mapreduce, see mapreduce.task.io.sort.factor
 in mapred-default.xml
 See https://issues.apache.org/jira/browse/HADOOP-6801">
      <doc>
      <![CDATA[@deprecated Moved to mapreduce, see mapreduce.task.io.sort.factor
 in mapred-default.xml
 See https://issues.apache.org/jira/browse/HADOOP-6801]]>
      </doc>
    </field>
    <field name="IO_SORT_FACTOR_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_SORT_FACTOR_DEFAULT]]>
      </doc>
    </field>
    <field name="IO_SERIALIZATIONS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="TFILE_IO_CHUNK_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="TFILE_IO_CHUNK_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for TFILE_IO_CHUNK_SIZE_DEFAULT]]>
      </doc>
    </field>
    <field name="TFILE_FS_INPUT_BUFFER_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="TFILE_FS_INPUT_BUFFER_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for TFILE_FS_INPUT_BUFFER_SIZE_KEY]]>
      </doc>
    </field>
    <field name="TFILE_FS_OUTPUT_BUFFER_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="TFILE_FS_OUTPUT_BUFFER_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for TFILE_FS_OUTPUT_BUFFER_SIZE_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECTION_MAXIDLETIME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECTION_MAXIDLETIME_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_CONNECTION_MAXIDLETIME_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_TIMEOUT_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_TIMEOUT_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_CONNECT_TIMEOUT_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_MAX_RETRIES_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_MAX_RETRIES_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_CONNECT_MAX_RETRIES_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_RETRY_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_RETRY_INTERVAL_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_CONNECT_RETRY_INTERVAL_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_MAX_RETRIES_ON_SOCKET_TIMEOUTS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_MAX_RETRIES_ON_SOCKET_TIMEOUTS_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_CONNECT_MAX_RETRIES_ON_SOCKET_TIMEOUTS_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_TCPNODELAY_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_TCPNODELAY_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Defalt value for IPC_CLIENT_TCPNODELAY_KEY]]>
      </doc>
    </field>
    <field name="IPC_SERVER_LISTEN_QUEUE_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_SERVER_LISTEN_QUEUE_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_SERVER_LISTEN_QUEUE_SIZE_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_KILL_MAX_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_KILL_MAX_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_KILL_MAX_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_IDLETHRESHOLD_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_IDLETHRESHOLD_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_IDLETHRESHOLD_DEFAULT]]>
      </doc>
    </field>
    <field name="IPC_SERVER_TCPNODELAY_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_SERVER_TCPNODELAY_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_SERVER_TCPNODELAY_KEY]]>
      </doc>
    </field>
    <field name="HADOOP_RPC_SOCKET_FACTORY_CLASS_DEFAULT_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_RPC_SOCKET_FACTORY_CLASS_DEFAULT_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SOCKS_SERVER_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_UTIL_HASH_TYPE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_UTIL_HASH_TYPE_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for HADOOP_UTIL_HASH_TYPE_KEY]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUP_MAPPING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_SECS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_SECS_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_NEGATIVE_CACHE_SECS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_NEGATIVE_CACHE_SECS_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_WARN_AFTER_MS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_WARN_AFTER_MS_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SECURITY_AUTHENTICATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_AUTHORIZATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_INSTRUMENTATION_REQUIRES_ADMIN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_SERVICE_USER_NAME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_AUTH_TO_LOCAL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SSL_ENABLED_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SSL_ENABLED_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HTTP_POLICY_HTTP_ONLY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HTTP_POLICY_HTTPS_ONLY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_RPC_PROTECTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_SASL_PROPS_RESOLVER_CLASS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Class to override Sasl Properties for a connection]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_CODEC_CLASSES_KEY_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_CIPHER_SUITE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_CIPHER_SUITE_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_JCE_PROVIDER_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_BUFFER_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_BUFFER_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Defalt value for HADOOP_SECURITY_CRYPTO_BUFFER_SIZE_KEY]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_IMPERSONATION_PROVIDER_CLASS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Class to override Impersonation provider]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_ENC_KEY_CACHE_SIZE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_ENC_KEY_CACHE_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for KMS_CLIENT_ENC_KEY_CACHE_SIZE]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_ENC_KEY_CACHE_LOW_WATERMARK" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_ENC_KEY_CACHE_LOW_WATERMARK_DEFAULT" type="float"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for KMS_CLIENT_ENC_KEY_CACHE_LOW_WATERMARK]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_ENC_KEY_CACHE_NUM_REFILL_THREADS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_ENC_KEY_CACHE_NUM_REFILL_THREADS_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for KMS_CLIENT_ENC_KEY_NUM_REFILL_THREADS]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_ENC_KEY_CACHE_EXPIRY_MS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_ENC_KEY_CACHE_EXPIRY_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for KMS_CLIENT_ENC_KEY_CACHE_EXPIRY (12 hrs)]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_JAVA_SECURE_RANDOM_ALGORITHM_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_JAVA_SECURE_RANDOM_ALGORITHM_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Defalt value for HADOOP_SECURITY_JAVA_SECURE_RANDOM_ALGORITHM_KEY]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_SECURE_RANDOM_IMPL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_SECURE_RANDOM_DEVICE_FILE_PATH_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See <a href="{@docRoot}/../core-default.html">core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_SECURE_RANDOM_DEVICE_FILE_PATH_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This class contains constants for configuration keys used
 in the common code.

 It includes all publicly documented configuration keys. In general
 this class should not be used directly (use CommonConfigurationKeys
 instead)]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.CommonConfigurationKeysPublic -->
  <!-- start class org.apache.hadoop.fs.ContentSummary -->
  <class name="ContentSummary" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="ContentSummary"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor]]>
      </doc>
    </constructor>
    <constructor name="ContentSummary" type="long, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor]]>
      </doc>
    </constructor>
    <constructor name="ContentSummary" type="long, long, long, long, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor]]>
      </doc>
    </constructor>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the length]]>
      </doc>
    </method>
    <method name="getDirectoryCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the directory count]]>
      </doc>
    </method>
    <method name="getFileCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the file count]]>
      </doc>
    </method>
    <method name="getQuota" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the directory quota]]>
      </doc>
    </method>
    <method name="getSpaceConsumed" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retuns (disk) space consumed]]>
      </doc>
    </method>
    <method name="getSpaceQuota" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns (disk) space quota]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getHeader" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="qOption" type="boolean"/>
      <doc>
      <![CDATA[Return the header of the output.
 if qOption is false, output directory count, file count, and content size;
 if qOption is true, output quota and remaining quota as well.
 
 @param qOption a flag indicating if quota needs to be printed or not
 @return the header of the output]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="qOption" type="boolean"/>
      <doc>
      <![CDATA[Return the string representation of the object in the output format.
 if qOption is false, output directory count, file count, and content size;
 if qOption is true, output quota and remaining quota as well.

 @param qOption a flag indicating if quota needs to be printed or not
 @return the string representation of the object]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="qOption" type="boolean"/>
      <param name="hOption" type="boolean"/>
      <doc>
      <![CDATA[Return the string representation of the object in the output format.
 if qOption is false, output directory count, file count, and content size;
 if qOption is true, output quota and remaining quota as well.
 if hOption is false file sizes are returned in bytes
 if hOption is true file sizes are returned in human readable 
 
 @param qOption a flag indicating if quota needs to be printed or not
 @param hOption a flag indicating if human readable output if to be used
 @return the string representation of the object]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Store the summary of a content (a directory or a file).]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ContentSummary -->
  <!-- start class org.apache.hadoop.fs.CreateFlag -->
  <class name="CreateFlag" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.fs.CreateFlag[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.fs.CreateFlag"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="validate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="java.util.EnumSet"/>
      <doc>
      <![CDATA[Validate the CreateFlag and throw exception if it is invalid
 @param flag set of CreateFlag
 @throws HadoopIllegalArgumentException if the CreateFlag is invalid]]>
      </doc>
    </method>
    <method name="validate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="java.lang.Object"/>
      <param name="pathExists" type="boolean"/>
      <param name="flag" type="java.util.EnumSet"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Validate the CreateFlag for create operation
 @param path Object representing the path; usually String or {@link Path}
 @param pathExists pass true if the path exists in the file system
 @param flag set of CreateFlag
 @throws IOException on error
 @throws HadoopIllegalArgumentException if the CreateFlag is invalid]]>
      </doc>
    </method>
    <doc>
    <![CDATA[CreateFlag specifies the file create semantic. Users can combine flags like: <br>
 <code>
 EnumSet.of(CreateFlag.CREATE, CreateFlag.APPEND)
 <code>
 <p>
 
 Use the CreateFlag as follows:
 <ol>
 <li> CREATE - to create a file if it does not exist, 
 else throw FileAlreadyExists.</li>
 <li> APPEND - to append to a file if it exists, 
 else throw FileNotFoundException.</li>
 <li> OVERWRITE - to truncate a file if it exists, 
 else throw FileNotFoundException.</li>
 <li> CREATE|APPEND - to create a file if it does not exist, 
 else append to an existing file.</li>
 <li> CREATE|OVERWRITE - to create a file if it does not exist, 
 else overwrite an existing file.</li>
 <li> SYNC_BLOCK - to force closed blocks to the disk device.
 In addition {@link Syncable#hsync()} should be called after each write,
 if true synchronous behavior is required.</li>
 </ol>
 
 Following combination is not valid and will result in 
 {@link HadoopIllegalArgumentException}:
 <ol>
 <li> APPEND|OVERWRITE</li>
 <li> CREATE|APPEND|OVERWRITE</li>
 </ol>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.CreateFlag -->
  <!-- start interface org.apache.hadoop.fs.DelegationTokenRenewer.Renewable -->
  <interface name="DelegationTokenRenewer.Renewable"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getRenewToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the renew token.]]>
      </doc>
    </method>
    <method name="setDelegationToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="token" type="org.apache.hadoop.security.token.Token"/>
      <doc>
      <![CDATA[Set delegation token.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The renewable interface used by the renewer.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.DelegationTokenRenewer.Renewable -->
  <!-- start class org.apache.hadoop.fs.DelegationTokenRenewer.RenewAction -->
  <class name="DelegationTokenRenewer.RenewAction" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.concurrent.Delayed"/>
    <method name="isValid" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDelay" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Get the delay until this event should happen.]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delayed" type="java.util.concurrent.Delayed"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="that" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An action that will renew and replace the file system's delegation 
 tokens automatically.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.DelegationTokenRenewer.RenewAction -->
  <!-- start class org.apache.hadoop.fs.DUHelper -->
  <class name="DUHelper" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getFolderUsage" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="folder" type="java.lang.String"/>
    </method>
    <method name="check" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="folder" type="java.lang.String"/>
    </method>
    <method name="getFileCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUsage" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.fs.DUHelper -->
  <!-- start class org.apache.hadoop.fs.FileAlreadyExistsException -->
  <class name="FileAlreadyExistsException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FileAlreadyExistsException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FileAlreadyExistsException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Used when target file already exists for any operation and 
 is not configured to be overwritten.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileAlreadyExistsException -->
  <!-- start class org.apache.hadoop.fs.FileChecksum -->
  <class name="FileChecksum" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="FileChecksum"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAlgorithmName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The checksum algorithm name]]>
      </doc>
    </method>
    <method name="getLength" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The length of the checksum in bytes]]>
      </doc>
    </method>
    <method name="getBytes" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The value of the checksum in bytes]]>
      </doc>
    </method>
    <method name="getChecksumOpt" return="org.apache.hadoop.fs.Options.ChecksumOpt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
      <doc>
      <![CDATA[Return true if both the algorithms and the values are the same.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An abstract class representing file checksums for files.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileChecksum -->
  <!-- start class org.apache.hadoop.fs.FileContext -->
  <class name="FileContext" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getFSofPath" return="org.apache.hadoop.fs.AbstractFileSystem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="absOrFqPath" type="org.apache.hadoop.fs.Path"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the file system of supplied path.
 
 @param absOrFqPath - absolute or fully qualified path
 @return the file system of the path
 
 @throws UnsupportedFileSystemException If the file system for
           <code>absOrFqPath</code> is not supported.
 @throws IOExcepton If the file system for <code>absOrFqPath</code> could
         not be instantiated.]]>
      </doc>
    </method>
    <method name="getFileContext" return="org.apache.hadoop.fs.FileContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defFS" type="org.apache.hadoop.fs.AbstractFileSystem"/>
      <param name="aConf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Create a FileContext with specified FS as default using the specified
 config.
 
 @param defFS
 @param aConf
 @return new FileContext with specifed FS as default.]]>
      </doc>
    </method>
    <method name="getFileContext" return="org.apache.hadoop.fs.FileContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="defaultFS" type="org.apache.hadoop.fs.AbstractFileSystem"/>
      <doc>
      <![CDATA[Create a FileContext for specified file system using the default config.
 
 @param defaultFS
 @return a FileContext with the specified AbstractFileSystem
                 as the default FS.]]>
      </doc>
    </method>
    <method name="getFileContext" return="org.apache.hadoop.fs.FileContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <doc>
      <![CDATA[Create a FileContext using the default config read from the
 $HADOOP_CONFIG/core.xml, Unspecified key-values for config are defaulted
 from core-defaults.xml in the release jar.
 
 @throws UnsupportedFileSystemException If the file system from the default
           configuration is not supported]]>
      </doc>
    </method>
    <method name="getLocalFSFileContext" return="org.apache.hadoop.fs.FileContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <doc>
      <![CDATA[@return a FileContext for the local file system using the default config.
 @throws UnsupportedFileSystemException If the file system for
           {@link FsConstants#LOCAL_FS_URI} is not supported.]]>
      </doc>
    </method>
    <method name="getFileContext" return="org.apache.hadoop.fs.FileContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaultFsUri" type="java.net.URI"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <doc>
      <![CDATA[Create a FileContext for specified URI using the default config.
 
 @param defaultFsUri
 @return a FileContext with the specified URI as the default FS.
 
 @throws UnsupportedFileSystemException If the file system for
           <code>defaultFsUri</code> is not supported]]>
      </doc>
    </method>
    <method name="getFileContext" return="org.apache.hadoop.fs.FileContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaultFsUri" type="java.net.URI"/>
      <param name="aConf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <doc>
      <![CDATA[Create a FileContext for specified default URI using the specified config.
 
 @param defaultFsUri
 @param aConf
 @return new FileContext for specified uri
 @throws UnsupportedFileSystemException If the file system with specified is
           not supported
 @throws RuntimeException If the file system specified is supported but
         could not be instantiated, or if login fails.]]>
      </doc>
    </method>
    <method name="getFileContext" return="org.apache.hadoop.fs.FileContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="aConf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <doc>
      <![CDATA[Create a FileContext using the passed config. Generally it is better to use
 {@link #getFileContext(URI, Configuration)} instead of this one.
 
 
 @param aConf
 @return new FileContext
 @throws UnsupportedFileSystemException If file system in the config
           is not supported]]>
      </doc>
    </method>
    <method name="getLocalFSFileContext" return="org.apache.hadoop.fs.FileContext"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="aConf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <doc>
      <![CDATA[@param aConf - from which the FileContext is configured
 @return a FileContext for the local file system using the specified config.
 
 @throws UnsupportedFileSystemException If default file system in the config
           is not supported]]>
      </doc>
    </method>
    <method name="getDefaultFileSystem" return="org.apache.hadoop.fs.AbstractFileSystem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setWorkingDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newWDir" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the working directory for wd-relative names (such a "foo/bar"). Working
 directory feature is provided by simply prefixing relative names with the
 working dir. Note this is different from Unix where the wd is actually set
 to the inode. Hence setWorkingDir does not follow symlinks etc. This works
 better in a distributed environment that has multiple independent roots.
 {@link #getWorkingDirectory()} should return what setWorkingDir() set.
 
 @param newWDir new working directory
 @throws IOException 
 <br>
           NewWdir can be one of:
           <ul>
           <li>relative path: "foo/bar";</li>
           <li>absolute without scheme: "/foo/bar"</li>
           <li>fully qualified with scheme: "xx://auth/foo/bar"</li>
           </ul>
 <br>
           Illegal WDs:
           <ul>
           <li>relative with scheme: "xx:foo/bar"</li>
           <li>non existent directory</li>
           </ul>]]>
      </doc>
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the working directory for wd-relative names (such a "foo/bar").]]>
      </doc>
    </method>
    <method name="getUgi" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the ugi in the file-context
 @return UserGroupInformation]]>
      </doc>
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the current user's home directory in this file system.
 The default implementation returns "/user/$USER/".
 @return the home directory]]>
      </doc>
    </method>
    <method name="getUMask" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the umask of this FileContext]]>
      </doc>
    </method>
    <method name="setUMask"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newUmask" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <doc>
      <![CDATA[Set umask to the supplied parameter.
 @param newUmask  the new umask]]>
      </doc>
    </method>
    <method name="resolvePath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Resolve the path following any symlinks or mount points
 @param f to be resolved
 @return fully qualified resolved path
 
 @throws FileNotFoundException  If <code>f</code> does not exist
 @throws AccessControlException if access denied
 @throws IOException If an IO Error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws
           undeclared exception to RPC server
 
 RuntimeExceptions:
 @throws InvalidPathException If path <code>f</code> is not valid]]>
      </doc>
    </method>
    <method name="makeQualified" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Make the path fully qualified if it is isn't. 
 A Fully-qualified path has scheme and authority specified and an absolute
 path.
 Use the default file system and working dir in this FileContext to qualify.
 @param path
 @return qualified path]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="createFlag" type="java.util.EnumSet"/>
      <param name="opts" type="org.apache.hadoop.fs.Options.CreateOpts[]"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create or overwrite file on indicated path and returns an output stream for
 writing into the file.
 
 @param f the file name to open
 @param createFlag gives the semantics of create; see {@link CreateFlag}
 @param opts file creation options; see {@link Options.CreateOpts}.
          <ul>
          <li>Progress - to report progress on the operation - default null
          <li>Permission - umask is applied against permisssion: default is
          FsPermissions:getDefault()
 
          <li>CreateParent - create missing parent path; default is to not
          to create parents
          <li>The defaults for the following are SS defaults of the file
          server implementing the target path. Not all parameters make sense
          for all kinds of file system - eg. localFS ignores Blocksize,
          replication, checksum
          <ul>
          <li>BufferSize - buffersize used in FSDataOutputStream
          <li>Blocksize - block size for file blocks
          <li>ReplicationFactor - replication for blocks
          <li>ChecksumParam - Checksum parameters. server default is used
          if not specified.
          </ul>
          </ul>
 
 @return {@link FSDataOutputStream} for created file
 
 @throws AccessControlException If access is denied
 @throws FileAlreadyExistsException If file <code>f</code> already exists
 @throws FileNotFoundException If parent of <code>f</code> does not exist
           and <code>createParent</code> is false
 @throws ParentNotDirectoryException If parent of <code>f</code> is not a
           directory.
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws
           undeclared exception to RPC server
 
 RuntimeExceptions:
 @throws InvalidPathException If path <code>f</code> is not valid]]>
      </doc>
    </method>
    <method name="mkdir"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="createParent" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Make(create) a directory and all the non-existent parents.
 
 @param dir - the dir to make
 @param permission - permissions is set permission&~umask
 @param createParent - if true then missing parent dirs are created if false
          then parent must exist
 
 @throws AccessControlException If access is denied
 @throws FileAlreadyExistsException If directory <code>dir</code> already
           exists
 @throws FileNotFoundException If parent of <code>dir</code> does not exist
           and <code>createParent</code> is false
 @throws ParentNotDirectoryException If parent of <code>dir</code> is not a
           directory
 @throws UnsupportedFileSystemException If file system for <code>dir</code>
         is not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server
 
 RuntimeExceptions:
 @throws InvalidPathException If path <code>dir</code> is not valid]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete a file.
 @param f the path to delete.
 @param recursive if path is a directory and set to 
 true, the directory is deleted else throws an exception. In
 case of a file the recursive can be set to either true or false.

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server
 
 RuntimeExceptions:
 @throws InvalidPathException If path <code>f</code> is invalid]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataInputStream at the indicated Path using
 default buffersize.
 @param f the file name to open

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If file <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code>
         is not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataInputStream at the indicated Path.
 
 @param f the file name to open
 @param bufferSize the size of the buffer to be used.
 
 @throws AccessControlException If access is denied
 @throws FileNotFoundException If file <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="setReplication" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set replication for an existing file.
 
 @param f file name
 @param replication new replication

 @return true if successful

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If file <code>f</code> does not exist
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="rename"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="options" type="org.apache.hadoop.fs.Options.Rename[]"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Renames Path src to Path dst
 <ul>
 <li
 <li>Fails if src is a file and dst is a directory.
 <li>Fails if src is a directory and dst is a file.
 <li>Fails if the parent of dst does not exist or is a file.
 </ul>
 <p>
 If OVERWRITE option is not passed as an argument, rename fails if the dst
 already exists.
 <p>
 If OVERWRITE option is passed as an argument, rename overwrites the dst if
 it is a file or an empty directory. Rename fails if dst is a non-empty
 directory.
 <p>
 Note that atomicity of rename is dependent on the file system
 implementation. Please refer to the file system documentation for details
 <p>
 
 @param src path to be renamed
 @param dst new path after rename
 
 @throws AccessControlException If access is denied
 @throws FileAlreadyExistsException If <code>dst</code> already exists and
           <code>options</options> has {@link Options.Rename#OVERWRITE} 
           option false.
 @throws FileNotFoundException If <code>src</code> does not exist
 @throws ParentNotDirectoryException If parent of <code>dst</code> is not a
           directory
 @throws UnsupportedFileSystemException If file system for <code>src</code>
           and <code>dst</code> is not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set permission of a path.
 @param f
 @param permission - the new absolute permission (umask is not applied)

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code>
         is not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set owner of a path (i.e. a file or a directory). The parameters username
 and groupname cannot both be null.
 
 @param f The path
 @param username If it is null, the original username remains unchanged.
 @param groupname If it is null, the original groupname remains unchanged.
 
 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server
 
 RuntimeExceptions:
 @throws HadoopIllegalArgumentException If <code>username</code> or
           <code>groupname</code> is invalid.]]>
      </doc>
    </method>
    <method name="setTimes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="mtime" type="long"/>
      <param name="atime" type="long"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set access time of a file.
 @param f The path
 @param mtime Set the modification time of this file.
        The number of milliseconds since epoch (Jan 1, 1970). 
        A value of -1 means that this call should not set modification time.
 @param atime Set the access time of this file.
        The number of milliseconds since Jan 1, 1970. 
        A value of -1 means that this call should not set access time.

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="getFileChecksum" return="org.apache.hadoop.fs.FileChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the checksum of a file.

 @param f file path

 @return The file checksum.  The default return value is null,
  which indicates that no checksum algorithm is implemented
  in the corresponding FileSystem.

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="setVerifyChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="verifyChecksum" type="boolean"/>
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the verify checksum flag for the  file system denoted by the path.
 This is only applicable if the 
 corresponding FileSystem supports checksum. By default doesn't do anything.
 @param verifyChecksum
 @param f set the verifyChecksum for the Filesystem containing this path

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a file status object that represents the path.
 @param f The path we want information from

 @return a FileStatus object

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="access"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="mode" type="org.apache.hadoop.fs.permission.FsAction"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Checks if the user can access a path.  The mode specifies which access
 checks to perform.  If the requested permissions are granted, then the
 method returns normally.  If access is denied, then the method throws an
 {@link AccessControlException}.
 <p/>
 The default implementation of this method calls {@link #getFileStatus(Path)}
 and checks the returned permissions against the requested permissions.
 Note that the getFileStatus call will be subject to authorization checks.
 Typically, this requires search (execute) permissions on each directory in
 the path's prefix, but this is implementation-defined.  Any file system
 that provides a richer authorization model (such as ACLs) may override the
 default implementation so that it checks against that model instead.
 <p>
 In general, applications should avoid using this method, due to the risk of
 time-of-check/time-of-use race conditions.  The permissions on a file may
 change immediately after the access call returns.  Most applications should
 prefer running specific file system actions as the desired user represented
 by a {@link UserGroupInformation}.

 @param path Path to check
 @param mode type of access to check
 @throws AccessControlException if access is denied
 @throws FileNotFoundException if the path does not exist
 @throws UnsupportedFileSystemException if file system for <code>path</code>
   is not supported
 @throws IOException see specific implementation
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="getFileLinkStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a file status object that represents the path. If the path 
 refers to a symlink then the FileStatus of the symlink is returned.
 The behavior is equivalent to #getFileStatus() if the underlying
 file system does not support symbolic links.
 @param  f The path we want information from.
 @return A FileStatus object
 
 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred]]>
      </doc>
    </method>
    <method name="getLinkTarget" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the target of the given symbolic link as it was specified
 when the link was created.  Links in the path leading up to the
 final path component are resolved transparently.

 @param f the path to return the target of
 @return The un-interpreted target of the symbolic link.
 
 @throws AccessControlException If access is denied
 @throws FileNotFoundException If path <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If the given path does not refer to a symlink
           or an I/O error occurred]]>
      </doc>
    </method>
    <method name="getFileBlockLocations" return="org.apache.hadoop.fs.BlockLocation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="start" type="long"/>
      <param name="len" type="long"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return blockLocation of the given file for the given offset and len.
  For a nonexistent file or regions, null will be returned.

 This call is most helpful with DFS, where it returns 
 hostnames of machines that contain the given file.
 
 @param f - get blocklocations of this file
 @param start position (byte offset)
 @param len (in bytes)

 @return block locations for given file at specified offset of len

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server
 
 RuntimeExceptions:
 @throws InvalidPathException If path <code>f</code> is invalid]]>
      </doc>
    </method>
    <method name="getFsStatus" return="org.apache.hadoop.fs.FsStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a status object describing the use and capacity of the
 file system denoted by the Parh argument p.
 If the file system has multiple partitions, the
 use and capacity of the partition pointed to by the specified
 path is reflected.
 
 @param f Path for which status should be obtained. null means the
 root partition of the default file system. 

 @return a FsStatus object

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="createSymlink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.apache.hadoop.fs.Path"/>
      <param name="link" type="org.apache.hadoop.fs.Path"/>
      <param name="createParent" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates a symbolic link to an existing file. An exception is thrown if 
 the symlink exits, the user does not have permission to create symlink,
 or the underlying file system does not support symlinks.
 
 Symlink permissions are ignored, access to a symlink is determined by
 the permissions of the symlink target.
 
 Symlinks in paths leading up to the final path component are resolved 
 transparently. If the final path component refers to a symlink some 
 functions operate on the symlink itself, these are:
 - delete(f) and deleteOnExit(f) - Deletes the symlink.
 - rename(src, dst) - If src refers to a symlink, the symlink is 
   renamed. If dst refers to a symlink, the symlink is over-written.
 - getLinkTarget(f) - Returns the target of the symlink. 
 - getFileLinkStatus(f) - Returns a FileStatus object describing
   the symlink.
 Some functions, create() and mkdir(), expect the final path component
 does not exist. If they are given a path that refers to a symlink that 
 does exist they behave as if the path referred to an existing file or 
 directory. All other functions fully resolve, ie follow, the symlink. 
 These are: open, setReplication, setOwner, setTimes, setWorkingDirectory,
 setPermission, getFileChecksum, setVerifyChecksum, getFileBlockLocations,
 getFsStatus, getFileStatus, exists, and listStatus.
 
 Symlink targets are stored as given to createSymlink, assuming the 
 underlying file system is capable of storing a fully qualified URI.
 Dangling symlinks are permitted. FileContext supports four types of 
 symlink targets, and resolves them as follows
 <pre>
 Given a path referring to a symlink of form:
 
   <---X---> 
   fs://host/A/B/link 
   <-----Y----->
 
 In this path X is the scheme and authority that identify the file system,
 and Y is the path leading up to the final path component "link". If Y is
 a symlink  itself then let Y' be the target of Y and X' be the scheme and
 authority of Y'. Symlink targets may:
 
 1. Fully qualified URIs
 
 fs://hostX/A/B/file  Resolved according to the target file system.
 
 2. Partially qualified URIs (eg scheme but no host)
 
 fs:///A/B/file  Resolved according to the target file system. Eg resolving
                 a symlink to hdfs:///A results in an exception because
                 HDFS URIs must be fully qualified, while a symlink to 
                 file:///A will not since Hadoop's local file systems 
                 require partially qualified URIs.
 
 3. Relative paths
 
 path  Resolves to [Y'][path]. Eg if Y resolves to hdfs://host/A and path 
       is "../B/file" then [Y'][path] is hdfs://host/B/file
 
 4. Absolute paths
 
 path  Resolves to [X'][path]. Eg if Y resolves hdfs://host/A/B and path
       is "/file" then [X][path] is hdfs://host/file
 </pre>
 
 @param target the target of the symbolic link
 @param link the path to be created that points to target
 @param createParent if true then missing parent dirs are created if 
                     false then parent must exist


 @throws AccessControlException If access is denied
 @throws FileAlreadyExistsException If file <code>linkcode> already exists
 @throws FileNotFoundException If <code>target</code> does not exist
 @throws ParentNotDirectoryException If parent of <code>link</code> is not a
           directory.
 @throws UnsupportedFileSystemException If file system for 
           <code>target</code> or <code>link</code> is not supported
 @throws IOException If an I/O error occurred]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses of the files/directories in the given path if the path is
 a directory.
 
 @param f is the path

 @return an iterator that traverses statuses of the files/directories 
         in the given path

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="listCorruptFileBlocks" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@return an iterator over the corrupt files under the given path
 (may contain duplicates if a file has more than one corrupt block)
 @throws IOException]]>
      </doc>
    </method>
    <method name="listLocatedStatus" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses of the files/directories in the given path if the path is
 a directory. 
 Return the file's status and block locations If the path is a file.
 
 If a returned status is a file, it contains the file's block locations.
 
 @param f is the path

 @return an iterator that traverses statuses of the files/directories 
         in the given path
 If any IO exception (for example the input directory gets deleted while
 listing is being executed), next() or hasNext() of the returned iterator
 may throw a RuntimeException with the io exception as the cause.

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="deleteOnExit" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Mark a path to be deleted on JVM shutdown.
 
 @param f the existing path to delete.

 @return  true if deleteOnExit is successful, otherwise false.

 @throws AccessControlException If access is denied
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="util" return="org.apache.hadoop.fs.FileContext.Util"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="resolve" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Resolves all symbolic links in the specified path.
 Returns the new path object.]]>
      </doc>
    </method>
    <method name="resolveIntermediate" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Resolves all symbolic links in the specified path leading up 
 to, but not including the final path component.
 @param f path to resolve
 @return the new path object.]]>
      </doc>
    </method>
    <method name="getStatistics" return="org.apache.hadoop.fs.FileSystem.Statistics"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Get the statistics for a particular file system
 
 @param uri
          the uri to lookup the statistics. Only scheme and authority part
          of the uri are used as the key to store and lookup.
 @return a statistics object]]>
      </doc>
    </method>
    <method name="clearStatistics"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears all the statistics stored in AbstractFileSystem, for all the file
 systems.]]>
      </doc>
    </method>
    <method name="printStatistics"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Prints the statistics to standard output. File System is identified by the
 scheme and authority.]]>
      </doc>
    </method>
    <method name="getAllStatistics" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Map of uri and statistics for each filesystem instantiated. The uri
         consists of scheme and authority for the filesystem.]]>
      </doc>
    </method>
    <method name="getDelegationTokens" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="renewer" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get delegation tokens for the file systems accessed for a given
 path.
 @param p Path for which delegations tokens are requested.
 @param renewer the account name that is allowed to renew the token.
 @return List of delegation tokens.
 @throws IOException]]>
      </doc>
    </method>
    <method name="modifyAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Modifies ACL entries of files and directories.  This method can add new ACL
 entries or modify the permissions on existing ACL entries.  All existing
 ACL entries that are not specified in this call are retained without
 changes.  (Modifications are merged into the current ACL.)

 @param path Path to modify
 @param aclSpec List<AclEntry> describing modifications
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes ACL entries from files and directories.  Other ACL entries are
 retained.

 @param path Path to modify
 @param aclSpec List<AclEntry> describing entries to remove
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeDefaultAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes all default ACL entries from files and directories.

 @param path Path to modify
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes all but the base ACL entries of files and directories.  The entries
 for user, group, and others are retained for compatibility with permission
 bits.

 @param path Path to modify
 @throws IOException if an ACL could not be removed]]>
      </doc>
    </method>
    <method name="setAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fully replaces ACL of files and directories, discarding all existing
 entries.

 @param path Path to modify
 @param aclSpec List<AclEntry> describing modifications, must include entries
   for user, group, and others for compatibility with permission bits.
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="getAclStatus" return="org.apache.hadoop.fs.permission.AclStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets the ACLs of files and directories.

 @param path Path to get
 @return RemoteIterator<AclStatus> which returns each AclStatus
 @throws IOException if an ACL could not be read]]>
      </doc>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to modify
 @param name xattr name.
 @param value xattr value.
 @throws IOException]]>
      </doc>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <param name="flag" type="java.util.EnumSet"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to modify
 @param name xattr name.
 @param value xattr value.
 @param flag xattr set flag
 @throws IOException]]>
      </doc>
    </method>
    <method name="getXAttr" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get an xattr for a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attribute
 @param name xattr name.
 @return byte[] xattr value.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattrs for a file or directory.
 Only those xattrs for which the logged-in user has permissions to view
 are returned.
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @return Map<String, byte[]> describing the XAttrs of the file or directory
 @throws IOException]]>
      </doc>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="names" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattrs for a file or directory.
 Only those xattrs for which the logged-in user has permissions to view
 are returned.
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @param names XAttr names.
 @return Map<String, byte[]> describing the XAttrs of the file or directory
 @throws IOException]]>
      </doc>
    </method>
    <method name="removeXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Remove an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to remove extended attribute
 @param name xattr name
 @throws IOException]]>
      </doc>
    </method>
    <method name="listXAttrs" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattr names for a file or directory.
 Only those xattr names which the logged-in user has permissions to view
 are returned.
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @return List<String> of the XAttr names of the file or directory
 @throws IOException]]>
      </doc>
    </method>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_PERM" type="org.apache.hadoop.fs.permission.FsPermission"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default permission for directory and symlink
 In previous versions, this default permission was also used to
 create files, so files created end up with ugo+x permission.
 See HADOOP-9155 for detail. 
 Two new constants are added to solve this, please use 
 {@link FileContext#DIR_DEFAULT_PERM} for directory, and use
 {@link FileContext#FILE_DEFAULT_PERM} for file.
 This constant is kept for compatibility.]]>
      </doc>
    </field>
    <field name="DIR_DEFAULT_PERM" type="org.apache.hadoop.fs.permission.FsPermission"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default permission for directory]]>
      </doc>
    </field>
    <field name="FILE_DEFAULT_PERM" type="org.apache.hadoop.fs.permission.FsPermission"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default permission for file]]>
      </doc>
    </field>
    <field name="SHUTDOWN_HOOK_PRIORITY" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Priority of the FileContext shutdown hook.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[The FileContext class provides an interface to the application writer for
 using the Hadoop file system.
 It provides a set of methods for the usual operation: create, open, 
 list, etc 
 
 <p>
 <b> *** Path Names *** </b>
 <p>
 
 The Hadoop file system supports a URI name space and URI names.
 It offers a forest of file systems that can be referenced using fully
 qualified URIs.
 Two common Hadoop file systems implementations are
 <ul>
 <li> the local file system: file:///path
 <li> the hdfs file system hdfs://nnAddress:nnPort/path
 </ul>
 
 While URI names are very flexible, it requires knowing the name or address
 of the server. For convenience one often wants to access the default system
 in one's environment without knowing its name/address. This has an
 additional benefit that it allows one to change one's default fs
  (e.g. admin moves application from cluster1 to cluster2).
 <p>
 
 To facilitate this, Hadoop supports a notion of a default file system.
 The user can set his default file system, although this is
 typically set up for you in your environment via your default config.
 A default file system implies a default scheme and authority; slash-relative
 names (such as /for/bar) are resolved relative to that default FS.
 Similarly a user can also have working-directory-relative names (i.e. names
 not starting with a slash). While the working directory is generally in the
 same default FS, the wd can be in a different FS.
 <p>
  Hence Hadoop path names can be one of:
  <ul>
  <li> fully qualified URI: scheme://authority/path
  <li> slash relative names: /path relative to the default file system
  <li> wd-relative names: path  relative to the working dir
  </ul>   
  Relative paths with scheme (scheme:foo/bar) are illegal.
  
  <p>
  <b>****The Role of the FileContext and configuration defaults****</b>
  <p>
  The FileContext provides file namespace context for resolving file names;
  it also contains the umask for permissions, In that sense it is like the
  per-process file-related state in Unix system.
  These two properties
  <ul> 
  <li> default file system i.e your slash)
  <li> umask
  </ul>
  in general, are obtained from the default configuration file
  in your environment,  (@see {@link Configuration}).
  
  No other configuration parameters are obtained from the default config as 
  far as the file context layer is concerned. All file system instances
  (i.e. deployments of file systems) have default properties; we call these
  server side (SS) defaults. Operation like create allow one to select many 
  properties: either pass them in as explicit parameters or use
  the SS properties.
  <p>
  The file system related SS defaults are
  <ul>
  <li> the home directory (default is "/user/userName")
  <li> the initial wd (only for local fs)
  <li> replication factor
  <li> block size
  <li> buffer size
  <li> encryptDataTransfer 
  <li> checksum option. (checksumType and  bytesPerChecksum)
  </ul>

 <p>
 <b> *** Usage Model for the FileContext class *** </b>
 <p>
 Example 1: use the default config read from the $HADOOP_CONFIG/core.xml.
   Unspecified values come from core-defaults.xml in the release jar.
  <ul>  
  <li> myFContext = FileContext.getFileContext(); // uses the default config
                                                // which has your default FS 
  <li>  myFContext.create(path, ...);
  <li>  myFContext.setWorkingDir(path)
  <li>  myFContext.open (path, ...);  
  </ul>  
 Example 2: Get a FileContext with a specific URI as the default FS
  <ul>  
  <li> myFContext = FileContext.getFileContext(URI)
  <li> myFContext.create(path, ...);
   ...
 </ul> 
 Example 3: FileContext with local file system as the default
  <ul> 
  <li> myFContext = FileContext.getLocalFSFileContext()
  <li> myFContext.create(path, ...);
  <li> ...
  </ul> 
 Example 4: Use a specific config, ignoring $HADOOP_CONFIG
  Generally you should not need use a config unless you are doing
   <ul> 
   <li> configX = someConfigSomeOnePassedToYou.
   <li> myFContext = getFileContext(configX); // configX is not changed,
                                              // is passed down 
   <li> myFContext.create(path, ...);
   <li>...
  </ul>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileContext -->
  <!-- start class org.apache.hadoop.fs.FileContext.Util -->
  <class name="FileContext.Util" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FileContext.Util"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="exists" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Does the file exist?
 Note: Avoid using this method if you already have FileStatus in hand.
 Instead reuse the FileStatus 
 @param f the  file or dir to be checked

 @throws AccessControlException If access is denied
 @throws IOException If an I/O error occurred
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="getContentSummary" return="org.apache.hadoop.fs.ContentSummary"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the {@link ContentSummary} of path f.
 @param f path

 @return the {@link ContentSummary} of path f.

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for 
         <code>f</code> is not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="files" type="org.apache.hadoop.fs.Path[]"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[See {@link #listStatus(Path[], PathFilter)}]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="filter" type="org.apache.hadoop.fs.PathFilter"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Filter files/directories in the given path using the user-supplied path
 filter.
 
 @param f is the path name
 @param filter is the user-supplied path filter

 @return an array of FileStatus objects for the files under the given path
         after applying the filter

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for 
         <code>pathPattern</code> is not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="files" type="org.apache.hadoop.fs.Path[]"/>
      <param name="filter" type="org.apache.hadoop.fs.PathFilter"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Filter files/directories in the given list of paths using user-supplied
 path filter.
 
 @param files is a list of paths
 @param filter is the filter

 @return a list of statuses for the files under the given paths after
         applying the filter

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If a file in <code>files</code> does not 
           exist
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses of the files/directories in the given path 
 if the path is a directory.
 
 @param f is the path

 @return an array that contains statuses of the files/directories 
         in the given path

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code> is
           not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="listFiles" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses and block locations of the files in the given path.
 
 If the path is a directory, 
   if recursive is false, returns files in the directory;
   if recursive is true, return files in the subtree rooted at the path.
   The subtree is traversed in the depth-first order.
 If the path is a file, return the file's status and block locations.
 Files across symbolic links are also returned.
 
 @param f is the path
 @param recursive if the subdirectories need to be traversed recursively

 @return an iterator that traverses statuses of the files
 If any IO exception (for example a sub-directory gets deleted while
 listing is being executed), next() or hasNext() of the returned iterator
 may throw a RuntimeException with the IO exception as the cause.

 @throws AccessControlException If access is denied
 @throws FileNotFoundException If <code>f</code> does not exist
 @throws UnsupportedFileSystemException If file system for <code>f</code>
         is not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="globStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pathPattern" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Return all the files that match filePattern and are not checksum
 files. Results are sorted by their names.
 
 <p>
 A filename pattern is composed of <i>regular</i> characters and
 <i>special pattern matching</i> characters, which are:

 <dl>
  <dd>
   <dl>
    <p>
    <dt> <tt> ? </tt>
    <dd> Matches any single character.

    <p>
    <dt> <tt> * </tt>
    <dd> Matches zero or more characters.

    <p>
    <dt> <tt> [<i>abc</i>] </tt>
    <dd> Matches a single character from character set
     <tt>{<i>a,b,c</i>}</tt>.

    <p>
    <dt> <tt> [<i>a</i>-<i>b</i>] </tt>
    <dd> Matches a single character from the character range
     <tt>{<i>a...b</i>}</tt>. Note: character <tt><i>a</i></tt> must be
     lexicographically less than or equal to character <tt><i>b</i></tt>.

    <p>
    <dt> <tt> [^<i>a</i>] </tt>
    <dd> Matches a single char that is not from character set or range
     <tt>{<i>a</i>}</tt>.  Note that the <tt>^</tt> character must occur
     immediately to the right of the opening bracket.

    <p>
    <dt> <tt> \<i>c</i> </tt>
    <dd> Removes (escapes) any special meaning of character <i>c</i>.

    <p>
    <dt> <tt> {ab,cd} </tt>
    <dd> Matches a string from the string set <tt>{<i>ab, cd</i>} </tt>
    
    <p>
    <dt> <tt> {ab,c{de,fh}} </tt>
    <dd> Matches a string from string set <tt>{<i>ab, cde, cfh</i>}</tt>

   </dl>
  </dd>
 </dl>

 @param pathPattern a regular expression specifying a pth pattern

 @return an array of paths that match the path pattern

 @throws AccessControlException If access is denied
 @throws UnsupportedFileSystemException If file system for 
         <code>pathPattern</code> is not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="globStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pathPattern" type="org.apache.hadoop.fs.Path"/>
      <param name="filter" type="org.apache.hadoop.fs.PathFilter"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return an array of FileStatus objects whose path names match pathPattern
 and is accepted by the user-supplied path filter. Results are sorted by
 their path names.
 Return null if pathPattern has no glob and the path does not exist.
 Return an empty array if pathPattern has a glob and no path matches it. 
 
 @param pathPattern regular expression specifying the path pattern
 @param filter user-supplied path filter

 @return an array of FileStatus objects

 @throws AccessControlException If access is denied
 @throws UnsupportedFileSystemException If file system for 
         <code>pathPattern</code> is not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server]]>
      </doc>
    </method>
    <method name="copy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy file from src to dest. See
 {@link #copy(Path, Path, boolean, boolean)}]]>
      </doc>
    </method>
    <method name="copy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteSource" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy from src to dst, optionally deleting src and overwriting dst.
 @param src
 @param dst
 @param deleteSource - delete src if true
 @param overwrite  overwrite dst if true; throw IOException if dst exists
         and overwrite is false.

 @return true if copy is successful

 @throws AccessControlException If access is denied
 @throws FileAlreadyExistsException If <code>dst</code> already exists
 @throws FileNotFoundException If <code>src</code> does not exist
 @throws ParentNotDirectoryException If parent of <code>dst</code> is not
           a directory
 @throws UnsupportedFileSystemException If file system for 
         <code>src</code> or <code>dst</code> is not supported
 @throws IOException If an I/O error occurred
 
 Exceptions applicable to file systems accessed over RPC:
 @throws RpcClientException If an exception occurred in the RPC client
 @throws RpcServerException If an exception occurred in the RPC server
 @throws UnexpectedServerException If server implementation throws 
           undeclared exception to RPC server
 
 RuntimeExceptions:
 @throws InvalidPathException If path <code>dst</code> is invalid]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility/library methods built over the basic FileContext methods.
 Since this are library functions, the oprtation are not atomic
 and some of them may partially complete if other threads are making
 changes to the same part of the name space.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileContext.Util -->
  <!-- start class org.apache.hadoop.fs.FileStatus -->
  <class name="FileStatus" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <implements name="java.lang.Comparable"/>
    <constructor name="FileStatus"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FileStatus" type="long, boolean, int, long, long, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FileStatus" type="long, boolean, int, long, long, long, org.apache.hadoop.fs.permission.FsPermission, java.lang.String, java.lang.String, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor for file systems on which symbolic links are not supported]]>
      </doc>
    </constructor>
    <constructor name="FileStatus" type="long, boolean, int, long, long, long, org.apache.hadoop.fs.permission.FsPermission, java.lang.String, java.lang.String, org.apache.hadoop.fs.Path, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FileStatus" type="org.apache.hadoop.fs.FileStatus"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy constructor.

 @param other FileStatus to copy]]>
      </doc>
    </constructor>
    <method name="getLen" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the length of this file, in bytes.
 @return the length of this file, in bytes.]]>
      </doc>
    </method>
    <method name="isFile" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Is this a file?
 @return true if this is a file]]>
      </doc>
    </method>
    <method name="isDirectory" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Is this a directory?
 @return true if this is a directory]]>
      </doc>
    </method>
    <method name="isDir" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link FileStatus#isFile()},  
 {@link FileStatus#isDirectory()}, and {@link FileStatus#isSymlink()} 
 instead.">
      <doc>
      <![CDATA[Old interface, instead use the explicit {@link FileStatus#isFile()}, 
 {@link FileStatus#isDirectory()}, and {@link FileStatus#isSymlink()} 
 @return true if this is a directory.
 @deprecated Use {@link FileStatus#isFile()},  
 {@link FileStatus#isDirectory()}, and {@link FileStatus#isSymlink()} 
 instead.]]>
      </doc>
    </method>
    <method name="isSymlink" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Is this a symbolic link?
 @return true if this is a symbolic link]]>
      </doc>
    </method>
    <method name="getBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the block size of the file.
 @return the number of bytes]]>
      </doc>
    </method>
    <method name="getReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the replication factor of a file.
 @return the replication factor of a file.]]>
      </doc>
    </method>
    <method name="getModificationTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the modification time of the file.
 @return the modification time of file in milliseconds since January 1, 1970 UTC.]]>
      </doc>
    </method>
    <method name="getAccessTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the access time of the file.
 @return the access time of file in milliseconds since January 1, 1970 UTC.]]>
      </doc>
    </method>
    <method name="getPermission" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get FsPermission associated with the file.
 @return permssion. If a filesystem does not have a notion of permissions
         or if permissions could not be determined, then default 
         permissions equivalent of "rwxrwxrwx" is returned.]]>
      </doc>
    </method>
    <method name="isEncrypted" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Tell whether the underlying file or directory is encrypted or not.

 @return true if the underlying file is encrypted.]]>
      </doc>
    </method>
    <method name="getOwner" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the owner of the file.
 @return owner of the file. The string could be empty if there is no
         notion of owner of a file in a filesystem or if it could not 
         be determined (rare).]]>
      </doc>
    </method>
    <method name="getGroup" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the group associated with the file.
 @return group for the file. The string could be empty if there is no
         notion of group of a file in a filesystem or if it could not 
         be determined (rare).]]>
      </doc>
    </method>
    <method name="getPath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <doc>
      <![CDATA[Sets permission.
 @param permission if permission is null, default value is set]]>
      </doc>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="owner" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets owner.
 @param owner if it is null, default value is set]]>
      </doc>
    </method>
    <method name="setGroup"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="group" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets group.
 @param group if it is null, default value is set]]>
      </doc>
    </method>
    <method name="getSymlink" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@return The contents of the symbolic link.]]>
      </doc>
    </method>
    <method name="setSymlink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compare this object to another object
 
 @param   o the object to be compared.
 @return  a negative integer, zero, or a positive integer as this object
   is less than, equal to, or greater than the specified object.
 
 @throws ClassCastException if the specified object's is not of 
         type FileStatus]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compare if this object is equal to another object
 @param   o the object to be compared.
 @return  true if two file status has the same path name; false if not.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash code value for the object, which is defined as
 the hash code of the path name.

 @return  a hash code value for the path name.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Interface that represents the client side information for a file.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileStatus -->
  <!-- start class org.apache.hadoop.fs.FileSystem -->
  <class name="FileSystem" extends="org.apache.hadoop.conf.Configured"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="FileSystem"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="user" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Get a filesystem instance based on the uri, the passed
 configuration and the user
 @param uri of the filesystem
 @param conf the configuration to use
 @param user to perform the get as
 @return the filesystem instance
 @throws IOException
 @throws InterruptedException]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the configured filesystem implementation.
 @param conf the configuration to use]]>
      </doc>
    </method>
    <method name="getDefaultUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the default filesystem URI from a configuration.
 @param conf the configuration to use
 @return the uri of the default filesystem]]>
      </doc>
    </method>
    <method name="setDefaultUri"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Set the default filesystem URI in a configuration.
 @param conf the configuration to alter
 @param uri the new default filesystem uri]]>
      </doc>
    </method>
    <method name="setDefaultUri"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the default filesystem URI in a configuration.
 @param conf the configuration to alter
 @param uri the new default filesystem uri]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Called after a new FileSystem instance is constructed.
 @param name a uri whose authority section names the host, port, etc.
   for this FileSystem
 @param conf the configuration]]>
      </doc>
    </method>
    <method name="getScheme" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the protocol scheme for the FileSystem.
 <p/>
 This implementation throws an <code>UnsupportedOperationException</code>.

 @return the protocol scheme for the FileSystem.]]>
      </doc>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a URI whose scheme and authority identify this FileSystem.]]>
      </doc>
    </method>
    <method name="getCanonicalUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a canonicalized form of this FileSystem's URI.
 
 The default implementation simply calls {@link #canonicalizeUri(URI)}
 on the filesystem's own URI, so subclasses typically only need to
 implement that method.

 @see #canonicalizeUri(URI)]]>
      </doc>
    </method>
    <method name="canonicalizeUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Canonicalize the given URI.
 
 This is filesystem-dependent, but may for example consist of
 canonicalizing the hostname using DNS and adding the default
 port if not specified.
 
 The default implementation simply fills in the default port if
 not specified and if the filesystem has a default port.

 @return URI
 @see NetUtils#getCanonicalUri(URI, int)]]>
      </doc>
    </method>
    <method name="getDefaultPort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the default port for this file system.
 @return the default port or 0 if there isn't one]]>
      </doc>
    </method>
    <method name="getFSofPath" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="absOrFqPath" type="org.apache.hadoop.fs.Path"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCanonicalServiceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a canonical service name for this file system.  The token cache is
 the only user of the canonical service name, and uses it to lookup this
 filesystem's service tokens.
 If file system provides a token of its own then it must have a canonical
 name, otherwise canonical name can be null.
 
 Default Impl: If the file system has child file systems 
 (such as an embedded file system) then it is assumed that the fs has no
 tokens of its own and hence returns a null name; otherwise a service
 name is built using Uri and port.
 
 @return a service string that uniquely identifies this file system, null
         if the filesystem does not implement tokens
 @see SecurityUtil#buildDTServiceName(URI, int)]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="call #getUri() instead.">
      <doc>
      <![CDATA[@deprecated call #getUri() instead.]]>
      </doc>
    </method>
    <method name="getNamed" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="call #get(URI,Configuration) instead.">
      <param name="name" type="java.lang.String"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@deprecated call #get(URI,Configuration) instead.]]>
      </doc>
    </method>
    <method name="getLocal" return="org.apache.hadoop.fs.LocalFileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the local file system.
 @param conf the configuration to configure the file system with
 @return a LocalFileSystem]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the FileSystem for this URI's scheme and authority.  The scheme
 of the URI determines a configuration property name,
 <tt>fs.<i>scheme</i>.class</tt> whose value names the FileSystem class.
 The entire URI is passed to the FileSystem instance's initialize method.]]>
      </doc>
    </method>
    <method name="newInstance" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="user" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Returns the FileSystem for this URI's scheme and authority and the 
 passed user. Internally invokes {@link #newInstance(URI, Configuration)}
 @param uri of the filesystem
 @param conf the configuration to use
 @param user to perform the get as
 @return filesystem instance
 @throws IOException
 @throws InterruptedException]]>
      </doc>
    </method>
    <method name="newInstance" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the FileSystem for this URI's scheme and authority.  The scheme
 of the URI determines a configuration property name,
 <tt>fs.<i>scheme</i>.class</tt> whose value names the FileSystem class.
 The entire URI is passed to the FileSystem instance's initialize method.
 This always returns a new FileSystem object.]]>
      </doc>
    </method>
    <method name="newInstance" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a unique configured filesystem implementation.
 This always returns a new FileSystem object.
 @param conf the configuration to use]]>
      </doc>
    </method>
    <method name="newInstanceLocal" return="org.apache.hadoop.fs.LocalFileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a unique local file system object
 @param conf the configuration to configure the file system with
 @return a LocalFileSystem
 This always returns a new FileSystem object.]]>
      </doc>
    </method>
    <method name="closeAll"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close all cached filesystems. Be sure those filesystems are not
 used anymore.
 
 @throws IOException]]>
      </doc>
    </method>
    <method name="closeAllForUGI"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ugi" type="org.apache.hadoop.security.UserGroupInformation"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close all cached filesystems for a given UGI. Be sure those filesystems 
 are not used anymore.
 @param ugi user group info to close
 @throws IOException]]>
      </doc>
    </method>
    <method name="makeQualified" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Make sure that a path specifies a FileSystem.
 @param path to use]]>
      </doc>
    </method>
    <method name="getDelegationToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="renewer" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a new delegation token for this file system.
 This is an internal method that should have been declared protected
 but wasn't historically.
 Callers should use {@link #addDelegationTokens(String, Credentials)}
 
 @param renewer the account name that is allowed to renew the token.
 @return a new delegation token
 @throws IOException]]>
      </doc>
    </method>
    <method name="addDelegationTokens" return="org.apache.hadoop.security.token.Token[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="renewer" type="java.lang.String"/>
      <param name="credentials" type="org.apache.hadoop.security.Credentials"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Obtain all delegation tokens used by this FileSystem that are not
 already present in the given Credentials.  Existing tokens will neither
 be verified as valid nor having the given renewer.  Missing tokens will
 be acquired and added to the given Credentials.
 
 Default Impl: works for simple fs with its own token
 and also for an embedded fs whose tokens are those of its
 children file system (i.e. the embedded fs has not tokens of its
 own).
 
 @param renewer the user allowed to renew the delegation tokens
 @param credentials cache in which to add new delegation tokens
 @return list of new delegation tokens
 @throws IOException]]>
      </doc>
    </method>
    <method name="getChildFileSystems" return="org.apache.hadoop.fs.FileSystem[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get all the immediate child FileSystems embedded in this FileSystem.
 It does not recurse and get grand children.  If a FileSystem
 has multiple child FileSystems, then it should return a unique list
 of those FileSystems.  Default is to return null to signify no children.
 
 @return FileSystems used by this FileSystem]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[create a file with the provided permission
 The permission of the file is set to be the provided permission as in
 setPermission, not permission&~umask
 
 It is implemented using two RPCs. It is understood that it is inefficient,
 but the implementation is thread-safe. The other option is to change the
 value of umask in configuration to be 0, but it is not thread-safe.
 
 @param fs file system handle
 @param file the name of the file to be created
 @param permission the permission of the file
 @return an output stream
 @throws IOException]]>
      </doc>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dir" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[create a directory with the provided permission
 The permission of the directory is set to be the provided permission as in
 setPermission, not permission&~umask
 
 @see #create(FileSystem, Path, FsPermission)
 
 @param fs file system handle
 @param dir the name of the directory to be created
 @param permission the permission of the directory
 @return true if the directory creation succeeds; false otherwise
 @throws IOException]]>
      </doc>
    </method>
    <method name="checkPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Check that a Path belongs to this FileSystem.
 @param path to check]]>
      </doc>
    </method>
    <method name="getFileBlockLocations" return="org.apache.hadoop.fs.BlockLocation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.FileStatus"/>
      <param name="start" type="long"/>
      <param name="len" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return an array containing hostnames, offset and size of 
 portions of the given file.  For a nonexistent 
 file or regions, null will be returned.

 This call is most helpful with DFS, where it returns 
 hostnames of machines that contain the given file.

 The FileSystem will simply return an elt containing 'localhost'.

 @param file FilesStatus to get data from
 @param start offset into the given file
 @param len length for which to get locations for]]>
      </doc>
    </method>
    <method name="getFileBlockLocations" return="org.apache.hadoop.fs.BlockLocation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="start" type="long"/>
      <param name="len" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return an array containing hostnames, offset and size of 
 portions of the given file.  For a nonexistent 
 file or regions, null will be returned.

 This call is most helpful with DFS, where it returns 
 hostnames of machines that contain the given file.

 The FileSystem will simply return an elt containing 'localhost'.

 @param p path is used to identify an FS since an FS could have
          another FS that it could be delegating the call to
 @param start offset into the given file
 @param len length for which to get locations for]]>
      </doc>
    </method>
    <method name="getServerDefaults" return="org.apache.hadoop.fs.FsServerDefaults"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #getServerDefaults(Path)} instead">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a set of server default configuration values
 @return server default configuration values
 @throws IOException
 @deprecated use {@link #getServerDefaults(Path)} instead]]>
      </doc>
    </method>
    <method name="getServerDefaults" return="org.apache.hadoop.fs.FsServerDefaults"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a set of server default configuration values
 @param p path is used to identify an FS since an FS could have
          another FS that it could be delegating the call to
 @return server default configuration values
 @throws IOException]]>
      </doc>
    </method>
    <method name="resolvePath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the fully-qualified path of path f resolving the path
 through any symlinks or mount point
 @param p path to be resolved
 @return fully qualified path 
 @throws FileNotFoundException]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataInputStream at the indicated Path.
 @param f the file name to open
 @param bufferSize the size of the buffer to be used.]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataInputStream at the indicated Path.
 @param f the file to open]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path.
 Files are overwritten by default.
 @param f the file to create]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path.
 @param f the file to create
 @param overwrite if a file with this name already exists, then if true,
   the file will be overwritten, and if false an exception will be thrown.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path with write-progress
 reporting.
 Files are overwritten by default.
 @param f the file to create
 @param progress to report progress]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path.
 Files are overwritten by default.
 @param f the file to create
 @param replication the replication factor]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path with write-progress
 reporting.
 Files are overwritten by default.
 @param f the file to create
 @param replication the replication factor
 @param progress to report progress]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path.
 @param f the file name to create
 @param overwrite if a file with this name already exists, then if true,
   the file will be overwritten, and if false an error will be thrown.
 @param bufferSize the size of the buffer to be used.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path with write-progress
 reporting.
 @param f the path of the file to open
 @param overwrite if a file with this name already exists, then if true,
   the file will be overwritten, and if false an error will be thrown.
 @param bufferSize the size of the buffer to be used.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path.
 @param f the file name to open
 @param overwrite if a file with this name already exists, then if true,
   the file will be overwritten, and if false an error will be thrown.
 @param bufferSize the size of the buffer to be used.
 @param replication required block replication for the file.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path with write-progress
 reporting.
 @param f the file name to open
 @param overwrite if a file with this name already exists, then if true,
   the file will be overwritten, and if false an error will be thrown.
 @param bufferSize the size of the buffer to be used.
 @param replication required block replication for the file.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path with write-progress
 reporting.
 @param f the file name to open
 @param permission
 @param overwrite if a file with this name already exists, then if true,
   the file will be overwritten, and if false an error will be thrown.
 @param bufferSize the size of the buffer to be used.
 @param replication required block replication for the file.
 @param blockSize
 @param progress
 @throws IOException
 @see #setPermission(Path, FsPermission)]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flags" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path with write-progress
 reporting.
 @param f the file name to open
 @param permission
 @param flags {@link CreateFlag}s to use for this stream.
 @param bufferSize the size of the buffer to be used.
 @param replication required block replication for the file.
 @param blockSize
 @param progress
 @throws IOException
 @see #setPermission(Path, FsPermission)]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flags" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="checksumOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create an FSDataOutputStream at the indicated Path with a custom
 checksum option
 @param f the file name to open
 @param permission
 @param flags {@link CreateFlag}s to use for this stream.
 @param bufferSize the size of the buffer to be used.
 @param replication required block replication for the file.
 @param blockSize
 @param progress
 @param checksumOpt checksum parameter. If null, the values
        found in conf will be used.
 @throws IOException
 @see #setPermission(Path, FsPermission)]]>
      </doc>
    </method>
    <method name="primitiveCreate" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="absolutePermission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flag" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="checksumOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="primitiveMkdir" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="absolutePermission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This version of the mkdirs method assumes that the permission is absolute.
 It has been added to support the FileContext that processes the permission
 with umask before calling this method.
 This a temporary method added to support the transition from FileSystem
 to FileContext for user applications.]]>
      </doc>
    </method>
    <method name="primitiveMkdir"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="absolutePermission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="createParent" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This version of the mkdirs method assumes that the permission is absolute.
 It has been added to support the FileContext that processes the permission
 with umask before calling this method.
 This a temporary method added to support the transition from FileSystem
 to FileContext for user applications.]]>
      </doc>
    </method>
    <method name="createNonRecursive" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="API only for 0.20-append">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataOutputStream at the indicated Path with write-progress
 reporting. Same as create(), except fails if parent directory doesn't
 already exist.
 @param f the file name to open
 @param overwrite if a file with this name already exists, then if true,
 the file will be overwritten, and if false an error will be thrown.
 @param bufferSize the size of the buffer to be used.
 @param replication required block replication for the file.
 @param blockSize
 @param progress
 @throws IOException
 @see #setPermission(Path, FsPermission)
 @deprecated API only for 0.20-append]]>
      </doc>
    </method>
    <method name="createNonRecursive" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="API only for 0.20-append">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataOutputStream at the indicated Path with write-progress
 reporting. Same as create(), except fails if parent directory doesn't
 already exist.
 @param f the file name to open
 @param permission
 @param overwrite if a file with this name already exists, then if true,
 the file will be overwritten, and if false an error will be thrown.
 @param bufferSize the size of the buffer to be used.
 @param replication required block replication for the file.
 @param blockSize
 @param progress
 @throws IOException
 @see #setPermission(Path, FsPermission)
 @deprecated API only for 0.20-append]]>
      </doc>
    </method>
    <method name="createNonRecursive" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="API only for 0.20-append">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flags" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataOutputStream at the indicated Path with write-progress
 reporting. Same as create(), except fails if parent directory doesn't
 already exist.
 @param f the file name to open
 @param permission
 @param flags {@link CreateFlag}s to use for this stream.
 @param bufferSize the size of the buffer to be used.
 @param replication required block replication for the file.
 @param blockSize
 @param progress
 @throws IOException
 @see #setPermission(Path, FsPermission)
 @deprecated API only for 0.20-append]]>
      </doc>
    </method>
    <method name="createNewFile" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates the given Path as a brand-new zero-length file.  If
 create fails, or if it already existed, return false.

 @param f path to use for create]]>
      </doc>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Append to an existing file (optional operation).
 Same as append(f, getConf().getInt("io.file.buffer.size", 4096), null)
 @param f the existing file to be appended.
 @throws IOException]]>
      </doc>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Append to an existing file (optional operation).
 Same as append(f, bufferSize, null).
 @param f the existing file to be appended.
 @param bufferSize the size of the buffer to be used.
 @throws IOException]]>
      </doc>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Append to an existing file (optional operation).
 @param f the existing file to be appended.
 @param bufferSize the size of the buffer to be used.
 @param progress for reporting progress if it is not null.
 @throws IOException]]>
      </doc>
    </method>
    <method name="concat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="trg" type="org.apache.hadoop.fs.Path"/>
      <param name="psrcs" type="org.apache.hadoop.fs.Path[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Concat existing files together.
 @param trg the path to the target destination.
 @param psrcs the paths to the sources to use for the concatenation.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use getFileStatus() instead">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get replication.
 
 @deprecated Use getFileStatus() instead
 @param src file name
 @return file replication
 @throws IOException]]>
      </doc>
    </method>
    <method name="setReplication" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set replication for an existing file.
 
 @param src file name
 @param replication new replication
 @throws IOException
 @return true if successful;
         false if file does not exist or is a directory]]>
      </doc>
    </method>
    <method name="rename" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Renames Path src to Path dst.  Can take place on local fs
 or remote DFS.
 @param src path to be renamed
 @param dst new path after rename
 @throws IOException on failure
 @return true if rename is successful]]>
      </doc>
    </method>
    <method name="rename"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="options" type="org.apache.hadoop.fs.Options.Rename[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Renames Path src to Path dst
 <ul>
 <li
 <li>Fails if src is a file and dst is a directory.
 <li>Fails if src is a directory and dst is a file.
 <li>Fails if the parent of dst does not exist or is a file.
 </ul>
 <p>
 If OVERWRITE option is not passed as an argument, rename fails
 if the dst already exists.
 <p>
 If OVERWRITE option is passed as an argument, rename overwrites
 the dst if it is a file or an empty directory. Rename fails if dst is
 a non-empty directory.
 <p>
 Note that atomicity of rename is dependent on the file system
 implementation. Please refer to the file system documentation for
 details. This default implementation is non atomic.
 <p>
 This method is deprecated since it is a temporary method added to 
 support the transition from FileSystem to FileContext for user 
 applications.
 
 @param src path to be renamed
 @param dst new path after rename
 @throws IOException on failure]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #delete(Path, boolean)} instead.">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete a file 
 @deprecated Use {@link #delete(Path, boolean)} instead.]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete a file.

 @param f the path to delete.
 @param recursive if path is a directory and set to 
 true, the directory is deleted else throws an exception. In
 case of a file the recursive can be set to either true or false. 
 @return  true if delete is successful else false. 
 @throws IOException]]>
      </doc>
    </method>
    <method name="deleteOnExit" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Mark a path to be deleted when FileSystem is closed.
 When the JVM shuts down,
 all FileSystem objects will be closed automatically.
 Then,
 the marked path will be deleted as a result of closing the FileSystem.

 The path has to exist in the file system.
 
 @param f the path to delete.
 @return  true if deleteOnExit is successful, otherwise false.
 @throws IOException]]>
      </doc>
    </method>
    <method name="cancelDeleteOnExit" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Cancel the deletion of the path when the FileSystem is closed
 @param f the path to cancel deletion]]>
      </doc>
    </method>
    <method name="processDeleteOnExit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Delete all files that were marked as delete-on-exit. This recursively
 deletes all files in the specified paths.]]>
      </doc>
    </method>
    <method name="exists" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Check if exists.
 @param f source file]]>
      </doc>
    </method>
    <method name="isDirectory" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[True iff the named path is a directory.
 Note: Avoid using this method. Instead reuse the FileStatus 
 returned by getFileStatus() or listStatus() methods.
 @param f path to check]]>
      </doc>
    </method>
    <method name="isFile" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[True iff the named path is a regular file.
 Note: Avoid using this method. Instead reuse the FileStatus 
 returned by getFileStatus() or listStatus() methods.
 @param f path to check]]>
      </doc>
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use getFileStatus() instead">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@deprecated Use getFileStatus() instead]]>
      </doc>
    </method>
    <method name="getContentSummary" return="org.apache.hadoop.fs.ContentSummary"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the {@link ContentSummary} of a given {@link Path}.
 @param f path to use]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses of the files/directories in the given path if the path is
 a directory.
 
 @param f given path
 @return the statuses of the files/directories in the given patch
 @throws FileNotFoundException when the path does not exist;
         IOException see specific implementation]]>
      </doc>
    </method>
    <method name="listCorruptFileBlocks" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@return an iterator over the corrupt files under the given path
 (may contain duplicates if a file has more than one corrupt block)
 @throws IOException]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="filter" type="org.apache.hadoop.fs.PathFilter"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Filter files/directories in the given path using the user-supplied path
 filter.
 
 @param f
          a path name
 @param filter
          the user-supplied path filter
 @return an array of FileStatus objects for the files under the given path
         after applying the filter
 @throws FileNotFoundException when the path does not exist;
         IOException see specific implementation]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="files" type="org.apache.hadoop.fs.Path[]"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Filter files/directories in the given list of paths using default
 path filter.
 
 @param files
          a list of paths
 @return a list of statuses for the files under the given paths after
         applying the filter default Path filter
 @throws FileNotFoundException when the path does not exist;
         IOException see specific implementation]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="files" type="org.apache.hadoop.fs.Path[]"/>
      <param name="filter" type="org.apache.hadoop.fs.PathFilter"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Filter files/directories in the given list of paths using user-supplied
 path filter.
 
 @param files
          a list of paths
 @param filter
          the user-supplied path filter
 @return a list of statuses for the files under the given paths after
         applying the filter
 @throws FileNotFoundException when the path does not exist;
         IOException see specific implementation]]>
      </doc>
    </method>
    <method name="globStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pathPattern" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[<p>Return all the files that match filePattern and are not checksum
 files. Results are sorted by their names.
 
 <p>
 A filename pattern is composed of <i>regular</i> characters and
 <i>special pattern matching</i> characters, which are:

 <dl>
  <dd>
   <dl>
    <p>
    <dt> <tt> ? </tt>
    <dd> Matches any single character.

    <p>
    <dt> <tt> * </tt>
    <dd> Matches zero or more characters.

    <p>
    <dt> <tt> [<i>abc</i>] </tt>
    <dd> Matches a single character from character set
     <tt>{<i>a,b,c</i>}</tt>.

    <p>
    <dt> <tt> [<i>a</i>-<i>b</i>] </tt>
    <dd> Matches a single character from the character range
     <tt>{<i>a...b</i>}</tt>.  Note that character <tt><i>a</i></tt> must be
     lexicographically less than or equal to character <tt><i>b</i></tt>.

    <p>
    <dt> <tt> [^<i>a</i>] </tt>
    <dd> Matches a single character that is not from character set or range
     <tt>{<i>a</i>}</tt>.  Note that the <tt>^</tt> character must occur
     immediately to the right of the opening bracket.

    <p>
    <dt> <tt> \<i>c</i> </tt>
    <dd> Removes (escapes) any special meaning of character <i>c</i>.

    <p>
    <dt> <tt> {ab,cd} </tt>
    <dd> Matches a string from the string set <tt>{<i>ab, cd</i>} </tt>
    
    <p>
    <dt> <tt> {ab,c{de,fh}} </tt>
    <dd> Matches a string from the string set <tt>{<i>ab, cde, cfh</i>}</tt>

   </dl>
  </dd>
 </dl>

 @param pathPattern a regular expression specifying a pth pattern

 @return an array of paths that match the path pattern
 @throws IOException]]>
      </doc>
    </method>
    <method name="globStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pathPattern" type="org.apache.hadoop.fs.Path"/>
      <param name="filter" type="org.apache.hadoop.fs.PathFilter"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return an array of FileStatus objects whose path names match pathPattern
 and is accepted by the user-supplied path filter. Results are sorted by
 their path names.
 Return null if pathPattern has no glob and the path does not exist.
 Return an empty array if pathPattern has a glob and no path matches it. 
 
 @param pathPattern
          a regular expression specifying the path pattern
 @param filter
          a user-supplied path filter
 @return an array of FileStatus objects
 @throws IOException if any I/O error occurs when fetching file status]]>
      </doc>
    </method>
    <method name="listLocatedStatus" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses of the files/directories in the given path if the path is
 a directory. 
 Return the file's status and block locations If the path is a file.
 
 If a returned status is a file, it contains the file's block locations.
 
 @param f is the path

 @return an iterator that traverses statuses of the files/directories 
         in the given path

 @throws FileNotFoundException If <code>f</code> does not exist
 @throws IOException If an I/O error occurred]]>
      </doc>
    </method>
    <method name="listLocatedStatus" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="filter" type="org.apache.hadoop.fs.PathFilter"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Listing a directory
 The returned results include its block location if it is a file
 The results are filtered by the given path filter
 @param f a path
 @param filter a path filter
 @return an iterator that traverses statuses of the files/directories 
         in the given path
 @throws FileNotFoundException if <code>f</code> does not exist
 @throws IOException if any I/O error occurred]]>
      </doc>
    </method>
    <method name="listFiles" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses and block locations of the files in the given path.
 
 If the path is a directory, 
   if recursive is false, returns files in the directory;
   if recursive is true, return files in the subtree rooted at the path.
 If the path is a file, return the file's status and block locations.
 
 @param f is the path
 @param recursive if the subdirectories need to be traversed recursively

 @return an iterator that traverses statuses of the files

 @throws FileNotFoundException when the path does not exist;
         IOException see specific implementation]]>
      </doc>
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the current user's home directory in this filesystem.
 The default implementation returns "/user/$USER/".]]>
      </doc>
    </method>
    <method name="setWorkingDirectory"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="new_dir" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Set the current working directory for the given file system. All relative
 paths will be resolved relative to it.
 
 @param new_dir]]>
      </doc>
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current working directory for the given file system
 @return the directory pathname]]>
      </doc>
    </method>
    <method name="getInitialWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Note: with the new FilesContext class, getWorkingDirectory()
 will be removed. 
 The working directory is implemented in FilesContext.
 
 Some file systems like LocalFileSystem have an initial workingDir
 that we use as the starting workingDir. For other file systems
 like HDFS there is no built in notion of an initial workingDir.
 
 @return if there is built in notion of workingDir then it
 is returned; else a null is returned.]]>
      </doc>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Call {@link #mkdirs(Path, FsPermission)} with default permission.]]>
      </doc>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Make the given file and all non-existent parents into
 directories. Has the semantics of Unix 'mkdir -p'.
 Existence of the directory hierarchy is not an error.
 @param f path to create
 @param permission to apply to f]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is on the local disk.  Add it to FS at
 the given dst name and the source is kept intact afterwards
 @param src path
 @param dst path]]>
      </doc>
    </method>
    <method name="moveFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcs" type="org.apache.hadoop.fs.Path[]"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src files is on the local disk.  Add it to FS at
 the given dst name, removing the source afterwards.
 @param srcs path
 @param dst path]]>
      </doc>
    </method>
    <method name="moveFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is on the local disk.  Add it to FS at
 the given dst name, removing the source afterwards.
 @param src path
 @param dst path]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is on the local disk.  Add it to FS at
 the given dst name.
 delSrc indicates if the source should be removed
 @param delSrc whether to delete the src
 @param src path
 @param dst path]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <param name="srcs" type="org.apache.hadoop.fs.Path[]"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src files are on the local disk.  Add it to FS at
 the given dst name.
 delSrc indicates if the source should be removed
 @param delSrc whether to delete the src
 @param overwrite whether to overwrite an existing file
 @param srcs array of paths which are source
 @param dst path]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is on the local disk.  Add it to FS at
 the given dst name.
 delSrc indicates if the source should be removed
 @param delSrc whether to delete the src
 @param overwrite whether to overwrite an existing file
 @param src path
 @param dst path]]>
      </doc>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under FS, and the dst is on the local disk.
 Copy it from FS control to the local dst name.
 @param src path
 @param dst path]]>
      </doc>
    </method>
    <method name="moveToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under FS, and the dst is on the local disk.
 Copy it from FS control to the local dst name.
 Remove the source afterwards
 @param src path
 @param dst path]]>
      </doc>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under FS, and the dst is on the local disk.
 Copy it from FS control to the local dst name.
 delSrc indicates if the src will be removed or not.
 @param delSrc whether to delete the src
 @param src path
 @param dst path]]>
      </doc>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="useRawLocalFileSystem" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under FS, and the dst is on the local disk. Copy it from FS
 control to the local dst name. delSrc indicates if the src will be removed
 or not. useRawLocalFileSystem indicates whether to use RawLocalFileSystem
 as local file system or not. RawLocalFileSystem is non crc file system.So,
 It will not create any crc files at local.
 
 @param delSrc
          whether to delete the src
 @param src
          path
 @param dst
          path
 @param useRawLocalFileSystem
          whether to use RawLocalFileSystem as local file system or not.
 
 @throws IOException
           - if any IO error]]>
      </doc>
    </method>
    <method name="startLocalOutput" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a local File that the user can write output to.  The caller
 provides both the eventual FS target name and the local working
 file.  If the FS is local, we write directly into the target.  If
 the FS is remote, we write into the tmp local area.
 @param fsOutputFile path of output file
 @param tmpLocalFile path of local tmp file]]>
      </doc>
    </method>
    <method name="completeLocalOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Called when we're all done writing to the target.  A local FS will
 do nothing, because we've written to exactly the right place.  A remote
 FS will copy the contents of tmpLocalFile to the correct target at
 fsOutputFile.
 @param fsOutputFile path of output file
 @param tmpLocalFile path to local tmp file]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[No more filesystem operations are needed.  Will
 release any held locks.]]>
      </doc>
    </method>
    <method name="getUsed" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the total size of all files in the filesystem.]]>
      </doc>
    </method>
    <method name="getBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use getFileStatus() instead">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@deprecated Use getFileStatus() instead]]>
      </doc>
    </method>
    <method name="getDefaultBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #getDefaultBlockSize(Path)} instead">
      <doc>
      <![CDATA[Return the number of bytes that large input files should be optimally
 be split into to minimize i/o time.
 @deprecated use {@link #getDefaultBlockSize(Path)} instead]]>
      </doc>
    </method>
    <method name="getDefaultBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Return the number of bytes that large input files should be optimally
 be split into to minimize i/o time.  The given path will be used to
 locate the actual filesystem.  The full path does not have to exist.
 @param f path of file
 @return the default block size for the path's filesystem]]>
      </doc>
    </method>
    <method name="getDefaultReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #getDefaultReplication(Path)} instead">
      <doc>
      <![CDATA[Get the default replication.
 @deprecated use {@link #getDefaultReplication(Path)} instead]]>
      </doc>
    </method>
    <method name="getDefaultReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Get the default replication for a path.   The given path will be used to
 locate the actual filesystem.  The full path does not have to exist.
 @param path of the file
 @return default replication for the path's filesystem]]>
      </doc>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a file status object that represents the path.
 @param f The path we want information from
 @return a FileStatus object
 @throws FileNotFoundException when the path does not exist;
         IOException see specific implementation]]>
      </doc>
    </method>
    <method name="access"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="mode" type="org.apache.hadoop.fs.permission.FsAction"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Checks if the user can access a path.  The mode specifies which access
 checks to perform.  If the requested permissions are granted, then the
 method returns normally.  If access is denied, then the method throws an
 {@link AccessControlException}.
 <p/>
 The default implementation of this method calls {@link #getFileStatus(Path)}
 and checks the returned permissions against the requested permissions.
 Note that the getFileStatus call will be subject to authorization checks.
 Typically, this requires search (execute) permissions on each directory in
 the path's prefix, but this is implementation-defined.  Any file system
 that provides a richer authorization model (such as ACLs) may override the
 default implementation so that it checks against that model instead.
 <p>
 In general, applications should avoid using this method, due to the risk of
 time-of-check/time-of-use race conditions.  The permissions on a file may
 change immediately after the access call returns.  Most applications should
 prefer running specific file system actions as the desired user represented
 by a {@link UserGroupInformation}.

 @param path Path to check
 @param mode type of access to check
 @throws AccessControlException if access is denied
 @throws FileNotFoundException if the path does not exist
 @throws IOException see specific implementation]]>
      </doc>
    </method>
    <method name="fixRelativePart" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[See {@link FileContext#fixRelativePart}]]>
      </doc>
    </method>
    <method name="createSymlink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.apache.hadoop.fs.Path"/>
      <param name="link" type="org.apache.hadoop.fs.Path"/>
      <param name="createParent" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[See {@link FileContext#createSymlink(Path, Path, boolean)}]]>
      </doc>
    </method>
    <method name="getFileLinkStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[See {@link FileContext#getFileLinkStatus(Path)}]]>
      </doc>
    </method>
    <method name="supportsSymlinks" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[See {@link AbstractFileSystem#supportsSymlinks()}]]>
      </doc>
    </method>
    <method name="getLinkTarget" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[See {@link FileContext#getLinkTarget(Path)}]]>
      </doc>
    </method>
    <method name="resolveLink" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[See {@link AbstractFileSystem#getLinkTarget(Path)}]]>
      </doc>
    </method>
    <method name="getFileChecksum" return="org.apache.hadoop.fs.FileChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the checksum of a file.

 @param f The file path
 @return The file checksum.  The default return value is null,
  which indicates that no checksum algorithm is implemented
  in the corresponding FileSystem.]]>
      </doc>
    </method>
    <method name="getFileChecksum" return="org.apache.hadoop.fs.FileChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="length" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the checksum of a file, from the beginning of the file till the
 specific length.
 @param f The file path
 @param length The length of the file range for checksum calculation
 @return The file checksum.]]>
      </doc>
    </method>
    <method name="setVerifyChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="verifyChecksum" type="boolean"/>
      <doc>
      <![CDATA[Set the verify checksum flag. This is only applicable if the 
 corresponding FileSystem supports checksum. By default doesn't do anything.
 @param verifyChecksum]]>
      </doc>
    </method>
    <method name="setWriteChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writeChecksum" type="boolean"/>
      <doc>
      <![CDATA[Set the write checksum flag. This is only applicable if the 
 corresponding FileSystem supports checksum. By default doesn't do anything.
 @param writeChecksum]]>
      </doc>
    </method>
    <method name="getStatus" return="org.apache.hadoop.fs.FsStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a status object describing the use and capacity of the
 file system. If the file system has multiple partitions, the
 use and capacity of the root partition is reflected.
 
 @return a FsStatus object
 @throws IOException
           see specific implementation]]>
      </doc>
    </method>
    <method name="getStatus" return="org.apache.hadoop.fs.FsStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a status object describing the use and capacity of the
 file system. If the file system has multiple partitions, the
 use and capacity of the partition pointed to by the specified
 path is reflected.
 @param p Path for which status should be obtained. null means
 the default partition. 
 @return a FsStatus object
 @throws IOException
           see specific implementation]]>
      </doc>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set permission of a path.
 @param p
 @param permission]]>
      </doc>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set owner of a path (i.e. a file or a directory).
 The parameters username and groupname cannot both be null.
 @param p The path
 @param username If it is null, the original username remains unchanged.
 @param groupname If it is null, the original groupname remains unchanged.]]>
      </doc>
    </method>
    <method name="setTimes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="mtime" type="long"/>
      <param name="atime" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set access time of a file
 @param p The path
 @param mtime Set the modification time of this file.
              The number of milliseconds since Jan 1, 1970. 
              A value of -1 means that this call should not set modification time.
 @param atime Set the access time of this file.
              The number of milliseconds since Jan 1, 1970. 
              A value of -1 means that this call should not set access time.]]>
      </doc>
    </method>
    <method name="createSnapshot" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a snapshot with a default name.
 @param path The directory where snapshots will be taken.
 @return the snapshot path.]]>
      </doc>
    </method>
    <method name="createSnapshot" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a snapshot
 @param path The directory where snapshots will be taken.
 @param snapshotName The name of the snapshot
 @return the snapshot path.]]>
      </doc>
    </method>
    <method name="renameSnapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotOldName" type="java.lang.String"/>
      <param name="snapshotNewName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Rename a snapshot
 @param path The directory path where the snapshot was taken
 @param snapshotOldName Old name of the snapshot
 @param snapshotNewName New name of the snapshot
 @throws IOException]]>
      </doc>
    </method>
    <method name="deleteSnapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete a snapshot of a directory
 @param path  The directory that the to-be-deleted snapshot belongs to
 @param snapshotName The name of the snapshot]]>
      </doc>
    </method>
    <method name="modifyAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Modifies ACL entries of files and directories.  This method can add new ACL
 entries or modify the permissions on existing ACL entries.  All existing
 ACL entries that are not specified in this call are retained without
 changes.  (Modifications are merged into the current ACL.)

 @param path Path to modify
 @param aclSpec List<AclEntry> describing modifications
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes ACL entries from files and directories.  Other ACL entries are
 retained.

 @param path Path to modify
 @param aclSpec List<AclEntry> describing entries to remove
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeDefaultAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes all default ACL entries from files and directories.

 @param path Path to modify
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes all but the base ACL entries of files and directories.  The entries
 for user, group, and others are retained for compatibility with permission
 bits.

 @param path Path to modify
 @throws IOException if an ACL could not be removed]]>
      </doc>
    </method>
    <method name="setAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fully replaces ACL of files and directories, discarding all existing
 entries.

 @param path Path to modify
 @param aclSpec List<AclEntry> describing modifications, must include entries
   for user, group, and others for compatibility with permission bits.
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="getAclStatus" return="org.apache.hadoop.fs.permission.AclStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets the ACL of a file or directory.

 @param path Path to get
 @return AclStatus describing the ACL of the file or directory
 @throws IOException if an ACL could not be read]]>
      </doc>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to modify
 @param name xattr name.
 @param value xattr value.
 @throws IOException]]>
      </doc>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <param name="flag" type="java.util.EnumSet"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to modify
 @param name xattr name.
 @param value xattr value.
 @param flag xattr set flag
 @throws IOException]]>
      </doc>
    </method>
    <method name="getXAttr" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get an xattr name and value for a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attribute
 @param name xattr name.
 @return byte[] xattr value.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattr name/value pairs for a file or directory.
 Only those xattrs which the logged-in user has permissions to view
 are returned.
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @return Map<String, byte[]> describing the XAttrs of the file or directory
 @throws IOException]]>
      </doc>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="names" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattrs name/value pairs for a file or directory.
 Only those xattrs which the logged-in user has permissions to view
 are returned.
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @param names XAttr names.
 @return Map<String, byte[]> describing the XAttrs of the file or directory
 @throws IOException]]>
      </doc>
    </method>
    <method name="listXAttrs" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattr names for a file or directory.
 Only those xattr names which the logged-in user has permissions to view
 are returned.
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @return List<String> of the XAttr names of the file or directory
 @throws IOException]]>
      </doc>
    </method>
    <method name="removeXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Remove an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p/>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to remove extended attribute
 @param name xattr name
 @throws IOException]]>
      </doc>
    </method>
    <method name="getFileSystemClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scheme" type="java.lang.String"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getStatistics" return="java.util.Map"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="use {@link #getAllStatistics} instead">
      <doc>
      <![CDATA[Get the Map of Statistics object indexed by URI Scheme.
 @return a Map having a key as URI scheme and value as Statistics object
 @deprecated use {@link #getAllStatistics} instead]]>
      </doc>
    </method>
    <method name="getAllStatistics" return="java.util.List"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the FileSystem classes that have Statistics]]>
      </doc>
    </method>
    <method name="getStatistics" return="org.apache.hadoop.fs.FileSystem.Statistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scheme" type="java.lang.String"/>
      <param name="cls" type="java.lang.Class"/>
      <doc>
      <![CDATA[Get the statistics for a particular file system
 @param cls the class to lookup
 @return a statistics object]]>
      </doc>
    </method>
    <method name="clearStatistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reset all statistics for all file systems]]>
      </doc>
    </method>
    <method name="printStatistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Print all statistics for all file systems]]>
      </doc>
    </method>
    <method name="areSymlinksEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="enableSymlinks"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="FS_DEFAULT_NAME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_FS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SHUTDOWN_HOOK_PRIORITY" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Priority of the FileSystem shutdown hook.]]>
      </doc>
    </field>
    <field name="statistics" type="org.apache.hadoop.fs.FileSystem.Statistics"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The statistics for this file system.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[An abstract base class for a fairly generic filesystem.  It
 may be implemented as a distributed filesystem, or as a "local"
 one that reflects the locally-connected disk.  The local version
 exists for small Hadoop instances and for testing.

 <p>

 All user code that may potentially use the Hadoop Distributed
 File System should be written to use a FileSystem object.  The
 Hadoop DFS is a multi-machine system that appears as a single
 disk.  It's useful because of its fault tolerance and potentially
 very large capacity.
 
 <p>
 The local implementation is {@link LocalFileSystem} and distributed
 implementation is DistributedFileSystem.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileSystem -->
  <!-- start class org.apache.hadoop.fs.FileSystem.Statistics -->
  <class name="FileSystem.Statistics" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="FileSystem.Statistics" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FileSystem.Statistics" type="org.apache.hadoop.fs.FileSystem.Statistics"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Copy constructor.
 
 @param other    The input Statistics object which is cloned.]]>
      </doc>
    </constructor>
    <method name="getThreadStatistics" return="org.apache.hadoop.fs.FileSystem.Statistics.StatisticsData"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get or create the thread-local data associated with the current thread.]]>
      </doc>
    </method>
    <method name="incrementBytesRead"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newBytes" type="long"/>
      <doc>
      <![CDATA[Increment the bytes read in the statistics
 @param newBytes the additional bytes read]]>
      </doc>
    </method>
    <method name="incrementBytesWritten"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newBytes" type="long"/>
      <doc>
      <![CDATA[Increment the bytes written in the statistics
 @param newBytes the additional bytes written]]>
      </doc>
    </method>
    <method name="incrementReadOps"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Increment the number of read operations
 @param count number of read operations]]>
      </doc>
    </method>
    <method name="incrementLargeReadOps"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Increment the number of large read operations
 @param count number of large read operations]]>
      </doc>
    </method>
    <method name="incrementWriteOps"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="count" type="int"/>
      <doc>
      <![CDATA[Increment the number of write operations
 @param count number of write operations]]>
      </doc>
    </method>
    <method name="getBytesRead" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the total number of bytes read
 @return the number of bytes]]>
      </doc>
    </method>
    <method name="getBytesWritten" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the total number of bytes written
 @return the number of bytes]]>
      </doc>
    </method>
    <method name="getReadOps" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the number of file system read operations such as list files
 @return number of read operations]]>
      </doc>
    </method>
    <method name="getLargeReadOps" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the number of large file system read operations such as list files
 under a large directory
 @return number of large read operations]]>
      </doc>
    </method>
    <method name="getWriteOps" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the number of file system write operations such as create, append 
 rename etc.
 @return number of write operations]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resets all statistics to 0.

 In order to reset, we add up all the thread-local statistics data, and
 set rootData to the negative of that.

 This may seem like a counterintuitive way to reset the statsitics.  Why
 can't we just zero out all the thread-local data?  Well, thread-local
 data can only be modified by the thread that owns it.  If we tried to
 modify the thread-local data from this thread, our modification might get
 interleaved with a read-modify-write operation done by the thread that
 owns the data.  That would result in our update getting lost.

 The approach used here avoids this problem because it only ever reads
 (not writes) the thread-local data.  Both reads and writes to rootData
 are done under the lock, so we're free to modify rootData from any thread
 that holds the lock.]]>
      </doc>
    </method>
    <method name="getScheme" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the uri scheme associated with this statistics object.
 @return the schema associated with this set of statistics]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Tracks statistics about how many reads, writes, and so forth have been
 done in a FileSystem.
 
 Since there is only one of these objects per FileSystem, there will 
 typically be many threads writing to this object.  Almost every operation
 on an open file will involve a write to this object.  In contrast, reading
 statistics is done infrequently by most programs, and not at all by others.
 Hence, this is optimized for writes.
 
 Each thread writes to its own thread-local area of memory.  This removes 
 contention and allows us to scale up to many, many threads.  To read
 statistics, the reader thread totals up the contents of all of the 
 thread-local data areas.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileSystem.Statistics -->
  <!-- start class org.apache.hadoop.fs.FileSystem.Statistics.StatisticsData -->
  <class name="FileSystem.Statistics.StatisticsData" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBytesRead" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBytesWritten" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getReadOps" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLargeReadOps" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getWriteOps" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Statistics data.
 
 There is only a single writer to thread-local StatisticsData objects.
 Hence, volatile is adequate here-- we do not need AtomicLong or similar
 to prevent lost updates.
 The Java specification guarantees that updates to volatile longs will
 be perceived as atomic with respect to other threads, which is all we
 need.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileSystem.Statistics.StatisticsData -->
  <!-- start class org.apache.hadoop.fs.FileUtil -->
  <class name="FileUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FileUtil"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="stat2Paths" return="org.apache.hadoop.fs.Path[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stats" type="org.apache.hadoop.fs.FileStatus[]"/>
      <doc>
      <![CDATA[convert an array of FileStatus to an array of Path
 
 @param stats
          an array of FileStatus objects
 @return an array of paths corresponding to the input]]>
      </doc>
    </method>
    <method name="stat2Paths" return="org.apache.hadoop.fs.Path[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stats" type="org.apache.hadoop.fs.FileStatus[]"/>
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[convert an array of FileStatus to an array of Path.
 If stats if null, return path
 @param stats
          an array of FileStatus objects
 @param path
          default path to return in stats is null
 @return an array of paths corresponding to the input]]>
      </doc>
    </method>
    <method name="fullyDelete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <doc>
      <![CDATA[Delete a directory and all its contents.  If
 we return false, the directory may be partially-deleted.
 (1) If dir is symlink to a file, the symlink is deleted. The file pointed
     to by the symlink is not deleted.
 (2) If dir is symlink to a directory, symlink is deleted. The directory
     pointed to by symlink is not deleted.
 (3) If dir is a normal file, it is deleted.
 (4) If dir is a normal directory, then dir and all its contents recursively
     are deleted.]]>
      </doc>
    </method>
    <method name="fullyDelete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <param name="tryGrantPermissions" type="boolean"/>
      <doc>
      <![CDATA[Delete a directory and all its contents.  If
 we return false, the directory may be partially-deleted.
 (1) If dir is symlink to a file, the symlink is deleted. The file pointed
     to by the symlink is not deleted.
 (2) If dir is symlink to a directory, symlink is deleted. The directory
     pointed to by symlink is not deleted.
 (3) If dir is a normal file, it is deleted.
 (4) If dir is a normal directory, then dir and all its contents recursively
     are deleted.
 @param dir the file or directory to be deleted
 @param tryGrantPermissions true if permissions should be modified to delete a file.
 @return true on success false on failure.]]>
      </doc>
    </method>
    <method name="readLink" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <doc>
      <![CDATA[Returns the target of the given symlink. Returns the empty string if
 the given path does not refer to a symlink or there is an error
 accessing the symlink.
 @param f File representing the symbolic link.
 @return The target of the symbolic link, empty string on error or if not
         a symlink.]]>
      </doc>
    </method>
    <method name="fullyDeleteContents" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <doc>
      <![CDATA[Delete the contents of a directory, not the directory itself.  If
 we return false, the directory may be partially-deleted.
 If dir is a symlink to a directory, all the contents of the actual
 directory pointed to by dir will be deleted.]]>
      </doc>
    </method>
    <method name="fullyDeleteContents" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <param name="tryGrantPermissions" type="boolean"/>
      <doc>
      <![CDATA[Delete the contents of a directory, not the directory itself.  If
 we return false, the directory may be partially-deleted.
 If dir is a symlink to a directory, all the contents of the actual
 directory pointed to by dir will be deleted.
 @param tryGrantPermissions if 'true', try grant +rwx permissions to this 
 and all the underlying directories before trying to delete their contents.]]>
      </doc>
    </method>
    <method name="fullyDelete"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link FileSystem#delete(Path, boolean)}">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dir" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Recursively delete a directory.
 
 @param fs {@link FileSystem} on which the path is present
 @param dir directory to recursively delete 
 @throws IOException
 @deprecated Use {@link FileSystem#delete(Path, boolean)}]]>
      </doc>
    </method>
    <method name="copy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dstFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteSource" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy files between FileSystems.]]>
      </doc>
    </method>
    <method name="copy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="srcs" type="org.apache.hadoop.fs.Path[]"/>
      <param name="dstFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteSource" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="copy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dstFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteSource" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy files between FileSystems.]]>
      </doc>
    </method>
    <method name="copy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="srcStatus" type="org.apache.hadoop.fs.FileStatus"/>
      <param name="dstFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteSource" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy files between FileSystems.]]>
      </doc>
    </method>
    <method name="copyMerge" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="srcDir" type="org.apache.hadoop.fs.Path"/>
      <param name="dstFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dstFile" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteSource" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="addString" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy all files in a directory to one output file (merge).]]>
      </doc>
    </method>
    <method name="copy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="java.io.File"/>
      <param name="dstFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteSource" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy local files to a FileSystem.]]>
      </doc>
    </method>
    <method name="copy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="srcFS" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="java.io.File"/>
      <param name="deleteSource" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy FileSystem files to local files.]]>
      </doc>
    </method>
    <method name="makeShellPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Convert an os-native filename to a path that works for the shell.
 @param filename The filename to convert
 @return The unix pathname
 @throws IOException on windows, there can be problems with the subprocess]]>
      </doc>
    </method>
    <method name="makeShellPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Convert an os-native filename to a path that works for the shell.
 @param file The filename to convert
 @return The unix pathname
 @throws IOException on windows, there can be problems with the subprocess]]>
      </doc>
    </method>
    <method name="makeShellPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="makeCanonicalPath" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Convert an os-native filename to a path that works for the shell.
 @param file The filename to convert
 @param makeCanonicalPath 
          Whether to make canonical path for the file passed
 @return The unix pathname
 @throws IOException on windows, there can be problems with the subprocess]]>
      </doc>
    </method>
    <method name="getDU" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <doc>
      <![CDATA[Takes an input dir and returns the du on that local directory. Very basic
 implementation.
 
 @param dir
          The input dir to get the disk space of this local dir
 @return The total disk space of the input local directory]]>
      </doc>
    </method>
    <method name="unZip"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inFile" type="java.io.File"/>
      <param name="unzipDir" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Given a File input it will unzip the file in a the unzip directory
 passed as the second parameter
 @param inFile The zip file as input
 @param unzipDir The unzip directory where to unzip the zip file.
 @throws IOException]]>
      </doc>
    </method>
    <method name="unTar"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inFile" type="java.io.File"/>
      <param name="untarDir" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Given a Tar File as input it will untar the file in a the untar directory
 passed as the second parameter
 
 This utility will untar ".tar" files and ".tar.gz","tgz" files.
  
 @param inFile The tar file as input. 
 @param untarDir The untar directory where to untar the tar file.
 @throws IOException]]>
      </doc>
    </method>
    <method name="symLink" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="java.lang.String"/>
      <param name="linkname" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a soft link between a src and destination
 only on a local disk. HDFS does not support this.
 On Windows, when symlink creation fails due to security
 setting, we will log a warning. The return code in this
 case is 2.

 @param target the target for symlink 
 @param linkname the symlink
 @return 0 on success]]>
      </doc>
    </method>
    <method name="chmod" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="java.lang.String"/>
      <param name="perm" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Change the permissions on a filename.
 @param filename the name of the file to change
 @param perm the permission string
 @return the exit code from the command
 @throws IOException
 @throws InterruptedException]]>
      </doc>
    </method>
    <method name="chmod" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="java.lang.String"/>
      <param name="perm" type="java.lang.String"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Change the permissions on a file / directory, recursively, if
 needed.
 @param filename name of the file whose permissions are to change
 @param perm permission string
 @param recursive true, if permissions should be changed recursively
 @return the exit code from the command.
 @throws IOException]]>
      </doc>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the ownership on a file / directory. User name and group name
 cannot both be null.
 @param file the file to change
 @param username the new user owner name
 @param groupname the new group owner name
 @throws IOException]]>
      </doc>
    </method>
    <method name="setReadable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <param name="readable" type="boolean"/>
      <doc>
      <![CDATA[Platform independent implementation for {@link File#setReadable(boolean)}
 File#setReadable does not work as expected on Windows.
 @param f input file
 @param readable
 @return true on success, false otherwise]]>
      </doc>
    </method>
    <method name="setWritable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <param name="writable" type="boolean"/>
      <doc>
      <![CDATA[Platform independent implementation for {@link File#setWritable(boolean)}
 File#setWritable does not work as expected on Windows.
 @param f input file
 @param writable
 @return true on success, false otherwise]]>
      </doc>
    </method>
    <method name="setExecutable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <param name="executable" type="boolean"/>
      <doc>
      <![CDATA[Platform independent implementation for {@link File#setExecutable(boolean)}
 File#setExecutable does not work as expected on Windows.
 Note: revoking execute permission on folders does not have the same
 behavior on Windows as on Unix platforms. Creating, deleting or renaming
 a file within that folder will still succeed on Windows.
 @param f input file
 @param executable
 @return true on success, false otherwise]]>
      </doc>
    </method>
    <method name="canRead" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <doc>
      <![CDATA[Platform independent implementation for {@link File#canRead()}
 @param f input file
 @return On Unix, same as {@link File#canRead()}
         On Windows, true if process has read access on the path]]>
      </doc>
    </method>
    <method name="canWrite" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <doc>
      <![CDATA[Platform independent implementation for {@link File#canWrite()}
 @param f input file
 @return On Unix, same as {@link File#canWrite()}
         On Windows, true if process has write access on the path]]>
      </doc>
    </method>
    <method name="canExecute" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <doc>
      <![CDATA[Platform independent implementation for {@link File#canExecute()}
 @param f input file
 @return On Unix, same as {@link File#canExecute()}
         On Windows, true if process has execute access on the path]]>
      </doc>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set permissions to the required value. Uses the java primitives instead
 of forking if group == other.
 @param f the file to change
 @param permission the new permissions
 @throws IOException]]>
      </doc>
    </method>
    <method name="createLocalTempFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="basefile" type="java.io.File"/>
      <param name="prefix" type="java.lang.String"/>
      <param name="isDeleteOnExit" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a tmp file for a base file.
 @param basefile the base file of the tmp
 @param prefix file name prefix of tmp
 @param isDeleteOnExit if true, the tmp will be deleted when the VM exits
 @return a newly created tmp file
 @exception IOException If a tmp file cannot created
 @see java.io.File#createTempFile(String, String, File)
 @see java.io.File#deleteOnExit()]]>
      </doc>
    </method>
    <method name="replaceFile"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="java.io.File"/>
      <param name="target" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Move the src file to the name specified by target.
 @param src the source file
 @param target the target file
 @exception IOException If this operation fails]]>
      </doc>
    </method>
    <method name="listFiles" return="java.io.File[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A wrapper for {@link File#listFiles()}. This java.io API returns null 
 when a dir is not a directory or for any I/O error. Instead of having
 null check everywhere File#listFiles() is used, we will add utility API
 to get around this problem. For the majority of cases where we prefer 
 an IOException to be thrown.
 @param dir directory for which listing should be performed
 @return list of files or empty list
 @exception IOException for invalid directory or for a bad disk.]]>
      </doc>
    </method>
    <method name="list" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A wrapper for {@link File#list()}. This java.io API returns null 
 when a dir is not a directory or for any I/O error. Instead of having
 null check everywhere File#list() is used, we will add utility API
 to get around this problem. For the majority of cases where we prefer 
 an IOException to be thrown.
 @param dir directory for which listing should be performed
 @return list of file names or empty string list
 @exception IOException for invalid directory or for a bad disk.]]>
      </doc>
    </method>
    <method name="createJarWithClassPath" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputClassPath" type="java.lang.String"/>
      <param name="pwd" type="org.apache.hadoop.fs.Path"/>
      <param name="callerEnv" type="java.util.Map"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createJarWithClassPath" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputClassPath" type="java.lang.String"/>
      <param name="pwd" type="org.apache.hadoop.fs.Path"/>
      <param name="targetDir" type="org.apache.hadoop.fs.Path"/>
      <param name="callerEnv" type="java.util.Map"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a jar file at the given path, containing a manifest with a classpath
 that references all specified entries.
 
 Some platforms may have an upper limit on command line length.  For example,
 the maximum command line length on Windows is 8191 characters, but the
 length of the classpath may exceed this.  To work around this limitation,
 use this method to create a small intermediate jar with a manifest that
 contains the full classpath.  It returns the absolute path to the new jar,
 which the caller may set as the classpath for a new process.
 
 Environment variable evaluation is not supported within a jar manifest, so
 this method expands environment variables before inserting classpath entries
 to the manifest.  The method parses environment variables according to
 platform-specific syntax (%VAR% on Windows, or $VAR otherwise).  On Windows,
 environment variables are case-insensitive.  For example, %VAR% and %var%
 evaluate to the same value.
 
 Specifying the classpath in a jar manifest does not support wildcards, so
 this method expands wildcards internally.  Any classpath entry that ends
 with * is translated to all files at that path with extension .jar or .JAR.
 
 @param inputClassPath String input classpath to bundle into the jar manifest
 @param pwd Path to working directory to save jar
 @param targetDir path to where the jar execution will have its working dir
 @param callerEnv Map<String, String> caller's environment variables to use
   for expansion
 @return String[] with absolute path to new jar in position 0 and
   unexpanded wild card entry path in position 1
 @throws IOException if there is an I/O error while writing the jar file]]>
      </doc>
    </method>
    <field name="SYMLINK_NO_PRIVILEGE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A collection of file-processing util methods]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileUtil -->
  <!-- start class org.apache.hadoop.fs.FileUtil.HardLink -->
  <class name="FileUtil.HardLink" extends="org.apache.hadoop.fs.HardLink"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="Use {@link org.apache.hadoop.fs.HardLink}">
    <constructor name="FileUtil.HardLink"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Class for creating hardlinks.
 Supports Unix, WindXP.
 @deprecated Use {@link org.apache.hadoop.fs.HardLink}]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FileUtil.HardLink -->
  <!-- start class org.apache.hadoop.fs.FilterFileSystem -->
  <class name="FilterFileSystem" extends="org.apache.hadoop.fs.FileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FilterFileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FilterFileSystem" type="org.apache.hadoop.fs.FileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getRawFileSystem" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the raw file system 
 @return FileSystem being filtered]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Called after a new FileSystem instance is constructed.
 @param name a uri whose authority section names the host, port, etc.
   for this FileSystem
 @param conf the configuration]]>
      </doc>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a URI whose scheme and authority identify this FileSystem.]]>
      </doc>
    </method>
    <method name="getCanonicalUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="canonicalizeUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
    </method>
    <method name="makeQualified" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Make sure that a path specifies a FileSystem.]]>
      </doc>
    </method>
    <method name="checkPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Check that a Path belongs to this FileSystem.]]>
      </doc>
    </method>
    <method name="getFileBlockLocations" return="org.apache.hadoop.fs.BlockLocation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.FileStatus"/>
      <param name="start" type="long"/>
      <param name="len" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="resolvePath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataInputStream at the indicated Path.
 @param f the file name to open
 @param bufferSize the size of the buffer to be used.]]>
      </doc>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="concat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="psrcs" type="org.apache.hadoop.fs.Path[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flags" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="checksumOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createNonRecursive" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flags" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setReplication" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set replication for an existing file.
 
 @param src file name
 @param replication new replication
 @throws IOException
 @return true if successful;
         false if file does not exist or is a directory]]>
      </doc>
    </method>
    <method name="rename" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Renames Path src to Path dst.  Can take place on local fs
 or remote DFS.]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete a file]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List files in a directory.]]>
      </doc>
    </method>
    <method name="listCorruptFileBlocks" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="listLocatedStatus" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List files and its block locations in a directory.]]>
      </doc>
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setWorkingDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newDir" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Set the current working directory for the given file system. All relative
 paths will be resolved relative to it.
 
 @param newDir]]>
      </doc>
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current working directory for the given file system
 
 @return the directory pathname]]>
      </doc>
    </method>
    <method name="getInitialWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getStatus" return="org.apache.hadoop.fs.FsStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is on the local disk.  Add it to FS at
 the given dst name.
 delSrc indicates if the source should be removed]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <param name="srcs" type="org.apache.hadoop.fs.Path[]"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src files are on the local disk.  Add it to FS at
 the given dst name.
 delSrc indicates if the source should be removed]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is on the local disk.  Add it to FS at
 the given dst name.
 delSrc indicates if the source should be removed]]>
      </doc>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under FS, and the dst is on the local disk.
 Copy it from FS control to the local dst name.
 delSrc indicates if the src will be removed or not.]]>
      </doc>
    </method>
    <method name="startLocalOutput" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a local File that the user can write output to.  The caller
 provides both the eventual FS target name and the local working
 file.  If the FS is local, we write directly into the target.  If
 the FS is remote, we write into the tmp local area.]]>
      </doc>
    </method>
    <method name="completeLocalOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Called when we're all done writing to the target.  A local FS will
 do nothing, because we've written to exactly the right place.  A remote
 FS will copy the contents of tmpLocalFile to the correct target at
 fsOutputFile.]]>
      </doc>
    </method>
    <method name="getUsed" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the total size of all files in the filesystem.]]>
      </doc>
    </method>
    <method name="getDefaultBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDefaultReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getServerDefaults" return="org.apache.hadoop.fs.FsServerDefaults"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getDefaultBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="getDefaultReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="getServerDefaults" return="org.apache.hadoop.fs.FsServerDefaults"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get file status.]]>
      </doc>
    </method>
    <method name="access"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="mode" type="org.apache.hadoop.fs.permission.FsAction"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createSymlink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.apache.hadoop.fs.Path"/>
      <param name="link" type="org.apache.hadoop.fs.Path"/>
      <param name="createParent" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileLinkStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="supportsSymlinks" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLinkTarget" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="resolveLink" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileChecksum" return="org.apache.hadoop.fs.FileChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileChecksum" return="org.apache.hadoop.fs.FileChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="length" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setVerifyChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="verifyChecksum" type="boolean"/>
    </method>
    <method name="setWriteChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writeChecksum" type="boolean"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setTimes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="mtime" type="long"/>
      <param name="atime" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="primitiveCreate" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="absolutePermission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flag" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="checksumOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="primitiveMkdir" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="abdolutePermission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getChildFileSystems" return="org.apache.hadoop.fs.FileSystem[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createSnapshot" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="renameSnapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotOldName" type="java.lang.String"/>
      <param name="snapshotNewName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="deleteSnapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="modifyAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeDefaultAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getAclStatus" return="org.apache.hadoop.fs.permission.AclStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <param name="flag" type="java.util.EnumSet"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getXAttr" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="names" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="listXAttrs" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="fs" type="org.apache.hadoop.fs.FileSystem"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="swapScheme" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A <code>FilterFileSystem</code> contains
 some other file system, which it uses as
 its  basic file system, possibly transforming
 the data along the way or providing  additional
 functionality. The class <code>FilterFileSystem</code>
 itself simply overrides all  methods of
 <code>FileSystem</code> with versions that
 pass all requests to the contained  file
 system. Subclasses of <code>FilterFileSystem</code>
 may further override some of  these methods
 and may also provide additional methods
 and fields.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FilterFileSystem -->
  <!-- start interface org.apache.hadoop.fs.FsConstants -->
  <interface name="FsConstants"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="LOCAL_FS_URI" type="java.net.URI"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FTP_SCHEME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MAX_PATH_LINKS" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="VIEWFS_URI" type="java.net.URI"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[ViewFs: viewFs file system (ie the mount file system on client side)]]>
      </doc>
    </field>
    <field name="VIEWFS_SCHEME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[FileSystem related constants.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.FsConstants -->
  <!-- start class org.apache.hadoop.fs.FSDataInputStream -->
  <class name="FSDataInputStream" extends="java.io.DataInputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.Seekable"/>
    <implements name="org.apache.hadoop.fs.PositionedReadable"/>
    <implements name="org.apache.hadoop.fs.ByteBufferReadable"/>
    <implements name="org.apache.hadoop.fs.HasFileDescriptor"/>
    <implements name="org.apache.hadoop.fs.CanSetDropBehind"/>
    <implements name="org.apache.hadoop.fs.CanSetReadahead"/>
    <implements name="org.apache.hadoop.fs.HasEnhancedByteBufferAccess"/>
    <constructor name="FSDataInputStream" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="seek"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="desired" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Seek to the given offset.

 @param desired offset to seek to]]>
      </doc>
    </method>
    <method name="getPos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the current position in the input stream.

 @return current position in the input stream]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read bytes from the given position in the stream to the given buffer.

 @param position  position in the input stream to seek
 @param buffer    buffer into which data is read
 @param offset    offset into the buffer in which data is written
 @param length    maximum number of bytes to read
 @return total number of bytes read into the buffer, or <code>-1</code>
         if there is no more data because the end of the stream has been
         reached]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read bytes from the given position in the stream to the given buffer.
 Continues to read until <code>length</code> bytes have been read.

 @param position  position in the input stream to seek
 @param buffer    buffer into which data is read
 @param offset    offset into the buffer in which data is written
 @param length    the number of bytes to read
 @throws EOFException If the end of stream is reached while reading.
                      If an exception is thrown an undetermined number
                      of bytes in the buffer may have been written.]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[See {@link #readFully(long, byte[], int, int)}.]]>
      </doc>
    </method>
    <method name="seekToNewSource" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetPos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Seek to the given position on an alternate copy of the data.

 @param  targetPos  position to seek to
 @return true if a new source is found, false otherwise]]>
      </doc>
    </method>
    <method name="getWrappedStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a reference to the wrapped input stream. Used by unit tests.

 @return the underlying input stream]]>
      </doc>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileDescriptor" return="java.io.FileDescriptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setReadahead"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readahead" type="java.lang.Long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
    </method>
    <method name="setDropBehind"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dropBehind" type="java.lang.Boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
    </method>
    <method name="read" return="java.nio.ByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bufferPool" type="org.apache.hadoop.io.ByteBufferPool"/>
      <param name="maxLength" type="int"/>
      <param name="opts" type="java.util.EnumSet"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
    </method>
    <method name="read" return="java.nio.ByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="bufferPool" type="org.apache.hadoop.io.ByteBufferPool"/>
      <param name="maxLength" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
    </method>
    <method name="releaseBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buffer" type="java.nio.ByteBuffer"/>
    </method>
    <doc>
    <![CDATA[Utility that wraps a {@link FSInputStream} in a {@link DataInputStream}
 and buffers input through a {@link BufferedInputStream}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FSDataInputStream -->
  <!-- start class org.apache.hadoop.fs.FSDataOutputStream -->
  <class name="FSDataOutputStream" extends="java.io.DataOutputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.Syncable"/>
    <implements name="org.apache.hadoop.fs.CanSetDropBehind"/>
    <constructor name="FSDataOutputStream" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="FSDataOutputStream" type="java.io.OutputStream, org.apache.hadoop.fs.FileSystem.Statistics"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="FSDataOutputStream" type="java.io.OutputStream, org.apache.hadoop.fs.FileSystem.Statistics, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="getPos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the current position in the output stream.

 @return the current position in the output stream]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close the underlying output stream.]]>
      </doc>
    </method>
    <method name="getWrappedStream" return="java.io.OutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a reference to the wrapped output stream.

 @return the underlying output stream]]>
      </doc>
    </method>
    <method name="sync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="hflush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="hsync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setDropBehind"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dropBehind" type="java.lang.Boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Utility that wraps a {@link OutputStream} in a {@link DataOutputStream}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FSDataOutputStream -->
  <!-- start class org.apache.hadoop.fs.FSError -->
  <class name="FSError" extends="java.lang.Error"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Thrown for unexpected filesystem errors, presumed to reflect disk errors
 in the native filesystem.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FSError -->
  <!-- start class org.apache.hadoop.fs.FSExceptionMessages -->
  <class name="FSExceptionMessages" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FSExceptionMessages"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="STREAM_IS_CLOSED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The operation failed because the stream is closed: {@value}]]>
      </doc>
    </field>
    <field name="NEGATIVE_SEEK" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Negative offset seek forbidden : {@value}]]>
      </doc>
    </field>
    <field name="CANNOT_SEEK_PAST_EOF" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Seeks : {@value}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Standard strings to use in exception messages in filesystems
 HDFS is used as the reference source of the strings]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FSExceptionMessages -->
  <!-- start class org.apache.hadoop.fs.FsServerDefaults -->
  <class name="FsServerDefaults" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="FsServerDefaults"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FsServerDefaults" type="long, int, int, short, int, boolean, long, org.apache.hadoop.util.DataChecksum.Type"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBytesPerChecksum" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getWritePacketSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFileBufferSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEncryptDataTransfer" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTrashInterval" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getChecksumType" return="org.apache.hadoop.util.DataChecksum.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Provides server default configuration values to clients.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FsServerDefaults -->
  <!-- start class org.apache.hadoop.fs.FsShell.Help -->
  <class name="FsShell.Help" extends="org.apache.hadoop.fs.shell.FsCommand"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="FsShell.Help"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="processRawArguments"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="args" type="java.util.LinkedList"/>
    </method>
    <field name="NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="USAGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DESCRIPTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Displays short usage of commands sans the long description]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FsShell.Help -->
  <!-- start class org.apache.hadoop.fs.FsShell.Usage -->
  <class name="FsShell.Usage" extends="org.apache.hadoop.fs.shell.FsCommand"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="FsShell.Usage"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="processRawArguments"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="args" type="java.util.LinkedList"/>
    </method>
    <field name="NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="USAGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DESCRIPTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Display help for commands with their short usage and long description]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FsShell.Usage -->
  <!-- start class org.apache.hadoop.fs.FsShellPermissions.Chgrp -->
  <class name="FsShellPermissions.Chgrp" extends="org.apache.hadoop.fs.FsShellPermissions.Chown"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FsShellPermissions.Chgrp"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="parseOwnerGroup"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="groupStr" type="java.lang.String"/>
    </method>
    <field name="NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="USAGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DESCRIPTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Used to change group of files]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FsShellPermissions.Chgrp -->
  <!-- start class org.apache.hadoop.fs.FsShellPermissions.Chmod -->
  <class name="FsShellPermissions.Chmod" extends="org.apache.hadoop.fs.FsShellPermissions"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FsShellPermissions.Chmod"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="processOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="args" type="java.util.LinkedList"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="processPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="item" type="org.apache.hadoop.fs.shell.PathData"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="USAGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DESCRIPTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="pp" type="org.apache.hadoop.fs.permission.ChmodParser"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[The pattern is almost as flexible as mode allowed by chmod shell command.
 The main restriction is that we recognize only rwxXt. To reduce errors we
 also enforce octal mode specifications of either 3 digits without a sticky
 bit setting or four digits with a sticky bit setting.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FsShellPermissions.Chmod -->
  <!-- start class org.apache.hadoop.fs.FsShellPermissions.Chown -->
  <class name="FsShellPermissions.Chown" extends="org.apache.hadoop.fs.FsShellPermissions"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FsShellPermissions.Chown"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="processOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="args" type="java.util.LinkedList"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="parseOwnerGroup"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="ownerStr" type="java.lang.String"/>
      <doc>
      <![CDATA[Parse the first argument into an owner and group
 @param ownerStr string describing new ownership]]>
      </doc>
    </method>
    <method name="processPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="item" type="org.apache.hadoop.fs.shell.PathData"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="USAGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DESCRIPTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="owner" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="group" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Used to change owner and/or group of files]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FsShellPermissions.Chown -->
  <!-- start class org.apache.hadoop.fs.FsStatus -->
  <class name="FsStatus" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="FsStatus" type="long, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a FsStatus object, using the specified statistics]]>
      </doc>
    </constructor>
    <method name="getCapacity" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the capacity in bytes of the file system]]>
      </doc>
    </method>
    <method name="getUsed" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the number of bytes used on the file system]]>
      </doc>
    </method>
    <method name="getRemaining" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the number of remaining bytes on the file system]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[This class is used to represent the capacity, free and used space on a
 {@link FileSystem}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.FsStatus -->
  <!-- start class org.apache.hadoop.fs.GlobFilter -->
  <class name="GlobFilter" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.PathFilter"/>
    <constructor name="GlobFilter" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates a glob filter with the specified file pattern.

 @param filePattern the file pattern.
 @throws IOException thrown if the file pattern is incorrect.]]>
      </doc>
    </constructor>
    <constructor name="GlobFilter" type="java.lang.String, org.apache.hadoop.fs.PathFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates a glob filter with the specified file pattern and an user filter.

 @param filePattern the file pattern.
 @param filter user filter in addition to the glob pattern.
 @throws IOException thrown if the file pattern is incorrect.]]>
      </doc>
    </constructor>
    <method name="accept" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
    </method>
    <doc>
    <![CDATA[A filter for POSIX glob pattern with brace expansions.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.GlobFilter -->
  <!-- start class org.apache.hadoop.fs.HardLink -->
  <class name="HardLink" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HardLink"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLinkMultArgLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fileDir" type="java.io.File"/>
      <param name="fileBaseNames" type="java.lang.String[]"/>
      <param name="linkDir" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Calculate the nominal length of all contributors to the total 
 commandstring length, including fixed overhead of the OS-dependent 
 command.  It's protected rather than private, to assist unit testing,
 but real clients are not expected to need it -- see the way 
 createHardLinkMult() uses it internally so the user doesn't need to worry
 about it.
 
 @param fileDir - source directory, parent of fileBaseNames
 @param fileBaseNames - array of path-less file names, relative
            to the source directory
 @param linkDir - target directory where the hardlinks will be put
 @return - total data length (must not exceed maxAllowedCmdArgLength)
 @throws IOException]]>
      </doc>
    </method>
    <method name="getMaxAllowedCmdArgLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return this private value for use by unit tests.
 Shell commands are not allowed to have a total string length
 exceeding this size.]]>
      </doc>
    </method>
    <method name="createHardLink"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="linkName" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates a hardlink 
 @param file - existing source file
 @param linkName - desired target link file]]>
      </doc>
    </method>
    <method name="createHardLinkMult"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="parentDir" type="java.io.File"/>
      <param name="fileBaseNames" type="java.lang.String[]"/>
      <param name="linkDir" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates hardlinks from multiple existing files within one parent
 directory, into one target directory.
 @param parentDir - directory containing source files
 @param fileBaseNames - list of path-less file names, as returned by 
                        parentDir.list()
 @param linkDir - where the hardlinks should be put.  It must already exist.
 
 If the list of files is too long (overflows maxAllowedCmdArgLength),
 we will automatically split it into multiple invocations of the
 underlying method.]]>
      </doc>
    </method>
    <method name="createHardLinkMult" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="parentDir" type="java.io.File"/>
      <param name="fileBaseNames" type="java.lang.String[]"/>
      <param name="linkDir" type="java.io.File"/>
      <param name="maxLength" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getLinkCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileName" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Retrieves the number of links to the specified file.]]>
      </doc>
    </method>
    <field name="linkStats" type="org.apache.hadoop.fs.HardLink.LinkStats"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Class for creating hardlinks.
 Supports Unix/Linux, Windows via winutils , and Mac OS X.
 
 The HardLink class was formerly a static inner class of FSUtil,
 and the methods provided were blatantly non-thread-safe.
 To enable volume-parallel Update snapshots, we now provide static 
 threadsafe methods that allocate new buffer string arrays
 upon each call.  We also provide an API to hardlink all files in a
 directory with a single command, which is up to 128 times more 
 efficient - and minimizes the impact of the extra buffer creations.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.HardLink -->
  <!-- start class org.apache.hadoop.fs.HardLink.LinkStats -->
  <class name="HardLink.LinkStats" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HardLink.LinkStats"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="report" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="countDirs" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="countSingleLinks" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="countMultLinks" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="countFilesMultLinks" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="countEmptyDirs" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="countPhysicalFileCopies" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[HardLink statistics counters and methods.
 Not multi-thread safe, obviously.
 Init is called during HardLink instantiation, above.
 
 These are intended for use by knowledgeable clients, not internally, 
 because many of the internal methods are static and can't update these
 per-instance counters.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.HardLink.LinkStats -->
  <!-- start class org.apache.hadoop.fs.HarFileSystem -->
  <class name="HarFileSystem" extends="org.apache.hadoop.fs.FileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HarFileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[public construction of harfilesystem]]>
      </doc>
    </constructor>
    <constructor name="HarFileSystem" type="org.apache.hadoop.fs.FileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor to create a HarFileSystem with an
 underlying filesystem.
 @param fs underlying file system]]>
      </doc>
    </constructor>
    <method name="getScheme" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the protocol scheme for the FileSystem.
 <p/>

 @return <code>har</code>]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Initialize a Har filesystem per har archive. The 
 archive home directory is the top level directory
 in the filesystem that contains the HAR archive.
 Be careful with this method, you do not want to go 
 on creating new Filesystem instances per call to 
 path.getFileSystem().
 the uri of Har is 
 har://underlyingfsscheme-host:port/archivepath.
 or 
 har:///archivepath. This assumes the underlying filesystem
 to be used in case not specified.]]>
      </doc>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHarVersion" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[return the top level archive.]]>
      </doc>
    </method>
    <method name="getInitialWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStatus" return="org.apache.hadoop.fs.FsStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCanonicalUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Used for delegation token related functionality. Must delegate to
 underlying file system.]]>
      </doc>
    </method>
    <method name="canonicalizeUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the uri of this filesystem.
 The uri is of the form 
 har://underlyingfsschema-host:port/pathintheunderlyingfs]]>
      </doc>
    </method>
    <method name="checkPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="resolvePath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="makeQualified" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="getFileBlockLocations" return="org.apache.hadoop.fs.BlockLocation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.FileStatus"/>
      <param name="start" type="long"/>
      <param name="len" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get block locations from the underlying fs and fix their
 offsets and lengths.
 @param file the input file status to get block locations
 @param start the start of the desired range in the contained file
 @param len the length of the desired range
 @return block locations for this segment of file
 @throws IOException]]>
      </doc>
    </method>
    <method name="getHarHash" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[the hash of the path p inside  the filesystem
 @param p the path in the harfilesystem
 @return the hash code of the path.]]>
      </doc>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[return the filestatus of files in har archive.
 The permission returned are that of the archive
 index files. The permissions are not persisted 
 while creating a hadoop archive.
 @param f the path in har filesystem
 @return filestatus.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getFileChecksum" return="org.apache.hadoop.fs.FileChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="length" type="long"/>
      <doc>
      <![CDATA[@return null since no checksum algorithm is implemented.]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns a har input stream which fakes end of 
 file. It reads the index files to get the part 
 file name and the size and start of the file.]]>
      </doc>
    </method>
    <method name="getChildFileSystems" return="org.apache.hadoop.fs.FileSystem[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Used for delegation token related functionality. Must delegate to
 underlying file system.]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createNonRecursive" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setReplication" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Not implemented.]]>
      </doc>
    </method>
    <method name="rename" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Not implemented.]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[liststatus returns the children of a directory 
 after looking up the index files.]]>
      </doc>
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[return the top level archive path.]]>
      </doc>
    </method>
    <method name="setWorkingDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newDir" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[not implemented.]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[not implemented.]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="overwrite" type="boolean"/>
      <param name="srcs" type="org.apache.hadoop.fs.Path[]"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[copies the file in the har filesystem to a local file.]]>
      </doc>
    </method>
    <method name="startLocalOutput" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[not implemented.]]>
      </doc>
    </method>
    <method name="completeLocalOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[not implemented.]]>
      </doc>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[not implemented.]]>
      </doc>
    </method>
    <method name="setTimes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="mtime" type="long"/>
      <param name="atime" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Not implemented.]]>
      </doc>
    </method>
    <method name="getServerDefaults" return="org.apache.hadoop.fs.FsServerDefaults"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getServerDefaults" return="org.apache.hadoop.fs.FsServerDefaults"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getUsed" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getDefaultBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDefaultBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="getDefaultReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDefaultReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
    </method>
    <field name="METADATA_CACHE_ENTRIES_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="METADATA_CACHE_ENTRIES_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="VERSION" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This is an implementation of the Hadoop Archive 
 Filesystem. This archive Filesystem has index files
 of the form _index* and has contents of the form
 part-*. The index files store the indexes of the 
 real files. The index files are of the form _masterindex
 and _index. The master index is a level of indirection 
 in to the index file to make the look ups faster. the index
 file is sorted with hash code of the paths that it contains 
 and the master index contains pointers to the positions in 
 index for ranges of hashcodes.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.HarFileSystem -->
  <!-- start class org.apache.hadoop.fs.HarFs -->
  <class name="HarFs" extends="org.apache.hadoop.fs.DelegateToFileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getUriDefaultPort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.fs.HarFs -->
  <!-- start class org.apache.hadoop.fs.InvalidPathException -->
  <class name="InvalidPathException" extends="org.apache.hadoop.HadoopIllegalArgumentException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvalidPathException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs exception with the specified detail message.
 
 @param path invalid path.]]>
      </doc>
    </constructor>
    <constructor name="InvalidPathException" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs exception with the specified detail message.
 
 @param path invalid path.
 @param reason Reason <code>path</code> is invalid]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Path string is invalid either because it has invalid characters or due to
 other file system specific reasons.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.InvalidPathException -->
  <!-- start class org.apache.hadoop.fs.InvalidRequestException -->
  <class name="InvalidRequestException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="InvalidRequestException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Thrown when the user makes a malformed request, for example missing required
 parameters or parameters that are not valid.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.InvalidRequestException -->
  <!-- start class org.apache.hadoop.fs.LocalFileSystem -->
  <class name="LocalFileSystem" extends="org.apache.hadoop.fs.ChecksumFileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LocalFileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LocalFileSystem" type="org.apache.hadoop.fs.FileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getScheme" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the protocol scheme for the FileSystem.
 <p/>

 @return <code>file</code>]]>
      </doc>
    </method>
    <method name="getRaw" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pathToFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Convert a path to a File.]]>
      </doc>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="reportChecksumFailure" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="in" type="org.apache.hadoop.fs.FSDataInputStream"/>
      <param name="inPos" type="long"/>
      <param name="sums" type="org.apache.hadoop.fs.FSDataInputStream"/>
      <param name="sumsPos" type="long"/>
      <doc>
      <![CDATA[Moves files to a bad file directory on the same device, so that their
 storage will not be reused.]]>
      </doc>
    </method>
    <method name="supportsSymlinks" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createSymlink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.apache.hadoop.fs.Path"/>
      <param name="link" type="org.apache.hadoop.fs.Path"/>
      <param name="createParent" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileLinkStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getLinkTarget" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Implement the FileSystem API for the checksumed local filesystem.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.LocalFileSystem -->
  <!-- start class org.apache.hadoop.fs.LocatedFileStatus -->
  <class name="LocatedFileStatus" extends="org.apache.hadoop.fs.FileStatus"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LocatedFileStatus" type="org.apache.hadoop.fs.FileStatus, org.apache.hadoop.fs.BlockLocation[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Constructor 
 @param stat a file status
 @param locations a file's block locations]]>
      </doc>
    </constructor>
    <constructor name="LocatedFileStatus" type="long, boolean, int, long, long, long, org.apache.hadoop.fs.permission.FsPermission, java.lang.String, java.lang.String, org.apache.hadoop.fs.Path, org.apache.hadoop.fs.Path, org.apache.hadoop.fs.BlockLocation[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor
 
 @param length a file's length
 @param isdir if the path is a directory
 @param block_replication the file's replication factor
 @param blocksize a file's block size
 @param modification_time a file's modification time
 @param access_time a file's access time
 @param permission a file's permission
 @param owner a file's owner
 @param group a file's group
 @param symlink symlink if the path is a symbolic link
 @param path the path's qualified name
 @param locations a file's block locations]]>
      </doc>
    </constructor>
    <method name="getBlockLocations" return="org.apache.hadoop.fs.BlockLocation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the file's block locations
 @return the file's block locations]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compare this object to another object
 
 @param   o the object to be compared.
 @return  a negative integer, zero, or a positive integer as this object
   is less than, equal to, or greater than the specified object.
 
 @throws ClassCastException if the specified object's is not of 
         type FileStatus]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compare if this object is equal to another object
 @param   o the object to be compared.
 @return  true if two file status has the same path name; false if not.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash code value for the object, which is defined as
 the hash code of the path name.

 @return  a hash code value for the path name.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class defines a FileStatus that includes a file's block locations.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.LocatedFileStatus -->
  <!-- start class org.apache.hadoop.fs.MD5MD5CRC32CastagnoliFileChecksum -->
  <class name="MD5MD5CRC32CastagnoliFileChecksum" extends="org.apache.hadoop.fs.MD5MD5CRC32FileChecksum"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MD5MD5CRC32CastagnoliFileChecksum"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Same as this(0, 0, null)]]>
      </doc>
    </constructor>
    <constructor name="MD5MD5CRC32CastagnoliFileChecksum" type="int, long, org.apache.hadoop.io.MD5Hash"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a MD5FileChecksum]]>
      </doc>
    </constructor>
    <method name="getCrcType" return="org.apache.hadoop.util.DataChecksum.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[For CRC32 with the Castagnoli polynomial]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.MD5MD5CRC32CastagnoliFileChecksum -->
  <!-- start class org.apache.hadoop.fs.MD5MD5CRC32GzipFileChecksum -->
  <class name="MD5MD5CRC32GzipFileChecksum" extends="org.apache.hadoop.fs.MD5MD5CRC32FileChecksum"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MD5MD5CRC32GzipFileChecksum"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Same as this(0, 0, null)]]>
      </doc>
    </constructor>
    <constructor name="MD5MD5CRC32GzipFileChecksum" type="int, long, org.apache.hadoop.io.MD5Hash"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a MD5FileChecksum]]>
      </doc>
    </constructor>
    <method name="getCrcType" return="org.apache.hadoop.util.DataChecksum.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[For CRC32 with the Gzip polynomial]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.MD5MD5CRC32GzipFileChecksum -->
  <!-- start class org.apache.hadoop.fs.Options -->
  <class name="Options" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[This class contains options related to file system operations.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.Options -->
  <!-- start class org.apache.hadoop.fs.Options.ChecksumOpt -->
  <class name="Options.ChecksumOpt" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options.ChecksumOpt"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a uninitialized one]]>
      </doc>
    </constructor>
    <constructor name="Options.ChecksumOpt" type="org.apache.hadoop.util.DataChecksum.Type, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Normal ctor
 @param type checksum type
 @param size bytes per checksum]]>
      </doc>
    </constructor>
    <method name="getBytesPerChecksum" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getChecksumType" return="org.apache.hadoop.util.DataChecksum.Type"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createDisabled" return="org.apache.hadoop.fs.Options.ChecksumOpt"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a ChecksumOpts that disables checksum]]>
      </doc>
    </method>
    <method name="processChecksumOpt" return="org.apache.hadoop.fs.Options.ChecksumOpt"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaultOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
      <param name="userOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
      <param name="userBytesPerChecksum" type="int"/>
      <doc>
      <![CDATA[A helper method for processing user input and default value to 
 create a combined checksum option. This is a bit complicated because
 bytesPerChecksum is kept for backward compatibility.

 @param defaultOpt Default checksum option
 @param userOpt User-specified checksum option. Ignored if null.
 @param userBytesPerChecksum User-specified bytesPerChecksum
                Ignored if < 0.]]>
      </doc>
    </method>
    <method name="processChecksumOpt" return="org.apache.hadoop.fs.Options.ChecksumOpt"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaultOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
      <param name="userOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
      <doc>
      <![CDATA[A helper method for processing user input and default value to 
 create a combined checksum option. 

 @param defaultOpt Default checksum option
 @param userOpt User-specified checksum option]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This is used in FileSystem and FileContext to specify checksum options.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.Options.ChecksumOpt -->
  <!-- start class org.apache.hadoop.fs.Options.CreateOpts -->
  <class name="Options.CreateOpts" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="blockSize" return="org.apache.hadoop.fs.Options.CreateOpts.BlockSize"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bs" type="long"/>
    </method>
    <method name="bufferSize" return="org.apache.hadoop.fs.Options.CreateOpts.BufferSize"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bs" type="int"/>
    </method>
    <method name="repFac" return="org.apache.hadoop.fs.Options.CreateOpts.ReplicationFactor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rf" type="short"/>
    </method>
    <method name="bytesPerChecksum" return="org.apache.hadoop.fs.Options.CreateOpts.BytesPerChecksum"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="crc" type="short"/>
    </method>
    <method name="checksumParam" return="org.apache.hadoop.fs.Options.CreateOpts.ChecksumParam"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="csumOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
    </method>
    <method name="perms" return="org.apache.hadoop.fs.Options.CreateOpts.Perms"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="perm" type="org.apache.hadoop.fs.permission.FsPermission"/>
    </method>
    <method name="createParent" return="org.apache.hadoop.fs.Options.CreateOpts.CreateParent"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="donotCreateParent" return="org.apache.hadoop.fs.Options.CreateOpts.CreateParent"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Class to support the varargs for create() options.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.Options.CreateOpts -->
  <!-- start class org.apache.hadoop.fs.Options.CreateOpts.BlockSize -->
  <class name="Options.CreateOpts.BlockSize" extends="org.apache.hadoop.fs.Options.CreateOpts"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options.CreateOpts.BlockSize" type="long"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.fs.Options.CreateOpts.BlockSize -->
  <!-- start class org.apache.hadoop.fs.Options.CreateOpts.BufferSize -->
  <class name="Options.CreateOpts.BufferSize" extends="org.apache.hadoop.fs.Options.CreateOpts"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options.CreateOpts.BufferSize" type="int"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.fs.Options.CreateOpts.BufferSize -->
  <!-- start class org.apache.hadoop.fs.Options.CreateOpts.BytesPerChecksum -->
  <class name="Options.CreateOpts.BytesPerChecksum" extends="org.apache.hadoop.fs.Options.CreateOpts"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options.CreateOpts.BytesPerChecksum" type="short"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This is not needed if ChecksumParam is specified.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.Options.CreateOpts.BytesPerChecksum -->
  <!-- start class org.apache.hadoop.fs.Options.CreateOpts.ChecksumParam -->
  <class name="Options.CreateOpts.ChecksumParam" extends="org.apache.hadoop.fs.Options.CreateOpts"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options.CreateOpts.ChecksumParam" type="org.apache.hadoop.fs.Options.ChecksumOpt"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="org.apache.hadoop.fs.Options.ChecksumOpt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.fs.Options.CreateOpts.ChecksumParam -->
  <!-- start class org.apache.hadoop.fs.Options.CreateOpts.CreateParent -->
  <class name="Options.CreateOpts.CreateParent" extends="org.apache.hadoop.fs.Options.CreateOpts"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options.CreateOpts.CreateParent" type="boolean"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.fs.Options.CreateOpts.CreateParent -->
  <!-- start class org.apache.hadoop.fs.Options.CreateOpts.Perms -->
  <class name="Options.CreateOpts.Perms" extends="org.apache.hadoop.fs.Options.CreateOpts"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options.CreateOpts.Perms" type="org.apache.hadoop.fs.permission.FsPermission"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.fs.Options.CreateOpts.Perms -->
  <!-- start class org.apache.hadoop.fs.Options.CreateOpts.Progress -->
  <class name="Options.CreateOpts.Progress" extends="org.apache.hadoop.fs.Options.CreateOpts"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options.CreateOpts.Progress" type="org.apache.hadoop.util.Progressable"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="org.apache.hadoop.util.Progressable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.fs.Options.CreateOpts.Progress -->
  <!-- start class org.apache.hadoop.fs.Options.CreateOpts.ReplicationFactor -->
  <class name="Options.CreateOpts.ReplicationFactor" extends="org.apache.hadoop.fs.Options.CreateOpts"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options.CreateOpts.ReplicationFactor" type="short"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.fs.Options.CreateOpts.ReplicationFactor -->
  <!-- start class org.apache.hadoop.fs.Options.Rename -->
  <class name="Options.Rename" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.fs.Options.Rename[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.fs.Options.Rename"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="valueOf" return="org.apache.hadoop.fs.Options.Rename"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="code" type="byte"/>
    </method>
    <method name="value" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Enum to support the varargs for rename() options]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.Options.Rename -->
  <!-- start class org.apache.hadoop.fs.ParentNotDirectoryException -->
  <class name="ParentNotDirectoryException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ParentNotDirectoryException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ParentNotDirectoryException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Indicates that the parent of specified Path is not a directory
 as expected.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ParentNotDirectoryException -->
  <!-- start class org.apache.hadoop.fs.Path -->
  <class name="Path" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <constructor name="Path" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resolve a child path against a parent path.]]>
      </doc>
    </constructor>
    <constructor name="Path" type="org.apache.hadoop.fs.Path, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resolve a child path against a parent path.]]>
      </doc>
    </constructor>
    <constructor name="Path" type="java.lang.String, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resolve a child path against a parent path.]]>
      </doc>
    </constructor>
    <constructor name="Path" type="org.apache.hadoop.fs.Path, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resolve a child path against a parent path.]]>
      </doc>
    </constructor>
    <constructor name="Path" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Construct a path from a String.  Path strings are URIs, but with
 unescaped elements and some additional normalization.]]>
      </doc>
    </constructor>
    <constructor name="Path" type="java.net.URI"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a path from a URI]]>
      </doc>
    </constructor>
    <constructor name="Path" type="java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a Path from components.]]>
      </doc>
    </constructor>
    <method name="getPathWithoutSchemeAndAuthority" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="mergePaths" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path1" type="org.apache.hadoop.fs.Path"/>
      <param name="path2" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Merge 2 paths such that the second path is appended relative to the first.
 The returned path has the scheme and authority of the first path.  On
 Windows, the drive specification in the second path is discarded.
 
 @param path1 Path first path
 @param path2 Path second path, to be appended relative to path1
 @return Path merged path]]>
      </doc>
    </method>
    <method name="isWindowsAbsolutePath" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pathString" type="java.lang.String"/>
      <param name="slashed" type="boolean"/>
      <doc>
      <![CDATA[Determine whether a given path string represents an absolute path on
 Windows. e.g. "C:/a/b" is an absolute path. "C:a/b" is not.

 @param pathString Supplies the path string to evaluate.
 @param slashed true if the given path is prefixed with "/".
 @return true if the supplied path looks like an absolute path with a Windows
 drive-specifier.]]>
      </doc>
    </method>
    <method name="toUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Convert this to a URI.]]>
      </doc>
    </method>
    <method name="getFileSystem" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the FileSystem that owns this Path.]]>
      </doc>
    </method>
    <method name="isAbsoluteAndSchemeAuthorityNull" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Is an absolute path (ie a slash relative path part)
  AND  a scheme is null AND  authority is null.]]>
      </doc>
    </method>
    <method name="isUriPathAbsolute" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[True if the path component (i.e. directory) of this URI is absolute.]]>
      </doc>
    </method>
    <method name="isAbsolute" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[There is some ambiguity here. An absolute path is a slash
 relative name without a scheme or an authority.
 So either this method was incorrectly named or its
 implementation is incorrect. This method returns true
 even if there is a scheme and authority.]]>
      </doc>
    </method>
    <method name="isRoot" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return true if and only if this path represents the root of a file system]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the final component of this path.]]>
      </doc>
    </method>
    <method name="getParent" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the parent of a path or null if at root.]]>
      </doc>
    </method>
    <method name="suffix" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="suffix" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds a suffix to the final name in the path.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="depth" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the number of elements in this path.]]>
      </doc>
    </method>
    <method name="makeQualified" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <doc>
      <![CDATA[Returns a qualified path object.
  
  Deprecated - use {@link #makeQualified(URI, Path)}]]>
      </doc>
    </method>
    <method name="makeQualified" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaultUri" type="java.net.URI"/>
      <param name="workingDir" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Returns a qualified path object.]]>
      </doc>
    </method>
    <field name="SEPARATOR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The directory separator, a slash.]]>
      </doc>
    </field>
    <field name="SEPARATOR_CHAR" type="char"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CUR_DIR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WINDOWS" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Names a file or directory in a {@link FileSystem}.
 Path strings use slash as the directory separator.  A path string is
 absolute if it begins with a slash.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.Path -->
  <!-- start class org.apache.hadoop.fs.PathAccessDeniedException -->
  <class name="PathAccessDeniedException" extends="org.apache.hadoop.fs.PathIOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PathAccessDeniedException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param path for the exception]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[EACCES]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.PathAccessDeniedException -->
  <!-- start class org.apache.hadoop.fs.PathExistsException -->
  <class name="PathExistsException" extends="org.apache.hadoop.fs.PathIOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PathExistsException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param path for the exception]]>
      </doc>
    </constructor>
    <constructor name="PathExistsException" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Exception corresponding to File Exists - EEXISTS]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.PathExistsException -->
  <!-- start interface org.apache.hadoop.fs.PathFilter -->
  <interface name="PathFilter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="accept" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Tests whether or not the specified abstract pathname should be
 included in a pathname list.

 @param  path  The abstract pathname to be tested
 @return  <code>true</code> if and only if <code>pathname</code>
          should be included]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.fs.PathFilter -->
  <!-- start class org.apache.hadoop.fs.PathIOException -->
  <class name="PathIOException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PathIOException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor a generic I/O error exception
  @param path for the exception]]>
      </doc>
    </constructor>
    <constructor name="PathIOException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Appends the text of a Throwable to the default error message
 @param path for the exception
 @param cause a throwable to extract the error message]]>
      </doc>
    </constructor>
    <constructor name="PathIOException" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Avoid using this method.  Use a subclass of PathIOException if
 possible.
 @param path for the exception
 @param error custom string to use an the error text]]>
      </doc>
    </constructor>
    <constructor name="PathIOException" type="java.lang.String, java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Format:
 cmd: {operation} `path' {to `target'}: error string]]>
      </doc>
    </method>
    <method name="getPath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Path that generated the exception]]>
      </doc>
    </method>
    <method name="getTargetPath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Path if the operation involved copying or moving, else null]]>
      </doc>
    </method>
    <method name="setOperation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="operation" type="java.lang.String"/>
      <doc>
      <![CDATA[Optional operation that will preface the path
 @param operation a string]]>
      </doc>
    </method>
    <method name="setTargetPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetPath" type="java.lang.String"/>
      <doc>
      <![CDATA[Optional path if the exception involved two paths, ex. a copy operation
 @param targetPath the of the operation]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Exceptions based on standard posix/linux style exceptions for path related
 errors. Returns an exception with the format "path: standard error string".
 
 This exception corresponds to Error Input/ouput(EIO)]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.PathIOException -->
  <!-- start class org.apache.hadoop.fs.PathIsDirectoryException -->
  <class name="PathIsDirectoryException" extends="org.apache.hadoop.fs.PathExistsException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PathIsDirectoryException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param path for the exception]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[EISDIR]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.PathIsDirectoryException -->
  <!-- start class org.apache.hadoop.fs.PathIsNotDirectoryException -->
  <class name="PathIsNotDirectoryException" extends="org.apache.hadoop.fs.PathExistsException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PathIsNotDirectoryException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param path for the exception]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[ENOTDIR]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.PathIsNotDirectoryException -->
  <!-- start class org.apache.hadoop.fs.PathIsNotEmptyDirectoryException -->
  <class name="PathIsNotEmptyDirectoryException" extends="org.apache.hadoop.fs.PathExistsException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PathIsNotEmptyDirectoryException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param path for the exception]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Generated by rm commands]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.PathIsNotEmptyDirectoryException -->
  <!-- start class org.apache.hadoop.fs.PathNotFoundException -->
  <class name="PathNotFoundException" extends="org.apache.hadoop.fs.PathIOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PathNotFoundException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param path for the exception]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception corresponding to Permission denied - ENOENT]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.PathNotFoundException -->
  <!-- start class org.apache.hadoop.fs.PathOperationException -->
  <class name="PathOperationException" extends="org.apache.hadoop.fs.PathExistsException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PathOperationException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param path for the exception]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[ENOTSUP]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.PathOperationException -->
  <!-- start class org.apache.hadoop.fs.PathPermissionException -->
  <class name="PathPermissionException" extends="org.apache.hadoop.fs.PathIOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PathPermissionException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param path for the exception]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Exception corresponding to Operation Not Permitted - EPERM]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.PathPermissionException -->
  <!-- start interface org.apache.hadoop.fs.PositionedReadable -->
  <interface name="PositionedReadable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read upto the specified number of bytes, from a given
 position within a file, and return the number of bytes read. This does not
 change the current offset of a file, and is thread-safe.]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read the specified number of bytes, from a given
 position within a file. This does not
 change the current offset of a file, and is thread-safe.]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buffer" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read number of bytes equal to the length of the buffer, from a given
 position within a file. This does not
 change the current offset of a file, and is thread-safe.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Stream that permits positional reading.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.PositionedReadable -->
  <!-- start class org.apache.hadoop.fs.RawLocalFileSystem -->
  <class name="RawLocalFileSystem" extends="org.apache.hadoop.fs.FileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RawLocalFileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="useStatIfAvailable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="pathToFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Convert a path to a File.]]>
      </doc>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createOutputStream" return="java.io.OutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="append" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createNonRecursive" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flags" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createNonRecursive" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="rename" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete the given path to a file or directory.
 @param p the path to delete
 @param recursive to delete sub-directories
 @return true if the file or directory and all its contents were deleted
 @throws IOException if p is non-empty and recursive is false]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mkOneDir" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="p2f" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates the specified directory hierarchy. Does not
 treat existence as an error.]]>
      </doc>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="primitiveMkdir" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="absolutePermission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setWorkingDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newDir" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Set the working directory to the given directory.]]>
      </doc>
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInitialWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getStatus" return="org.apache.hadoop.fs.FsStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="moveFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startLocalOutput" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="completeLocalOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsWorkingFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Use the command chown to set owner.]]>
      </doc>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Use the command chmod to set permission.]]>
      </doc>
    </method>
    <method name="setTimes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="mtime" type="long"/>
      <param name="atime" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Sets the {@link Path}'s last modified time <em>only</em> to the given
 valid time.

 @param mtime the modification time to set (only if greater than zero).
 @param atime currently ignored.
 @throws IOException if setting the last modified time fails.]]>
      </doc>
    </method>
    <method name="supportsSymlinks" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createSymlink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.apache.hadoop.fs.Path"/>
      <param name="link" type="org.apache.hadoop.fs.Path"/>
      <param name="createParent" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileLinkStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a FileStatus representing the given path. If the path refers
 to a symlink return a FileStatus representing the link rather than
 the object the link refers to.]]>
      </doc>
    </method>
    <method name="getLinkTarget" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Implement the FileSystem API for the raw local filesystem.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.RawLocalFileSystem -->
  <!-- start class org.apache.hadoop.fs.ReadOption -->
  <class name="ReadOption" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.fs.ReadOption[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.fs.ReadOption"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Options that can be used when reading from a FileSystem.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ReadOption -->
  <!-- start interface org.apache.hadoop.fs.RemoteIterator -->
  <interface name="RemoteIterator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns <tt>true</tt> if the iteration has more elements.

 @return <tt>true</tt> if the iterator has more elements.
 @throws IOException if any IO error occurs]]>
      </doc>
    </method>
    <method name="next" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the next element in the iteration.

 @return the next element in the iteration.
 @throws NoSuchElementException iteration has no more elements.
 @throws IOException if any IO error occurs]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An iterator over a collection whose elements need to be fetched remotely]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.RemoteIterator -->
  <!-- start interface org.apache.hadoop.fs.Seekable -->
  <interface name="Seekable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="seek"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Seek to the given offset from the start of the file.
 The next read() will be from that location.  Can't
 seek past the end of the file.]]>
      </doc>
    </method>
    <method name="getPos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the current offset from the start of the file]]>
      </doc>
    </method>
    <method name="seekToNewSource" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetPos" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Seeks a different copy of the data.  Returns true if 
 found a new source, false otherwise.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Stream that permits seeking.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.Seekable -->
  <!-- start interface org.apache.hadoop.fs.Syncable -->
  <interface name="Syncable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="sync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="As of HADOOP 0.21.0, replaced by hflush">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@deprecated As of HADOOP 0.21.0, replaced by hflush
 @see #hflush()]]>
      </doc>
    </method>
    <method name="hflush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Flush out the data in client's user buffer. After the return of
 this call, new readers will see the data.
 @throws IOException if any error occurs]]>
      </doc>
    </method>
    <method name="hsync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Similar to posix fsync, flush out the data in client's user buffer 
 all the way to the disk device (but the disk may have it in its cache).
 @throws IOException if error occurs]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This interface for flush/sync operation.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.Syncable -->
  <!-- start class org.apache.hadoop.fs.Trash -->
  <class name="Trash" extends="org.apache.hadoop.conf.Configured"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Trash" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a trash can accessor.
 @param conf a Configuration]]>
      </doc>
    </constructor>
    <constructor name="Trash" type="org.apache.hadoop.fs.FileSystem, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a trash can accessor for the FileSystem provided.
 @param fs the FileSystem
 @param conf a Configuration]]>
      </doc>
    </constructor>
    <method name="moveToAppropriateTrash" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[In case of the symlinks or mount points, one has to move the appropriate
 trashbin in the actual volume of the path p being deleted.

 Hence we get the file system of the fully-qualified resolved-path and
 then move the path p to the trashbin in that volume,
 @param fs - the filesystem of path p
 @param p - the  path being deleted - to be moved to trasg
 @param conf - configuration
 @return false if the item is already in the trash or trash is disabled
 @throws IOException on error]]>
      </doc>
    </method>
    <method name="isEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the trash is enabled for this filesystem]]>
      </doc>
    </method>
    <method name="moveToTrash" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Move a file or directory to the current trash directory.
 @return false if the item is already in the trash or trash is disabled]]>
      </doc>
    </method>
    <method name="checkpoint"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a trash checkpoint.]]>
      </doc>
    </method>
    <method name="expunge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete old checkpoint(s).]]>
      </doc>
    </method>
    <method name="getEmptier" return="java.lang.Runnable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a {@link Runnable} that periodically empties the trash of all
 users, intended to be run by the superuser.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides a trash facility which supports pluggable Trash policies. 

 See the implementation of the configured TrashPolicy for more
 details.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.Trash -->
  <!-- start class org.apache.hadoop.fs.TrashPolicy -->
  <class name="TrashPolicy" extends="org.apache.hadoop.conf.Configured"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TrashPolicy"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="initialize"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="home" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Used to setup the trash policy. Must be implemented by all TrashPolicy
 implementations
 @param conf the configuration to be used
 @param fs the filesystem to be used
 @param home the home directory]]>
      </doc>
    </method>
    <method name="isEnabled" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether the Trash Policy is enabled for this filesystem]]>
      </doc>
    </method>
    <method name="moveToTrash" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Move a file or directory to the current trash directory.
 @return false if the item is already in the trash or trash is disabled]]>
      </doc>
    </method>
    <method name="createCheckpoint"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a trash checkpoint.]]>
      </doc>
    </method>
    <method name="deleteCheckpoint"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete old trash checkpoint(s).]]>
      </doc>
    </method>
    <method name="getCurrentTrashDir" return="org.apache.hadoop.fs.Path"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current working directory of the Trash Policy]]>
      </doc>
    </method>
    <method name="getEmptier" return="java.lang.Runnable"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a {@link Runnable} that periodically empties the trash of all
 users, intended to be run by the superuser.]]>
      </doc>
    </method>
    <method name="getInstance" return="org.apache.hadoop.fs.TrashPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="home" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Get an instance of the configured TrashPolicy based on the value 
 of the configuration parameter fs.trash.classname.

 @param conf the configuration to be used
 @param fs the file system to be used
 @param home the home directory
 @return an instance of TrashPolicy]]>
      </doc>
    </method>
    <field name="fs" type="org.apache.hadoop.fs.FileSystem"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="trash" type="org.apache.hadoop.fs.Path"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="deletionInterval" type="long"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This interface is used for implementing different Trash policies.
 Provides factory method to create instances of the configured Trash policy.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.TrashPolicy -->
  <!-- start class org.apache.hadoop.fs.UnsupportedFileSystemException -->
  <class name="UnsupportedFileSystemException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UnsupportedFileSystemException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs exception with the specified detail message. 
 @param message exception message.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[File system for a given file system name/scheme is not supported]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.UnsupportedFileSystemException -->
  <!-- start class org.apache.hadoop.fs.XAttrCodec -->
  <class name="XAttrCodec" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.fs.XAttrCodec[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.fs.XAttrCodec"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="decodeValue" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Decode string representation of a value and check whether it's 
 encoded. If the given string begins with 0x or 0X, it expresses
 a hexadecimal number. If the given string begins with 0s or 0S,
 base64 encoding is expected. If the given string is enclosed in 
 double quotes, the inner string is treated as text. Otherwise 
 the given string is treated as text. 
 @param value string representation of the value.
 @return byte[] the value
 @throws IOException]]>
      </doc>
    </method>
    <method name="encodeValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte[]"/>
      <param name="encoding" type="org.apache.hadoop.fs.XAttrCodec"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Encode byte[] value to string representation with encoding. 
 Values encoded as text strings are enclosed in double quotes (\"), 
 while strings encoded as hexadecimal and base64 are prefixed with 
 0x and 0s, respectively.
 @param value byte[] value
 @param encoding
 @return String string representation of value
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The value of <code>XAttr</code> is byte[], this class is to 
 covert byte[] to some kind of string representation or convert back.
 String representation is convenient for display and input. For example
 display in screen as shell response and json response, input as http
 or shell parameter.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.XAttrCodec -->
  <!-- start class org.apache.hadoop.fs.XAttrSetFlag -->
  <class name="XAttrSetFlag" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.fs.XAttrSetFlag[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.fs.XAttrSetFlag"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="validate"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="xAttrName" type="java.lang.String"/>
      <param name="xAttrExists" type="boolean"/>
      <param name="flag" type="java.util.EnumSet"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.fs.XAttrSetFlag -->
  <!-- start class org.apache.hadoop.fs.ZeroCopyUnavailableException -->
  <class name="ZeroCopyUnavailableException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ZeroCopyUnavailableException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ZeroCopyUnavailableException" type="java.lang.String, java.lang.Exception"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ZeroCopyUnavailableException" type="java.lang.Exception"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.fs.ZeroCopyUnavailableException -->
  <doc>
  <![CDATA[An abstract file system API.]]>
  </doc>
</package>
<package name="org.apache.hadoop.fs.crypto">
  <!-- start class org.apache.hadoop.fs.crypto.CryptoFSDataInputStream -->
  <class name="CryptoFSDataInputStream" extends="org.apache.hadoop.fs.FSDataInputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CryptoFSDataInputStream" type="org.apache.hadoop.fs.FSDataInputStream, org.apache.hadoop.crypto.CryptoCodec, int, byte[], byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="CryptoFSDataInputStream" type="org.apache.hadoop.fs.FSDataInputStream, org.apache.hadoop.crypto.CryptoCodec, byte[], byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.fs.crypto.CryptoFSDataInputStream -->
  <!-- start class org.apache.hadoop.fs.crypto.CryptoFSDataOutputStream -->
  <class name="CryptoFSDataOutputStream" extends="org.apache.hadoop.fs.FSDataOutputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CryptoFSDataOutputStream" type="org.apache.hadoop.fs.FSDataOutputStream, org.apache.hadoop.crypto.CryptoCodec, int, byte[], byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="CryptoFSDataOutputStream" type="org.apache.hadoop.fs.FSDataOutputStream, org.apache.hadoop.crypto.CryptoCodec, byte[], byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="getPos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.fs.crypto.CryptoFSDataOutputStream -->
</package>
<package name="org.apache.hadoop.fs.ftp">
  <!-- start class org.apache.hadoop.fs.ftp.FTPException -->
  <class name="FTPException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FTPException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FTPException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FTPException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[A class to wrap a {@link Throwable} into a Runtime Exception.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ftp.FTPException -->
  <!-- start class org.apache.hadoop.fs.ftp.FTPFileSystem -->
  <class name="FTPFileSystem" extends="org.apache.hadoop.fs.FileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FTPFileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getScheme" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the protocol scheme for the FileSystem.
 <p/>

 @return <code>ftp</code>]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A stream obtained via this call must be closed before using other APIs of
 this class or else the invocation will block.]]>
      </doc>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This optional operation is not yet supported.]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="rename" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setWorkingDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newDir" type="org.apache.hadoop.fs.Path"/>
    </method>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_BUFFER_SIZE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_BLOCK_SIZE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FS_FTP_USER_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FS_FTP_HOST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FS_FTP_HOST_PORT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FS_FTP_PASSWORD_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="E_SAME_DIRECTORY_ONLY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[<p>
 A {@link FileSystem} backed by an FTP client provided by <a
 href="http://commons.apache.org/net/">Apache Commons Net</a>.
 </p>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ftp.FTPFileSystem -->
</package>
<package name="org.apache.hadoop.fs.permission">
  <!-- start class org.apache.hadoop.fs.permission.AccessControlException -->
  <class name="AccessControlException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Use {@link org.apache.hadoop.security.AccessControlException} 
             instead.">
    <constructor name="AccessControlException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor is needed for unwrapping from 
 {@link org.apache.hadoop.ipc.RemoteException}.]]>
      </doc>
    </constructor>
    <constructor name="AccessControlException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an {@link AccessControlException}
 with the specified detail message.
 @param s the detail message.]]>
      </doc>
    </constructor>
    <constructor name="AccessControlException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a new exception with the specified cause and a detail
 message of <tt>(cause==null ? null : cause.toString())</tt> (which
 typically contains the class and detail message of <tt>cause</tt>).
 @param  cause the cause (which is saved for later retrieval by the
         {@link #getCause()} method).  (A <tt>null</tt> value is
         permitted, and indicates that the cause is nonexistent or
         unknown.)]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[An exception class for access control related issues.
 @deprecated Use {@link org.apache.hadoop.security.AccessControlException} 
             instead.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.permission.AccessControlException -->
  <!-- start class org.apache.hadoop.fs.permission.AclEntry -->
  <class name="AclEntry" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getType" return="org.apache.hadoop.fs.permission.AclEntryType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the ACL entry type.

 @return AclEntryType ACL entry type]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the optional ACL entry name.

 @return String ACL entry name, or null if undefined]]>
      </doc>
    </method>
    <method name="getPermission" return="org.apache.hadoop.fs.permission.FsAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the set of permissions in the ACL entry.

 @return FsAction set of permissions in the ACL entry]]>
      </doc>
    </method>
    <method name="getScope" return="org.apache.hadoop.fs.permission.AclEntryScope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the scope of the ACL entry.

 @return AclEntryScope scope of the ACL entry]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="parseAclSpec" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="aclSpec" type="java.lang.String"/>
      <param name="includePermission" type="boolean"/>
      <doc>
      <![CDATA[Parses a string representation of an ACL spec into a list of AclEntry
 objects. Example: "user::rwx,user:foo:rw-,group::r--,other::---"
 
 @param aclSpec
          String representation of an ACL spec.
 @param includePermission
          for setAcl operations this will be true. i.e. AclSpec should
          include permissions.<br>
          But for removeAcl operation it will be false. i.e. AclSpec should
          not contain permissions.<br>
          Example: "user:foo,group:bar"
 @return Returns list of {@link AclEntry} parsed]]>
      </doc>
    </method>
    <method name="parseAclEntry" return="org.apache.hadoop.fs.permission.AclEntry"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="aclStr" type="java.lang.String"/>
      <param name="includePermission" type="boolean"/>
      <doc>
      <![CDATA[Parses a string representation of an ACL into a AclEntry object.<br>
 
 @param aclStr
          String representation of an ACL.<br>
          Example: "user:foo:rw-"
 @param includePermission
          for setAcl operations this will be true. i.e. Acl should include
          permissions.<br>
          But for removeAcl operation it will be false. i.e. Acl should not
          contain permissions.<br>
          Example: "user:foo,group:bar,mask::"
 @return Returns an {@link AclEntry} object]]>
      </doc>
    </method>
    <method name="aclSpecToString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="aclSpec" type="java.util.List"/>
      <doc>
      <![CDATA[Convert a List of AclEntries into a string - the reverse of parseAclSpec.
 @param aclSpec List of AclEntries to convert
 @return String representation of aclSpec]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Defines a single entry in an ACL.  An ACL entry has a type (user, group,
 mask, or other), an optional name (referring to a specific user or group), a
 set of permissions (any combination of read, write and execute), and a scope
 (access or default).  AclEntry instances are immutable.  Use a {@link Builder}
 to create a new instance.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.permission.AclEntry -->
  <!-- start class org.apache.hadoop.fs.permission.AclEntry.Builder -->
  <class name="AclEntry.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AclEntry.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setType" return="org.apache.hadoop.fs.permission.AclEntry.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.apache.hadoop.fs.permission.AclEntryType"/>
      <doc>
      <![CDATA[Sets the ACL entry type.

 @param type AclEntryType ACL entry type
 @return Builder this builder, for call chaining]]>
      </doc>
    </method>
    <method name="setName" return="org.apache.hadoop.fs.permission.AclEntry.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the optional ACL entry name.

 @param name String optional ACL entry name
 @return Builder this builder, for call chaining]]>
      </doc>
    </method>
    <method name="setPermission" return="org.apache.hadoop.fs.permission.AclEntry.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permission" type="org.apache.hadoop.fs.permission.FsAction"/>
      <doc>
      <![CDATA[Sets the set of permissions in the ACL entry.

 @param permission FsAction set of permissions in the ACL entry
 @return Builder this builder, for call chaining]]>
      </doc>
    </method>
    <method name="setScope" return="org.apache.hadoop.fs.permission.AclEntry.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scope" type="org.apache.hadoop.fs.permission.AclEntryScope"/>
      <doc>
      <![CDATA[Sets the scope of the ACL entry.  If this method is not called, then the
 builder assumes {@link AclEntryScope#ACCESS}.

 @param scope AclEntryScope scope of the ACL entry
 @return Builder this builder, for call chaining]]>
      </doc>
    </method>
    <method name="build" return="org.apache.hadoop.fs.permission.AclEntry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a new AclEntry populated with the set properties.

 @return AclEntry new AclEntry]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Builder for creating new AclEntry instances.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.permission.AclEntry.Builder -->
  <!-- start class org.apache.hadoop.fs.permission.AclEntryScope -->
  <class name="AclEntryScope" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.fs.permission.AclEntryScope[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.fs.permission.AclEntryScope"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Specifies the scope or intended usage of an ACL entry.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.permission.AclEntryScope -->
  <!-- start class org.apache.hadoop.fs.permission.AclEntryType -->
  <class name="AclEntryType" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.fs.permission.AclEntryType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.fs.permission.AclEntryType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Specifies the type of an ACL entry.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.permission.AclEntryType -->
  <!-- start class org.apache.hadoop.fs.permission.AclStatus -->
  <class name="AclStatus" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getOwner" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the file owner.

 @return String file owner]]>
      </doc>
    </method>
    <method name="getGroup" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the file group.

 @return String file group]]>
      </doc>
    </method>
    <method name="isStickyBit" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the sticky bit.
 
 @return boolean sticky bit]]>
      </doc>
    </method>
    <method name="getEntries" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the list of all ACL entries, ordered by their natural ordering.

 @return List<AclEntry> unmodifiable ordered list of all ACL entries]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An AclStatus contains the ACL information of a specific file. AclStatus
 instances are immutable. Use a {@link Builder} to create a new instance.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.permission.AclStatus -->
  <!-- start class org.apache.hadoop.fs.permission.AclStatus.Builder -->
  <class name="AclStatus.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AclStatus.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="owner" return="org.apache.hadoop.fs.permission.AclStatus.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="owner" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the file owner.

 @param owner String file owner
 @return Builder this builder, for call chaining]]>
      </doc>
    </method>
    <method name="group" return="org.apache.hadoop.fs.permission.AclStatus.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="group" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the file group.

 @param group String file group
 @return Builder this builder, for call chaining]]>
      </doc>
    </method>
    <method name="addEntry" return="org.apache.hadoop.fs.permission.AclStatus.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="org.apache.hadoop.fs.permission.AclEntry"/>
      <doc>
      <![CDATA[Adds an ACL entry.

 @param e AclEntry entry to add
 @return Builder this builder, for call chaining]]>
      </doc>
    </method>
    <method name="addEntries" return="org.apache.hadoop.fs.permission.AclStatus.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entries" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[Adds a list of ACL entries.

 @param entries AclEntry entries to add
 @return Builder this builder, for call chaining]]>
      </doc>
    </method>
    <method name="stickyBit" return="org.apache.hadoop.fs.permission.AclStatus.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stickyBit" type="boolean"/>
      <doc>
      <![CDATA[Sets sticky bit. If this method is not called, then the builder assumes
 false.

 @param stickyBit
          boolean sticky bit
 @return Builder this builder, for call chaining]]>
      </doc>
    </method>
    <method name="build" return="org.apache.hadoop.fs.permission.AclStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds a new AclStatus populated with the set properties.

 @return AclStatus new AclStatus]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Builder for creating new Acl instances.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.permission.AclStatus.Builder -->
  <!-- start class org.apache.hadoop.fs.permission.FsAction -->
  <class name="FsAction" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.fs.permission.FsAction[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.fs.permission.FsAction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="implies" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="that" type="org.apache.hadoop.fs.permission.FsAction"/>
      <doc>
      <![CDATA[Return true if this action implies that action.
 @param that]]>
      </doc>
    </method>
    <method name="and" return="org.apache.hadoop.fs.permission.FsAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="that" type="org.apache.hadoop.fs.permission.FsAction"/>
      <doc>
      <![CDATA[AND operation.]]>
      </doc>
    </method>
    <method name="or" return="org.apache.hadoop.fs.permission.FsAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="that" type="org.apache.hadoop.fs.permission.FsAction"/>
      <doc>
      <![CDATA[OR operation.]]>
      </doc>
    </method>
    <method name="not" return="org.apache.hadoop.fs.permission.FsAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[NOT operation.]]>
      </doc>
    </method>
    <method name="getFsAction" return="org.apache.hadoop.fs.permission.FsAction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permission" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the FsAction enum for String representation of permissions
 
 @param permission
          3-character string representation of permission. ex: rwx
 @return Returns FsAction enum if the corresponding FsAction exists for permission.
         Otherwise returns null]]>
      </doc>
    </method>
    <field name="SYMBOL" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Symbolic representation]]>
      </doc>
    </field>
    <doc>
    <![CDATA[File system actions, e.g. read, write, etc.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.permission.FsAction -->
  <!-- start class org.apache.hadoop.fs.permission.FsPermission -->
  <class name="FsPermission" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="FsPermission" type="org.apache.hadoop.fs.permission.FsAction, org.apache.hadoop.fs.permission.FsAction, org.apache.hadoop.fs.permission.FsAction"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct by the given {@link FsAction}.
 @param u user action
 @param g group action
 @param o other action]]>
      </doc>
    </constructor>
    <constructor name="FsPermission" type="org.apache.hadoop.fs.permission.FsAction, org.apache.hadoop.fs.permission.FsAction, org.apache.hadoop.fs.permission.FsAction, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FsPermission" type="short"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct by the given mode.
 @param mode
 @see #toShort()]]>
      </doc>
    </constructor>
    <constructor name="FsPermission" type="org.apache.hadoop.fs.permission.FsPermission"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Copy constructor
 
 @param other other permission]]>
      </doc>
    </constructor>
    <constructor name="FsPermission" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct by given mode, either in octal or symbolic format.
 @param mode mode as a string, either in octal or symbolic format
 @throws IllegalArgumentException if <code>mode</code> is invalid]]>
      </doc>
    </constructor>
    <method name="createImmutable" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="permission" type="short"/>
      <doc>
      <![CDATA[Create an immutable {@link FsPermission} object.]]>
      </doc>
    </method>
    <method name="getUserAction" return="org.apache.hadoop.fs.permission.FsAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return user {@link FsAction}.]]>
      </doc>
    </method>
    <method name="getGroupAction" return="org.apache.hadoop.fs.permission.FsAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return group {@link FsAction}.]]>
      </doc>
    </method>
    <method name="getOtherAction" return="org.apache.hadoop.fs.permission.FsAction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return other {@link FsAction}.]]>
      </doc>
    </method>
    <method name="fromShort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="short"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create and initialize a {@link FsPermission} from {@link DataInput}.]]>
      </doc>
    </method>
    <method name="toShort" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Encode the object to a short.]]>
      </doc>
    </method>
    <method name="toExtendedShort" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Encodes the object to a short.  Unlike {@link #toShort()}, this method may
 return values outside the fixed range 00000 - 01777 if extended features
 are encoded into this permission, such as the ACL bit.

 @return short extended short representation of this permission]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="applyUMask" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="umask" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <doc>
      <![CDATA[Apply a umask to this permission and return a new one.

 The umask is used by create, mkdir, and other Hadoop filesystem operations.
 The mode argument for these operations is modified by removing the bits
 which are set in the umask.  Thus, the umask limits the permissions which
 newly created files and directories get.

 @param umask              The umask to use
 
 @return                   The effective permission]]>
      </doc>
    </method>
    <method name="getUMask" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the user file creation mask (umask)
 
 {@code UMASK_LABEL} config param has umask value that is either symbolic 
 or octal.
 
 Symbolic umask is applied relative to file mode creation mask; 
 the permission op characters '+' clears the corresponding bit in the mask, 
 '-' sets bits in the mask.
 
 Octal umask, the specified bits are set in the file mode creation mask.
 
 {@code DEPRECATED_UMASK_LABEL} config param has umask value set to decimal.]]>
      </doc>
    </method>
    <method name="getStickyBit" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAclBit" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if there is also an ACL (access control list).

 @return boolean true if there is also an ACL (access control list).]]>
      </doc>
    </method>
    <method name="getEncryptedBit" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the file is encrypted or directory is in an encryption zone]]>
      </doc>
    </method>
    <method name="setUMask"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="umask" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <doc>
      <![CDATA[Set the user file creation mask (umask)]]>
      </doc>
    </method>
    <method name="getDefault" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the default permission for directory and symlink.
 In previous versions, this default permission was also used to
 create files, so files created end up with ugo+x permission.
 See HADOOP-9155 for detail. 
 Two new methods are added to solve this, please use 
 {@link FsPermission#getDirDefault()} for directory, and use
 {@link FsPermission#getFileDefault()} for file.
 This method is kept for compatibility.]]>
      </doc>
    </method>
    <method name="getDirDefault" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the default permission for directory.]]>
      </doc>
    </method>
    <method name="getFileDefault" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the default permission for file.]]>
      </doc>
    </method>
    <method name="getCachePoolDefault" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the default permission for cache pools.]]>
      </doc>
    </method>
    <method name="valueOf" return="org.apache.hadoop.fs.permission.FsPermission"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="unixSymbolicPermission" type="java.lang.String"/>
      <doc>
      <![CDATA[Create a FsPermission from a Unix symbolic permission string
 @param unixSymbolicPermission e.g. "-rw-rw-rw-"]]>
      </doc>
    </method>
    <field name="MAX_PERMISSION_LENGTH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Maximum acceptable length of a permission string to parse]]>
      </doc>
    </field>
    <field name="DEPRECATED_UMASK_LABEL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[umask property label deprecated key and code in getUMask method
  to accommodate it may be removed in version .23]]>
      </doc>
    </field>
    <field name="UMASK_LABEL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_UMASK" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A class for file/directory permissions.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.permission.FsPermission -->
</package>
<package name="org.apache.hadoop.fs.viewfs">
  <!-- start class org.apache.hadoop.fs.viewfs.ConfigUtil -->
  <class name="ConfigUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConfigUtil"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getConfigViewFsPrefix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mountTableName" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the config variable prefix for the specified mount table
 @param mountTableName - the name of the mount table
 @return the config variable prefix for the specified mount table]]>
      </doc>
    </method>
    <method name="getConfigViewFsPrefix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the config variable prefix for the default mount table
 @return the config variable prefix for the default mount table]]>
      </doc>
    </method>
    <method name="addLink"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="mountTableName" type="java.lang.String"/>
      <param name="src" type="java.lang.String"/>
      <param name="target" type="java.net.URI"/>
      <doc>
      <![CDATA[Add a link to the config for the specified mount table
 @param conf - add the link to this conf
 @param mountTableName
 @param src - the src path name
 @param target - the target URI link]]>
      </doc>
    </method>
    <method name="addLink"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="src" type="java.lang.String"/>
      <param name="target" type="java.net.URI"/>
      <doc>
      <![CDATA[Add a link to the config for the default mount table
 @param conf - add the link to this conf
 @param src - the src path name
 @param target - the target URI link]]>
      </doc>
    </method>
    <method name="setHomeDirConf"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="homedir" type="java.lang.String"/>
      <doc>
      <![CDATA[Add config variable for homedir for default mount table
 @param conf - add to this conf
 @param homedir - the home dir path starting with slash]]>
      </doc>
    </method>
    <method name="setHomeDirConf"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="mountTableName" type="java.lang.String"/>
      <param name="homedir" type="java.lang.String"/>
      <doc>
      <![CDATA[Add config variable for homedir the specified mount table
 @param conf - add to this conf
 @param homedir - the home dir path starting with slash]]>
      </doc>
    </method>
    <method name="getHomeDirValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the value of the home dir conf value for default mount table
 @param conf - from this conf
 @return home dir value, null if variable is not in conf]]>
      </doc>
    </method>
    <method name="getHomeDirValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="mountTableName" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the home dir conf value for specfied mount table
 @param conf - from this conf
 @param mountTableName - the mount table
 @return home dir value, null if variable is not in conf]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utilities for config variables of the viewFs See {@link ViewFs}]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.viewfs.ConfigUtil -->
  <!-- start interface org.apache.hadoop.fs.viewfs.Constants -->
  <interface name="Constants"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="CONFIG_VIEWFS_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Prefix for the config variable prefix for the ViewFs mount-table]]>
      </doc>
    </field>
    <field name="CONFIG_VIEWFS_HOMEDIR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Prefix for the home dir for the mount table - if not specified
 then the hadoop default value (/user) is used.]]>
      </doc>
    </field>
    <field name="CONFIG_VIEWFS_DEFAULT_MOUNT_TABLE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Config variable name for the default mount table.]]>
      </doc>
    </field>
    <field name="CONFIG_VIEWFS_PREFIX_DEFAULT_MOUNT_TABLE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Config variable full prefix for the default mount table.]]>
      </doc>
    </field>
    <field name="CONFIG_VIEWFS_LINK" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Config variable for specifying a simple link]]>
      </doc>
    </field>
    <field name="CONFIG_VIEWFS_LINK_MERGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Config variable for specifying a merge link]]>
      </doc>
    </field>
    <field name="CONFIG_VIEWFS_LINK_MERGE_SLASH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Config variable for specifying a merge of the root of the mount-table
  with the root of another file system.]]>
      </doc>
    </field>
    <field name="PERMISSION_555" type="org.apache.hadoop.fs.permission.FsPermission"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Config variable prefixes for ViewFs -
     see {@link org.apache.hadoop.fs.viewfs.ViewFs} for examples.
 The mount table is specified in the config using these prefixes.
 See {@link org.apache.hadoop.fs.viewfs.ConfigUtil} for convenience lib.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.viewfs.Constants -->
  <!-- start class org.apache.hadoop.fs.viewfs.NotInMountpointException -->
  <class name="NotInMountpointException" extends="java.lang.UnsupportedOperationException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NotInMountpointException" type="org.apache.hadoop.fs.Path, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="NotInMountpointException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[NotInMountpointException extends the UnsupportedOperationException.
 Exception class used in cases where the given path is not mounted 
 through viewfs.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.viewfs.NotInMountpointException -->
  <!-- start class org.apache.hadoop.fs.viewfs.ViewFileSystem -->
  <class name="ViewFileSystem" extends="org.apache.hadoop.fs.FileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ViewFileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This is the  constructor with the signature needed by
 {@link FileSystem#createFileSystem(URI, Configuration)}
 
 After this constructor is called initialize() is called.
 @throws IOException]]>
      </doc>
    </constructor>
    <constructor name="ViewFileSystem" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Convenience Constructor for apps to call directly
 @param conf
 @throws IOException]]>
      </doc>
    </constructor>
    <method name="getScheme" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the protocol scheme for the FileSystem.
 <p/>

 @return <code>viewfs</code>]]>
      </doc>
    </method>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="theUri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Called after a new FileSystem instance is constructed.
 @param theUri a uri whose authority section names the host, port, etc. for
          this FileSystem
 @param conf the configuration]]>
      </doc>
    </method>
    <method name="getTrashCanLocation" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="resolvePath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setWorkingDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="new_dir" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createNonRecursive" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flags" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileBlockLocations" return="org.apache.hadoop.fs.BlockLocation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileStatus"/>
      <param name="start" type="long"/>
      <param name="len" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileChecksum" return="org.apache.hadoop.fs.FileChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="access"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="mode" type="org.apache.hadoop.fs.permission.FsAction"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="rename" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setReplication" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setTimes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="mtime" type="long"/>
      <param name="atime" type="long"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="modifyAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeDefaultAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getAclStatus" return="org.apache.hadoop.fs.permission.AclStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <param name="flag" type="java.util.EnumSet"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getXAttr" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="names" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="listXAttrs" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setVerifyChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="verifyChecksum" type="boolean"/>
    </method>
    <method name="getDefaultBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDefaultReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getServerDefaults" return="org.apache.hadoop.fs.FsServerDefaults"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getDefaultBlockSize" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="getDefaultReplication" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="getServerDefaults" return="org.apache.hadoop.fs.FsServerDefaults"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getContentSummary" return="org.apache.hadoop.fs.ContentSummary"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setWriteChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writeChecksum" type="boolean"/>
    </method>
    <method name="getChildFileSystems" return="org.apache.hadoop.fs.FileSystem[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMountPoints" return="org.apache.hadoop.fs.viewfs.ViewFileSystem.MountPoint[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[ViewFileSystem (extends the FileSystem interface) implements a client-side
 mount table. Its spec and implementation is identical to {@link ViewFs}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.viewfs.ViewFileSystem -->
  <!-- start class org.apache.hadoop.fs.viewfs.ViewFileSystem.MountPoint -->
  <class name="ViewFileSystem.MountPoint" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
  </class>
  <!-- end class org.apache.hadoop.fs.viewfs.ViewFileSystem.MountPoint -->
  <!-- start class org.apache.hadoop.fs.viewfs.ViewFs -->
  <class name="ViewFs" extends="org.apache.hadoop.fs.AbstractFileSystem"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ViewFs" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="URISyntaxException" type="java.net.URISyntaxException"/>
    </constructor>
    <method name="getServerDefaults" return="org.apache.hadoop.fs.FsServerDefaults"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getUriDefaultPort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="resolvePath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createInternal" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="flag" type="java.util.EnumSet"/>
      <param name="absolutePermission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="checksumOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
      <param name="createParent" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileBlockLocations" return="org.apache.hadoop.fs.BlockLocation[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="start" type="long"/>
      <param name="len" type="long"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileChecksum" return="org.apache.hadoop.fs.FileChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="access"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="mode" type="org.apache.hadoop.fs.permission.FsAction"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileLinkStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFsStatus" return="org.apache.hadoop.fs.FsStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="listStatusIterator" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mkdir"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="createParent" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="renameInternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
    </method>
    <method name="renameInternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="supportsSymlinks" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createSymlink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.apache.hadoop.fs.Path"/>
      <param name="link" type="org.apache.hadoop.fs.Path"/>
      <param name="createParent" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
    </method>
    <method name="getLinkTarget" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setReplication" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setTimes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="mtime" type="long"/>
      <param name="atime" type="long"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setVerifyChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="verifyChecksum" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getMountPoints" return="org.apache.hadoop.fs.viewfs.ViewFs.MountPoint[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDelegationTokens" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="renewer" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="isValidName" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="java.lang.String"/>
    </method>
    <method name="modifyAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeDefaultAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getAclStatus" return="org.apache.hadoop.fs.permission.AclStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <param name="flag" type="java.util.EnumSet"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getXAttr" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="names" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="listXAttrs" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[ViewFs (extends the AbstractFileSystem interface) implements a client-side
 mount table. The viewFs file system is implemented completely in memory on
 the client side. The client-side mount table allows a client to provide a 
 customized view of a file system namespace that is composed from 
 one or more individual file systems (a localFs or Hdfs, S3fs, etc).
 For example one could have a mount table that provides links such as
 <ul>
 <li>  /user          -> hdfs://nnContainingUserDir/user
 <li>  /project/foo   -> hdfs://nnProject1/projects/foo
 <li>  /project/bar   -> hdfs://nnProject2/projects/bar
 <li>  /tmp           -> hdfs://nnTmp/privateTmpForUserXXX
 </ul> 
 
 ViewFs is specified with the following URI: <b>viewfs:///</b> 
 <p>
 To use viewfs one would typically set the default file system in the
 config  (i.e. fs.default.name< = viewfs:///) along with the
 mount table config variables as described below. 
 
 <p>
 <b> ** Config variables to specify the mount table entries ** </b>
 <p>
 
 The file system is initialized from the standard Hadoop config through
 config variables.
 See {@link FsConstants} for URI and Scheme constants; 
 See {@link Constants} for config var constants; 
 see {@link ConfigUtil} for convenient lib.
 
 <p>
 All the mount table config entries for view fs are prefixed by 
 <b>fs.viewfs.mounttable.</b>
 For example the above example can be specified with the following
  config variables:
  <ul>
  <li> fs.viewfs.mounttable.default.link./user=
  hdfs://nnContainingUserDir/user
  <li> fs.viewfs.mounttable.default.link./project/foo=
  hdfs://nnProject1/projects/foo
  <li> fs.viewfs.mounttable.default.link./project/bar=
  hdfs://nnProject2/projects/bar
  <li> fs.viewfs.mounttable.default.link./tmp=
  hdfs://nnTmp/privateTmpForUserXXX
  </ul>
  
 The default mount table (when no authority is specified) is 
 from config variables prefixed by <b>fs.viewFs.mounttable.default </b>
 The authority component of a URI can be used to specify a different mount
 table. For example,
 <ul>
 <li>  viewfs://sanjayMountable/
 </ul>
 is initialized from fs.viewFs.mounttable.sanjayMountable.* config variables.
 
  <p> 
  <b> **** Merge Mounts **** </b>(NOTE: merge mounts are not implemented yet.)
  <p>
  
   One can also use "MergeMounts" to merge several directories (this is
   sometimes  called union-mounts or junction-mounts in the literature.
   For example of the home directories are stored on say two file systems
   (because they do not fit on one) then one could specify a mount
   entry such as following merges two dirs:
   <ul>
   <li> /user -> hdfs://nnUser1/user,hdfs://nnUser2/user
   </ul>
  Such a mergeLink can be specified with the following config var where ","
  is used as the separator for each of links to be merged:
  <ul>
  <li> fs.viewfs.mounttable.default.linkMerge./user=
  hdfs://nnUser1/user,hdfs://nnUser1/user
  </ul>
   A special case of the merge mount is where mount table's root is merged
   with the root (slash) of another file system:
   <ul>
   <li>    fs.viewfs.mounttable.default.linkMergeSlash=hdfs://nn99/
   </ul>
   In this cases the root of the mount table is merged with the root of
            <b>hdfs://nn99/ </b>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.viewfs.ViewFs -->
  <!-- start class org.apache.hadoop.fs.viewfs.ViewFs.MountPoint -->
  <class name="ViewFs.MountPoint" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
  </class>
  <!-- end class org.apache.hadoop.fs.viewfs.ViewFs.MountPoint -->
</package>
<package name="org.apache.hadoop.ha">
  <!-- start class org.apache.hadoop.ha.ActiveStandbyElector.ActiveNotFoundException -->
  <class name="ActiveStandbyElector.ActiveNotFoundException" extends="java.lang.Exception"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ActiveStandbyElector.ActiveNotFoundException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Exception thrown when there is no active leader]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ha.ActiveStandbyElector.ActiveNotFoundException -->
  <!-- start interface org.apache.hadoop.ha.ActiveStandbyElector.ActiveStandbyElectorCallback -->
  <interface name="ActiveStandbyElector.ActiveStandbyElectorCallback"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="becomeActive"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ServiceFailedException" type="org.apache.hadoop.ha.ServiceFailedException"/>
      <doc>
      <![CDATA[This method is called when the app becomes the active leader.
 If the service fails to become active, it should throw
 ServiceFailedException. This will cause the elector to
 sleep for a short period, then re-join the election.
 
 Callback implementations are expected to manage their own
 timeouts (e.g. when making an RPC to a remote node).]]>
      </doc>
    </method>
    <method name="becomeStandby"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This method is called when the app becomes a standby]]>
      </doc>
    </method>
    <method name="enterNeutralMode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If the elector gets disconnected from Zookeeper and does not know about
 the lock state, then it will notify the service via the enterNeutralMode
 interface. The service may choose to ignore this or stop doing state
 changing operations. Upon reconnection, the elector verifies the leader
 status and calls back on the becomeActive and becomeStandby app
 interfaces. <br/>
 Zookeeper disconnects can happen due to network issues or loss of
 Zookeeper quorum. Thus enterNeutralMode can be used to guard against
 split-brain issues. In such situations it might be prudent to call
 becomeStandby too. However, such state change operations might be
 expensive and enterNeutralMode can help guard against doing that for
 transient issues.]]>
      </doc>
    </method>
    <method name="notifyFatalError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="errorMessage" type="java.lang.String"/>
      <doc>
      <![CDATA[If there is any fatal error (e.g. wrong ACL's, unexpected Zookeeper
 errors or Zookeeper persistent unavailability) then notifyFatalError is
 called to notify the app about it.]]>
      </doc>
    </method>
    <method name="fenceOldActive"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="oldActiveData" type="byte[]"/>
      <doc>
      <![CDATA[If an old active has failed, rather than exited gracefully, then
 the new active may need to take some fencing actions against it
 before proceeding with failover.
 
 @param oldActiveData the application data provided by the prior active]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Callback interface to interact with the ActiveStandbyElector object. <br/>
 The application will be notified with a callback only on state changes
 (i.e. there will never be successive calls to becomeActive without an
 intermediate call to enterNeutralMode). <br/>
 The callbacks will be running on Zookeeper client library threads. The
 application should return from these callbacks quickly so as not to impede
 Zookeeper client library performance and notifications. The app will
 typically remember the state change and return from the callback. It will
 then proceed with implementing actions around that state change. It is
 possible to be called back again while these actions are in flight and the
 app should handle this scenario.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.ha.ActiveStandbyElector.ActiveStandbyElectorCallback -->
  <!-- start class org.apache.hadoop.ha.BadFencingConfigurationException -->
  <class name="BadFencingConfigurationException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BadFencingConfigurationException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BadFencingConfigurationException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Indicates that the operator has specified an invalid configuration
 for fencing methods.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ha.BadFencingConfigurationException -->
  <!-- start class org.apache.hadoop.ha.FailoverFailedException -->
  <class name="FailoverFailedException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FailoverFailedException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FailoverFailedException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Exception thrown to indicate service failover has failed.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ha.FailoverFailedException -->
  <!-- start interface org.apache.hadoop.ha.FenceMethod -->
  <interface name="FenceMethod"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="checkArgs"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String"/>
      <exception name="BadFencingConfigurationException" type="org.apache.hadoop.ha.BadFencingConfigurationException"/>
      <doc>
      <![CDATA[Verify that the given fencing method's arguments are valid.
 @param args the arguments provided in the configuration. This may
        be null if the operator did not configure any arguments.
 @throws BadFencingConfigurationException if the arguments are invalid]]>
      </doc>
    </method>
    <method name="tryFence" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.apache.hadoop.ha.HAServiceTarget"/>
      <param name="args" type="java.lang.String"/>
      <exception name="BadFencingConfigurationException" type="org.apache.hadoop.ha.BadFencingConfigurationException"/>
      <doc>
      <![CDATA[Attempt to fence the target node.
 @param serviceAddr the address (host:ipcport) of the service to fence
 @param args the configured arguments, which were checked at startup by
             {@link #checkArgs(String)}
 @return true if fencing was successful, false if unsuccessful or
              indeterminate
 @throws BadFencingConfigurationException if the configuration was
         determined to be invalid only at runtime]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A fencing method is a method by which one node can forcibly prevent
 another node from making continued progress. This might be implemented
 by killing a process on the other node, by denying the other node's
 access to shared storage, or by accessing a PDU to cut the other node's
 power.
 <p>
 Since these methods are often vendor- or device-specific, operators
 may implement this interface in order to achieve fencing.
 <p>
 Fencing is configured by the operator as an ordered list of methods to
 attempt. Each method will be tried in turn, and the next in the list
 will only be attempted if the previous one fails. See {@link NodeFencer}
 for more information.
 <p>
 If an implementation also implements {@link Configurable} then its
 <code>setConf</code> method will be called upon instantiation.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.ha.FenceMethod -->
  <!-- start class org.apache.hadoop.ha.HAAdmin.UsageInfo -->
  <class name="HAAdmin.UsageInfo" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="HAAdmin.UsageInfo" type="java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="args" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="help" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.ha.HAAdmin.UsageInfo -->
  <!-- start interface org.apache.hadoop.ha.HAServiceProtocol -->
  <interface name="HAServiceProtocol"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="monitorHealth"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="HealthCheckFailedException" type="org.apache.hadoop.ha.HealthCheckFailedException"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Monitor the health of service. This periodically called by the HA
 frameworks to monitor the health of the service.
 
 Service is expected to perform checks to ensure it is functional.
 If the service is not healthy due to failure or partial failure,
 it is expected to throw {@link HealthCheckFailedException}.
 The definition of service not healthy is left to the service.
 
 Note that when health check of an Active service fails,
 failover to standby may be done.
 
 @throws HealthCheckFailedException
           if the health check of a service fails.
 @throws AccessControlException
           if access is denied.
 @throws IOException
           if other errors happen]]>
      </doc>
    </method>
    <method name="transitionToActive"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reqInfo" type="org.apache.hadoop.ha.HAServiceProtocol.StateChangeRequestInfo"/>
      <exception name="ServiceFailedException" type="org.apache.hadoop.ha.ServiceFailedException"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Request service to transition to active state. No operation, if the
 service is already in active state.
 
 @throws ServiceFailedException
           if transition from standby to active fails.
 @throws AccessControlException
           if access is denied.
 @throws IOException
           if other errors happen]]>
      </doc>
    </method>
    <method name="transitionToStandby"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reqInfo" type="org.apache.hadoop.ha.HAServiceProtocol.StateChangeRequestInfo"/>
      <exception name="ServiceFailedException" type="org.apache.hadoop.ha.ServiceFailedException"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Request service to transition to standby state. No operation, if the
 service is already in standby state.
 
 @throws ServiceFailedException
           if transition from active to standby fails.
 @throws AccessControlException
           if access is denied.
 @throws IOException
           if other errors happen]]>
      </doc>
    </method>
    <method name="getServiceStatus" return="org.apache.hadoop.ha.HAServiceStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the current status of the service. The status indicates
 the current <em>state</em> (e.g ACTIVE/STANDBY) as well as
 some additional information. {@see HAServiceStatus}
 
 @throws AccessControlException
           if access is denied.
 @throws IOException
           if other errors happen]]>
      </doc>
    </method>
    <field name="versionID" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Initial version of the protocol]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Protocol interface that provides High Availability related primitives to
 monitor and fail-over the service.
 
 This interface could be used by HA frameworks to manage the service.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.ha.HAServiceProtocol -->
  <!-- start class org.apache.hadoop.ha.HAServiceProtocol.HAServiceState -->
  <class name="HAServiceProtocol.HAServiceState" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.ha.HAServiceProtocol.HAServiceState[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.ha.HAServiceProtocol.HAServiceState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An HA service may be in active or standby state. During startup, it is in
 an unknown INITIALIZING state. During shutdown, it is in the STOPPING state
 and can no longer return to active/standby states.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ha.HAServiceProtocol.HAServiceState -->
  <!-- start class org.apache.hadoop.ha.HAServiceProtocol.RequestSource -->
  <class name="HAServiceProtocol.RequestSource" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.ha.HAServiceProtocol.RequestSource[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.ha.HAServiceProtocol.RequestSource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.ha.HAServiceProtocol.RequestSource -->
  <!-- start class org.apache.hadoop.ha.HAServiceProtocol.StateChangeRequestInfo -->
  <class name="HAServiceProtocol.StateChangeRequestInfo" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HAServiceProtocol.StateChangeRequestInfo" type="org.apache.hadoop.ha.HAServiceProtocol.RequestSource"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSource" return="org.apache.hadoop.ha.HAServiceProtocol.RequestSource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Information describing the source for a request to change state.
 This is used to differentiate requests from automatic vs CLI
 failover controllers, and in the future may include epoch
 information.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ha.HAServiceProtocol.StateChangeRequestInfo -->
  <!-- start class org.apache.hadoop.ha.HAServiceProtocolHelper -->
  <class name="HAServiceProtocolHelper" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HAServiceProtocolHelper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="monitorHealth"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="svc" type="org.apache.hadoop.ha.HAServiceProtocol"/>
      <param name="reqInfo" type="org.apache.hadoop.ha.HAServiceProtocol.StateChangeRequestInfo"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="transitionToActive"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="svc" type="org.apache.hadoop.ha.HAServiceProtocol"/>
      <param name="reqInfo" type="org.apache.hadoop.ha.HAServiceProtocol.StateChangeRequestInfo"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="transitionToStandby"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="svc" type="org.apache.hadoop.ha.HAServiceProtocol"/>
      <param name="reqInfo" type="org.apache.hadoop.ha.HAServiceProtocol.StateChangeRequestInfo"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Helper for making {@link HAServiceProtocol} RPC calls. This helper
 unwraps the {@link RemoteException} to specific exceptions.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ha.HAServiceProtocolHelper -->
  <!-- start class org.apache.hadoop.ha.HAServiceTarget -->
  <class name="HAServiceTarget" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HAServiceTarget"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAddress" return="java.net.InetSocketAddress"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the IPC address of the target node.]]>
      </doc>
    </method>
    <method name="getZKFCAddress" return="java.net.InetSocketAddress"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the IPC address of the ZKFC on the target node]]>
      </doc>
    </method>
    <method name="getFencer" return="org.apache.hadoop.ha.NodeFencer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return a Fencer implementation configured for this target node]]>
      </doc>
    </method>
    <method name="checkFencingConfigured"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="BadFencingConfigurationException" type="org.apache.hadoop.ha.BadFencingConfigurationException"/>
      <doc>
      <![CDATA[@throws BadFencingConfigurationException if the fencing configuration
 appears to be invalid. This is divorced from the above
 {@link #getFencer()} method so that the configuration can be checked
 during the pre-flight phase of failover.]]>
      </doc>
    </method>
    <method name="getProxy" return="org.apache.hadoop.ha.HAServiceProtocol"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="timeoutMs" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@return a proxy to connect to the target HA Service.]]>
      </doc>
    </method>
    <method name="getZKFCProxy" return="org.apache.hadoop.ha.ZKFCProtocol"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="timeoutMs" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@return a proxy to the ZKFC which is associated with this HA service.]]>
      </doc>
    </method>
    <method name="getFencingParameters" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addFencingParameters"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="ret" type="java.util.Map"/>
      <doc>
      <![CDATA[Hook to allow subclasses to add any parameters they would like to
 expose to fencing implementations/scripts. Fencing methods are free
 to use this map as they see fit -- notably, the shell script
 implementation takes each entry, prepends 'target_', substitutes
 '_' for '.', and adds it to the environment of the script.

 Subclass implementations should be sure to delegate to the superclass
 implementation as well as adding their own keys.

 @param ret map which can be mutated to pass parameters to the fencer]]>
      </doc>
    </method>
    <method name="isAutoFailoverEnabled" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return true if auto failover should be considered enabled]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a target of the client side HA administration commands.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ha.HAServiceTarget -->
  <!-- start class org.apache.hadoop.ha.HealthCheckFailedException -->
  <class name="HealthCheckFailedException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HealthCheckFailedException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="HealthCheckFailedException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Exception thrown to indicate that health check of a service failed.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ha.HealthCheckFailedException -->
  <!-- start class org.apache.hadoop.ha.ServiceFailedException -->
  <class name="ServiceFailedException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServiceFailedException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServiceFailedException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Exception thrown to indicate that an operation performed
 to modify the state of a service or application failed.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ha.ServiceFailedException -->
  <!-- start class org.apache.hadoop.ha.ShellCommandFencer -->
  <class name="ShellCommandFencer" extends="org.apache.hadoop.conf.Configured"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.ha.FenceMethod"/>
    <constructor name="ShellCommandFencer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="checkArgs"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String"/>
      <exception name="BadFencingConfigurationException" type="org.apache.hadoop.ha.BadFencingConfigurationException"/>
    </method>
    <method name="tryFence" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.apache.hadoop.ha.HAServiceTarget"/>
      <param name="cmd" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Fencing method that runs a shell command. It should be specified
 in the fencing configuration like:<br>
 <code>
   shell(/path/to/my/script.sh arg1 arg2 ...)
 </code><br>
 The string between '(' and ')' is passed directly to a bash shell
 (cmd.exe on Windows) and may not include any closing parentheses.<p>
 
 The shell command will be run with an environment set up to contain
 all of the current Hadoop configuration variables, with the '_' character 
 replacing any '.' characters in the configuration keys.<p>
 
 If the shell command returns an exit code of 0, the fencing is
 determined to be successful. If it returns any other exit code, the
 fencing was not successful and the next fencing method in the list
 will be attempted.<p>
 
 <em>Note:</em> this fencing method does not implement any timeout.
 If timeouts are necessary, they should be implemented in the shell
 script itself (eg by forking a subshell to kill its parent in
 some number of seconds).]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ha.ShellCommandFencer -->
  <!-- start class org.apache.hadoop.ha.SshFenceByTcpPort -->
  <class name="SshFenceByTcpPort" extends="org.apache.hadoop.conf.Configured"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.ha.FenceMethod"/>
    <constructor name="SshFenceByTcpPort"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="checkArgs"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="argStr" type="java.lang.String"/>
      <exception name="BadFencingConfigurationException" type="org.apache.hadoop.ha.BadFencingConfigurationException"/>
      <doc>
      <![CDATA[Verify that the argument, if given, in the conf is parseable.]]>
      </doc>
    </method>
    <method name="tryFence" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.apache.hadoop.ha.HAServiceTarget"/>
      <param name="argsStr" type="java.lang.String"/>
      <exception name="BadFencingConfigurationException" type="org.apache.hadoop.ha.BadFencingConfigurationException"/>
    </method>
    <doc>
    <![CDATA[This fencing implementation sshes to the target node and uses 
 <code>fuser</code> to kill the process listening on the service's
 TCP port. This is more accurate than using "jps" since it doesn't 
 require parsing, and will work even if there are multiple service
 processes running on the same machine.<p>
 It returns a successful status code if:
 <ul>
 <li><code>fuser</code> indicates it successfully killed a process, <em>or</em>
 <li><code>nc -z</code> indicates that nothing is listening on the target port
 </ul>
 <p>
 This fencing mechanism is configured as following in the fencing method
 list:
 <code>sshfence([[username][:ssh-port]])</code>
 where the optional argument specifies the username and port to use
 with ssh.
 <p>
 In order to achieve passwordless SSH, the operator must also configure
 <code>dfs.ha.fencing.ssh.private-key-files<code> to point to an
 SSH key that has passphrase-less access to the given username and host.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.ha.SshFenceByTcpPort -->
</package>
<package name="org.apache.hadoop.ha.protocolPB">
  <!-- start interface org.apache.hadoop.ha.protocolPB.HAServiceProtocolPB -->
  <interface name="HAServiceProtocolPB"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.ha.proto.HAServiceProtocolProtos.HAServiceProtocolService.BlockingInterface"/>
    <implements name="org.apache.hadoop.ipc.VersionedProtocol"/>
  </interface>
  <!-- end interface org.apache.hadoop.ha.protocolPB.HAServiceProtocolPB -->
  <!-- start class org.apache.hadoop.ha.protocolPB.ZKFCProtocolClientSideTranslatorPB -->
  <class name="ZKFCProtocolClientSideTranslatorPB" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.ha.ZKFCProtocol"/>
    <implements name="java.io.Closeable"/>
    <implements name="org.apache.hadoop.ipc.ProtocolTranslator"/>
    <constructor name="ZKFCProtocolClientSideTranslatorPB" type="java.net.InetSocketAddress, org.apache.hadoop.conf.Configuration, javax.net.SocketFactory, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="cedeActive"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="millisToCede" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
    </method>
    <method name="gracefulFailover"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUnderlyingProxyObject" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.ha.protocolPB.ZKFCProtocolClientSideTranslatorPB -->
  <!-- start interface org.apache.hadoop.ha.protocolPB.ZKFCProtocolPB -->
  <interface name="ZKFCProtocolPB"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.ha.proto.ZKFCProtocolProtos.ZKFCProtocolService.BlockingInterface"/>
    <implements name="org.apache.hadoop.ipc.VersionedProtocol"/>
  </interface>
  <!-- end interface org.apache.hadoop.ha.protocolPB.ZKFCProtocolPB -->
</package>
<package name="org.apache.hadoop.http.lib">
  <!-- start class org.apache.hadoop.http.lib.StaticUserWebFilter -->
  <class name="StaticUserWebFilter" extends="org.apache.hadoop.http.FilterInitializer"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="StaticUserWebFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="initFilter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="container" type="org.apache.hadoop.http.FilterContainer"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <doc>
    <![CDATA[Provides a servlet filter that pretends to authenticate a fake user (Dr.Who)
 so that the web UI is usable for a secure cluster without authentication.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.http.lib.StaticUserWebFilter -->
  <!-- start class org.apache.hadoop.http.lib.StaticUserWebFilter.StaticUserFilter -->
  <class name="StaticUserWebFilter.StaticUserFilter" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.servlet.Filter"/>
    <constructor name="StaticUserWebFilter.StaticUserFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="destroy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="doFilter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="javax.servlet.ServletRequest"/>
      <param name="response" type="javax.servlet.ServletResponse"/>
      <param name="chain" type="javax.servlet.FilterChain"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="ServletException" type="javax.servlet.ServletException"/>
    </method>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="javax.servlet.FilterConfig"/>
      <exception name="ServletException" type="javax.servlet.ServletException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.http.lib.StaticUserWebFilter.StaticUserFilter -->
  <doc>
  <![CDATA[This package provides user-selectable (via configuration) classes that add
functionality to the web UI. They are configured as a list of classes in the
configuration parameter <b>hadoop.http.filter.initializers</b>.

<ul>
<li> <b>StaticUserWebFilter</b> - An authorization plugin that makes all
users a static configured user.
</ul>]]>
  </doc>
</package>
<package name="org.apache.hadoop.io">
  <!-- start class org.apache.hadoop.io.AbstractMapWritable -->
  <class name="AbstractMapWritable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="AbstractMapWritable"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[constructor.]]>
      </doc>
    </constructor>
    <method name="addToMap"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <doc>
      <![CDATA[Add a Class to the maps if it is not already present.]]>
      </doc>
    </method>
    <method name="getClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="id" type="byte"/>
      <doc>
      <![CDATA[@return the Class class for the specified id]]>
      </doc>
    </method>
    <method name="getId" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <doc>
      <![CDATA[@return the id for the specified Class]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.io.Writable"/>
      <doc>
      <![CDATA[Used by child copy constructors.]]>
      </doc>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the conf]]>
      </doc>
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[@param conf the conf to set]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Abstract base class for MapWritable and SortedMapWritable
 
 Unlike org.apache.nutch.crawl.MapWritable, this class allows creation of
 MapWritable&lt;Writable, MapWritable&gt; so the CLASS_TO_ID and ID_TO_CLASS
 maps travel with the class instead of being static.
 
 Class ids range from 1 to 127 so there can be at most 127 distinct classes
 in any specific map instance.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.AbstractMapWritable -->
  <!-- start class org.apache.hadoop.io.ArrayFile -->
  <class name="ArrayFile" extends="org.apache.hadoop.io.MapFile"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ArrayFile"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[A dense file-based mapping from integers to values.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ArrayFile -->
  <!-- start class org.apache.hadoop.io.ArrayFile.Reader -->
  <class name="ArrayFile.Reader" extends="org.apache.hadoop.io.MapFile.Reader"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ArrayFile.Reader" type="org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct an array reader for the named file.]]>
      </doc>
    </constructor>
    <method name="seek"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Positions the reader before its <code>n</code>th value.]]>
      </doc>
    </method>
    <method name="next" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read and return the next value in the file.]]>
      </doc>
    </method>
    <method name="key" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the key associated with the most recent call to {@link
 #seek(long)}, {@link #next(Writable)}, or {@link
 #get(long,Writable)}.]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <param name="value" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the <code>n</code>th value in the file.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provide access to an existing array file.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ArrayFile.Reader -->
  <!-- start class org.apache.hadoop.io.ArrayFile.Writer -->
  <class name="ArrayFile.Writer" extends="org.apache.hadoop.io.MapFile.Writer"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ArrayFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named file for values of the named class.]]>
      </doc>
    </constructor>
    <constructor name="ArrayFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType, org.apache.hadoop.util.Progressable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named file for values of the named class.]]>
      </doc>
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Append a value to the file.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Write a new array file.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ArrayFile.Writer -->
  <!-- start class org.apache.hadoop.io.ArrayPrimitiveWritable -->
  <class name="ArrayPrimitiveWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="ArrayPrimitiveWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct an empty instance, for use during Writable read]]>
      </doc>
    </constructor>
    <constructor name="ArrayPrimitiveWritable" type="java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct an instance of known type but no value yet
 for use with type-specific wrapper classes]]>
      </doc>
    </constructor>
    <constructor name="ArrayPrimitiveWritable" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Wrap an existing array of primitives
 @param value - array of primitives]]>
      </doc>
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the original array.  
 Client must cast it back to type componentType[]
 (or may use type-specific wrapper classes).
 @return - original array as Object]]>
      </doc>
    </method>
    <method name="getComponentType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDeclaredComponentType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isDeclaredComponentType" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="componentType" type="java.lang.Class"/>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[This is a wrapper class.  It wraps a Writable implementation around
 an array of primitives (e.g., int[], long[], etc.), with optimized 
 wire format, and without creating new objects per element.
 
 This is a wrapper class only; it does not make a copy of the 
 underlying array.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ArrayPrimitiveWritable -->
  <!-- start class org.apache.hadoop.io.ArrayWritable -->
  <class name="ArrayWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="ArrayWritable" type="java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ArrayWritable" type="java.lang.Class, org.apache.hadoop.io.Writable[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ArrayWritable" type="java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getValueClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toArray" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="org.apache.hadoop.io.Writable[]"/>
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A Writable for arrays containing instances of a class. The elements of this
 writable must all be instances of the same class. If this writable will be
 the input for a Reducer, you will need to create a subclass that sets the
 value to be of the proper type.

 For example:
 <code>
 public class IntArrayWritable extends ArrayWritable {
   public IntArrayWritable() { 
     super(IntWritable.class); 
   }	
 }
 </code>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ArrayWritable -->
  <!-- start class org.apache.hadoop.io.BinaryComparable -->
  <class name="BinaryComparable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <constructor name="BinaryComparable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLength" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return n st bytes 0..n-1 from {#getBytes()} are valid.]]>
      </doc>
    </method>
    <method name="getBytes" return="byte[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return representative byte array for this instance.]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.io.BinaryComparable"/>
      <doc>
      <![CDATA[Compare bytes from {#getBytes()}.
 @see org.apache.hadoop.io.WritableComparator#compareBytes(byte[],int,int,byte[],int,int)]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Compare bytes from {#getBytes()} to those provided.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
      <doc>
      <![CDATA[Return true if bytes from {#getBytes()} match.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a hash of the bytes returned from {#getBytes()}.
 @see org.apache.hadoop.io.WritableComparator#hashBytes(byte[],int)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface supported by {@link org.apache.hadoop.io.WritableComparable}
 types supporting ordering/permutation by a representative set of bytes.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.BinaryComparable -->
  <!-- start class org.apache.hadoop.io.BloomMapFile -->
  <class name="BloomMapFile" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BloomMapFile"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="delete"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="BLOOM_FILE_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HASH_COUNT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This class extends {@link MapFile} and provides very much the same
 functionality. However, it uses dynamic Bloom filters to provide
 quick membership test for keys, and it offers a fast version of 
 {@link Reader#get(WritableComparable, Writable)} operation, especially in
 case of sparsely populated MapFile-s.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.BloomMapFile -->
  <!-- start class org.apache.hadoop.io.BloomMapFile.Reader -->
  <class name="BloomMapFile.Reader" extends="org.apache.hadoop.io.MapFile.Reader"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BloomMapFile.Reader" type="org.apache.hadoop.fs.Path, org.apache.hadoop.conf.Configuration, org.apache.hadoop.io.SequenceFile.Reader.Option[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="BloomMapFile.Reader" type="org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="BloomMapFile.Reader" type="org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, org.apache.hadoop.conf.Configuration, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="BloomMapFile.Reader" type="org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="probablyHasKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Checks if this MapFile has the indicated key. The membership test is
 performed using a Bloom filter, so the result has always non-zero
 probability of false positives.
 @param key key to check
 @return  false iff key doesn't exist, true if key probably exists.
 @throws IOException]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="val" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fast version of the
 {@link MapFile.Reader#get(WritableComparable, Writable)} method. First
 it checks the Bloom filter for the existence of the key, and only if
 present it performs the real get operation. This yields significant
 performance improvements for get operations on sparsely populated files.]]>
      </doc>
    </method>
    <method name="getBloomFilter" return="org.apache.hadoop.util.bloom.Filter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieve the Bloom filter used by this instance of the Reader.
 @return a Bloom filter (see {@link Filter})]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.io.BloomMapFile.Reader -->
  <!-- start class org.apache.hadoop.io.BloomMapFile.Writer -->
  <class name="BloomMapFile.Writer" extends="org.apache.hadoop.io.MapFile.Writer"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BloomMapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType, org.apache.hadoop.io.compress.CompressionCodec, org.apache.hadoop.util.Progressable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="BloomMapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType, org.apache.hadoop.util.Progressable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="BloomMapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="BloomMapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType, org.apache.hadoop.io.compress.CompressionCodec, org.apache.hadoop.util.Progressable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="BloomMapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType, org.apache.hadoop.util.Progressable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="BloomMapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="BloomMapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="BloomMapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="BloomMapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.Path, org.apache.hadoop.io.SequenceFile.Writer.Option[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="val" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.io.BloomMapFile.Writer -->
  <!-- start class org.apache.hadoop.io.BooleanWritable -->
  <class name="BooleanWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="BooleanWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BooleanWritable" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Set the value of the BooleanWritable]]>
      </doc>
    </method>
    <method name="get" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the value of the BooleanWritable]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.io.BooleanWritable"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for booleans.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.BooleanWritable -->
  <!-- start class org.apache.hadoop.io.BooleanWritable.Comparator -->
  <class name="BooleanWritable.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BooleanWritable.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A Comparator optimized for BooleanWritable.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.BooleanWritable.Comparator -->
  <!-- start interface org.apache.hadoop.io.ByteBufferPool -->
  <interface name="ByteBufferPool"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getBuffer" return="java.nio.ByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="direct" type="boolean"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Get a new direct ByteBuffer.  The pool can provide this from
 removing a buffer from its internal cache, or by allocating a 
 new buffer.

 @param direct     Whether the buffer should be direct.
 @param length     The minimum length the buffer will have.
 @return           A new ByteBuffer.  This ByteBuffer must be direct.
                   Its capacity can be less than what was requested, but
                   must be at least 1 byte.]]>
      </doc>
    </method>
    <method name="putBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buffer" type="java.nio.ByteBuffer"/>
      <doc>
      <![CDATA[Release a buffer back to the pool.
 The pool may choose to put this buffer into its cache.

 @param buffer    a direct bytebuffer]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.io.ByteBufferPool -->
  <!-- start class org.apache.hadoop.io.BytesWritable -->
  <class name="BytesWritable" extends="org.apache.hadoop.io.BinaryComparable"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="BytesWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a zero-size sequence.]]>
      </doc>
    </constructor>
    <constructor name="BytesWritable" type="byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a BytesWritable using the byte array as the initial value.
 @param bytes This array becomes the backing storage for the object.]]>
      </doc>
    </constructor>
    <constructor name="BytesWritable" type="byte[], int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a BytesWritable using the byte array as the initial value
 and length as the length. Use this constructor if the array is larger
 than the value it represents.
 @param bytes This array becomes the backing storage for the object.
 @param length The number of bytes to use from array.]]>
      </doc>
    </constructor>
    <method name="copyBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a copy of the bytes that is exactly the length of the data.
 See {@link #getBytes()} for faster access to the underlying array.]]>
      </doc>
    </method>
    <method name="getBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the data backing the BytesWritable. Please use {@link #copyBytes()}
 if you need the returned array to be precisely the length of the data.
 @return The data is only valid between 0 and getLength() - 1.]]>
      </doc>
    </method>
    <method name="get" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #getBytes()} instead.">
      <doc>
      <![CDATA[Get the data from the BytesWritable.
 @deprecated Use {@link #getBytes()} instead.]]>
      </doc>
    </method>
    <method name="getLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current size of the buffer.]]>
      </doc>
    </method>
    <method name="getSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #getLength()} instead.">
      <doc>
      <![CDATA[Get the current size of the buffer.
 @deprecated Use {@link #getLength()} instead.]]>
      </doc>
    </method>
    <method name="setSize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="int"/>
      <doc>
      <![CDATA[Change the size of the buffer. The values in the old range are preserved
 and any new values are undefined. The capacity is changed if it is 
 necessary.
 @param size The new number of bytes]]>
      </doc>
    </method>
    <method name="getCapacity" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the capacity, which is the maximum size that could handled without
 resizing the backing storage.
 @return The number of bytes]]>
      </doc>
    </method>
    <method name="setCapacity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="new_cap" type="int"/>
      <doc>
      <![CDATA[Change the capacity of the backing storage.
 The data is preserved.
 @param new_cap The new capacity in bytes.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newData" type="org.apache.hadoop.io.BytesWritable"/>
      <doc>
      <![CDATA[Set the BytesWritable to the contents of the given newData.
 @param newData the value to set this BytesWritable to.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newData" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Set the value to a copy of the given byte range
 @param newData the new values to copy in
 @param offset the offset in newData to start at
 @param length the number of bytes to copy]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="right_obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Are the two byte sequences equal?]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Generate the stream of bytes as hex pairs separated by ' '.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A byte sequence that is usable as a key or value.
 It is resizable and distinguishes between the size of the sequence and
 the current capacity. The hash function is the front of the md5 of the 
 buffer. The sort order is the same as memcmp.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.BytesWritable -->
  <!-- start class org.apache.hadoop.io.BytesWritable.Comparator -->
  <class name="BytesWritable.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BytesWritable.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
      <doc>
      <![CDATA[Compare the buffers in serialized form.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A Comparator optimized for BytesWritable.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.BytesWritable.Comparator -->
  <!-- start class org.apache.hadoop.io.ByteWritable -->
  <class name="ByteWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="ByteWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ByteWritable" type="byte"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Set the value of this ByteWritable.]]>
      </doc>
    </method>
    <method name="get" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the value of this ByteWritable.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a ByteWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.io.ByteWritable"/>
      <doc>
      <![CDATA[Compares two ByteWritables.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for a single byte.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ByteWritable -->
  <!-- start class org.apache.hadoop.io.ByteWritable.Comparator -->
  <class name="ByteWritable.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ByteWritable.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A Comparator optimized for ByteWritable.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ByteWritable.Comparator -->
  <!-- start interface org.apache.hadoop.io.Closeable -->
  <interface name="Closeable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="use java.io.Closeable">
    <implements name="java.io.Closeable"/>
    <doc>
    <![CDATA[@deprecated use java.io.Closeable]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.Closeable -->
  <!-- start class org.apache.hadoop.io.CompressedWritable -->
  <class name="CompressedWritable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="CompressedWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="ensureInflated"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Must be called by all methods which access fields to ensure that the data
 has been uncompressed.]]>
      </doc>
    </method>
    <method name="readFieldsCompressed"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Subclasses implement this instead of {@link #readFields(DataInput)}.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCompressed"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Subclasses implement this instead of {@link #write(DataOutput)}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A base-class for Writables which store themselves compressed and lazily
 inflate on field access.  This is useful for large objects whose fields are
 not be altered during a map or reduce operation: leaving the field data
 compressed makes copying the instance from one file to another much
 faster.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.CompressedWritable -->
  <!-- start class org.apache.hadoop.io.DataInputByteBuffer -->
  <class name="DataInputByteBuffer" extends="java.io.DataInputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DataInputByteBuffer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="java.nio.ByteBuffer[]"/>
    </method>
    <method name="getData" return="java.nio.ByteBuffer[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPosition" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.io.DataInputByteBuffer -->
  <!-- start class org.apache.hadoop.io.DataOutputByteBuffer -->
  <class name="DataOutputByteBuffer" extends="java.io.DataOutputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DataOutputByteBuffer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DataOutputByteBuffer" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DataOutputByteBuffer" type="int, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getData" return="java.nio.ByteBuffer[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.io.DataOutputByteBuffer -->
  <!-- start class org.apache.hadoop.io.DataOutputOutputStream -->
  <class name="DataOutputOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="constructOutputStream" return="java.io.OutputStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <doc>
      <![CDATA[Construct an OutputStream from the given DataOutput. If 'out'
 is already an OutputStream, simply returns it. Otherwise, wraps
 it in an OutputStream.
 @param out the DataOutput to wrap
 @return an OutputStream instance that outputs to 'out']]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[OutputStream implementation that wraps a DataOutput.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.DataOutputOutputStream -->
  <!-- start class org.apache.hadoop.io.DefaultStringifier -->
  <class name="DefaultStringifier" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Stringifier"/>
    <constructor name="DefaultStringifier" type="org.apache.hadoop.conf.Configuration, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="fromString" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="T"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="store"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="item" type="K"/>
      <param name="keyName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Stores the item in the configuration with the given keyName.
 
 @param <K>  the class of the item
 @param conf the configuration to store
 @param item the object to be stored
 @param keyName the name of the key to use
 @throws IOException : forwards Exceptions from the underlying 
 {@link Serialization} classes.]]>
      </doc>
    </method>
    <method name="load" return="K"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="keyName" type="java.lang.String"/>
      <param name="itemClass" type="java.lang.Class"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Restores the object from the configuration.
 
 @param <K> the class of the item
 @param conf the configuration to use
 @param keyName the name of the key to use
 @param itemClass the class of the item
 @return restored object
 @throws IOException : forwards Exceptions from the underlying 
 {@link Serialization} classes.]]>
      </doc>
    </method>
    <method name="storeArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="items" type="K[]"/>
      <param name="keyName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Stores the array of items in the configuration with the given keyName.
 
 @param <K> the class of the item
 @param conf the configuration to use 
 @param items the objects to be stored
 @param keyName the name of the key to use
 @throws IndexOutOfBoundsException if the items array is empty
 @throws IOException : forwards Exceptions from the underlying 
 {@link Serialization} classes.]]>
      </doc>
    </method>
    <method name="loadArray" return="K[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="keyName" type="java.lang.String"/>
      <param name="itemClass" type="java.lang.Class"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Restores the array of objects from the configuration.
 
 @param <K> the class of the item
 @param conf the configuration to use
 @param keyName the name of the key to use
 @param itemClass the class of the item
 @return restored object
 @throws IOException : forwards Exceptions from the underlying 
 {@link Serialization} classes.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[DefaultStringifier is the default implementation of the {@link Stringifier}
 interface which stringifies the objects using base64 encoding of the
 serialized version of the objects. The {@link Serializer} and
 {@link Deserializer} are obtained from the {@link SerializationFactory}.
 <br>
 DefaultStringifier offers convenience methods to store/load objects to/from
 the configuration.
 
 @param <T> the class of the objects to stringify]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.DefaultStringifier -->
  <!-- start class org.apache.hadoop.io.DoubleWritable -->
  <class name="DoubleWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="DoubleWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DoubleWritable" type="double"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
    </method>
    <method name="get" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a DoubleWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.io.DoubleWritable"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Writable for Double values.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.DoubleWritable -->
  <!-- start class org.apache.hadoop.io.DoubleWritable.Comparator -->
  <class name="DoubleWritable.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DoubleWritable.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A Comparator optimized for DoubleWritable.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.DoubleWritable.Comparator -->
  <!-- start class org.apache.hadoop.io.ElasticByteBufferPool -->
  <class name="ElasticByteBufferPool" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.ByteBufferPool"/>
    <constructor name="ElasticByteBufferPool"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getBuffer" return="java.nio.ByteBuffer"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="direct" type="boolean"/>
      <param name="length" type="int"/>
    </method>
    <method name="putBuffer"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buffer" type="java.nio.ByteBuffer"/>
    </method>
    <doc>
    <![CDATA[This is a simple ByteBufferPool which just creates ByteBuffers as needed.
 It also caches ByteBuffers after they're released.  It will always return
 the smallest cached buffer with at least the capacity you request.
 We don't try to do anything clever here like try to limit the maximum cache
 size.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ElasticByteBufferPool -->
  <!-- start class org.apache.hadoop.io.EnumSetWritable -->
  <class name="EnumSetWritable" extends="java.util.AbstractCollection"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="EnumSetWritable" type="java.util.EnumSet, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a new EnumSetWritable. If the <tt>value</tt> argument is null or
 its size is zero, the <tt>elementType</tt> argument must not be null. If
 the argument <tt>value</tt>'s size is bigger than zero, the argument
 <tt>elementType</tt> is not be used.
 
 @param value
 @param elementType]]>
      </doc>
    </constructor>
    <constructor name="EnumSetWritable" type="java.util.EnumSet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a new EnumSetWritable. Argument <tt>value</tt> should not be null
 or empty.
 
 @param value]]>
      </doc>
    </constructor>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="add" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="E"/>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.util.EnumSet"/>
      <param name="elementType" type="java.lang.Class"/>
      <doc>
      <![CDATA[reset the EnumSetWritable with specified
 <tt>value</value> and <tt>elementType</tt>. If the <tt>value</tt> argument
 is null or its size is zero, the <tt>elementType</tt> argument must not be
 null. If the argument <tt>value</tt>'s size is bigger than zero, the
 argument <tt>elementType</tt> is not be used.
 
 @param value
 @param elementType]]>
      </doc>
    </method>
    <method name="get" return="java.util.EnumSet"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the value of this EnumSetWritable.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true if <code>o</code> is an EnumSetWritable with the same value,
 or both are null.]]>
      </doc>
    </method>
    <method name="getElementType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the class of all the elements of the underlying EnumSetWriable. It
 may return null.
 
 @return the element class]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <doc>
    <![CDATA[A Writable wrapper for EnumSet.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.EnumSetWritable -->
  <!-- start class org.apache.hadoop.io.FloatWritable -->
  <class name="FloatWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="FloatWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FloatWritable" type="float"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Set the value of this FloatWritable.]]>
      </doc>
    </method>
    <method name="get" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the value of this FloatWritable.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a FloatWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.io.FloatWritable"/>
      <doc>
      <![CDATA[Compares two FloatWritables.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for floats.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.FloatWritable -->
  <!-- start class org.apache.hadoop.io.FloatWritable.Comparator -->
  <class name="FloatWritable.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FloatWritable.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A Comparator optimized for FloatWritable.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.FloatWritable.Comparator -->
  <!-- start class org.apache.hadoop.io.GenericWritable -->
  <class name="GenericWritable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="GenericWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="org.apache.hadoop.io.Writable"/>
      <doc>
      <![CDATA[Set the instance that is wrapped.
 
 @param obj]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the wrapped instance.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getTypes" return="java.lang.Class[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return all classes that may be wrapped.  Subclasses should implement this
 to return a constant array of classes.]]>
      </doc>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <doc>
    <![CDATA[A wrapper for Writable instances.
 <p>
 When two sequence files, which have same Key type but different Value
 types, are mapped out to reduce, multiple Value types is not allowed.
 In this case, this class can help you wrap instances with different types.
 </p>
 
 <p>
 Compared with <code>ObjectWritable</code>, this class is much more effective,
 because <code>ObjectWritable</code> will append the class declaration as a String 
 into the output file in every Key-Value pair.
 </p>
 
 <p>
 Generic Writable implements {@link Configurable} interface, so that it will be 
 configured by the framework. The configuration is passed to the wrapped objects
 implementing {@link Configurable} interface <i>before deserialization</i>. 
 </p>
 
 how to use it: <br>
 1. Write your own class, such as GenericObject, which extends GenericWritable.<br> 
 2. Implements the abstract method <code>getTypes()</code>, defines 
    the classes which will be wrapped in GenericObject in application.
    Attention: this classes defined in <code>getTypes()</code> method, must
    implement <code>Writable</code> interface.
 <br><br>
 
 The code looks like this:
 <blockquote><pre>
 public class GenericObject extends GenericWritable {
 
   private static Class[] CLASSES = {
               ClassType1.class, 
               ClassType2.class,
               ClassType3.class,
               };

   protected Class[] getTypes() {
       return CLASSES;
   }

 }
 </pre></blockquote>
 
 @since Nov 8, 2006]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.GenericWritable -->
  <!-- start class org.apache.hadoop.io.IntWritable -->
  <class name="IntWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="IntWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="IntWritable" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Set the value of this IntWritable.]]>
      </doc>
    </method>
    <method name="get" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the value of this IntWritable.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a IntWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.io.IntWritable"/>
      <doc>
      <![CDATA[Compares two IntWritables.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for ints.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.IntWritable -->
  <!-- start class org.apache.hadoop.io.IntWritable.Comparator -->
  <class name="IntWritable.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="IntWritable.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A Comparator optimized for IntWritable.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.IntWritable.Comparator -->
  <!-- start class org.apache.hadoop.io.IOUtils -->
  <class name="IOUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="IOUtils"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="copyBytes"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="out" type="java.io.OutputStream"/>
      <param name="buffSize" type="int"/>
      <param name="close" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies from one stream to another.

 @param in InputStrem to read from
 @param out OutputStream to write to
 @param buffSize the size of the buffer 
 @param close whether or not close the InputStream and 
 OutputStream at the end. The streams are closed in the finally clause.]]>
      </doc>
    </method>
    <method name="copyBytes"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="out" type="java.io.OutputStream"/>
      <param name="buffSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies from one stream to another.
 
 @param in InputStrem to read from
 @param out OutputStream to write to
 @param buffSize the size of the buffer]]>
      </doc>
    </method>
    <method name="copyBytes"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="out" type="java.io.OutputStream"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies from one stream to another. <strong>closes the input and output streams 
 at the end</strong>.

 @param in InputStrem to read from
 @param out OutputStream to write to
 @param conf the Configuration object]]>
      </doc>
    </method>
    <method name="copyBytes"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="out" type="java.io.OutputStream"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="close" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies from one stream to another.

 @param in InputStream to read from
 @param out OutputStream to write to
 @param conf the Configuration object
 @param close whether or not close the InputStream and 
 OutputStream at the end. The streams are closed in the finally clause.]]>
      </doc>
    </method>
    <method name="copyBytes"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="out" type="java.io.OutputStream"/>
      <param name="count" type="long"/>
      <param name="close" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copies count bytes from one stream to another.

 @param in InputStream to read from
 @param out OutputStream to write to
 @param count number of bytes to copy
 @param close whether to close the streams
 @throws IOException if bytes can not be read or written]]>
      </doc>
    </method>
    <method name="wrappedReadForCompressedData" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="is" type="java.io.InputStream"/>
      <param name="buf" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Utility wrapper for reading from {@link InputStream}. It catches any errors
 thrown by the underlying stream (either IO or decompression-related), and
 re-throws as an IOException.
 
 @param is - InputStream to be read from
 @param buf - buffer the data is read into
 @param off - offset within buf
 @param len - amount of data to be read
 @return number of bytes read]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="buf" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads len bytes in a loop.

 @param in InputStream to read from
 @param buf The buffer to fill
 @param off offset from the buffer
 @param len the length of bytes to read
 @throws IOException if it could not read requested number of bytes 
 for any reason (including EOF)]]>
      </doc>
    </method>
    <method name="skipFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="len" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Similar to readFully(). Skips bytes in a loop.
 @param in The InputStream to skip bytes from
 @param len number of bytes to skip.
 @throws IOException if it could not skip requested number of bytes 
 for any reason (including EOF)]]>
      </doc>
    </method>
    <method name="cleanup"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="log" type="org.apache.commons.logging.Log"/>
      <param name="closeables" type="java.io.Closeable[]"/>
      <doc>
      <![CDATA[Close the Closeable objects and <b>ignore</b> any {@link IOException} or 
 null pointers. Must only be used for cleanup in exception handlers.

 @param log the log to record problems to at debug level. Can be null.
 @param closeables the objects to close]]>
      </doc>
    </method>
    <method name="closeStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.Closeable"/>
      <doc>
      <![CDATA[Closes the stream ignoring {@link IOException}.
 Must only be called in cleaning up from exception handlers.

 @param stream the Stream to close]]>
      </doc>
    </method>
    <method name="closeSocket"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sock" type="java.net.Socket"/>
      <doc>
      <![CDATA[Closes the socket ignoring {@link IOException}

 @param sock the Socket to close]]>
      </doc>
    </method>
    <method name="writeFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bc" type="java.nio.channels.WritableByteChannel"/>
      <param name="buf" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a ByteBuffer to a WritableByteChannel, handling short writes.
 
 @param bc               The WritableByteChannel to write to
 @param buf              The input buffer
 @throws IOException     On I/O error]]>
      </doc>
    </method>
    <method name="writeFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fc" type="java.nio.channels.FileChannel"/>
      <param name="buf" type="java.nio.ByteBuffer"/>
      <param name="offset" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a ByteBuffer to a FileChannel at a given offset, 
 handling short writes.
 
 @param fc               The FileChannel to write to
 @param buf              The input buffer
 @param offset           The offset in the file to start writing at
 @throws IOException     On I/O error]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An utility class for I/O related functionality.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.IOUtils -->
  <!-- start class org.apache.hadoop.io.IOUtils.NullOutputStream -->
  <class name="IOUtils.NullOutputStream" extends="java.io.OutputStream"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="IOUtils.NullOutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[The /dev/null of OutputStreams.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.IOUtils.NullOutputStream -->
  <!-- start class org.apache.hadoop.io.LongWritable -->
  <class name="LongWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="LongWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LongWritable" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Set the value of this LongWritable.]]>
      </doc>
    </method>
    <method name="get" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the value of this LongWritable.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a LongWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.io.LongWritable"/>
      <doc>
      <![CDATA[Compares two LongWritables.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for longs.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.LongWritable -->
  <!-- start class org.apache.hadoop.io.LongWritable.Comparator -->
  <class name="LongWritable.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LongWritable.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A Comparator optimized for LongWritable.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.LongWritable.Comparator -->
  <!-- start class org.apache.hadoop.io.LongWritable.DecreasingComparator -->
  <class name="LongWritable.DecreasingComparator" extends="org.apache.hadoop.io.LongWritable.Comparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LongWritable.DecreasingComparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="b" type="org.apache.hadoop.io.WritableComparable"/>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A decreasing Comparator optimized for LongWritable.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.LongWritable.DecreasingComparator -->
  <!-- start class org.apache.hadoop.io.MapFile -->
  <class name="MapFile" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MapFile"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="rename"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="oldName" type="java.lang.String"/>
      <param name="newName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Renames an existing map directory.]]>
      </doc>
    </method>
    <method name="delete"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deletes the named map file.]]>
      </doc>
    </method>
    <method name="fix" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="dir" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valueClass" type="java.lang.Class"/>
      <param name="dryrun" type="boolean"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[This method attempts to fix a corrupt MapFile by re-creating its index.
 @param fs filesystem
 @param dir directory containing the MapFile data and index
 @param keyClass key class (has to be a subclass of Writable)
 @param valueClass value class (has to be a subclass of Writable)
 @param dryrun do not perform any changes, just report what needs to be done
 @return number of valid entries in this MapFile, or -1 if no fixing was needed
 @throws Exception]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <field name="INDEX_FILE_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The name of the index file.]]>
      </doc>
    </field>
    <field name="DATA_FILE_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The name of the data file.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A file-based map from keys to values.
 
 <p>A map is a directory containing two files, the <code>data</code> file,
 containing all keys and values in the map, and a smaller <code>index</code>
 file, containing a fraction of the keys.  The fraction is determined by
 {@link Writer#getIndexInterval()}.

 <p>The index file is read entirely into memory.  Thus key implementations
 should try to keep themselves small.

 <p>Map files are created by adding entries in-order.  To maintain a large
 database, perform updates by copying the previous version of a database and
 merging in a sorted change list, to create a new version of the database in
 a new file.  Sorting large change lists can be done with {@link
 SequenceFile.Sorter}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.MapFile -->
  <!-- start class org.apache.hadoop.io.MapFile.Reader -->
  <class name="MapFile.Reader" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="MapFile.Reader" type="org.apache.hadoop.fs.Path, org.apache.hadoop.conf.Configuration, org.apache.hadoop.io.SequenceFile.Reader.Option[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="MapFile.Reader" type="org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="deprecated, no comment">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a map reader for the named map.
 @deprecated]]>
      </doc>
    </constructor>
    <constructor name="MapFile.Reader" type="org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="deprecated, no comment">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a map reader for the named map using the named comparator.
 @deprecated]]>
      </doc>
    </constructor>
    <method name="getKeyClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the class of keys in this file.]]>
      </doc>
    </method>
    <method name="getValueClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the class of values in this file.]]>
      </doc>
    </method>
    <method name="comparator" return="org.apache.hadoop.io.MapFile.Reader.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.apache.hadoop.io.WritableComparator"/>
    </method>
    <method name="open"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="dir" type="org.apache.hadoop.fs.Path"/>
      <param name="comparator" type="org.apache.hadoop.io.WritableComparator"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="options" type="org.apache.hadoop.io.SequenceFile.Reader.Option[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createDataFileReader" return="org.apache.hadoop.io.SequenceFile.Reader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="dataFile" type="org.apache.hadoop.fs.Path"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="options" type="org.apache.hadoop.io.SequenceFile.Reader.Option[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Override this method to specialize the type of
 {@link SequenceFile.Reader} returned.]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Re-positions the reader before its first key.]]>
      </doc>
    </method>
    <method name="midKey" return="org.apache.hadoop.io.WritableComparable"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the key at approximately the middle of the file. Or null if the
  file is empty.]]>
      </doc>
    </method>
    <method name="finalKey"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads the final key from the file.

 @param key key to read into]]>
      </doc>
    </method>
    <method name="seek" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Positions the reader at the named key, or if none such exists, at the
 first entry after the named key.  Returns true iff the named key exists
 in this map.]]>
      </doc>
    </method>
    <method name="next" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="val" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read the next key/value pair in the map into <code>key</code> and
 <code>val</code>.  Returns true if such a pair exists and false when at
 the end of the map]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="val" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the value for the named key, or null if none exists.]]>
      </doc>
    </method>
    <method name="getClosest" return="org.apache.hadoop.io.WritableComparable"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="val" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Finds the record that is the closest match to the specified key.
 Returns <code>key</code> or if it does not exist, at the first entry
 after the named key.
 
-     * @param key       - key that we're trying to find
-     * @param val       - data value if key is found
-     * @return          - the key that was the closest match or null if eof.]]>
      </doc>
    </method>
    <method name="getClosest" return="org.apache.hadoop.io.WritableComparable"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="val" type="org.apache.hadoop.io.Writable"/>
      <param name="before" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Finds the record that is the closest match to the specified key.
 
 @param key       - key that we're trying to find
 @param val       - data value if key is found
 @param before    - IF true, and <code>key</code> does not exist, return
 the first entry that falls just before the <code>key</code>.  Otherwise,
 return the record that sorts just after.
 @return          - the key that was the closest match or null if eof.]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close the map.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provide access to an existing map.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.MapFile.Reader -->
  <!-- start interface org.apache.hadoop.io.MapFile.Reader.Option -->
  <interface name="MapFile.Reader.Option"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.SequenceFile.Reader.Option"/>
  </interface>
  <!-- end interface org.apache.hadoop.io.MapFile.Reader.Option -->
  <!-- start class org.apache.hadoop.io.MapFile.Writer -->
  <class name="MapFile.Writer" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="MapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="Use Writer(Configuration, Path, Option...) instead.">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named map for keys of the named class. 
 @deprecated Use Writer(Configuration, Path, Option...) instead.]]>
      </doc>
    </constructor>
    <constructor name="MapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType, org.apache.hadoop.util.Progressable"
      static="false" final="false" visibility="public"
      deprecated="Use Writer(Configuration, Path, Option...) instead.">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named map for keys of the named class. 
 @deprecated Use Writer(Configuration, Path, Option...) instead.]]>
      </doc>
    </constructor>
    <constructor name="MapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType, org.apache.hadoop.io.compress.CompressionCodec, org.apache.hadoop.util.Progressable"
      static="false" final="false" visibility="public"
      deprecated="Use Writer(Configuration, Path, Option...) instead.">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named map for keys of the named class. 
 @deprecated Use Writer(Configuration, Path, Option...) instead.]]>
      </doc>
    </constructor>
    <constructor name="MapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType"
      static="false" final="false" visibility="public"
      deprecated="Use Writer(Configuration, Path, Option...) instead.">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named map for keys of the named class. 
 @deprecated Use Writer(Configuration, Path, Option...) instead.]]>
      </doc>
    </constructor>
    <constructor name="MapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="Use Writer(Configuration, Path, Option...) instead.">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named map using the named key comparator. 
 @deprecated Use Writer(Configuration, Path, Option...) instead.]]>
      </doc>
    </constructor>
    <constructor name="MapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType"
      static="false" final="false" visibility="public"
      deprecated="Use Writer(Configuration, Path, Option...) instead.">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named map using the named key comparator. 
 @deprecated Use Writer(Configuration, Path, Option...) instead.]]>
      </doc>
    </constructor>
    <constructor name="MapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType, org.apache.hadoop.util.Progressable"
      static="false" final="false" visibility="public"
      deprecated="Use Writer(Configuration, Path, Option...)} instead.">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named map using the named key comparator. 
 @deprecated Use Writer(Configuration, Path, Option...)} instead.]]>
      </doc>
    </constructor>
    <constructor name="MapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType, org.apache.hadoop.io.compress.CompressionCodec, org.apache.hadoop.util.Progressable"
      static="false" final="false" visibility="public"
      deprecated="Use Writer(Configuration, Path, Option...) instead.">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named map using the named key comparator. 
 @deprecated Use Writer(Configuration, Path, Option...) instead.]]>
      </doc>
    </constructor>
    <constructor name="MapFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.Path, org.apache.hadoop.io.SequenceFile.Writer.Option[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="keyClass" return="org.apache.hadoop.io.MapFile.Writer.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Class"/>
    </method>
    <method name="comparator" return="org.apache.hadoop.io.MapFile.Writer.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.apache.hadoop.io.WritableComparator"/>
    </method>
    <method name="valueClass" return="org.apache.hadoop.io.SequenceFile.Writer.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Class"/>
    </method>
    <method name="compression" return="org.apache.hadoop.io.SequenceFile.Writer.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
    </method>
    <method name="compression" return="org.apache.hadoop.io.SequenceFile.Writer.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
    </method>
    <method name="progressable" return="org.apache.hadoop.io.SequenceFile.Writer.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.apache.hadoop.util.Progressable"/>
    </method>
    <method name="getIndexInterval" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of entries that are added before an index entry is added.]]>
      </doc>
    </method>
    <method name="setIndexInterval"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="interval" type="int"/>
      <doc>
      <![CDATA[Sets the index interval.
 @see #getIndexInterval()]]>
      </doc>
    </method>
    <method name="setIndexInterval"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="interval" type="int"/>
      <doc>
      <![CDATA[Sets the index interval and stores it in conf
 @see #getIndexInterval()]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close the map.]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="val" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Append a key/value pair to the map.  The key must be greater or equal
 to the previous key added to the map.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Writes a new map.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.MapFile.Writer -->
  <!-- start interface org.apache.hadoop.io.MapFile.Writer.Option -->
  <interface name="MapFile.Writer.Option"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.SequenceFile.Writer.Option"/>
  </interface>
  <!-- end interface org.apache.hadoop.io.MapFile.Writer.Option -->
  <!-- start class org.apache.hadoop.io.MapWritable -->
  <class name="MapWritable" extends="org.apache.hadoop.io.AbstractMapWritable"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Map"/>
    <constructor name="MapWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor.]]>
      </doc>
    </constructor>
    <constructor name="MapWritable" type="org.apache.hadoop.io.MapWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Copy constructor.
 
 @param other the map to copy from]]>
      </doc>
    </constructor>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="entrySet" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keySet" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="put" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.Writable"/>
      <param name="value" type="org.apache.hadoop.io.Writable"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.util.Map"/>
    </method>
    <method name="remove" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A Writable Map.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.MapWritable -->
  <!-- start class org.apache.hadoop.io.MD5Hash -->
  <class name="MD5Hash" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="MD5Hash"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an MD5Hash.]]>
      </doc>
    </constructor>
    <constructor name="MD5Hash" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an MD5Hash from a hex string.]]>
      </doc>
    </constructor>
    <constructor name="MD5Hash" type="byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs an MD5Hash with a specified value.]]>
      </doc>
    </constructor>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="org.apache.hadoop.io.MD5Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Constructs, reads and returns an instance.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="that" type="org.apache.hadoop.io.MD5Hash"/>
      <doc>
      <![CDATA[Copy the contents of another instance into this instance.]]>
      </doc>
    </method>
    <method name="getDigest" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the digest bytes.]]>
      </doc>
    </method>
    <method name="digest" return="org.apache.hadoop.io.MD5Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="byte[]"/>
      <doc>
      <![CDATA[Construct a hash value for a byte array.]]>
      </doc>
    </method>
    <method name="getDigester" return="java.security.MessageDigest"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a thread local MD5 digester]]>
      </doc>
    </method>
    <method name="digest" return="org.apache.hadoop.io.MD5Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a hash value for the content from the InputStream.]]>
      </doc>
    </method>
    <method name="digest" return="org.apache.hadoop.io.MD5Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Construct a hash value for a byte array.]]>
      </doc>
    </method>
    <method name="digest" return="org.apache.hadoop.io.MD5Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Construct a hash value for a String.]]>
      </doc>
    </method>
    <method name="digest" return="org.apache.hadoop.io.MD5Hash"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="org.apache.hadoop.io.UTF8"/>
      <doc>
      <![CDATA[Construct a hash value for a String.]]>
      </doc>
    </method>
    <method name="halfDigest" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a half-sized version of this MD5.  Fits in a long]]>
      </doc>
    </method>
    <method name="quarterDigest" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a 32-bit digest of the MD5.
 @return the first 4 bytes of the md5]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is an MD5Hash whose digest contains the
 same values.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a hash code value for this object.
 Only uses the first 4 bytes, since md5s are evenly distributed.]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="that" type="org.apache.hadoop.io.MD5Hash"/>
      <doc>
      <![CDATA[Compares this object with the specified object for order.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of this object.]]>
      </doc>
    </method>
    <method name="setDigest"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hex" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the digest value from a hex string.]]>
      </doc>
    </method>
    <field name="MD5_LEN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A Writable for MD5 hash values.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.MD5Hash -->
  <!-- start class org.apache.hadoop.io.MD5Hash.Comparator -->
  <class name="MD5Hash.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MD5Hash.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A WritableComparator optimized for MD5Hash keys.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.MD5Hash.Comparator -->
  <!-- start class org.apache.hadoop.io.MultipleIOException -->
  <class name="MultipleIOException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getExceptions" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the underlying exceptions]]>
      </doc>
    </method>
    <method name="createIOException" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exceptions" type="java.util.List"/>
      <doc>
      <![CDATA[A convenient method to create an {@link IOException}.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Encapsulate a list of {@link IOException} into an {@link IOException}]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.MultipleIOException -->
  <!-- start class org.apache.hadoop.io.NullWritable -->
  <class name="NullWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <method name="get" return="org.apache.hadoop.io.NullWritable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the single instance of this class.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.io.NullWritable"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Singleton Writable with no data.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.NullWritable -->
  <!-- start class org.apache.hadoop.io.NullWritable.Comparator -->
  <class name="NullWritable.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NullWritable.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
      <doc>
      <![CDATA[Compare the buffers in serialized form.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A Comparator &quot;optimized&quot; for NullWritable.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.NullWritable.Comparator -->
  <!-- start class org.apache.hadoop.io.ObjectWritable -->
  <class name="ObjectWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="ObjectWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectWritable" type="java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ObjectWritable" type="java.lang.Class, java.lang.Object"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the instance, or null if none.]]>
      </doc>
    </method>
    <method name="getDeclaredClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the class this is meant to be.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
      <doc>
      <![CDATA[Reset the instance.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeObject"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="instance" type="java.lang.Object"/>
      <param name="declaredClass" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a {@link Writable}, {@link String}, primitive type, or an array of
 the preceding.]]>
      </doc>
    </method>
    <method name="writeObject"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="instance" type="java.lang.Object"/>
      <param name="declaredClass" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="allowCompactArrays" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a {@link Writable}, {@link String}, primitive type, or an array of
 the preceding.  
 
 @param allowCompactArrays - set true for RPC and internal or intra-cluster
 usages.  Set false for inter-cluster, File, and other persisted output 
 usages, to preserve the ability to interchange files with other clusters 
 that may not be running the same version of software.  Sometime in ~2013 
 we can consider removing this parameter and always using the compact format.]]>
      </doc>
    </method>
    <method name="readObject" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a {@link Writable}, {@link String}, primitive type, or an array of
 the preceding.]]>
      </doc>
    </method>
    <method name="readObject" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="objectWritable" type="org.apache.hadoop.io.ObjectWritable"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a {@link Writable}, {@link String}, primitive type, or an array of
 the preceding.]]>
      </doc>
    </method>
    <method name="loadClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="className" type="java.lang.String"/>
      <doc>
      <![CDATA[Find and load the class with given name <tt>className</tt> by first finding
 it in the specified <tt>conf</tt>. If the specified <tt>conf</tt> is null,
 try load it directly.]]>
      </doc>
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A polymorphic Writable that writes an instance with it's class name.
 Handles arrays, strings and primitive types without a Writable wrapper.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ObjectWritable -->
  <!-- start interface org.apache.hadoop.io.RawComparator -->
  <interface name="RawComparator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Comparator"/>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
      <doc>
      <![CDATA[Compare two objects in binary.
 b1[s1:l1] is the first object, and b2[s2:l2] is the second object.
 
 @param b1 The first byte array.
 @param s1 The position index in b1. The object under comparison's starting index.
 @param l1 The length of the object in b1.
 @param b2 The second byte array.
 @param s2 The position index in b2. The object under comparison's starting index.
 @param l2 The length of the object under comparison in b2.
 @return An integer result of the comparison.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 A {@link Comparator} that operates directly on byte representations of
 objects.
 </p>
 @param <T>
 @see DeserializerComparator]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.RawComparator -->
  <!-- start interface org.apache.hadoop.io.ReadaheadPool.ReadaheadRequest -->
  <interface name="ReadaheadPool.ReadaheadRequest"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="cancel"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Cancels the request for readahead. This should be used
 if the reader no longer needs the requested data, <em>before</em>
 closing the related file descriptor.
 
 It is safe to use even if the readahead request has already
 been fulfilled.]]>
      </doc>
    </method>
    <method name="getOffset" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the requested offset]]>
      </doc>
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the requested length]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An outstanding readahead request that has been submitted to
 the pool. This request may be pending or may have been
 completed.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.ReadaheadPool.ReadaheadRequest -->
  <!-- start class org.apache.hadoop.io.SecureIOUtils -->
  <class name="SecureIOUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SecureIOUtils"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="openForRandomRead" return="java.io.RandomAccessFile"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <param name="mode" type="java.lang.String"/>
      <param name="expectedOwner" type="java.lang.String"/>
      <param name="expectedGroup" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Open the given File for random read access, verifying the expected user/
 group constraints if security is enabled.
 
 Note that this function provides no additional security checks if hadoop
 security is disabled, since doing the checks would be too expensive when
 native libraries are not available.
 
 @param f file that we are trying to open
 @param mode mode in which we want to open the random access file
 @param expectedOwner the expected user owner for the file
 @param expectedGroup the expected group owner for the file
 @throws IOException if an IO error occurred or if the user/group does
 not match when security is enabled.]]>
      </doc>
    </method>
    <method name="forceSecureOpenForRandomRead" return="java.io.RandomAccessFile"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <param name="mode" type="java.lang.String"/>
      <param name="expectedOwner" type="java.lang.String"/>
      <param name="expectedGroup" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Same as openForRandomRead except that it will run even if security is off.
 This is used by unit tests.]]>
      </doc>
    </method>
    <method name="openFSDataInputStream" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="expectedOwner" type="java.lang.String"/>
      <param name="expectedGroup" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens the {@link FSDataInputStream} on the requested file on local file
 system, verifying the expected user/group constraints if security is
 enabled.
 @param file absolute path of the file
 @param expectedOwner the expected user owner for the file
 @param expectedGroup the expected group owner for the file
 @throws IOException if an IO Error occurred or the user/group does not
 match if security is enabled]]>
      </doc>
    </method>
    <method name="forceSecureOpenFSDataInputStream" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="expectedOwner" type="java.lang.String"/>
      <param name="expectedGroup" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Same as openFSDataInputStream except that it will run even if security is
 off. This is used by unit tests.]]>
      </doc>
    </method>
    <method name="openForRead" return="java.io.FileInputStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <param name="expectedOwner" type="java.lang.String"/>
      <param name="expectedGroup" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Open the given File for read access, verifying the expected user/group
 constraints if security is enabled.

 Note that this function provides no additional checks if Hadoop
 security is disabled, since doing the checks would be too expensive
 when native libraries are not available.

 @param f the file that we are trying to open
 @param expectedOwner the expected user owner for the file
 @param expectedGroup the expected group owner for the file
 @throws IOException if an IO Error occurred, or security is enabled and
 the user/group does not match]]>
      </doc>
    </method>
    <method name="forceSecureOpenForRead" return="java.io.FileInputStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <param name="expectedOwner" type="java.lang.String"/>
      <param name="expectedGroup" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Same as openForRead() except that it will run even if security is off.
 This is used by unit tests.]]>
      </doc>
    </method>
    <method name="createForWrite" return="java.io.FileOutputStream"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="java.io.File"/>
      <param name="permissions" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Open the specified File for write access, ensuring that it does not exist.
 @param f the file that we want to create
 @param permissions we want to have on the file (if security is enabled)

 @throws AlreadyExistsException if the file already exists
 @throws IOException if any other error occurred]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class provides secure APIs for opening and creating files on the local
 disk. The main issue this class tries to handle is that of symlink traversal.
 <br/>
 An example of such an attack is:
 <ol>
 <li> Malicious user removes his task's syslog file, and puts a link to the
 jobToken file of a target user.</li>
 <li> Malicious user tries to open the syslog file via the servlet on the
 tasktracker.</li>
 <li> The tasktracker is unaware of the symlink, and simply streams the contents
 of the jobToken file. The malicious user can now access potentially sensitive
 map outputs, etc. of the target user's job.</li>
 </ol>
 A similar attack is possible involving task log truncation, but in that case
 due to an insecure write to a file.
 <br/>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SecureIOUtils -->
  <!-- start class org.apache.hadoop.io.SecureIOUtils.AlreadyExistsException -->
  <class name="SecureIOUtils.AlreadyExistsException" extends="java.io.IOException"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SecureIOUtils.AlreadyExistsException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SecureIOUtils.AlreadyExistsException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Signals that an attempt to create a file at a given pathname has failed
 because another file already existed at that path.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SecureIOUtils.AlreadyExistsException -->
  <!-- start class org.apache.hadoop.io.SequenceFile -->
  <class name="SequenceFile" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getDefaultCompressionType" return="org.apache.hadoop.io.SequenceFile.CompressionType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="job" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the compression type for the reduce outputs
 @param job the job config to look in
 @return the kind of compression to use]]>
      </doc>
    </method>
    <method name="setDefaultCompressionType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="job" type="org.apache.hadoop.conf.Configuration"/>
      <param name="val" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <doc>
      <![CDATA[Set the default compression type for sequence files.
 @param job the configuration to modify
 @param val the new compression type (none, block, record)]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="opts" type="org.apache.hadoop.io.SequenceFile.Writer.Option[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a new Writer with the given options.
 @param conf the configuration to use
 @param opts the options to create the file with
 @return a new Writer
 @throws IOException]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem. 
 @param conf The configuration.
 @param name The name of the file. 
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException
 @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem. 
 @param conf The configuration.
 @param name The name of the file. 
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException
 @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem. 
 @param conf The configuration.
 @param name The name of the file. 
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @param progress The Progressable object to track progress.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException
 @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem. 
 @param conf The configuration.
 @param name The name of the file. 
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @param codec The compression codec.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException
 @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="metadata" type="org.apache.hadoop.io.SequenceFile.Metadata"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem. 
 @param conf The configuration.
 @param name The name of the file. 
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @param codec The compression codec.
 @param progress The Progressable object to track progress.
 @param metadata The metadata of the file.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException
 @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="metadata" type="org.apache.hadoop.io.SequenceFile.Metadata"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem.
 @param conf The configuration.
 @param name The name of the file.
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param bufferSize buffer size for the underlaying outputstream.
 @param replication replication factor for the file.
 @param blockSize block size for the file.
 @param compressionType The compression type.
 @param codec The compression codec.
 @param progress The Progressable object to track progress.
 @param metadata The metadata of the file.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException
 @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="createParent" type="boolean"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <param name="metadata" type="org.apache.hadoop.io.SequenceFile.Metadata"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem.
 @param conf The configuration.
 @param name The name of the file.
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param bufferSize buffer size for the underlaying outputstream.
 @param replication replication factor for the file.
 @param blockSize block size for the file.
 @param createParent create parent directory if non-existent
 @param compressionType The compression type.
 @param codec The compression codec.
 @param metadata The metadata of the file.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fc" type="org.apache.hadoop.fs.FileContext"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <param name="metadata" type="org.apache.hadoop.io.SequenceFile.Metadata"/>
      <param name="createFlag" type="java.util.EnumSet"/>
      <param name="opts" type="org.apache.hadoop.fs.Options.CreateOpts[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fc The context for the specified file.
 @param conf The configuration.
 @param name The name of the file.
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @param codec The compression codec.
 @param metadata The metadata of the file.
 @param createFlag gives the semantics of create: overwrite, append etc.
 @param opts file creation options; see {@link CreateOpts}.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="name" type="org.apache.hadoop.fs.Path"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of SequenceFile Writer.
 @param fs The configured filesystem. 
 @param conf The configuration.
 @param name The name of the file. 
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @param codec The compression codec.
 @param progress The Progressable object to track progress.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException
 @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="out" type="org.apache.hadoop.fs.FSDataOutputStream"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <param name="metadata" type="org.apache.hadoop.io.SequenceFile.Metadata"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of 'raw' SequenceFile Writer.
 @param conf The configuration.
 @param out The stream on top which the writer is to be constructed.
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @param codec The compression codec.
 @param metadata The metadata of the file.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException
 @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.]]>
      </doc>
    </method>
    <method name="createWriter" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="out" type="org.apache.hadoop.fs.FSDataOutputStream"/>
      <param name="keyClass" type="java.lang.Class"/>
      <param name="valClass" type="java.lang.Class"/>
      <param name="compressionType" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the preferred type of 'raw' SequenceFile Writer.
 @param conf The configuration.
 @param out The stream on top which the writer is to be constructed.
 @param keyClass The 'key' type.
 @param valClass The 'value' type.
 @param compressionType The compression type.
 @param codec The compression codec.
 @return Returns the handle to the constructed SequenceFile Writer.
 @throws IOException
 @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}
     instead.]]>
      </doc>
    </method>
    <field name="SYNC_INTERVAL" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The number of bytes between sync points.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[<code>SequenceFile</code>s are flat files consisting of binary key/value 
 pairs.
 
 <p><code>SequenceFile</code> provides {@link SequenceFile.Writer},
 {@link SequenceFile.Reader} and {@link Sorter} classes for writing,
 reading and sorting respectively.</p>
 
 There are three <code>SequenceFile</code> <code>Writer</code>s based on the 
 {@link CompressionType} used to compress key/value pairs:
 <ol>
   <li>
   <code>Writer</code> : Uncompressed records.
   </li>
   <li>
   <code>RecordCompressWriter</code> : Record-compressed files, only compress 
                                       values.
   </li>
   <li>
   <code>BlockCompressWriter</code> : Block-compressed files, both keys & 
                                      values are collected in 'blocks' 
                                      separately and compressed. The size of 
                                      the 'block' is configurable.
 </ol>
 
 <p>The actual compression algorithm used to compress key and/or values can be
 specified by using the appropriate {@link CompressionCodec}.</p>
 
 <p>The recommended way is to use the static <tt>createWriter</tt> methods
 provided by the <code>SequenceFile</code> to chose the preferred format.</p>

 <p>The {@link SequenceFile.Reader} acts as the bridge and can read any of the
 above <code>SequenceFile</code> formats.</p>

 <h4 id="Formats">SequenceFile Formats</h4>
 
 <p>Essentially there are 3 different formats for <code>SequenceFile</code>s
 depending on the <code>CompressionType</code> specified. All of them share a
 <a href="#Header">common header</a> described below.
 
 <h5 id="Header">SequenceFile Header</h5>
 <ul>
   <li>
   version - 3 bytes of magic header <b>SEQ</b>, followed by 1 byte of actual 
             version number (e.g. SEQ4 or SEQ6)
   </li>
   <li>
   keyClassName -key class
   </li>
   <li>
   valueClassName - value class
   </li>
   <li>
   compression - A boolean which specifies if compression is turned on for 
                 keys/values in this file.
   </li>
   <li>
   blockCompression - A boolean which specifies if block-compression is 
                      turned on for keys/values in this file.
   </li>
   <li>
   compression codec - <code>CompressionCodec</code> class which is used for  
                       compression of keys and/or values (if compression is 
                       enabled).
   </li>
   <li>
   metadata - {@link Metadata} for this file.
   </li>
   <li>
   sync - A sync marker to denote end of the header.
   </li>
 </ul>
 
 <h5 id="#UncompressedFormat">Uncompressed SequenceFile Format</h5>
 <ul>
 <li>
 <a href="#Header">Header</a>
 </li>
 <li>
 Record
   <ul>
     <li>Record length</li>
     <li>Key length</li>
     <li>Key</li>
     <li>Value</li>
   </ul>
 </li>
 <li>
 A sync-marker every few <code>100</code> bytes or so.
 </li>
 </ul>

 <h5 id="#RecordCompressedFormat">Record-Compressed SequenceFile Format</h5>
 <ul>
 <li>
 <a href="#Header">Header</a>
 </li>
 <li>
 Record
   <ul>
     <li>Record length</li>
     <li>Key length</li>
     <li>Key</li>
     <li><i>Compressed</i> Value</li>
   </ul>
 </li>
 <li>
 A sync-marker every few <code>100</code> bytes or so.
 </li>
 </ul>
 
 <h5 id="#BlockCompressedFormat">Block-Compressed SequenceFile Format</h5>
 <ul>
 <li>
 <a href="#Header">Header</a>
 </li>
 <li>
 Record <i>Block</i>
   <ul>
     <li>Uncompressed number of records in the block</li>
     <li>Compressed key-lengths block-size</li>
     <li>Compressed key-lengths block</li>
     <li>Compressed keys block-size</li>
     <li>Compressed keys block</li>
     <li>Compressed value-lengths block-size</li>
     <li>Compressed value-lengths block</li>
     <li>Compressed values block-size</li>
     <li>Compressed values block</li>
   </ul>
 </li>
 <li>
 A sync-marker every block.
 </li>
 </ul>
 
 <p>The compressed blocks of key lengths and value lengths consist of the 
 actual lengths of individual keys/values encoded in ZeroCompressedInteger 
 format.</p>
 
 @see CompressionCodec]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SequenceFile -->
  <!-- start class org.apache.hadoop.io.SequenceFile.CompressionType -->
  <class name="SequenceFile.CompressionType" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.io.SequenceFile.CompressionType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.io.SequenceFile.CompressionType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The compression type used to compress key/value pairs in the 
 {@link SequenceFile}.
 
 @see SequenceFile.Writer]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SequenceFile.CompressionType -->
  <!-- start class org.apache.hadoop.io.SequenceFile.Metadata -->
  <class name="SequenceFile.Metadata" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="SequenceFile.Metadata"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SequenceFile.Metadata" type="java.util.TreeMap"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="org.apache.hadoop.io.Text"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="org.apache.hadoop.io.Text"/>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="org.apache.hadoop.io.Text"/>
      <param name="value" type="org.apache.hadoop.io.Text"/>
    </method>
    <method name="getMetadata" return="java.util.TreeMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.io.SequenceFile.Metadata"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[The class encapsulating with the metadata of a file.
 The metadata of a file is a list of attribute name/value
 pairs of Text type.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SequenceFile.Metadata -->
  <!-- start class org.apache.hadoop.io.SequenceFile.Reader -->
  <class name="SequenceFile.Reader" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="SequenceFile.Reader" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.io.SequenceFile.Reader.Option[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="SequenceFile.Reader" type="org.apache.hadoop.fs.FileSystem, org.apache.hadoop.fs.Path, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="Use Reader(Configuration, Option...) instead.">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a reader by opening a file from the given file system.
 @param fs The file system used to open the file.
 @param file The file being read.
 @param conf Configuration
 @throws IOException
 @deprecated Use Reader(Configuration, Option...) instead.]]>
      </doc>
    </constructor>
    <constructor name="SequenceFile.Reader" type="org.apache.hadoop.fs.FSDataInputStream, int, long, long, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="Use Reader(Configuration, Reader.Option...) instead.">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a reader by the given input stream.
 @param in An input stream.
 @param buffersize unused
 @param start The starting position.
 @param length The length being read.
 @param conf Configuration
 @throws IOException
 @deprecated Use Reader(Configuration, Reader.Option...) instead.]]>
      </doc>
    </constructor>
    <method name="file" return="org.apache.hadoop.io.SequenceFile.Reader.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Create an option to specify the path name of the sequence file.
 @param value the path to read
 @return a new option]]>
      </doc>
    </method>
    <method name="stream" return="org.apache.hadoop.io.SequenceFile.Reader.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.apache.hadoop.fs.FSDataInputStream"/>
      <doc>
      <![CDATA[Create an option to specify the stream with the sequence file.
 @param value the stream to read.
 @return a new option]]>
      </doc>
    </method>
    <method name="start" return="org.apache.hadoop.io.SequenceFile.Reader.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Create an option to specify the starting byte to read.
 @param value the number of bytes to skip over
 @return a new option]]>
      </doc>
    </method>
    <method name="length" return="org.apache.hadoop.io.SequenceFile.Reader.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Create an option to specify the number of bytes to read.
 @param value the number of bytes to read
 @return a new option]]>
      </doc>
    </method>
    <method name="bufferSize" return="org.apache.hadoop.io.SequenceFile.Reader.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Create an option with the buffer size for reading the given pathname.
 @param value the number of bytes to buffer
 @return a new option]]>
      </doc>
    </method>
    <method name="openFile" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="fs" type="org.apache.hadoop.fs.FileSystem"/>
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="length" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Override this method to specialize the type of
 {@link FSDataInputStream} returned.
 @param fs The file system used to open the file.
 @param file The file being read.
 @param bufferSize The buffer size used to read the file.
 @param length The length being read if it is >= 0.  Otherwise,
               the length is not available.
 @return The opened stream.
 @throws IOException]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close the file.]]>
      </doc>
    </method>
    <method name="getKeyClassName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of the key class.]]>
      </doc>
    </method>
    <method name="getKeyClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the class of keys in this file.]]>
      </doc>
    </method>
    <method name="getValueClassName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of the value class.]]>
      </doc>
    </method>
    <method name="getValueClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the class of values in this file.]]>
      </doc>
    </method>
    <method name="isCompressed" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if values are compressed.]]>
      </doc>
    </method>
    <method name="isBlockCompressed" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if records are block-compressed.]]>
      </doc>
    </method>
    <method name="getCompressionCodec" return="org.apache.hadoop.io.compress.CompressionCodec"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the compression codec of data in this file.]]>
      </doc>
    </method>
    <method name="getCompressionType" return="org.apache.hadoop.io.SequenceFile.CompressionType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the compression type for this file.
 @return the compression type]]>
      </doc>
    </method>
    <method name="getMetadata" return="org.apache.hadoop.io.SequenceFile.Metadata"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the metadata object of the file]]>
      </doc>
    </method>
    <method name="getCurrentValue"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the 'value' corresponding to the last read 'key'.
 @param val : The 'value' to be read.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getCurrentValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the 'value' corresponding to the last read 'key'.
 @param val : The 'value' to be read.
 @throws IOException]]>
      </doc>
    </method>
    <method name="next" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read the next key in the file into <code>key</code>, skipping its
 value.  True if another entry exists, and false at end of file.]]>
      </doc>
    </method>
    <method name="next" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.Writable"/>
      <param name="val" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read the next key/value pair in the file into <code>key</code> and
 <code>val</code>.  Returns true if such a pair exists and false when at
 end of file]]>
      </doc>
    </method>
    <method name="createValueBytes" return="org.apache.hadoop.io.SequenceFile.ValueBytes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="nextRaw" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.DataOutputBuffer"/>
      <param name="val" type="org.apache.hadoop.io.SequenceFile.ValueBytes"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read 'raw' records.
 @param key - The buffer into which the key is read
 @param val - The 'raw' value
 @return Returns the total record length or -1 for end of file
 @throws IOException]]>
      </doc>
    </method>
    <method name="nextRawKey" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.DataOutputBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read 'raw' keys.
 @param key - The buffer into which the key is read
 @return Returns the key length or -1 for end of file
 @throws IOException]]>
      </doc>
    </method>
    <method name="next" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read the next key in the file, skipping its
 value.  Return null at end of file.]]>
      </doc>
    </method>
    <method name="nextRawValue" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="org.apache.hadoop.io.SequenceFile.ValueBytes"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read 'raw' values.
 @param val - The 'raw' value
 @return Returns the value length
 @throws IOException]]>
      </doc>
    </method>
    <method name="seek"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the current byte position in the input file.

 <p>The position passed must be a position returned by {@link
 SequenceFile.Writer#getLength()} when writing this file.  To seek to an arbitrary
 position, use {@link SequenceFile.Reader#sync(long)}.]]>
      </doc>
    </method>
    <method name="sync"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Seek to the next sync mark past a given position.]]>
      </doc>
    </method>
    <method name="syncSeen" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true iff the previous call to next passed a sync mark.]]>
      </doc>
    </method>
    <method name="getPosition" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the current byte position in the input file.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the name of the file.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Reads key/value pairs from a sequence-format file.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SequenceFile.Reader -->
  <!-- start interface org.apache.hadoop.io.SequenceFile.Reader.Option -->
  <interface name="SequenceFile.Reader.Option"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[A tag interface for all of the Reader options]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.SequenceFile.Reader.Option -->
  <!-- start class org.apache.hadoop.io.SequenceFile.Sorter -->
  <class name="SequenceFile.Sorter" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SequenceFile.Sorter" type="org.apache.hadoop.fs.FileSystem, java.lang.Class, java.lang.Class, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sort and merge files containing the named classes.]]>
      </doc>
    </constructor>
    <constructor name="SequenceFile.Sorter" type="org.apache.hadoop.fs.FileSystem, org.apache.hadoop.io.RawComparator, java.lang.Class, java.lang.Class, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sort and merge using an arbitrary {@link RawComparator}.]]>
      </doc>
    </constructor>
    <constructor name="SequenceFile.Sorter" type="org.apache.hadoop.fs.FileSystem, org.apache.hadoop.io.RawComparator, java.lang.Class, java.lang.Class, org.apache.hadoop.conf.Configuration, org.apache.hadoop.io.SequenceFile.Metadata"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sort and merge using an arbitrary {@link RawComparator}.]]>
      </doc>
    </constructor>
    <method name="setFactor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="factor" type="int"/>
      <doc>
      <![CDATA[Set the number of streams to merge at once.]]>
      </doc>
    </method>
    <method name="getFactor" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the number of streams to merge at once.]]>
      </doc>
    </method>
    <method name="setMemory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="memory" type="int"/>
      <doc>
      <![CDATA[Set the total amount of buffer memory, in bytes.]]>
      </doc>
    </method>
    <method name="getMemory" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the total amount of buffer memory, in bytes.]]>
      </doc>
    </method>
    <method name="setProgressable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="progressable" type="org.apache.hadoop.util.Progressable"/>
      <doc>
      <![CDATA[Set the progressable object in order to report progress.]]>
      </doc>
    </method>
    <method name="sort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inFiles" type="org.apache.hadoop.fs.Path[]"/>
      <param name="outFile" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteInput" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Perform a file sort from a set of input files into an output file.
 @param inFiles the files to be sorted
 @param outFile the sorted output file
 @param deleteInput should the input files be deleted as they are read?]]>
      </doc>
    </method>
    <method name="sortAndIterate" return="org.apache.hadoop.io.SequenceFile.Sorter.RawKeyValueIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inFiles" type="org.apache.hadoop.fs.Path[]"/>
      <param name="tempDir" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteInput" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Perform a file sort from a set of input files and return an iterator.
 @param inFiles the files to be sorted
 @param tempDir the directory where temp files are created during sort
 @param deleteInput should the input files be deleted as they are read?
 @return iterator the RawKeyValueIterator]]>
      </doc>
    </method>
    <method name="sort"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inFile" type="org.apache.hadoop.fs.Path"/>
      <param name="outFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The backwards compatible interface to sort.
 @param inFile the input file to sort
 @param outFile the sorted output file]]>
      </doc>
    </method>
    <method name="merge" return="org.apache.hadoop.io.SequenceFile.Sorter.RawKeyValueIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="segments" type="java.util.List"/>
      <param name="tmpDir" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Merges the list of segments of type <code>SegmentDescriptor</code>
 @param segments the list of SegmentDescriptors
 @param tmpDir the directory to write temporary files into
 @return RawKeyValueIterator
 @throws IOException]]>
      </doc>
    </method>
    <method name="merge" return="org.apache.hadoop.io.SequenceFile.Sorter.RawKeyValueIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inNames" type="org.apache.hadoop.fs.Path[]"/>
      <param name="deleteInputs" type="boolean"/>
      <param name="tmpDir" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Merges the contents of files passed in Path[] using a max factor value
 that is already set
 @param inNames the array of path names
 @param deleteInputs true if the input files should be deleted when 
 unnecessary
 @param tmpDir the directory to write temporary files into
 @return RawKeyValueIteratorMergeQueue
 @throws IOException]]>
      </doc>
    </method>
    <method name="merge" return="org.apache.hadoop.io.SequenceFile.Sorter.RawKeyValueIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inNames" type="org.apache.hadoop.fs.Path[]"/>
      <param name="deleteInputs" type="boolean"/>
      <param name="factor" type="int"/>
      <param name="tmpDir" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Merges the contents of files passed in Path[]
 @param inNames the array of path names
 @param deleteInputs true if the input files should be deleted when 
 unnecessary
 @param factor the factor that will be used as the maximum merge fan-in
 @param tmpDir the directory to write temporary files into
 @return RawKeyValueIteratorMergeQueue
 @throws IOException]]>
      </doc>
    </method>
    <method name="merge" return="org.apache.hadoop.io.SequenceFile.Sorter.RawKeyValueIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inNames" type="org.apache.hadoop.fs.Path[]"/>
      <param name="tempDir" type="org.apache.hadoop.fs.Path"/>
      <param name="deleteInputs" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Merges the contents of files passed in Path[]
 @param inNames the array of path names
 @param tempDir the directory for creating temp files during merge
 @param deleteInputs true if the input files should be deleted when 
 unnecessary
 @return RawKeyValueIteratorMergeQueue
 @throws IOException]]>
      </doc>
    </method>
    <method name="cloneFileAttributes" return="org.apache.hadoop.io.SequenceFile.Writer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="outputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="prog" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Clones the attributes (like compression of the input file and creates a 
 corresponding Writer
 @param inputFile the path of the input file whose attributes should be 
 cloned
 @param outputFile the path of the output file 
 @param prog the Progressable to report status during the file write
 @return Writer
 @throws IOException]]>
      </doc>
    </method>
    <method name="writeFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="records" type="org.apache.hadoop.io.SequenceFile.Sorter.RawKeyValueIterator"/>
      <param name="writer" type="org.apache.hadoop.io.SequenceFile.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes records from RawKeyValueIterator into a file represented by the 
 passed writer
 @param records the RawKeyValueIterator
 @param writer the Writer created earlier 
 @throws IOException]]>
      </doc>
    </method>
    <method name="merge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inFiles" type="org.apache.hadoop.fs.Path[]"/>
      <param name="outFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Merge the provided files.
 @param inFiles the array of input path names
 @param outFile the final output file
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Sorts key/value pairs in a sequence-format file.

 <p>For best performance, applications should make sure that the {@link
 Writable#readFields(DataInput)} implementation of their keys is
 very efficient.  In particular, it should avoid allocating memory.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SequenceFile.Sorter -->
  <!-- start interface org.apache.hadoop.io.SequenceFile.Sorter.RawKeyValueIterator -->
  <interface name="SequenceFile.Sorter.RawKeyValueIterator"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getKey" return="org.apache.hadoop.io.DataOutputBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets the current raw key
 @return DataOutputBuffer
 @throws IOException]]>
      </doc>
    </method>
    <method name="getValue" return="org.apache.hadoop.io.SequenceFile.ValueBytes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets the current raw value
 @return ValueBytes 
 @throws IOException]]>
      </doc>
    </method>
    <method name="next" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Sets up the current key and value (for getKey and getValue)
 @return true if there exists a key/value, false otherwise 
 @throws IOException]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[closes the iterator so that the underlying streams can be closed
 @throws IOException]]>
      </doc>
    </method>
    <method name="getProgress" return="org.apache.hadoop.util.Progress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets the Progress object; this has a float (0.0 - 1.0) 
 indicating the bytes processed by the iterator so far]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The interface to iterate over raw keys/values of SequenceFiles.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.SequenceFile.Sorter.RawKeyValueIterator -->
  <!-- start class org.apache.hadoop.io.SequenceFile.Sorter.SegmentDescriptor -->
  <class name="SequenceFile.Sorter.SegmentDescriptor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <constructor name="SequenceFile.Sorter.SegmentDescriptor" type="long, long, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a segment
 @param segmentOffset the offset of the segment in the file
 @param segmentLength the length of the segment
 @param segmentPathName the path name of the file containing the segment]]>
      </doc>
    </constructor>
    <method name="doSync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Do the sync checks]]>
      </doc>
    </method>
    <method name="preserveInput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="preserve" type="boolean"/>
      <doc>
      <![CDATA[Whether to delete the files when no longer needed]]>
      </doc>
    </method>
    <method name="shouldPreserveInput" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="nextRawKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fills up the rawKey object with the key returned by the Reader
 @return true if there is a key returned; false, otherwise
 @throws IOException]]>
      </doc>
    </method>
    <method name="nextRawValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rawValue" type="org.apache.hadoop.io.SequenceFile.ValueBytes"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fills up the passed rawValue with the value corresponding to the key
 read earlier
 @param rawValue
 @return the length of the value
 @throws IOException]]>
      </doc>
    </method>
    <method name="getKey" return="org.apache.hadoop.io.DataOutputBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the stored rawKey]]>
      </doc>
    </method>
    <method name="cleanup"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The default cleanup. Subclasses can override this with a custom 
 cleanup]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class defines a merge segment. This class can be subclassed to 
 provide a customized cleanup method implementation. In this 
 implementation, cleanup closes the file handle and deletes the file]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SequenceFile.Sorter.SegmentDescriptor -->
  <!-- start interface org.apache.hadoop.io.SequenceFile.ValueBytes -->
  <interface name="SequenceFile.ValueBytes"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="writeUncompressedBytes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="outStream" type="java.io.DataOutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes the uncompressed bytes to the outStream.
 @param outStream : Stream to write uncompressed bytes into.
 @throws IOException]]>
      </doc>
    </method>
    <method name="writeCompressedBytes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="outStream" type="java.io.DataOutputStream"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write compressed bytes to outStream. 
 Note: that it will NOT compress the bytes if they are not compressed.
 @param outStream : Stream to write compressed bytes into.]]>
      </doc>
    </method>
    <method name="getSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Size of stored data.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The interface to 'raw' values of SequenceFiles.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.SequenceFile.ValueBytes -->
  <!-- start class org.apache.hadoop.io.SequenceFile.Writer -->
  <class name="SequenceFile.Writer" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <implements name="org.apache.hadoop.fs.Syncable"/>
    <constructor name="SequenceFile.Writer" type="org.apache.hadoop.fs.FileSystem, org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.Path, java.lang.Class, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="Use 
   {@link SequenceFile#createWriter(Configuration, Writer.Option...)} 
   instead.">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named file.
 @deprecated Use 
   {@link SequenceFile#createWriter(Configuration, Writer.Option...)} 
   instead.]]>
      </doc>
    </constructor>
    <constructor name="SequenceFile.Writer" type="org.apache.hadoop.fs.FileSystem, org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.Path, java.lang.Class, java.lang.Class, org.apache.hadoop.util.Progressable, org.apache.hadoop.io.SequenceFile.Metadata"
      static="false" final="false" visibility="public"
      deprecated="Use 
   {@link SequenceFile#createWriter(Configuration, Writer.Option...)} 
   instead.">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named file with write-progress reporter.
 @deprecated Use 
   {@link SequenceFile#createWriter(Configuration, Writer.Option...)} 
   instead.]]>
      </doc>
    </constructor>
    <constructor name="SequenceFile.Writer" type="org.apache.hadoop.fs.FileSystem, org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.Path, java.lang.Class, java.lang.Class, int, short, long, org.apache.hadoop.util.Progressable, org.apache.hadoop.io.SequenceFile.Metadata"
      static="false" final="false" visibility="public"
      deprecated="Use 
   {@link SequenceFile#createWriter(Configuration, Writer.Option...)} 
   instead.">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named file with write-progress reporter. 
 @deprecated Use 
   {@link SequenceFile#createWriter(Configuration, Writer.Option...)} 
   instead.]]>
      </doc>
    </constructor>
    <method name="file" return="org.apache.hadoop.io.SequenceFile.Writer.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="bufferSize" return="org.apache.hadoop.io.SequenceFile.Writer.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
    </method>
    <method name="stream" return="org.apache.hadoop.io.SequenceFile.Writer.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.apache.hadoop.fs.FSDataOutputStream"/>
    </method>
    <method name="replication" return="org.apache.hadoop.io.SequenceFile.Writer.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="short"/>
    </method>
    <method name="blockSize" return="org.apache.hadoop.io.SequenceFile.Writer.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
    </method>
    <method name="progressable" return="org.apache.hadoop.io.SequenceFile.Writer.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.apache.hadoop.util.Progressable"/>
    </method>
    <method name="keyClass" return="org.apache.hadoop.io.SequenceFile.Writer.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Class"/>
    </method>
    <method name="valueClass" return="org.apache.hadoop.io.SequenceFile.Writer.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Class"/>
    </method>
    <method name="metadata" return="org.apache.hadoop.io.SequenceFile.Writer.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.apache.hadoop.io.SequenceFile.Metadata"/>
    </method>
    <method name="compression" return="org.apache.hadoop.io.SequenceFile.Writer.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
    </method>
    <method name="compression" return="org.apache.hadoop.io.SequenceFile.Writer.Option"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.apache.hadoop.io.SequenceFile.CompressionType"/>
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
    </method>
    <method name="getKeyClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the class of keys in this file.]]>
      </doc>
    </method>
    <method name="getValueClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the class of values in this file.]]>
      </doc>
    </method>
    <method name="getCompressionCodec" return="org.apache.hadoop.io.compress.CompressionCodec"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the compression codec of data in this file.]]>
      </doc>
    </method>
    <method name="sync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[create a sync point]]>
      </doc>
    </method>
    <method name="syncFs"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #hsync()} or {@link #hflush()} instead">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[flush all currently written data to the file system
 @deprecated Use {@link #hsync()} or {@link #hflush()} instead]]>
      </doc>
    </method>
    <method name="hsync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="hflush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close the file.]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.Writable"/>
      <param name="val" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Append a key/value pair.]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
      <param name="val" type="java.lang.Object"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Append a key/value pair.]]>
      </doc>
    </method>
    <method name="appendRaw"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keyData" type="byte[]"/>
      <param name="keyOffset" type="int"/>
      <param name="keyLength" type="int"/>
      <param name="val" type="org.apache.hadoop.io.SequenceFile.ValueBytes"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Returns the current length of the output file.

 <p>This always returns a synchronized position.  In other words,
 immediately after calling {@link SequenceFile.Reader#seek(long)} with a position
 returned by this method, {@link SequenceFile.Reader#next(Writable)} may be called.  However
 the key may be earlier in the file than key last written when this
 method was called (e.g., with block-compression, it may be the first key
 in the block that was being written when this method was called).]]>
      </doc>
    </method>
    <field name="keySerializer" type="org.apache.hadoop.io.serializer.Serializer"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="uncompressedValSerializer" type="org.apache.hadoop.io.serializer.Serializer"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="compressedValSerializer" type="org.apache.hadoop.io.serializer.Serializer"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Write key/value pairs to a sequence-format file.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SequenceFile.Writer -->
  <!-- start interface org.apache.hadoop.io.SequenceFile.Writer.Option -->
  <interface name="SequenceFile.Writer.Option"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
  </interface>
  <!-- end interface org.apache.hadoop.io.SequenceFile.Writer.Option -->
  <!-- start class org.apache.hadoop.io.SetFile -->
  <class name="SetFile" extends="org.apache.hadoop.io.MapFile"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SetFile"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[A file-based set of keys.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SetFile -->
  <!-- start class org.apache.hadoop.io.SetFile.Reader -->
  <class name="SetFile.Reader" extends="org.apache.hadoop.io.MapFile.Reader"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SetFile.Reader" type="org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a set reader for the named set.]]>
      </doc>
    </constructor>
    <constructor name="SetFile.Reader" type="org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct a set reader for the named set using the named comparator.]]>
      </doc>
    </constructor>
    <method name="seek" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="next" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read the next key in a set into <code>key</code>.  Returns
 true if such a key exists and false when at the end of the set.]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.io.WritableComparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read the matching key from a set into <code>key</code>.
 Returns <code>key</code>, or null if no match exists.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provide access to an existing set file.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SetFile.Reader -->
  <!-- start class org.apache.hadoop.io.SetFile.Writer -->
  <class name="SetFile.Writer" extends="org.apache.hadoop.io.MapFile.Writer"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SetFile.Writer" type="org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="pass a Configuration too">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create the named set for keys of the named class. 
  @deprecated pass a Configuration too]]>
      </doc>
    </constructor>
    <constructor name="SetFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, java.lang.Class, org.apache.hadoop.io.SequenceFile.CompressionType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a set naming the element class and compression type.]]>
      </doc>
    </constructor>
    <constructor name="SetFile.Writer" type="org.apache.hadoop.conf.Configuration, org.apache.hadoop.fs.FileSystem, java.lang.String, org.apache.hadoop.io.WritableComparator, org.apache.hadoop.io.SequenceFile.CompressionType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a set naming the element comparator and compression type.]]>
      </doc>
    </constructor>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Append a key to a set.  The key must be strictly greater than the
 previous key added to the set.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Write a new set file.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SetFile.Writer -->
  <!-- start class org.apache.hadoop.io.ShortWritable -->
  <class name="ShortWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="ShortWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ShortWritable" type="short"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="short"/>
      <doc>
      <![CDATA[Set the value of this ShortWritable.]]>
      </doc>
    </method>
    <method name="get" return="short"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the value of this ShortWritable.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[read the short value]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[write short value]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a ShortWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[hash code]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.io.ShortWritable"/>
      <doc>
      <![CDATA[Compares two ShortWritable.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Short values in string format]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A WritableComparable for shorts.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ShortWritable -->
  <!-- start class org.apache.hadoop.io.ShortWritable.Comparator -->
  <class name="ShortWritable.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ShortWritable.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A Comparator optimized for ShortWritable.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.ShortWritable.Comparator -->
  <!-- start class org.apache.hadoop.io.SortedMapWritable -->
  <class name="SortedMapWritable" extends="org.apache.hadoop.io.AbstractMapWritable"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.SortedMap"/>
    <constructor name="SortedMapWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[default constructor.]]>
      </doc>
    </constructor>
    <constructor name="SortedMapWritable" type="org.apache.hadoop.io.SortedMapWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Copy constructor.
 
 @param other the map to copy from]]>
      </doc>
    </constructor>
    <method name="comparator" return="java.util.Comparator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="firstKey" return="org.apache.hadoop.io.WritableComparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="headMap" return="java.util.SortedMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toKey" type="org.apache.hadoop.io.WritableComparable"/>
    </method>
    <method name="lastKey" return="org.apache.hadoop.io.WritableComparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="subMap" return="java.util.SortedMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="toKey" type="org.apache.hadoop.io.WritableComparable"/>
    </method>
    <method name="tailMap" return="java.util.SortedMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fromKey" type="org.apache.hadoop.io.WritableComparable"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="containsKey" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="containsValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="entrySet" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="keySet" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="put" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="value" type="org.apache.hadoop.io.Writable"/>
    </method>
    <method name="putAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.util.Map"/>
    </method>
    <method name="remove" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="values" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A Writable SortedMap.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.SortedMapWritable -->
  <!-- start interface org.apache.hadoop.io.Stringifier -->
  <interface name="Stringifier"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="T"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Converts the object to a string representation
 @param obj the object to convert
 @return the string representation of the object
 @throws IOException if the object cannot be converted]]>
      </doc>
    </method>
    <method name="fromString" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Restores the object from its string representation.
 @param str the string representation of the object
 @return restored object
 @throws IOException if the object cannot be restored]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Closes this object. 
 @throws IOException if an I/O error occurs]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Stringifier interface offers two methods to convert an object 
 to a string representation and restore the object given its 
 string representation.
 @param <T> the class of the objects to stringify]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.Stringifier -->
  <!-- start class org.apache.hadoop.io.Text -->
  <class name="Text" extends="org.apache.hadoop.io.BinaryComparable"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="Text"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Text" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct from a string.]]>
      </doc>
    </constructor>
    <constructor name="Text" type="org.apache.hadoop.io.Text"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct from another text.]]>
      </doc>
    </constructor>
    <constructor name="Text" type="byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct from a byte array.]]>
      </doc>
    </constructor>
    <method name="copyBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a copy of the bytes that is exactly the length of the data.
 See {@link #getBytes()} for faster access to the underlying array.]]>
      </doc>
    </method>
    <method name="getBytes" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the raw bytes; however, only data up to {@link #getLength()} is
 valid. Please use {@link #copyBytes()} if you
 need the returned array to be precisely the length of the data.]]>
      </doc>
    </method>
    <method name="getLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of bytes in the byte array]]>
      </doc>
    </method>
    <method name="charAt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="int"/>
      <doc>
      <![CDATA[Returns the Unicode Scalar Value (32-bit integer value)
 for the character at <code>position</code>. Note that this
 method avoids using the converter or doing String instantiation
 @return the Unicode scalar value at position or -1
          if the position is invalid or points to a
          trailing byte]]>
      </doc>
    </method>
    <method name="find" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="java.lang.String"/>
    </method>
    <method name="find" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="what" type="java.lang.String"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Finds any occurence of <code>what</code> in the backing
 buffer, starting as position <code>start</code>. The starting
 position is measured in bytes and the return value is in
 terms of byte position in the buffer. The backing buffer is
 not converted to a string for this operation.
 @return byte position of the first occurence of the search
         string in the UTF-8 buffer or -1 if not found]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[Set to contain the contents of a string.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <doc>
      <![CDATA[Set to a utf8 byte array]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.io.Text"/>
      <doc>
      <![CDATA[copy a text.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Set the Text to range of bytes
 @param utf8 the data to copy from
 @param start the first position of the new string
 @param len the number of bytes of the new string]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Append a range of bytes to the end of the given text
 @param utf8 the data to copy from
 @param start the first position to append from utf8
 @param len the number of bytes to append]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clear the string to empty.

 <em>Note</em>: For performance reasons, this call does not clear the
 underlying byte array that is retrievable via {@link #getBytes()}.
 In order to free the byte-array memory, call {@link #set(byte[])}
 with an empty byte array (For example, <code>new byte[0]</code>).]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Convert text back to string
 @see java.lang.Object#toString()]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[deserialize]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="maxLength" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Skips over one Text in the input.]]>
      </doc>
    </method>
    <method name="readWithKnownLength"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a Text object whose length is already known.
 This allows creating Text from a stream which uses a different serialization
 format.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[serialize
 write this object to out
 length uses zero-compressed encoding
 @see Writable#write(DataOutput)]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="maxLength" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a Text with the same contents.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="decode" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <exception name="CharacterCodingException" type="java.nio.charset.CharacterCodingException"/>
      <doc>
      <![CDATA[Converts the provided byte array to a String using the
 UTF-8 encoding. If the input is malformed,
 replace by a default value.]]>
      </doc>
    </method>
    <method name="decode" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="length" type="int"/>
      <exception name="CharacterCodingException" type="java.nio.charset.CharacterCodingException"/>
    </method>
    <method name="decode" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="length" type="int"/>
      <param name="replace" type="boolean"/>
      <exception name="CharacterCodingException" type="java.nio.charset.CharacterCodingException"/>
      <doc>
      <![CDATA[Converts the provided byte array to a String using the
 UTF-8 encoding. If <code>replace</code> is true, then
 malformed input is replaced with the
 substitution character, which is U+FFFD. Otherwise the
 method throws a MalformedInputException.]]>
      </doc>
    </method>
    <method name="encode" return="java.nio.ByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <exception name="CharacterCodingException" type="java.nio.charset.CharacterCodingException"/>
      <doc>
      <![CDATA[Converts the provided String to bytes using the
 UTF-8 encoding. If the input is malformed,
 invalid chars are replaced by a default value.
 @return ByteBuffer: bytes stores at ByteBuffer.array() 
                     and length is ByteBuffer.limit()]]>
      </doc>
    </method>
    <method name="encode" return="java.nio.ByteBuffer"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <param name="replace" type="boolean"/>
      <exception name="CharacterCodingException" type="java.nio.charset.CharacterCodingException"/>
      <doc>
      <![CDATA[Converts the provided String to bytes using the
 UTF-8 encoding. If <code>replace</code> is true, then
 malformed input is replaced with the
 substitution character, which is U+FFFD. Otherwise the
 method throws a MalformedInputException.
 @return ByteBuffer: bytes stores at ByteBuffer.array() 
                     and length is ByteBuffer.limit()]]>
      </doc>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a UTF8 encoded string from in]]>
      </doc>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="maxLength" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a UTF8 encoded string with a maximum size]]>
      </doc>
    </method>
    <method name="writeString" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="s" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a UTF8 encoded string to out]]>
      </doc>
    </method>
    <method name="writeString" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="s" type="java.lang.String"/>
      <param name="maxLength" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a UTF8 encoded string with a maximum size to out]]>
      </doc>
    </method>
    <method name="validateUTF8"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <exception name="MalformedInputException" type="java.nio.charset.MalformedInputException"/>
      <doc>
      <![CDATA[Check if a byte array contains valid utf-8
 @param utf8 byte array
 @throws MalformedInputException if the byte array contains invalid utf-8]]>
      </doc>
    </method>
    <method name="validateUTF8"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="utf8" type="byte[]"/>
      <param name="start" type="int"/>
      <param name="len" type="int"/>
      <exception name="MalformedInputException" type="java.nio.charset.MalformedInputException"/>
      <doc>
      <![CDATA[Check to see if a byte array is valid utf-8
 @param utf8 the array of bytes
 @param start the offset of the first byte in the array
 @param len the length of the byte sequence
 @throws MalformedInputException if the byte array contains invalid bytes]]>
      </doc>
    </method>
    <method name="bytesToCodePoint" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="java.nio.ByteBuffer"/>
      <doc>
      <![CDATA[Returns the next code point at the current position in
 the buffer. The buffer's position will be incremented.
 Any mark set on this buffer will be changed by this method!]]>
      </doc>
    </method>
    <method name="utf8Length" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="string" type="java.lang.String"/>
      <doc>
      <![CDATA[For the given string, returns the number of UTF-8 bytes
 required to encode the string.
 @param string text to encode
 @return number of UTF-8 bytes required to encode]]>
      </doc>
    </method>
    <field name="DEFAULT_MAX_LEN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This class stores text using standard UTF8 encoding.  It provides methods
 to serialize, deserialize, and compare texts at byte level.  The type of
 length is integer and is serialized using zero-compressed format.  <p>In
 addition, it provides methods for string traversal without converting the
 byte array to a string.  <p>Also includes utilities for
 serializing/deserialing a string, coding/decoding a string, checking if a
 byte array contains valid UTF8 code, calculating the length of an encoded
 string.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.Text -->
  <!-- start class org.apache.hadoop.io.Text.Comparator -->
  <class name="Text.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Text.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A WritableComparator optimized for Text keys.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.Text.Comparator -->
  <!-- start class org.apache.hadoop.io.TwoDArrayWritable -->
  <class name="TwoDArrayWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="TwoDArrayWritable" type="java.lang.Class"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TwoDArrayWritable" type="java.lang.Class, org.apache.hadoop.io.Writable[][]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="toArray" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="values" type="org.apache.hadoop.io.Writable[][]"/>
    </method>
    <method name="get" return="org.apache.hadoop.io.Writable[][]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A Writable for 2D arrays containing a matrix of instances of a class.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.TwoDArrayWritable -->
  <!-- start class org.apache.hadoop.io.UTF8.Comparator -->
  <class name="UTF8.Comparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UTF8.Comparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <doc>
    <![CDATA[A WritableComparator optimized for UTF8 keys.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.UTF8.Comparator -->
  <!-- start class org.apache.hadoop.io.VersionedWritable -->
  <class name="VersionedWritable" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="VersionedWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getVersion" return="byte"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the version number of the current implementation.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A base class for Writables that provides version checking.

 <p>This is useful when a class may evolve, so that instances written by the
 old version of the class may still be processed by the new version.  To
 handle this situation, {@link #readFields(DataInput)}
 implementations should catch {@link VersionMismatchException}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.VersionedWritable -->
  <!-- start class org.apache.hadoop.io.VersionMismatchException -->
  <class name="VersionMismatchException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="VersionMismatchException" type="byte, byte"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a string representation of this object.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Thrown by {@link VersionedWritable#readFields(DataInput)} when the
 version of an object being read does not match the current implementation
 version as returned by {@link VersionedWritable#getVersion()}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.VersionMismatchException -->
  <!-- start class org.apache.hadoop.io.VIntWritable -->
  <class name="VIntWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="VIntWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="VIntWritable" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Set the value of this VIntWritable.]]>
      </doc>
    </method>
    <method name="get" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the value of this VIntWritable.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a VIntWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.io.VIntWritable"/>
      <doc>
      <![CDATA[Compares two VIntWritables.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for integer values stored in variable-length format.
 Such values take between one and five bytes.  Smaller values take fewer bytes.
 
 @see org.apache.hadoop.io.WritableUtils#readVInt(DataInput)]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.VIntWritable -->
  <!-- start class org.apache.hadoop.io.VLongWritable -->
  <class name="VLongWritable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <constructor name="VLongWritable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="VLongWritable" type="long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Set the value of this LongWritable.]]>
      </doc>
    </method>
    <method name="get" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the value of this LongWritable.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Returns true iff <code>o</code> is a VLongWritable with the same value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.io.VLongWritable"/>
      <doc>
      <![CDATA[Compares two VLongWritables.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A WritableComparable for longs in a variable-length format. Such values take
  between one and five bytes.  Smaller values take fewer bytes.
  
  @see org.apache.hadoop.io.WritableUtils#readVLong(DataInput)]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.VLongWritable -->
  <!-- start interface org.apache.hadoop.io.Writable -->
  <interface name="Writable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serialize the fields of this object to <code>out</code>.
 
 @param out <code>DataOuput</code> to serialize this object into.
 @throws IOException]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deserialize the fields of this object from <code>in</code>.  
 
 <p>For efficiency, implementations should attempt to re-use storage in the 
 existing object where possible.</p>
 
 @param in <code>DataInput</code> to deseriablize this object from.
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A serializable object which implements a simple, efficient, serialization 
 protocol, based on {@link DataInput} and {@link DataOutput}.

 <p>Any <code>key</code> or <code>value</code> type in the Hadoop Map-Reduce
 framework implements this interface.</p>
 
 <p>Implementations typically implement a static <code>read(DataInput)</code>
 method which constructs a new instance, calls {@link #readFields(DataInput)} 
 and returns the instance.</p>
 
 <p>Example:</p>
 <p><blockquote><pre>
     public class MyWritable implements Writable {
       // Some data     
       private int counter;
       private long timestamp;
       
       public void write(DataOutput out) throws IOException {
         out.writeInt(counter);
         out.writeLong(timestamp);
       }
       
       public void readFields(DataInput in) throws IOException {
         counter = in.readInt();
         timestamp = in.readLong();
       }
       
       public static MyWritable read(DataInput in) throws IOException {
         MyWritable w = new MyWritable();
         w.readFields(in);
         return w;
       }
     }
 </pre></blockquote></p>]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.Writable -->
  <!-- start interface org.apache.hadoop.io.WritableComparable -->
  <interface name="WritableComparable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.Writable"/>
    <implements name="java.lang.Comparable"/>
    <doc>
    <![CDATA[A {@link Writable} which is also {@link Comparable}. 

 <p><code>WritableComparable</code>s can be compared to each other, typically 
 via <code>Comparator</code>s. Any type which is to be used as a 
 <code>key</code> in the Hadoop Map-Reduce framework should implement this
 interface.</p>

 <p>Note that <code>hashCode()</code> is frequently used in Hadoop to partition
 keys. It's important that your implementation of hashCode() returns the same 
 result across different instances of the JVM. Note also that the default 
 <code>hashCode()</code> implementation in <code>Object</code> does <b>not</b>
 satisfy this property.</p>
  
 <p>Example:</p>
 <p><blockquote><pre>
     public class MyWritableComparable implements WritableComparable<MyWritableComparable> {
       // Some data
       private int counter;
       private long timestamp;
       
       public void write(DataOutput out) throws IOException {
         out.writeInt(counter);
         out.writeLong(timestamp);
       }
       
       public void readFields(DataInput in) throws IOException {
         counter = in.readInt();
         timestamp = in.readLong();
       }
       
       public int compareTo(MyWritableComparable o) {
         int thisValue = this.value;
         int thatValue = o.value;
         return (thisValue &lt; thatValue ? -1 : (thisValue==thatValue ? 0 : 1));
       }

       public int hashCode() {
         final int prime = 31;
         int result = 1;
         result = prime * result + counter;
         result = prime * result + (int) (timestamp ^ (timestamp &gt;&gt;&gt; 32));
         return result
       }
     }
 </pre></blockquote></p>]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.WritableComparable -->
  <!-- start class org.apache.hadoop.io.WritableComparator -->
  <class name="WritableComparator" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.RawComparator"/>
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="WritableComparator"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="WritableComparator" type="java.lang.Class"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct for a {@link WritableComparable} implementation.]]>
      </doc>
    </constructor>
    <constructor name="WritableComparator" type="java.lang.Class, boolean"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="WritableComparator" type="java.lang.Class, org.apache.hadoop.conf.Configuration, boolean"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="org.apache.hadoop.io.WritableComparator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <doc>
      <![CDATA[For backwards compatibility.]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.io.WritableComparator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get a comparator for a {@link WritableComparable} implementation.]]>
      </doc>
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="define"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="comparator" type="org.apache.hadoop.io.WritableComparator"/>
      <doc>
      <![CDATA[Register an optimized comparator for a {@link WritableComparable}
 implementation. Comparators registered with this method must be
 thread-safe.]]>
      </doc>
    </method>
    <method name="getKeyClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the WritableComparable implementation class.]]>
      </doc>
    </method>
    <method name="newKey" return="org.apache.hadoop.io.WritableComparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a new {@link WritableComparable} instance.]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
      <doc>
      <![CDATA[Optimization hook.  Override this to make SequenceFile.Sorter's scream.

 <p>The default implementation reads the data into two {@link
 WritableComparable}s (using {@link
 Writable#readFields(DataInput)}, then calls {@link
 #compare(WritableComparable,WritableComparable)}.]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="org.apache.hadoop.io.WritableComparable"/>
      <param name="b" type="org.apache.hadoop.io.WritableComparable"/>
      <doc>
      <![CDATA[Compare two WritableComparables.

 <p> The default implementation uses the natural ordering, calling {@link
 Comparable#compareTo(Object)}.]]>
      </doc>
    </method>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="a" type="java.lang.Object"/>
      <param name="b" type="java.lang.Object"/>
    </method>
    <method name="compareBytes" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
      <doc>
      <![CDATA[Lexicographic order of binary data.]]>
      </doc>
    </method>
    <method name="hashBytes" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Compute hash for binary data.]]>
      </doc>
    </method>
    <method name="hashBytes" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Compute hash for binary data.]]>
      </doc>
    </method>
    <method name="readUnsignedShort" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Parse an unsigned short from a byte array.]]>
      </doc>
    </method>
    <method name="readInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Parse an integer from a byte array.]]>
      </doc>
    </method>
    <method name="readFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Parse a float from a byte array.]]>
      </doc>
    </method>
    <method name="readLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Parse a long from a byte array.]]>
      </doc>
    </method>
    <method name="readDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Parse a double from a byte array.]]>
      </doc>
    </method>
    <method name="readVLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a zero-compressed encoded long from a byte array and returns it.
 @param bytes byte array with decode long
 @param start starting index
 @throws java.io.IOException 
 @return deserialized long]]>
      </doc>
    </method>
    <method name="readVInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a zero-compressed encoded integer from a byte array and returns it.
 @param bytes byte array with the encoded integer
 @param start start index
 @throws java.io.IOException 
 @return deserialized integer]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A Comparator for {@link WritableComparable}s.

 <p>This base implemenation uses the natural ordering.  To define alternate
 orderings, override {@link #compare(WritableComparable,WritableComparable)}.

 <p>One may optimize compare-intensive operations by overriding
 {@link #compare(byte[],int,int,byte[],int,int)}.  Static utility methods are
 provided to assist in optimized implementations of this method.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.WritableComparator -->
  <!-- start class org.apache.hadoop.io.WritableFactories -->
  <class name="WritableFactories" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setFactory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="factory" type="org.apache.hadoop.io.WritableFactory"/>
      <doc>
      <![CDATA[Define a factory for a class.]]>
      </doc>
    </method>
    <method name="getFactory" return="org.apache.hadoop.io.WritableFactory"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <doc>
      <![CDATA[Define a factory for a class.]]>
      </doc>
    </method>
    <method name="newInstance" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Create a new instance of a class with a defined factory.]]>
      </doc>
    </method>
    <method name="newInstance" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <doc>
      <![CDATA[Create a new instance of a class with a defined factory.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Factories for non-public writables.  Defining a factory permits {@link
 ObjectWritable} to be able to construct instances of non-public classes.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.WritableFactories -->
  <!-- start interface org.apache.hadoop.io.WritableFactory -->
  <interface name="WritableFactory"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="newInstance" return="org.apache.hadoop.io.Writable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a new instance.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A factory for a class of Writable.
 @see WritableFactories]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.WritableFactory -->
  <!-- start class org.apache.hadoop.io.WritableUtils -->
  <class name="WritableUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="WritableUtils"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="readCompressedByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skipCompressedByteArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCompressedByteArray" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="bytes" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readCompressedString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCompressedString" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="s" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="s" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeStringArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="s" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeCompressedStringArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="s" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readStringArray" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readCompressedStringArray" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="displayByteArray"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="byte[]"/>
    </method>
    <method name="clone" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="orig" type="T"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Make a copy of a writable object using serialization to a buffer.
 @param orig The object to copy
 @return The copied object]]>
      </doc>
    </method>
    <method name="cloneInto"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use ReflectionUtils.cloneInto instead.">
      <param name="dst" type="org.apache.hadoop.io.Writable"/>
      <param name="src" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Make a copy of the writable object using serialiation to a buffer
 @param dst the object to copy from
 @param src the object to copy into, which is destroyed
 @throws IOException
 @deprecated use ReflectionUtils.cloneInto instead.]]>
      </doc>
    </method>
    <method name="writeVInt"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.DataOutput"/>
      <param name="i" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serializes an integer to a binary stream with zero-compressed encoding.
 For -120 <= i <= 127, only one byte is used with the actual value.
 For other values of i, the first byte value indicates whether the
 integer is positive or negative, and the number of bytes that follow.
 If the first byte value v is between -121 and -124, the following integer
 is positive, with number of bytes that follow are -(v+120).
 If the first byte value v is between -125 and -128, the following integer
 is negative, with number of bytes that follow are -(v+124). Bytes are
 stored in the high-non-zero-byte-first order.

 @param stream Binary output stream
 @param i Integer to be serialized
 @throws java.io.IOException]]>
      </doc>
    </method>
    <method name="writeVLong"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.DataOutput"/>
      <param name="i" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serializes a long to a binary stream with zero-compressed encoding.
 For -112 <= i <= 127, only one byte is used with the actual value.
 For other values of i, the first byte value indicates whether the
 long is positive or negative, and the number of bytes that follow.
 If the first byte value v is between -113 and -120, the following long
 is positive, with number of bytes that follow are -(v+112).
 If the first byte value v is between -121 and -128, the following long
 is negative, with number of bytes that follow are -(v+120). Bytes are
 stored in the high-non-zero-byte-first order.
 
 @param stream Binary output stream
 @param i Long to be serialized
 @throws java.io.IOException]]>
      </doc>
    </method>
    <method name="readVLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a zero-compressed encoded long from input stream and returns it.
 @param stream Binary input stream
 @throws java.io.IOException 
 @return deserialized long from stream.]]>
      </doc>
    </method>
    <method name="readVInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a zero-compressed encoded integer from input stream and returns it.
 @param stream Binary input stream
 @throws java.io.IOException 
 @return deserialized integer from stream.]]>
      </doc>
    </method>
    <method name="readVIntInRange" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.DataInput"/>
      <param name="lower" type="int"/>
      <param name="upper" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads an integer from the input stream and returns it.

 This function validates that the integer is between [lower, upper],
 inclusive.

 @param stream Binary input stream
 @throws java.io.IOException
 @return deserialized integer from stream]]>
      </doc>
    </method>
    <method name="isNegativeVInt" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Given the first byte of a vint/vlong, determine the sign
 @param value the first byte
 @return is the value negative]]>
      </doc>
    </method>
    <method name="decodeVIntSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="byte"/>
      <doc>
      <![CDATA[Parse the first byte of a vint/vlong to determine the number of bytes
 @param value the first byte of the vint/vlong
 @return the total number of bytes (1 to 9)]]>
      </doc>
    </method>
    <method name="getVIntSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="long"/>
      <doc>
      <![CDATA[Get the encoded length if an integer is stored in a variable-length format
 @return the encoded length]]>
      </doc>
    </method>
    <method name="readEnum" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="enumType" type="java.lang.Class"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read an Enum value from DataInput, Enums are read and written 
 using String values. 
 @param <T> Enum type
 @param in DataInput to read from 
 @param enumType Class type of Enum
 @return Enum represented by String read from DataInput
 @throws IOException]]>
      </doc>
    </method>
    <method name="writeEnum"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="enumVal" type="java.lang.Enum"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[writes String value of enum to DataOutput. 
 @param out Dataoutput stream
 @param enumVal enum value
 @throws IOException]]>
      </doc>
    </method>
    <method name="skipFully"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Skip <i>len</i> number of bytes in input stream<i>in</i>
 @param in input stream
 @param len number of bytes to skip
 @throws IOException when skipped less number of bytes]]>
      </doc>
    </method>
    <method name="toByteArray" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writables" type="org.apache.hadoop.io.Writable[]"/>
      <doc>
      <![CDATA[Convert writables to a byte array]]>
      </doc>
    </method>
    <method name="readStringSafely" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <param name="maxLength" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Read a string, but check it for sanity. The format consists of a vint
 followed by the given number of bytes.
 @param in the stream to read from
 @param maxLength the largest acceptable length of the encoded string
 @return the bytes as a string
 @throws IOException if reading from the DataInput fails
 @throws IllegalArgumentException if the encoded byte size for string 
             is negative or larger than maxSize. Only the vint is read.]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.io.WritableUtils -->
  <doc>
  <![CDATA[Generic i/o code for use when reading and writing data to the network,
to databases, and to files.]]>
  </doc>
</package>
<package name="org.apache.hadoop.io.compress">
  <!-- start class org.apache.hadoop.io.compress.BlockCompressorStream -->
  <class name="BlockCompressorStream" extends="org.apache.hadoop.io.compress.CompressorStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlockCompressorStream" type="java.io.OutputStream, org.apache.hadoop.io.compress.Compressor, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a {@link BlockCompressorStream}.
 
 @param out stream
 @param compressor compressor to be used
 @param bufferSize size of buffer
 @param compressionOverhead maximum 'overhead' of the compression 
                            algorithm with given bufferSize]]>
      </doc>
    </constructor>
    <constructor name="BlockCompressorStream" type="java.io.OutputStream, org.apache.hadoop.io.compress.Compressor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a {@link BlockCompressorStream} with given output-stream and 
 compressor.
 Use default of 512 as bufferSize and compressionOverhead of 
 (1% of bufferSize + 12 bytes) =  18 bytes (zlib algorithm).
 
 @param out stream
 @param compressor compressor to be used]]>
      </doc>
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write the data provided to the compression codec, compressing no more
 than the buffer size less the compression overhead as specified during
 construction for each block.

 Each block contains the uncompressed length for the block, followed by
 one or more length-prefixed blocks of compressed data.]]>
      </doc>
    </method>
    <method name="finish"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="compress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A {@link org.apache.hadoop.io.compress.CompressorStream} which works
 with 'block-based' based compression algorithms, as opposed to 
 'stream-based' compression algorithms.

 It should be noted that this wrapper does not guarantee that blocks will
 be sized for the compressor. If the
 {@link org.apache.hadoop.io.compress.Compressor} requires buffering to
 effect meaningful compression, it is responsible for it.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.BlockCompressorStream -->
  <!-- start class org.apache.hadoop.io.compress.BlockDecompressorStream -->
  <class name="BlockDecompressorStream" extends="org.apache.hadoop.io.compress.DecompressorStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BlockDecompressorStream" type="java.io.InputStream, org.apache.hadoop.io.compress.Decompressor, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link BlockDecompressorStream}.
 
 @param in input stream
 @param decompressor decompressor to use
 @param bufferSize size of buffer
 @throws IOException]]>
      </doc>
    </constructor>
    <constructor name="BlockDecompressorStream" type="java.io.InputStream, org.apache.hadoop.io.compress.Decompressor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link BlockDecompressorStream}.
 
 @param in input stream
 @param decompressor decompressor to use
 @throws IOException]]>
      </doc>
    </constructor>
    <constructor name="BlockDecompressorStream" type="java.io.InputStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="decompress" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCompressedData" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="resetState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A {@link org.apache.hadoop.io.compress.DecompressorStream} which works
 with 'block-based' based compression algorithms, as opposed to 
 'stream-based' compression algorithms.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.BlockDecompressorStream -->
  <!-- start class org.apache.hadoop.io.compress.BZip2Codec -->
  <class name="BZip2Codec" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <implements name="org.apache.hadoop.io.compress.SplittableCompressionCodec"/>
    <constructor name="BZip2Codec"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of BZip2Codec.]]>
      </doc>
    </constructor>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Set the configuration to be used by this object.

 @param conf the configuration object.]]>
      </doc>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the configuration used by this object.

 @return the configuration object used by this objec.]]>
      </doc>
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionOutputStream} that will write to the given
 {@link OutputStream}.

 @param out        the location for the final output stream
 @return a stream the user can write uncompressed data to, to have it 
         compressed
 @throws IOException]]>
      </doc>
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="compressor" type="org.apache.hadoop.io.compress.Compressor"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionOutputStream} that will write to the given
 {@link OutputStream} with the given {@link Compressor}.

 @param out        the location for the final output stream
 @param compressor compressor to use
 @return a stream the user can write uncompressed data to, to have it 
         compressed
 @throws IOException]]>
      </doc>
    </method>
    <method name="getCompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of {@link Compressor} needed by this {@link CompressionCodec}.

 @return the type of compressor needed by this codec.]]>
      </doc>
    </method>
    <method name="createCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link Compressor} for use by this {@link CompressionCodec}.

 @return a new compressor for use by this codec]]>
      </doc>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionInputStream} that will read from the given
 input stream and return a stream for uncompressed data.

 @param in the stream to read compressed bytes from
 @return a stream to read uncompressed bytes from
 @throws IOException]]>
      </doc>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionInputStream} that will read from the given
 {@link InputStream} with the given {@link Decompressor}, and return a 
 stream for uncompressed data.

 @param in           the stream to read compressed bytes from
 @param decompressor decompressor to use
 @return a stream to read uncompressed bytes from
 @throws IOException]]>
      </doc>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.SplitCompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seekableIn" type="java.io.InputStream"/>
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <param name="start" type="long"/>
      <param name="end" type="long"/>
      <param name="readMode" type="org.apache.hadoop.io.compress.SplittableCompressionCodec.READ_MODE"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Creates CompressionInputStream to be used to read off uncompressed data
 in one of the two reading modes. i.e. Continuous or Blocked reading modes

 @param seekableIn The InputStream
 @param start The start offset into the compressed stream
 @param end The end offset into the compressed stream
 @param readMode Controls whether progress is reported continuously or
                 only at block boundaries.

 @return CompressionInputStream for BZip2 aligned at block boundaries]]>
      </doc>
    </method>
    <method name="getDecompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of {@link Decompressor} needed by this {@link CompressionCodec}.

 @return the type of decompressor needed by this codec.]]>
      </doc>
    </method>
    <method name="createDecompressor" return="org.apache.hadoop.io.compress.Decompressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link Decompressor} for use by this {@link CompressionCodec}.

 @return a new decompressor for use by this codec]]>
      </doc>
    </method>
    <method name="getDefaultExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[.bz2 is recognized as the default extension for compressed BZip2 files

 @return A String telling the default bzip2 file extension]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class provides output and input streams for bzip2 compression
 and decompression.  It uses the native bzip2 library on the system
 if possible, else it uses a pure-Java implementation of the bzip2
 algorithm.  The configuration parameter
 io.compression.codec.bzip2.library can be used to control this
 behavior.

 In the pure-Java mode, the Compressor and Decompressor interfaces
 are not implemented.  Therefore, in that mode, those methods of
 CompressionCodec which have a Compressor or Decompressor type
 argument, throw UnsupportedOperationException.

 Currently, support for splittability is available only in the
 pure-Java mode; therefore, if a SplitCompressionInputStream is
 requested, the pure-Java implementation is used, regardless of the
 setting of the configuration parameter mentioned above.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.BZip2Codec -->
  <!-- start class org.apache.hadoop.io.compress.CodecPool -->
  <class name="CodecPool" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CodecPool"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get a {@link Compressor} for the given {@link CompressionCodec} from the 
 pool or a new one.

 @param codec the <code>CompressionCodec</code> for which to get the 
              <code>Compressor</code>
 @param conf the <code>Configuration</code> object which contains confs for creating or reinit the compressor
 @return <code>Compressor</code> for the given 
         <code>CompressionCodec</code> from the pool or a new one]]>
      </doc>
    </method>
    <method name="getCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
    </method>
    <method name="getDecompressor" return="org.apache.hadoop.io.compress.Decompressor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <doc>
      <![CDATA[Get a {@link Decompressor} for the given {@link CompressionCodec} from the
 pool or a new one.
  
 @param codec the <code>CompressionCodec</code> for which to get the 
              <code>Decompressor</code>
 @return <code>Decompressor</code> for the given 
         <code>CompressionCodec</code> the pool or a new one]]>
      </doc>
    </method>
    <method name="returnCompressor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="compressor" type="org.apache.hadoop.io.compress.Compressor"/>
      <doc>
      <![CDATA[Return the {@link Compressor} to the pool.
 
 @param compressor the <code>Compressor</code> to be returned to the pool]]>
      </doc>
    </method>
    <method name="returnDecompressor"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <doc>
      <![CDATA[Return the {@link Decompressor} to the pool.
 
 @param decompressor the <code>Decompressor</code> to be returned to the 
                     pool]]>
      </doc>
    </method>
    <method name="getLeasedCompressorsCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <doc>
      <![CDATA[Return the number of leased {@link Compressor}s for this
 {@link CompressionCodec}]]>
      </doc>
    </method>
    <method name="getLeasedDecompressorsCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="codec" type="org.apache.hadoop.io.compress.CompressionCodec"/>
      <doc>
      <![CDATA[Return the number of leased {@link Decompressor}s for this
 {@link CompressionCodec}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A global compressor/decompressor pool used to save and reuse 
 (possibly native) compression/decompression codecs.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.CodecPool -->
  <!-- start interface org.apache.hadoop.io.compress.CompressionCodec -->
  <interface name="CompressionCodec"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionOutputStream} that will write to the given 
 {@link OutputStream}.
 
 @param out the location for the final output stream
 @return a stream the user can write uncompressed data to have it compressed
 @throws IOException]]>
      </doc>
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="compressor" type="org.apache.hadoop.io.compress.Compressor"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionOutputStream} that will write to the given 
 {@link OutputStream} with the given {@link Compressor}.
 
 @param out the location for the final output stream
 @param compressor compressor to use
 @return a stream the user can write uncompressed data to have it compressed
 @throws IOException]]>
      </doc>
    </method>
    <method name="getCompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of {@link Compressor} needed by this {@link CompressionCodec}.
 
 @return the type of compressor needed by this codec.]]>
      </doc>
    </method>
    <method name="createCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link Compressor} for use by this {@link CompressionCodec}.
 
 @return a new compressor for use by this codec]]>
      </doc>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionInputStream} that will read from the given
 input stream.
 
 @param in the stream to read compressed bytes from
 @return a stream to read uncompressed bytes from
 @throws IOException]]>
      </doc>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionInputStream} that will read from the given 
 {@link InputStream} with the given {@link Decompressor}.
 
 @param in the stream to read compressed bytes from
 @param decompressor decompressor to use
 @return a stream to read uncompressed bytes from
 @throws IOException]]>
      </doc>
    </method>
    <method name="getDecompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of {@link Decompressor} needed by this {@link CompressionCodec}.
 
 @return the type of decompressor needed by this codec.]]>
      </doc>
    </method>
    <method name="createDecompressor" return="org.apache.hadoop.io.compress.Decompressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link Decompressor} for use by this {@link CompressionCodec}.
 
 @return a new decompressor for use by this codec]]>
      </doc>
    </method>
    <method name="getDefaultExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the default filename extension for this kind of compression.
 @return the extension including the '.']]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class encapsulates a streaming compression/decompression pair.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.compress.CompressionCodec -->
  <!-- start class org.apache.hadoop.io.compress.CompressionCodec.Util -->
  <class name="CompressionCodec.Util" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CompressionCodec.Util"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.io.compress.CompressionCodec.Util -->
  <!-- start class org.apache.hadoop.io.compress.CompressionCodecFactory -->
  <class name="CompressionCodecFactory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CompressionCodecFactory" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Find the codecs specified in the config value io.compression.codecs 
 and register them. Defaults to gzip and deflate.]]>
      </doc>
    </constructor>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Print the extension map out as a string.]]>
      </doc>
    </method>
    <method name="getCodecClasses" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Get the list of codecs discovered via a Java ServiceLoader, or
 listed in the configuration. Codecs specified in configuration come
 later in the returned list, and are considered to override those
 from the ServiceLoader.
 @param conf the configuration to look in
 @return a list of the {@link CompressionCodec} classes]]>
      </doc>
    </method>
    <method name="setCodecClasses"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="classes" type="java.util.List"/>
      <doc>
      <![CDATA[Sets a list of codec classes in the configuration. In addition to any
 classes specified using this method, {@link CompressionCodec} classes on
 the classpath are discovered using a Java ServiceLoader.
 @param conf the configuration to modify
 @param classes the list of classes to set]]>
      </doc>
    </method>
    <method name="getCodec" return="org.apache.hadoop.io.compress.CompressionCodec"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Find the relevant compression codec for the given file based on its
 filename suffix.
 @param file the filename to check
 @return the codec object]]>
      </doc>
    </method>
    <method name="getCodecByClassName" return="org.apache.hadoop.io.compress.CompressionCodec"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classname" type="java.lang.String"/>
      <doc>
      <![CDATA[Find the relevant compression codec for the codec's canonical class name.
 @param classname the canonical class name of the codec
 @return the codec object]]>
      </doc>
    </method>
    <method name="getCodecByName" return="org.apache.hadoop.io.compress.CompressionCodec"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="codecName" type="java.lang.String"/>
      <doc>
      <![CDATA[Find the relevant compression codec for the codec's canonical class name
 or by codec alias.
 <p/>
 Codec aliases are case insensitive.
 <p/>
 The code alias is the short class name (without the package name).
 If the short class name ends with 'Codec', then there are two aliases for
 the codec, the complete short class name and the short class name without
 the 'Codec' ending. For example for the 'GzipCodec' codec class name the
 alias are 'gzip' and 'gzipcodec'.

 @param codecName the canonical class name of the codec
 @return the codec object]]>
      </doc>
    </method>
    <method name="getCodecClassByName" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="codecName" type="java.lang.String"/>
      <doc>
      <![CDATA[Find the relevant compression codec for the codec's canonical class name
 or by codec alias and returns its implemetation class.
 <p/>
 Codec aliases are case insensitive.
 <p/>
 The code alias is the short class name (without the package name).
 If the short class name ends with 'Codec', then there are two aliases for
 the codec, the complete short class name and the short class name without
 the 'Codec' ending. For example for the 'GzipCodec' codec class name the
 alias are 'gzip' and 'gzipcodec'.

 @param codecName the canonical class name of the codec
 @return the codec class]]>
      </doc>
    </method>
    <method name="removeSuffix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filename" type="java.lang.String"/>
      <param name="suffix" type="java.lang.String"/>
      <doc>
      <![CDATA[Removes a suffix from a filename, if it has it.
 @param filename the filename to strip
 @param suffix the suffix to remove
 @return the shortened filename]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[A little test program.
 @param args]]>
      </doc>
    </method>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A factory that will find the correct codec for a given filename.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.CompressionCodecFactory -->
  <!-- start class org.apache.hadoop.io.compress.CompressionInputStream -->
  <class name="CompressionInputStream" extends="java.io.InputStream"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.Seekable"/>
    <constructor name="CompressionInputStream" type="java.io.InputStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a compression input stream that reads
 the decompressed bytes from the given stream.
 
 @param in The input stream to be compressed.
 @throws IOException]]>
      </doc>
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read bytes from the stream.
 Made abstract to prevent leakage to underlying stream.]]>
      </doc>
    </method>
    <method name="resetState"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reset the decompressor to its initial state and discard any buffered data,
 as the underlying stream may have been repositioned.]]>
      </doc>
    </method>
    <method name="getPos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[This method returns the current position in the stream.

 @return Current position in stream as a long]]>
      </doc>
    </method>
    <method name="seek"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pos" type="long"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[This method is current not supported.

 @throws UnsupportedOperationException]]>
      </doc>
    </method>
    <method name="seekToNewSource" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="targetPos" type="long"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[This method is current not supported.

 @throws UnsupportedOperationException]]>
      </doc>
    </method>
    <field name="in" type="java.io.InputStream"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The input stream to be compressed.]]>
      </doc>
    </field>
    <field name="maxAvailableData" type="long"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A compression input stream.

 <p>Implementations are assumed to be buffered.  This permits clients to
 reposition the underlying input stream then call {@link #resetState()},
 without having to also synchronize client buffers.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.CompressionInputStream -->
  <!-- start class org.apache.hadoop.io.compress.CompressionOutputStream -->
  <class name="CompressionOutputStream" extends="java.io.OutputStream"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CompressionOutputStream" type="java.io.OutputStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a compression output stream that writes
 the compressed bytes to the given stream.
 @param out]]>
      </doc>
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write compressed bytes to the stream.
 Made abstract to prevent leakage to underlying stream.]]>
      </doc>
    </method>
    <method name="finish"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Finishes writing compressed data to the output stream 
 without closing the underlying stream.]]>
      </doc>
    </method>
    <method name="resetState"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reset the compression to the initial state. 
 Does not reset the underlying stream.]]>
      </doc>
    </method>
    <field name="out" type="java.io.OutputStream"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The output stream to be compressed.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A compression output stream.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.CompressionOutputStream -->
  <!-- start interface org.apache.hadoop.io.compress.Compressor -->
  <interface name="Compressor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setInput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Sets input data for compression. 
 This should be called whenever #needsInput() returns 
 <code>true</code> indicating that more input data is required.
 
 @param b Input data
 @param off Start offset
 @param len Length]]>
      </doc>
    </method>
    <method name="needsInput" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the input data buffer is empty and 
 #setInput() should be called to provide more input. 
 
 @return <code>true</code> if the input data buffer is empty and 
 #setInput() should be called in order to provide more input.]]>
      </doc>
    </method>
    <method name="setDictionary"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Sets preset dictionary for compression. A preset dictionary 
 is used when the history buffer can be predetermined. 

 @param b Dictionary data bytes
 @param off Start offset
 @param len Length]]>
      </doc>
    </method>
    <method name="getBytesRead" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return number of uncompressed bytes input so far.]]>
      </doc>
    </method>
    <method name="getBytesWritten" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return number of compressed bytes output so far.]]>
      </doc>
    </method>
    <method name="finish"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When called, indicates that compression should end
 with the current contents of the input buffer.]]>
      </doc>
    </method>
    <method name="finished" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the end of the compressed 
 data output stream has been reached.
 @return <code>true</code> if the end of the compressed
 data output stream has been reached.]]>
      </doc>
    </method>
    <method name="compress" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fills specified buffer with compressed data. Returns actual number
 of bytes of compressed data. A return value of 0 indicates that
 needsInput() should be called in order to determine if more input
 data is required.
 
 @param b Buffer for the compressed data
 @param off Start offset of the data
 @param len Size of the buffer
 @return The actual number of bytes of compressed data.]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resets compressor so that a new set of input data can be processed.]]>
      </doc>
    </method>
    <method name="end"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Closes the compressor and discards any unprocessed input.]]>
      </doc>
    </method>
    <method name="reinit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Prepare the compressor to be used in a new stream with settings defined in
 the given Configuration
 
 @param conf Configuration from which new setting are fetched]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Specification of a stream-based 'compressor' which can be  
 plugged into a {@link CompressionOutputStream} to compress data.
 This is modelled after {@link java.util.zip.Deflater}]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.compress.Compressor -->
  <!-- start class org.apache.hadoop.io.compress.CompressorStream -->
  <class name="CompressorStream" extends="org.apache.hadoop.io.compress.CompressionOutputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CompressorStream" type="java.io.OutputStream, org.apache.hadoop.io.compress.Compressor, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CompressorStream" type="java.io.OutputStream, org.apache.hadoop.io.compress.Compressor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="CompressorStream" type="java.io.OutputStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Allow derived classes to directly set the underlying stream.
 
 @param out Underlying output stream.]]>
      </doc>
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="compress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="finish"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="resetState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="compressor" type="org.apache.hadoop.io.compress.Compressor"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="buffer" type="byte[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="closed" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.io.compress.CompressorStream -->
  <!-- start interface org.apache.hadoop.io.compress.Decompressor -->
  <interface name="Decompressor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setInput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Sets input data for decompression. 
 This should be called if and only if {@link #needsInput()} returns 
 <code>true</code> indicating that more input data is required.
 (Both native and non-native versions of various Decompressors require
 that the data passed in via <code>b[]</code> remain unmodified until
 the caller is explicitly notified--via {@link #needsInput()}--that the
 buffer may be safely modified.  With this requirement, an extra
 buffer-copy can be avoided.)
 
 @param b Input data
 @param off Start offset
 @param len Length]]>
      </doc>
    </method>
    <method name="needsInput" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if the input data buffer is empty and 
 {@link #setInput(byte[], int, int)} should be called to
 provide more input. 
 
 @return <code>true</code> if the input data buffer is empty and 
 {@link #setInput(byte[], int, int)} should be called in
 order to provide more input.]]>
      </doc>
    </method>
    <method name="setDictionary"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <doc>
      <![CDATA[Sets preset dictionary for compression. A preset dictionary
 is used when the history buffer can be predetermined. 

 @param b Dictionary data bytes
 @param off Start offset
 @param len Length]]>
      </doc>
    </method>
    <method name="needsDictionary" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if a preset dictionary is needed for decompression.
 @return <code>true</code> if a preset dictionary is needed for decompression]]>
      </doc>
    </method>
    <method name="finished" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns <code>true</code> if the end of the decompressed 
 data output stream has been reached. Indicates a concatenated data stream
 when finished() returns <code>true</code> and {@link #getRemaining()}
 returns a positive value. finished() will be reset with the
 {@link #reset()} method.
 @return <code>true</code> if the end of the decompressed
 data output stream has been reached.]]>
      </doc>
    </method>
    <method name="decompress" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fills specified buffer with uncompressed data. Returns actual number
 of bytes of uncompressed data. A return value of 0 indicates that
 {@link #needsInput()} should be called in order to determine if more
 input data is required.
 
 @param b Buffer for the compressed data
 @param off Start offset of the data
 @param len Size of the buffer
 @return The actual number of bytes of compressed data.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getRemaining" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the number of bytes remaining in the compressed data buffer.
 Indicates a concatenated data stream if {@link #finished()} returns
 <code>true</code> and getRemaining() returns a positive value. If
 {@link #finished()} returns <code>true</code> and getRemaining() returns
 a zero value, indicates that the end of data stream has been reached and
 is not a concatenated data stream. 
 @return The number of bytes remaining in the compressed data buffer.]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Resets decompressor and input and output buffers so that a new set of
 input data can be processed. If {@link #finished()}} returns
 <code>true</code> and {@link #getRemaining()} returns a positive value,
 reset() is called before processing of the next data stream in the
 concatenated data stream. {@link #finished()} will be reset and will
 return <code>false</code> when reset() is called.]]>
      </doc>
    </method>
    <method name="end"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Closes the decompressor and discards any unprocessed input.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Specification of a stream-based 'de-compressor' which can be  
 plugged into a {@link CompressionInputStream} to compress data.
 This is modelled after {@link java.util.zip.Inflater}]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.compress.Decompressor -->
  <!-- start class org.apache.hadoop.io.compress.DecompressorStream -->
  <class name="DecompressorStream" extends="org.apache.hadoop.io.compress.CompressionInputStream"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DecompressorStream" type="java.io.InputStream, org.apache.hadoop.io.compress.Decompressor, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="DecompressorStream" type="java.io.InputStream, org.apache.hadoop.io.compress.Decompressor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="DecompressorStream" type="java.io.InputStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Allow derived classes to directly set the underlying stream.
 
 @param in Underlying input stream.
 @throws IOException]]>
      </doc>
    </constructor>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="decompress" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCompressedData" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="checkStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="resetState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="available" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="markSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readlimit" type="int"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="buffer" type="byte[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="eof" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="closed" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.io.compress.DecompressorStream -->
  <!-- start class org.apache.hadoop.io.compress.DefaultCodec -->
  <class name="DefaultCodec" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <implements name="org.apache.hadoop.io.compress.CompressionCodec"/>
    <implements name="org.apache.hadoop.io.compress.DirectDecompressionCodec"/>
    <constructor name="DefaultCodec"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="compressor" type="org.apache.hadoop.io.compress.Compressor"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getCompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getDecompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createDecompressor" return="org.apache.hadoop.io.compress.Decompressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createDirectDecompressor" return="org.apache.hadoop.io.compress.DirectDecompressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="getDefaultExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.io.compress.DefaultCodec -->
  <!-- start class org.apache.hadoop.io.compress.DeflateCodec -->
  <class name="DeflateCodec" extends="org.apache.hadoop.io.compress.DefaultCodec"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DeflateCodec"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Alias class for DefaultCodec to enable codec discovery by 'deflate' name.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.DeflateCodec -->
  <!-- start interface org.apache.hadoop.io.compress.DirectDecompressionCodec -->
  <interface name="DirectDecompressionCodec"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.compress.CompressionCodec"/>
    <method name="createDirectDecompressor" return="org.apache.hadoop.io.compress.DirectDecompressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link DirectDecompressor} for use by this {@link DirectDecompressionCodec}.
 
 @return a new direct decompressor for use by this codec]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class encapsulates a codec which can decompress direct bytebuffers.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.compress.DirectDecompressionCodec -->
  <!-- start interface org.apache.hadoop.io.compress.DirectDecompressor -->
  <interface name="DirectDecompressor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="decompress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="java.nio.ByteBuffer"/>
      <param name="dst" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Specification of a direct ByteBuffer 'de-compressor'.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.compress.DirectDecompressor -->
  <!-- start class org.apache.hadoop.io.compress.DoNotPool -->
  <class name="DoNotPool"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[This is a marker annotation that marks a compressor or decompressor 
 type as not to be pooled.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.DoNotPool -->
  <!-- start class org.apache.hadoop.io.compress.GzipCodec -->
  <class name="GzipCodec" extends="org.apache.hadoop.io.compress.DefaultCodec"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GzipCodec"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="compressor" type="org.apache.hadoop.io.compress.Compressor"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createDecompressor" return="org.apache.hadoop.io.compress.Decompressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDecompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createDirectDecompressor" return="org.apache.hadoop.io.compress.DirectDecompressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDefaultExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This class creates gzip compressors/decompressors.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.GzipCodec -->
  <!-- start class org.apache.hadoop.io.compress.GzipCodec.GzipOutputStream -->
  <class name="GzipCodec.GzipOutputStream" extends="org.apache.hadoop.io.compress.CompressorStream"
    abstract="false"
    static="true" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="GzipCodec.GzipOutputStream" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="GzipCodec.GzipOutputStream" type="org.apache.hadoop.io.compress.CompressorStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Allow children types to put a different type in here.
 @param out the Deflater stream to use]]>
      </doc>
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="data" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="finish"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="resetState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A bridge that wraps around a DeflaterOutputStream to make it 
 a CompressionOutputStream.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.GzipCodec.GzipOutputStream -->
  <!-- start class org.apache.hadoop.io.compress.Lz4Codec -->
  <class name="Lz4Codec" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <implements name="org.apache.hadoop.io.compress.CompressionCodec"/>
    <constructor name="Lz4Codec"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Set the configuration to be used by this object.

 @param conf the configuration object.]]>
      </doc>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the configuration used by this object.

 @return the configuration object used by this objec.]]>
      </doc>
    </method>
    <method name="isNativeCodeLoaded" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Are the native lz4 libraries loaded & initialized?

 @return true if loaded & initialized, otherwise false]]>
      </doc>
    </method>
    <method name="getLibraryName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionOutputStream} that will write to the given
 {@link OutputStream}.

 @param out the location for the final output stream
 @return a stream the user can write uncompressed data to have it compressed
 @throws IOException]]>
      </doc>
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="compressor" type="org.apache.hadoop.io.compress.Compressor"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionOutputStream} that will write to the given
 {@link OutputStream} with the given {@link Compressor}.

 @param out        the location for the final output stream
 @param compressor compressor to use
 @return a stream the user can write uncompressed data to have it compressed
 @throws IOException]]>
      </doc>
    </method>
    <method name="getCompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of {@link Compressor} needed by this {@link CompressionCodec}.

 @return the type of compressor needed by this codec.]]>
      </doc>
    </method>
    <method name="createCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link Compressor} for use by this {@link CompressionCodec}.

 @return a new compressor for use by this codec]]>
      </doc>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionInputStream} that will read from the given
 input stream.

 @param in the stream to read compressed bytes from
 @return a stream to read uncompressed bytes from
 @throws IOException]]>
      </doc>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionInputStream} that will read from the given
 {@link InputStream} with the given {@link Decompressor}.

 @param in           the stream to read compressed bytes from
 @param decompressor decompressor to use
 @return a stream to read uncompressed bytes from
 @throws IOException]]>
      </doc>
    </method>
    <method name="getDecompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of {@link Decompressor} needed by this {@link CompressionCodec}.

 @return the type of decompressor needed by this codec.]]>
      </doc>
    </method>
    <method name="createDecompressor" return="org.apache.hadoop.io.compress.Decompressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link Decompressor} for use by this {@link CompressionCodec}.

 @return a new decompressor for use by this codec]]>
      </doc>
    </method>
    <method name="getDefaultExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the default filename extension for this kind of compression.

 @return <code>.lz4</code>.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class creates lz4 compressors/decompressors.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.Lz4Codec -->
  <!-- start class org.apache.hadoop.io.compress.SnappyCodec -->
  <class name="SnappyCodec" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <implements name="org.apache.hadoop.io.compress.CompressionCodec"/>
    <implements name="org.apache.hadoop.io.compress.DirectDecompressionCodec"/>
    <constructor name="SnappyCodec"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Set the configuration to be used by this object.

 @param conf the configuration object.]]>
      </doc>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the configuration used by this object.

 @return the configuration object used by this objec.]]>
      </doc>
    </method>
    <method name="checkNativeCodeLoaded"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Are the native snappy libraries loaded & initialized?]]>
      </doc>
    </method>
    <method name="isNativeCodeLoaded" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLibraryName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionOutputStream} that will write to the given
 {@link OutputStream}.

 @param out the location for the final output stream
 @return a stream the user can write uncompressed data to have it compressed
 @throws IOException]]>
      </doc>
    </method>
    <method name="createOutputStream" return="org.apache.hadoop.io.compress.CompressionOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <param name="compressor" type="org.apache.hadoop.io.compress.Compressor"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionOutputStream} that will write to the given
 {@link OutputStream} with the given {@link Compressor}.

 @param out        the location for the final output stream
 @param compressor compressor to use
 @return a stream the user can write uncompressed data to have it compressed
 @throws IOException]]>
      </doc>
    </method>
    <method name="getCompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of {@link Compressor} needed by this {@link CompressionCodec}.

 @return the type of compressor needed by this codec.]]>
      </doc>
    </method>
    <method name="createCompressor" return="org.apache.hadoop.io.compress.Compressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link Compressor} for use by this {@link CompressionCodec}.

 @return a new compressor for use by this codec]]>
      </doc>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionInputStream} that will read from the given
 input stream.

 @param in the stream to read compressed bytes from
 @return a stream to read uncompressed bytes from
 @throws IOException]]>
      </doc>
    </method>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.CompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a {@link CompressionInputStream} that will read from the given
 {@link InputStream} with the given {@link Decompressor}.

 @param in           the stream to read compressed bytes from
 @param decompressor decompressor to use
 @return a stream to read uncompressed bytes from
 @throws IOException]]>
      </doc>
    </method>
    <method name="getDecompressorType" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of {@link Decompressor} needed by this {@link CompressionCodec}.

 @return the type of decompressor needed by this codec.]]>
      </doc>
    </method>
    <method name="createDecompressor" return="org.apache.hadoop.io.compress.Decompressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new {@link Decompressor} for use by this {@link CompressionCodec}.

 @return a new decompressor for use by this codec]]>
      </doc>
    </method>
    <method name="createDirectDecompressor" return="org.apache.hadoop.io.compress.DirectDecompressor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="getDefaultExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the default filename extension for this kind of compression.

 @return <code>.snappy</code>.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class creates snappy compressors/decompressors.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.SnappyCodec -->
  <!-- start class org.apache.hadoop.io.compress.SplitCompressionInputStream -->
  <class name="SplitCompressionInputStream" extends="org.apache.hadoop.io.compress.CompressionInputStream"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SplitCompressionInputStream" type="java.io.InputStream, long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="setStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="start" type="long"/>
    </method>
    <method name="setEnd"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="end" type="long"/>
    </method>
    <method name="getAdjustedStart" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[After calling createInputStream, the values of start or end
 might change.  So this method can be used to get the new value of start.
 @return The changed value of start]]>
      </doc>
    </method>
    <method name="getAdjustedEnd" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[After calling createInputStream, the values of start or end
 might change.  So this method can be used to get the new value of end.
 @return The changed value of end]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An InputStream covering a range of compressed data. The start and end
 offsets requested by a client may be modified by the codec to fit block
 boundaries or other algorithm-dependent requirements.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.SplitCompressionInputStream -->
  <!-- start interface org.apache.hadoop.io.compress.SplittableCompressionCodec -->
  <interface name="SplittableCompressionCodec"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.compress.CompressionCodec"/>
    <method name="createInputStream" return="org.apache.hadoop.io.compress.SplitCompressionInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seekableIn" type="java.io.InputStream"/>
      <param name="decompressor" type="org.apache.hadoop.io.compress.Decompressor"/>
      <param name="start" type="long"/>
      <param name="end" type="long"/>
      <param name="readMode" type="org.apache.hadoop.io.compress.SplittableCompressionCodec.READ_MODE"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a stream as dictated by the readMode.  This method is used when
 the codecs wants the ability to work with the underlying stream positions.

 @param seekableIn  The seekable input stream (seeks in compressed data)
 @param start The start offset into the compressed stream. May be changed
              by the underlying codec.
 @param end The end offset into the compressed stream. May be changed by
            the underlying codec.
 @param readMode Controls whether stream position is reported continuously
                 from the compressed stream only only at block boundaries.
 @return  a stream to read uncompressed bytes from]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This interface is meant to be implemented by those compression codecs
 which are capable to compress / de-compress a stream starting at any
 arbitrary position.

 Especially the process of de-compressing a stream starting at some arbitrary
 position is challenging.  Most of the codecs are only able to successfully
 de-compress a stream, if they start from the very beginning till the end.
 One of the reasons is the stored state at the beginning of the stream which
 is crucial for de-compression.

 Yet there are few codecs which do not save the whole state at the beginning
 of the stream and hence can be used to de-compress stream starting at any
 arbitrary points.  This interface is meant to be used by such codecs.  Such
 codecs are highly valuable, especially in the context of Hadoop, because
 an input compressed file can be split and hence can be worked on by multiple
 machines in parallel.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.compress.SplittableCompressionCodec -->
  <!-- start class org.apache.hadoop.io.compress.SplittableCompressionCodec.READ_MODE -->
  <class name="SplittableCompressionCodec.READ_MODE" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.io.compress.SplittableCompressionCodec.READ_MODE[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.io.compress.SplittableCompressionCodec.READ_MODE"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[During decompression, data can be read off from the decompressor in two
 modes, namely continuous and blocked.  Few codecs (e.g. BZip2) are capable
 of compressing data in blocks and then decompressing the blocks.  In
 Blocked reading mode codecs inform 'end of block' events to its caller.
 While in continuous mode, the caller of codecs is unaware about the blocks
 and uncompressed data is spilled out like a continuous stream.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.compress.SplittableCompressionCodec.READ_MODE -->
</package>
<package name="org.apache.hadoop.io.file.tfile">
  <!-- start class org.apache.hadoop.io.file.tfile.MetaBlockAlreadyExists -->
  <class name="MetaBlockAlreadyExists" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Exception - Meta Block with the same name already exists.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.file.tfile.MetaBlockAlreadyExists -->
  <!-- start class org.apache.hadoop.io.file.tfile.MetaBlockDoesNotExist -->
  <class name="MetaBlockDoesNotExist" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Exception - No such Meta Block with the given name.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.file.tfile.MetaBlockDoesNotExist -->
  <!-- start interface org.apache.hadoop.io.file.tfile.RawComparable -->
  <interface name="RawComparable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="buffer" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the underlying byte array.
 
 @return The underlying byte array.]]>
      </doc>
    </method>
    <method name="offset" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the offset of the first byte in the byte array.
 
 @return The offset of the first byte in the byte array.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the size of the byte range in the byte array.
 
 @return The size of the byte range in the byte array.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface for objects that can be compared through {@link RawComparator}.
 This is useful in places where we need a single object reference to specify a
 range of bytes in a byte array, such as {@link Comparable} or
 {@link Collections#binarySearch(java.util.List, Object, Comparator)}
 
 The actual comparison among RawComparable's requires an external
 RawComparator and it is applications' responsibility to ensure two
 RawComparable are supposed to be semantically comparable with the same
 RawComparator.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.file.tfile.RawComparable -->
  <!-- start class org.apache.hadoop.io.file.tfile.TFile -->
  <class name="TFile" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="makeComparator" return="java.util.Comparator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Make a raw comparator from a string name.
 
 @param name
          Comparator name
 @return A RawComparable comparator.]]>
      </doc>
    </method>
    <method name="getSupportedCompressionAlgorithms" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get names of supported compression algorithms. The names are acceptable by
 TFile.Writer.
 
 @return Array of strings, each represents a supported compression
         algorithm. Currently, the following compression algorithms are
         supported.
         <ul>
         <li>"none" - No compression.
         <li>"lzo" - LZO compression.
         <li>"gz" - GZIP compression.
         </ul>]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Dumping the TFile information.
 
 @param args
          A list of TFile paths.]]>
      </doc>
    </method>
    <field name="COMPRESSION_GZ" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[compression: gzip]]>
      </doc>
    </field>
    <field name="COMPRESSION_LZO" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[compression: lzo]]>
      </doc>
    </field>
    <field name="COMPRESSION_NONE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[compression: none]]>
      </doc>
    </field>
    <field name="COMPARATOR_MEMCMP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[comparator: memcmp]]>
      </doc>
    </field>
    <field name="COMPARATOR_JCLASS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[comparator prefix: java class]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A TFile is a container of key-value pairs. Both keys and values are type-less
 bytes. Keys are restricted to 64KB, value length is not restricted
 (practically limited to the available disk storage). TFile further provides
 the following features:
 <ul>
 <li>Block Compression.
 <li>Named meta data blocks.
 <li>Sorted or unsorted keys.
 <li>Seek by key or by file offset.
 </ul>
 The memory footprint of a TFile includes the following:
 <ul>
 <li>Some constant overhead of reading or writing a compressed block.
 <ul>
 <li>Each compressed block requires one compression/decompression codec for
 I/O.
 <li>Temporary space to buffer the key.
 <li>Temporary space to buffer the value (for TFile.Writer only). Values are
 chunk encoded, so that we buffer at most one chunk of user data. By default,
 the chunk buffer is 1MB. Reading chunked value does not require additional
 memory.
 </ul>
 <li>TFile index, which is proportional to the total number of Data Blocks.
 The total amount of memory needed to hold the index can be estimated as
 (56+AvgKeySize)*NumBlocks.
 <li>MetaBlock index, which is proportional to the total number of Meta
 Blocks.The total amount of memory needed to hold the index for Meta Blocks
 can be estimated as (40+AvgMetaBlockName)*NumMetaBlock.
 </ul>
 <p>
 The behavior of TFile can be customized by the following variables through
 Configuration:
 <ul>
 <li><b>tfile.io.chunk.size</b>: Value chunk size. Integer (in bytes). Default
 to 1MB. Values of the length less than the chunk size is guaranteed to have
 known value length in read time (See
 {@link TFile.Reader.Scanner.Entry#isValueLengthKnown()}).
 <li><b>tfile.fs.output.buffer.size</b>: Buffer size used for
 FSDataOutputStream. Integer (in bytes). Default to 256KB.
 <li><b>tfile.fs.input.buffer.size</b>: Buffer size used for
 FSDataInputStream. Integer (in bytes). Default to 256KB.
 </ul>
 <p>
 Suggestions on performance optimization.
 <ul>
 <li>Minimum block size. We recommend a setting of minimum block size between
 256KB to 1MB for general usage. Larger block size is preferred if files are
 primarily for sequential access. However, it would lead to inefficient random
 access (because there are more data to decompress). Smaller blocks are good
 for random access, but require more memory to hold the block index, and may
 be slower to create (because we must flush the compressor stream at the
 conclusion of each data block, which leads to an FS I/O flush). Further, due
 to the internal caching in Compression codec, the smallest possible block
 size would be around 20KB-30KB.
 <li>The current implementation does not offer true multi-threading for
 reading. The implementation uses FSDataInputStream seek()+read(), which is
 shown to be much faster than positioned-read call in single thread mode.
 However, it also means that if multiple threads attempt to access the same
 TFile (using multiple scanners) simultaneously, the actual I/O is carried out
 sequentially even if they access different DFS blocks.
 <li>Compression codec. Use "none" if the data is not very compressable (by
 compressable, I mean a compression ratio at least 2:1). Generally, use "lzo"
 as the starting point for experimenting. "gz" overs slightly better
 compression ratio over "lzo" but requires 4x CPU to compress and 2x CPU to
 decompress, comparing to "lzo".
 <li>File system buffering, if the underlying FSDataInputStream and
 FSDataOutputStream is already adequately buffered; or if applications
 reads/writes keys and values in large buffers, we can reduce the sizes of
 input/output buffering in TFile layer by setting the configuration parameters
 "tfile.fs.input.buffer.size" and "tfile.fs.output.buffer.size".
 </ul>
 
 Some design rationale behind TFile can be found at <a
 href=https://issues.apache.org/jira/browse/HADOOP-3315>Hadoop-3315</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.file.tfile.TFile -->
  <!-- start class org.apache.hadoop.io.file.tfile.TFile.Reader -->
  <class name="TFile.Reader" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="TFile.Reader" type="org.apache.hadoop.fs.FSDataInputStream, long, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Constructor
 
 @param fsdis
          FS input stream of the TFile.
 @param fileLength
          The length of TFile. This is required because we have no easy
          way of knowing the actual size of the input file through the
          File input stream.
 @param conf
 @throws IOException]]>
      </doc>
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close the reader. The state of the Reader object is undefined after
 close. Calling close() for multiple times has no effect.]]>
      </doc>
    </method>
    <method name="getComparatorName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the string representation of the comparator.
 
 @return If the TFile is not sorted by keys, an empty string will be
         returned. Otherwise, the actual comparator string that is
         provided during the TFile creation time will be returned.]]>
      </doc>
    </method>
    <method name="isSorted" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Is the TFile sorted?
 
 @return true if TFile is sorted.]]>
      </doc>
    </method>
    <method name="getEntryCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the number of key-value pair entries in TFile.
 
 @return the number of key-value pairs in TFile]]>
      </doc>
    </method>
    <method name="getFirstKey" return="org.apache.hadoop.io.file.tfile.RawComparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the first key in the TFile.
 
 @return The first key in the TFile.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getLastKey" return="org.apache.hadoop.io.file.tfile.RawComparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the last key in the TFile.
 
 @return The last key in the TFile.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getEntryComparator" return="java.util.Comparator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a Comparator object to compare Entries. It is useful when you want
 stores the entries in a collection (such as PriorityQueue) and perform
 sorting or comparison among entries based on the keys without copying out
 the key.
 
 @return An Entry Comparator..]]>
      </doc>
    </method>
    <method name="getComparator" return="java.util.Comparator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an instance of the RawComparator that is constructed based on the
 string comparator representation.
 
 @return a Comparator that can compare RawComparable's.]]>
      </doc>
    </method>
    <method name="getMetaBlock" return="java.io.DataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="MetaBlockDoesNotExist" type="org.apache.hadoop.io.file.tfile.MetaBlockDoesNotExist"/>
      <doc>
      <![CDATA[Stream access to a meta block.``
 
 @param name
          The name of the meta block.
 @return The input stream.
 @throws IOException
           on I/O error.
 @throws MetaBlockDoesNotExist
           If the meta block with the name does not exist.]]>
      </doc>
    </method>
    <method name="getRecordNumNear" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="offset" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the RecordNum for the first key-value pair in a compressed block
 whose byte offset in the TFile is greater than or equal to the specified
 offset.
 
 @param offset
          the user supplied offset.
 @return the RecordNum to the corresponding entry. If no such entry
         exists, it returns the total entry count.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getKeyNear" return="org.apache.hadoop.io.file.tfile.RawComparable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="offset" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a sample key that is within a block whose starting offset is greater
 than or equal to the specified offset.
 
 @param offset
          The file offset.
 @return the key that fits the requirement; or null if no such key exists
         (which could happen if the offset is close to the end of the
         TFile).
 @throws IOException]]>
      </doc>
    </method>
    <method name="createScanner" return="org.apache.hadoop.io.file.tfile.TFile.Reader.Scanner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a scanner than can scan the whole TFile.
 
 @return The scanner object. A valid Scanner is always returned even if
         the TFile is empty.
 @throws IOException]]>
      </doc>
    </method>
    <method name="createScannerByByteRange" return="org.apache.hadoop.io.file.tfile.TFile.Reader.Scanner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="offset" type="long"/>
      <param name="length" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a scanner that covers a portion of TFile based on byte offsets.
 
 @param offset
          The beginning byte offset in the TFile.
 @param length
          The length of the region.
 @return The actual coverage of the returned scanner tries to match the
         specified byte-region but always round up to the compression
         block boundaries. It is possible that the returned scanner
         contains zero key-value pairs even if length is positive.
 @throws IOException]]>
      </doc>
    </method>
    <method name="createScanner" return="org.apache.hadoop.io.file.tfile.TFile.Reader.Scanner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #createScannerByKey(byte[], byte[])} instead.">
      <param name="beginKey" type="byte[]"/>
      <param name="endKey" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a scanner that covers a portion of TFile based on keys.
 
 @param beginKey
          Begin key of the scan (inclusive). If null, scan from the first
          key-value entry of the TFile.
 @param endKey
          End key of the scan (exclusive). If null, scan up to the last
          key-value entry of the TFile.
 @return The actual coverage of the returned scanner will cover all keys
         greater than or equal to the beginKey and less than the endKey.
 @throws IOException
 
 @deprecated Use {@link #createScannerByKey(byte[], byte[])} instead.]]>
      </doc>
    </method>
    <method name="createScannerByKey" return="org.apache.hadoop.io.file.tfile.TFile.Reader.Scanner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="beginKey" type="byte[]"/>
      <param name="endKey" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a scanner that covers a portion of TFile based on keys.
 
 @param beginKey
          Begin key of the scan (inclusive). If null, scan from the first
          key-value entry of the TFile.
 @param endKey
          End key of the scan (exclusive). If null, scan up to the last
          key-value entry of the TFile.
 @return The actual coverage of the returned scanner will cover all keys
         greater than or equal to the beginKey and less than the endKey.
 @throws IOException]]>
      </doc>
    </method>
    <method name="createScanner" return="org.apache.hadoop.io.file.tfile.TFile.Reader.Scanner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use {@link #createScannerByKey(RawComparable, RawComparable)}
             instead.">
      <param name="beginKey" type="org.apache.hadoop.io.file.tfile.RawComparable"/>
      <param name="endKey" type="org.apache.hadoop.io.file.tfile.RawComparable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a scanner that covers a specific key range.
 
 @param beginKey
          Begin key of the scan (inclusive). If null, scan from the first
          key-value entry of the TFile.
 @param endKey
          End key of the scan (exclusive). If null, scan up to the last
          key-value entry of the TFile.
 @return The actual coverage of the returned scanner will cover all keys
         greater than or equal to the beginKey and less than the endKey.
 @throws IOException
 
 @deprecated Use {@link #createScannerByKey(RawComparable, RawComparable)}
             instead.]]>
      </doc>
    </method>
    <method name="createScannerByKey" return="org.apache.hadoop.io.file.tfile.TFile.Reader.Scanner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="beginKey" type="org.apache.hadoop.io.file.tfile.RawComparable"/>
      <param name="endKey" type="org.apache.hadoop.io.file.tfile.RawComparable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a scanner that covers a specific key range.
 
 @param beginKey
          Begin key of the scan (inclusive). If null, scan from the first
          key-value entry of the TFile.
 @param endKey
          End key of the scan (exclusive). If null, scan up to the last
          key-value entry of the TFile.
 @return The actual coverage of the returned scanner will cover all keys
         greater than or equal to the beginKey and less than the endKey.
 @throws IOException]]>
      </doc>
    </method>
    <method name="createScannerByRecordNum" return="org.apache.hadoop.io.file.tfile.TFile.Reader.Scanner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="beginRecNum" type="long"/>
      <param name="endRecNum" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a scanner that covers a range of records.
 
 @param beginRecNum
          The RecordNum for the first record (inclusive).
 @param endRecNum
          The RecordNum for the last record (exclusive). To scan the whole
          file, either specify endRecNum==-1 or endRecNum==getEntryCount().
 @return The TFile scanner that covers the specified range of records.
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[TFile Reader. Users may only read TFiles by creating TFile.Reader.Scanner.
 objects. A scanner may scan the whole TFile ({@link Reader#createScanner()}
 ) , a portion of TFile based on byte offsets (
 {@link Reader#createScannerByByteRange(long, long)}), or a portion of TFile with keys
 fall in a certain key range (for sorted TFile only,
 {@link Reader#createScannerByKey(byte[], byte[])} or
 {@link Reader#createScannerByKey(RawComparable, RawComparable)}).]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.file.tfile.TFile.Reader -->
  <!-- start class org.apache.hadoop.io.file.tfile.TFile.Reader.Scanner -->
  <class name="TFile.Reader.Scanner" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="TFile.Reader.Scanner" type="org.apache.hadoop.io.file.tfile.TFile.Reader, long, long"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Constructor
 
 @param reader
          The TFile reader object.
 @param offBegin
          Begin byte-offset of the scan.
 @param offEnd
          End byte-offset of the scan.
 @throws IOException
 
           The offsets will be rounded to the beginning of a compressed
           block whose offset is greater than or equal to the specified
           offset.]]>
      </doc>
    </constructor>
    <constructor name="TFile.Reader.Scanner" type="org.apache.hadoop.io.file.tfile.TFile.Reader, org.apache.hadoop.io.file.tfile.RawComparable, org.apache.hadoop.io.file.tfile.RawComparable"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Constructor
 
 @param reader
          The TFile reader object.
 @param beginKey
          Begin key of the scan. If null, scan from the first <K,V>
          entry of the TFile.
 @param endKey
          End key of the scan. If null, scan up to the last <K, V> entry
          of the TFile.
 @throws IOException]]>
      </doc>
    </constructor>
    <method name="seekTo" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Move the cursor to the first entry whose key is greater than or equal
 to the input key. Synonymous to seekTo(key, 0, key.length). The entry
 returned by the previous entry() call will be invalid.
 
 @param key
          The input key
 @return true if we find an equal key.
 @throws IOException]]>
      </doc>
    </method>
    <method name="seekTo" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="byte[]"/>
      <param name="keyOffset" type="int"/>
      <param name="keyLen" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Move the cursor to the first entry whose key is greater than or equal
 to the input key. The entry returned by the previous entry() call will
 be invalid.
 
 @param key
          The input key
 @param keyOffset
          offset in the key buffer.
 @param keyLen
          key buffer length.
 @return true if we find an equal key; false otherwise.
 @throws IOException]]>
      </doc>
    </method>
    <method name="rewind"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Rewind to the first entry in the scanner. The entry returned by the
 previous entry() call will be invalid.
 
 @throws IOException]]>
      </doc>
    </method>
    <method name="seekToEnd"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Seek to the end of the scanner. The entry returned by the previous
 entry() call will be invalid.
 
 @throws IOException]]>
      </doc>
    </method>
    <method name="lowerBound"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Move the cursor to the first entry whose key is greater than or equal
 to the input key. Synonymous to lowerBound(key, 0, key.length). The
 entry returned by the previous entry() call will be invalid.
 
 @param key
          The input key
 @throws IOException]]>
      </doc>
    </method>
    <method name="lowerBound"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="byte[]"/>
      <param name="keyOffset" type="int"/>
      <param name="keyLen" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Move the cursor to the first entry whose key is greater than or equal
 to the input key. The entry returned by the previous entry() call will
 be invalid.
 
 @param key
          The input key
 @param keyOffset
          offset in the key buffer.
 @param keyLen
          key buffer length.
 @throws IOException]]>
      </doc>
    </method>
    <method name="upperBound"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Move the cursor to the first entry whose key is strictly greater than
 the input key. Synonymous to upperBound(key, 0, key.length). The entry
 returned by the previous entry() call will be invalid.
 
 @param key
          The input key
 @throws IOException]]>
      </doc>
    </method>
    <method name="upperBound"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="byte[]"/>
      <param name="keyOffset" type="int"/>
      <param name="keyLen" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Move the cursor to the first entry whose key is strictly greater than
 the input key. The entry returned by the previous entry() call will be
 invalid.
 
 @param key
          The input key
 @param keyOffset
          offset in the key buffer.
 @param keyLen
          key buffer length.
 @throws IOException]]>
      </doc>
    </method>
    <method name="advance" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Move the cursor to the next key-value pair. The entry returned by the
 previous entry() call will be invalid.
 
 @return true if the cursor successfully moves. False when cursor is
         already at the end location and cannot be advanced.
 @throws IOException]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close the scanner. Release all resources. The behavior of using the
 scanner after calling close is not defined. The entry returned by the
 previous entry() call will be invalid.]]>
      </doc>
    </method>
    <method name="atEnd" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Is cursor at the end location?
 
 @return true if the cursor is at the end location.]]>
      </doc>
    </method>
    <method name="entry" return="org.apache.hadoop.io.file.tfile.TFile.Reader.Scanner.Entry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get an entry to access the key and value.
 
 @return The Entry object to access the key and value.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getRecordNum" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the RecordNum corresponding to the entry pointed by the cursor.
 @return The RecordNum corresponding to the entry pointed by the cursor.
 @throws IOException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The TFile Scanner. The Scanner has an implicit cursor, which, upon
 creation, points to the first key-value pair in the scan range. If the
 scan range is empty, the cursor will point to the end of the scan range.
 <p>
 Use {@link Scanner#atEnd()} to test whether the cursor is at the end
 location of the scanner.
 <p>
 Use {@link Scanner#advance()} to move the cursor to the next key-value
 pair (or end if none exists). Use seekTo methods (
 {@link Scanner#seekTo(byte[])} or
 {@link Scanner#seekTo(byte[], int, int)}) to seek to any arbitrary
 location in the covered range (including backward seeking). Use
 {@link Scanner#rewind()} to seek back to the beginning of the scanner.
 Use {@link Scanner#seekToEnd()} to seek to the end of the scanner.
 <p>
 Actual keys and values may be obtained through {@link Scanner.Entry}
 object, which is obtained through {@link Scanner#entry()}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.file.tfile.TFile.Reader.Scanner -->
  <!-- start class org.apache.hadoop.io.file.tfile.TFile.Reader.Scanner.Entry -->
  <class name="TFile.Reader.Scanner.Entry" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <constructor name="TFile.Reader.Scanner.Entry"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKeyLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the length of the key.
 
 @return the length of the key.]]>
      </doc>
    </method>
    <method name="get"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.BytesWritable"/>
      <param name="value" type="org.apache.hadoop.io.BytesWritable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy the key and value in one shot into BytesWritables. This is
 equivalent to getKey(key); getValue(value);
 
 @param key
          BytesWritable to hold key.
 @param value
          BytesWritable to hold value
 @throws IOException]]>
      </doc>
    </method>
    <method name="getKey" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.BytesWritable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy the key into BytesWritable. The input BytesWritable will be
 automatically resized to the actual key size.
 
 @param key
          BytesWritable to hold the key.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="org.apache.hadoop.io.BytesWritable"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy the value into BytesWritable. The input BytesWritable will be
 automatically resized to the actual value size. The implementation
 directly uses the buffer inside BytesWritable for storing the value.
 The call does not require the value length to be known.
 
 @param value
 @throws IOException]]>
      </doc>
    </method>
    <method name="writeKey" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writing the key to the output stream. This method avoids copying key
 buffer from Scanner into user buffer, then writing to the output
 stream.
 
 @param out
          The output stream
 @return the length of the key.
 @throws IOException]]>
      </doc>
    </method>
    <method name="writeValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writing the value to the output stream. This method avoids copying
 value data from Scanner into user buffer, then writing to the output
 stream. It does not require the value length to be known.
 
 @param out
          The output stream
 @return the length of the value
 @throws IOException]]>
      </doc>
    </method>
    <method name="getKey" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy the key into user supplied buffer.
 
 @param buf
          The buffer supplied by user. The length of the buffer must
          not be shorter than the key length.
 @return The length of the key.
 
 @throws IOException]]>
      </doc>
    </method>
    <method name="getKey" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="byte[]"/>
      <param name="offset" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy the key into user supplied buffer.
 
 @param buf
          The buffer supplied by user.
 @param offset
          The starting offset of the user buffer where we should copy
          the key into. Requiring the key-length + offset no greater
          than the buffer length.
 @return The length of the key.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getKeyStream" return="java.io.DataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Streaming access to the key. Useful for desrializing the key into
 user objects.
 
 @return The input stream.]]>
      </doc>
    </method>
    <method name="getValueLength" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the length of the value. isValueLengthKnown() must be tested
 true.
 
 @return the length of the value.]]>
      </doc>
    </method>
    <method name="getValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy value into user-supplied buffer. User supplied buffer must be
 large enough to hold the whole value. The value part of the key-value
 pair pointed by the current cursor is not cached and can only be
 examined once. Calling any of the following functions more than once
 without moving the cursor will result in exception:
 {@link #getValue(byte[])}, {@link #getValue(byte[], int)},
 {@link #getValueStream}.
 
 @return the length of the value. Does not require
         isValueLengthKnown() to be true.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="byte[]"/>
      <param name="offset" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Copy value into user-supplied buffer. User supplied buffer must be
 large enough to hold the whole value (starting from the offset). The
 value part of the key-value pair pointed by the current cursor is not
 cached and can only be examined once. Calling any of the following
 functions more than once without moving the cursor will result in
 exception: {@link #getValue(byte[])}, {@link #getValue(byte[], int)},
 {@link #getValueStream}.
 
 @return the length of the value. Does not require
         isValueLengthKnown() to be true.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getValueStream" return="java.io.DataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Stream access to value. The value part of the key-value pair pointed
 by the current cursor is not cached and can only be examined once.
 Calling any of the following functions more than once without moving
 the cursor will result in exception: {@link #getValue(byte[])},
 {@link #getValue(byte[], int)}, {@link #getValueStream}.
 
 @return The input stream for reading the value.
 @throws IOException]]>
      </doc>
    </method>
    <method name="isValueLengthKnown" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check whether it is safe to call getValueLength().
 
 @return true if value length is known before hand. Values less than
         the chunk size will always have their lengths known before
         hand. Values that are written out as a whole (with advertised
         length up-front) will always have their lengths known in
         read.]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="byte[]"/>
      <doc>
      <![CDATA[Compare the entry key to another key. Synonymous to compareTo(key, 0,
 key.length).
 
 @param buf
          The key buffer.
 @return comparison result between the entry key with the input key.]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Compare the entry key to another key. Synonymous to compareTo(new
 ByteArray(buf, offset, length)
 
 @param buf
          The key buffer
 @param offset
          offset into the key buffer.
 @param length
          the length of the key.
 @return comparison result between the entry key with the input key.]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.io.file.tfile.RawComparable"/>
      <doc>
      <![CDATA[Compare an entry with a RawComparable object. This is useful when
 Entries are stored in a collection, and we want to compare a user
 supplied key.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
      <doc>
      <![CDATA[Compare whether this and other points to the same key value.]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Entry to a &lt;Key, Value&gt; pair.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.file.tfile.TFile.Reader.Scanner.Entry -->
  <!-- start class org.apache.hadoop.io.file.tfile.TFile.Writer -->
  <class name="TFile.Writer" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="TFile.Writer" type="org.apache.hadoop.fs.FSDataOutputStream, int, java.lang.String, java.lang.String, org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Constructor
 
 @param fsdos
          output stream for writing. Must be at position 0.
 @param minBlockSize
          Minimum compressed block size in bytes. A compression block will
          not be closed until it reaches this size except for the last
          block.
 @param compressName
          Name of the compression algorithm. Must be one of the strings
          returned by {@link TFile#getSupportedCompressionAlgorithms()}.
 @param comparator
          Leave comparator as null or empty string if TFile is not sorted.
          Otherwise, provide the string name for the comparison algorithm
          for keys. Two kinds of comparators are supported.
          <ul>
          <li>Algorithmic comparator: binary comparators that is language
          independent. Currently, only "memcmp" is supported.
          <li>Language-specific comparator: binary comparators that can
          only be constructed in specific language. For Java, the syntax
          is "jclass:", followed by the class name of the RawComparator.
          Currently, we only support RawComparators that can be
          constructed through the default constructor (with no
          parameters). Parameterized RawComparators such as
          {@link WritableComparator} or
          {@link JavaSerializationComparator} may not be directly used.
          One should write a wrapper class that inherits from such classes
          and use its default constructor to perform proper
          initialization.
          </ul>
 @param conf
          The configuration object.
 @throws IOException]]>
      </doc>
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Close the Writer. Resources will be released regardless of the exceptions
 being thrown. Future close calls will have no effect.
 
 The underlying FSDataOutputStream is not closed.]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="byte[]"/>
      <param name="value" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Adding a new key-value pair to the TFile. This is synonymous to
 append(key, 0, key.length, value, 0, value.length)
 
 @param key
          Buffer for key.
 @param value
          Buffer for value.
 @throws IOException]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="byte[]"/>
      <param name="koff" type="int"/>
      <param name="klen" type="int"/>
      <param name="value" type="byte[]"/>
      <param name="voff" type="int"/>
      <param name="vlen" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Adding a new key-value pair to TFile.
 
 @param key
          buffer for key.
 @param koff
          offset in key buffer.
 @param klen
          length of key.
 @param value
          buffer for value.
 @param voff
          offset in value buffer.
 @param vlen
          length of value.
 @throws IOException
           Upon IO errors.
           <p>
           If an exception is thrown, the TFile will be in an inconsistent
           state. The only legitimate call after that would be close]]>
      </doc>
    </method>
    <method name="prepareAppendKey" return="java.io.DataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Obtain an output stream for writing a key into TFile. This may only be
 called when there is no active Key appending stream or value appending
 stream.
 
 @param length
          The expected length of the key. If length of the key is not
          known, set length = -1. Otherwise, the application must write
          exactly as many bytes as specified here before calling close on
          the returned output stream.
 @return The key appending output stream.
 @throws IOException]]>
      </doc>
    </method>
    <method name="prepareAppendValue" return="java.io.DataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="length" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Obtain an output stream for writing a value into TFile. This may only be
 called right after a key appending operation (the key append stream must
 be closed).
 
 @param length
          The expected length of the value. If length of the value is not
          known, set length = -1. Otherwise, the application must write
          exactly as many bytes as specified here before calling close on
          the returned output stream. Advertising the value size up-front
          guarantees that the value is encoded in one chunk, and avoids
          intermediate chunk buffering.
 @throws IOException]]>
      </doc>
    </method>
    <method name="prepareMetaBlock" return="java.io.DataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="compressName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="MetaBlockAlreadyExists" type="org.apache.hadoop.io.file.tfile.MetaBlockAlreadyExists"/>
      <doc>
      <![CDATA[Obtain an output stream for creating a meta block. This function may not
 be called when there is a key append stream or value append stream
 active. No more key-value insertion is allowed after a meta data block
 has been added to TFile.
 
 @param name
          Name of the meta block.
 @param compressName
          Name of the compression algorithm to be used. Must be one of the
          strings returned by
          {@link TFile#getSupportedCompressionAlgorithms()}.
 @return A DataOutputStream that can be used to write Meta Block data.
         Closing the stream would signal the ending of the block.
 @throws IOException
 @throws MetaBlockAlreadyExists
           the Meta Block with the same name already exists.]]>
      </doc>
    </method>
    <method name="prepareMetaBlock" return="java.io.DataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="MetaBlockAlreadyExists" type="org.apache.hadoop.io.file.tfile.MetaBlockAlreadyExists"/>
      <doc>
      <![CDATA[Obtain an output stream for creating a meta block. This function may not
 be called when there is a key append stream or value append stream
 active. No more key-value insertion is allowed after a meta data block
 has been added to TFile. Data will be compressed using the default
 compressor as defined in Writer's constructor.
 
 @param name
          Name of the meta block.
 @return A DataOutputStream that can be used to write Meta Block data.
         Closing the stream would signal the ending of the block.
 @throws IOException
 @throws MetaBlockAlreadyExists
           the Meta Block with the same name already exists.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[TFile Writer.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.file.tfile.TFile.Writer -->
  <!-- start class org.apache.hadoop.io.file.tfile.Utils -->
  <class name="Utils" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="writeVInt"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="n" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Encoding an integer into a variable-length encoding format. Synonymous to
 <code>Utils#writeVLong(out, n)</code>.
 
 @param out
          output stream
 @param n
          The integer to be encoded
 @throws IOException
 @see Utils#writeVLong(DataOutput, long)]]>
      </doc>
    </method>
    <method name="writeVLong"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Encoding a Long integer into a variable-length encoding format.
 <ul>
 <li>if n in [-32, 127): encode in one byte with the actual value.
 Otherwise,
 <li>if n in [-20*2^8, 20*2^8): encode in two bytes: byte[0] = n/256 - 52;
 byte[1]=n&0xff. Otherwise,
 <li>if n IN [-16*2^16, 16*2^16): encode in three bytes: byte[0]=n/2^16 -
 88; byte[1]=(n>>8)&0xff; byte[2]=n&0xff. Otherwise,
 <li>if n in [-8*2^24, 8*2^24): encode in four bytes: byte[0]=n/2^24 - 112;
 byte[1] = (n>>16)&0xff; byte[2] = (n>>8)&0xff; byte[3]=n&0xff. Otherwise:
 <li>if n in [-2^31, 2^31): encode in five bytes: byte[0]=-125; byte[1] =
 (n>>24)&0xff; byte[2]=(n>>16)&0xff; byte[3]=(n>>8)&0xff; byte[4]=n&0xff;
 <li>if n in [-2^39, 2^39): encode in six bytes: byte[0]=-124; byte[1] =
 (n>>32)&0xff; byte[2]=(n>>24)&0xff; byte[3]=(n>>16)&0xff;
 byte[4]=(n>>8)&0xff; byte[5]=n&0xff
 <li>if n in [-2^47, 2^47): encode in seven bytes: byte[0]=-123; byte[1] =
 (n>>40)&0xff; byte[2]=(n>>32)&0xff; byte[3]=(n>>24)&0xff;
 byte[4]=(n>>16)&0xff; byte[5]=(n>>8)&0xff; byte[6]=n&0xff;
 <li>if n in [-2^55, 2^55): encode in eight bytes: byte[0]=-122; byte[1] =
 (n>>48)&0xff; byte[2] = (n>>40)&0xff; byte[3]=(n>>32)&0xff;
 byte[4]=(n>>24)&0xff; byte[5]=(n>>16)&0xff; byte[6]=(n>>8)&0xff;
 byte[7]=n&0xff;
 <li>if n in [-2^63, 2^63): encode in nine bytes: byte[0]=-121; byte[1] =
 (n>>54)&0xff; byte[2] = (n>>48)&0xff; byte[3] = (n>>40)&0xff;
 byte[4]=(n>>32)&0xff; byte[5]=(n>>24)&0xff; byte[6]=(n>>16)&0xff;
 byte[7]=(n>>8)&0xff; byte[8]=n&0xff;
 </ul>
 
 @param out
          output stream
 @param n
          the integer number
 @throws IOException]]>
      </doc>
    </method>
    <method name="readVInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Decoding the variable-length integer. Synonymous to
 <code>(int)Utils#readVLong(in)</code>.
 
 @param in
          input stream
 @return the decoded integer
 @throws IOException
 
 @see Utils#readVLong(DataInput)]]>
      </doc>
    </method>
    <method name="readVLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Decoding the variable-length integer. Suppose the value of the first byte
 is FB, and the following bytes are NB[*].
 <ul>
 <li>if (FB >= -32), return (long)FB;
 <li>if (FB in [-72, -33]), return (FB+52)<<8 + NB[0]&0xff;
 <li>if (FB in [-104, -73]), return (FB+88)<<16 + (NB[0]&0xff)<<8 +
 NB[1]&0xff;
 <li>if (FB in [-120, -105]), return (FB+112)<<24 + (NB[0]&0xff)<<16 +
 (NB[1]&0xff)<<8 + NB[2]&0xff;
 <li>if (FB in [-128, -121]), return interpret NB[FB+129] as a signed
 big-endian integer.
 
 @param in
          input stream
 @return the decoded long integer.
 @throws IOException]]>
      </doc>
    </method>
    <method name="writeString"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <param name="s" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a String as a VInt n, followed by n Bytes as in Text format.
 
 @param out
 @param s
 @throws IOException]]>
      </doc>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a String as a VInt n, followed by n Bytes in Text format.
 
 @param in
          The input stream.
 @return The string
 @throws IOException]]>
      </doc>
    </method>
    <method name="lowerBound" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="list" type="java.util.List"/>
      <param name="key" type="T"/>
      <param name="cmp" type="java.util.Comparator"/>
      <doc>
      <![CDATA[Lower bound binary search. Find the index to the first element in the list
 that compares greater than or equal to key.
 
 @param <T>
          Type of the input key.
 @param list
          The list
 @param key
          The input key.
 @param cmp
          Comparator for the key.
 @return The index to the desired element if it exists; or list.size()
         otherwise.]]>
      </doc>
    </method>
    <method name="upperBound" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="list" type="java.util.List"/>
      <param name="key" type="T"/>
      <param name="cmp" type="java.util.Comparator"/>
      <doc>
      <![CDATA[Upper bound binary search. Find the index to the first element in the list
 that compares greater than the input key.
 
 @param <T>
          Type of the input key.
 @param list
          The list
 @param key
          The input key.
 @param cmp
          Comparator for the key.
 @return The index to the desired element if it exists; or list.size()
         otherwise.]]>
      </doc>
    </method>
    <method name="lowerBound" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="list" type="java.util.List"/>
      <param name="key" type="T"/>
      <doc>
      <![CDATA[Lower bound binary search. Find the index to the first element in the list
 that compares greater than or equal to key.
 
 @param <T>
          Type of the input key.
 @param list
          The list
 @param key
          The input key.
 @return The index to the desired element if it exists; or list.size()
         otherwise.]]>
      </doc>
    </method>
    <method name="upperBound" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="list" type="java.util.List"/>
      <param name="key" type="T"/>
      <doc>
      <![CDATA[Upper bound binary search. Find the index to the first element in the list
 that compares greater than the input key.
 
 @param <T>
          Type of the input key.
 @param list
          The list
 @param key
          The input key.
 @return The index to the desired element if it exists; or list.size()
         otherwise.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Supporting Utility classes used by TFile, and shared by users of TFile.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.file.tfile.Utils -->
  <!-- start class org.apache.hadoop.io.file.tfile.Utils.Version -->
  <class name="Utils.Version" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <constructor name="Utils.Version" type="java.io.DataInput"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct the Version object by reading from the input stream.
 
 @param in
          input stream
 @throws IOException]]>
      </doc>
    </constructor>
    <constructor name="Utils.Version" type="short, short"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor.
 
 @param major
          major version.
 @param minor
          minor version.]]>
      </doc>
    </constructor>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write the objec to a DataOutput. The serialized format of the Version is
 major version followed by minor version, both as big-endian short
 integers.
 
 @param out
          The DataOutput object.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getMajor" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the major version.
 
 @return Major version.]]>
      </doc>
    </method>
    <method name="getMinor" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the minor version.
 
 @return The minor version.]]>
      </doc>
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the size of the serialized Version object.
 
 @return serialized size of the version object.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a string representation of the version.]]>
      </doc>
    </method>
    <method name="compatibleWith" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.io.file.tfile.Utils.Version"/>
      <doc>
      <![CDATA[Test compatibility.
 
 @param other
          The Version object to test compatibility with.
 @return true if both versions have the same major version number; false
         otherwise.]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="that" type="org.apache.hadoop.io.file.tfile.Utils.Version"/>
      <doc>
      <![CDATA[Compare this version with another version.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A generic Version class. We suggest applications built on top of TFile use
 this class to maintain version information in their meta blocks.
 
 A version number consists of a major version and a minor version. The
 suggested usage of major and minor version number is to increment major
 version number when the new storage format is not backward compatible, and
 increment the minor version otherwise.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.file.tfile.Utils.Version -->
</package>
<package name="org.apache.hadoop.io.serializer">
  <!-- start class org.apache.hadoop.io.serializer.JavaSerialization -->
  <class name="JavaSerialization" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.serializer.Serialization"/>
    <constructor name="JavaSerialization"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="accept" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
    </method>
    <method name="getDeserializer" return="org.apache.hadoop.io.serializer.Deserializer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
    </method>
    <method name="getSerializer" return="org.apache.hadoop.io.serializer.Serializer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
    </method>
    <doc>
    <![CDATA[<p>
 An experimental {@link Serialization} for Java {@link Serializable} classes.
 </p>
 @see JavaSerializationComparator]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.serializer.JavaSerialization -->
  <!-- start class org.apache.hadoop.io.serializer.JavaSerializationComparator -->
  <class name="JavaSerializationComparator" extends="org.apache.hadoop.io.serializer.DeserializerComparator"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JavaSerializationComparator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="compare" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o1" type="T"/>
      <param name="o2" type="T"/>
    </method>
    <doc>
    <![CDATA[<p>
 A {@link RawComparator} that uses a {@link JavaSerialization}
 {@link Deserializer} to deserialize objects that are then compared via
 their {@link Comparable} interfaces.
 </p>
 @param <T>
 @see JavaSerialization]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.serializer.JavaSerializationComparator -->
  <!-- start class org.apache.hadoop.io.serializer.WritableSerialization -->
  <class name="WritableSerialization" extends="org.apache.hadoop.conf.Configured"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.serializer.Serialization"/>
    <constructor name="WritableSerialization"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="accept" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
    </method>
    <method name="getSerializer" return="org.apache.hadoop.io.serializer.Serializer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
    </method>
    <method name="getDeserializer" return="org.apache.hadoop.io.serializer.Deserializer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
    </method>
    <doc>
    <![CDATA[A {@link Serialization} for {@link Writable}s that delegates to
 {@link Writable#write(java.io.DataOutput)} and
 {@link Writable#readFields(java.io.DataInput)}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.serializer.WritableSerialization -->
  <doc>
  <![CDATA[<p>
This package provides a mechanism for using different serialization frameworks
in Hadoop. The property "io.serializations" defines a list of
{@link org.apache.hadoop.io.serializer.Serialization}s that know how to create
{@link org.apache.hadoop.io.serializer.Serializer}s and
{@link org.apache.hadoop.io.serializer.Deserializer}s.
</p>

<p>
To add a new serialization framework write an implementation of
{@link org.apache.hadoop.io.serializer.Serialization} and add its name to the
"io.serializations" property.
</p>]]>
  </doc>
</package>
<package name="org.apache.hadoop.io.serializer.avro">
  <!-- start interface org.apache.hadoop.io.serializer.avro.AvroReflectSerializable -->
  <interface name="AvroReflectSerializable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Tag interface for Avro 'reflect' serializable classes. Classes implementing 
 this interface can be serialized/deserialized using 
 {@link AvroReflectSerialization}.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.io.serializer.avro.AvroReflectSerializable -->
  <!-- start class org.apache.hadoop.io.serializer.avro.AvroReflectSerialization -->
  <class name="AvroReflectSerialization" extends="org.apache.hadoop.io.serializer.avro.AvroSerialization"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AvroReflectSerialization"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="accept" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
    </method>
    <method name="getReader" return="org.apache.avro.io.DatumReader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Object"/>
    </method>
    <method name="getWriter" return="org.apache.avro.io.DatumWriter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
    </method>
    <field name="AVRO_REFLECT_PACKAGES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Key to configure packages that contain classes to be serialized and 
 deserialized using this class. Multiple packages can be specified using 
 comma-separated list.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Serialization for Avro Reflect classes. For a class to be accepted by this 
 serialization, it must either be in the package list configured via 
 <code>avro.reflect.pkgs</code> or implement 
 {@link AvroReflectSerializable} interface.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.serializer.avro.AvroReflectSerialization -->
  <!-- start class org.apache.hadoop.io.serializer.avro.AvroSerialization -->
  <class name="AvroSerialization" extends="org.apache.hadoop.conf.Configured"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.io.serializer.Serialization"/>
    <constructor name="AvroSerialization"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getDeserializer" return="org.apache.hadoop.io.serializer.Deserializer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
    </method>
    <method name="getSerializer" return="org.apache.hadoop.io.serializer.Serializer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="T"/>
      <doc>
      <![CDATA[Return an Avro Schema instance for the given class.]]>
      </doc>
    </method>
    <method name="getWriter" return="org.apache.avro.io.DatumWriter"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <doc>
      <![CDATA[Create and return Avro DatumWriter for the given class.]]>
      </doc>
    </method>
    <method name="getReader" return="org.apache.avro.io.DatumReader"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <doc>
      <![CDATA[Create and return Avro DatumReader for the given class.]]>
      </doc>
    </method>
    <field name="AVRO_SCHEMA_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Base class for providing serialization to Avro types.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.serializer.avro.AvroSerialization -->
  <!-- start class org.apache.hadoop.io.serializer.avro.AvroSpecificSerialization -->
  <class name="AvroSpecificSerialization" extends="org.apache.hadoop.io.serializer.avro.AvroSerialization"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AvroSpecificSerialization"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="accept" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
    </method>
    <method name="getReader" return="org.apache.avro.io.DatumReader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="org.apache.avro.specific.SpecificRecord"/>
    </method>
    <method name="getWriter" return="org.apache.avro.io.DatumWriter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
    </method>
    <doc>
    <![CDATA[Serialization for Avro Specific classes. This serialization is to be used 
 for classes generated by Avro's 'specific' compiler.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.io.serializer.avro.AvroSpecificSerialization -->
  <doc>
  <![CDATA[<p>
This package provides Avro serialization in Hadoop. This can be used to 
serialize/deserialize Avro types in Hadoop.
</p>

<p>
Use {@link org.apache.hadoop.io.serializer.avro.AvroSpecificSerialization} for 
serialization of classes generated by Avro's 'specific' compiler.
</p>

<p>
Use {@link org.apache.hadoop.io.serializer.avro.AvroReflectSerialization} for 
other classes. 
{@link org.apache.hadoop.io.serializer.avro.AvroReflectSerialization} work for  
any class which is either in the package list configured via 
{@link org.apache.hadoop.io.serializer.avro.AvroReflectSerialization#AVRO_REFLECT_PACKAGES} 
or implement {@link org.apache.hadoop.io.serializer.avro.AvroReflectSerializable}
interface.
</p>]]>
  </doc>
</package>
<package name="org.apache.hadoop.ipc.protocolPB">
  <!-- start class org.apache.hadoop.ipc.protocolPB.GenericRefreshProtocolClientSideTranslatorPB -->
  <class name="GenericRefreshProtocolClientSideTranslatorPB" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.ipc.ProtocolMetaInterface"/>
    <implements name="org.apache.hadoop.ipc.GenericRefreshProtocol"/>
    <implements name="java.io.Closeable"/>
    <constructor name="GenericRefreshProtocolClientSideTranslatorPB" type="org.apache.hadoop.ipc.protocolPB.GenericRefreshProtocolPB"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="refresh" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="identifier" type="java.lang.String"/>
      <param name="args" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="isMethodSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="methodName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.ipc.protocolPB.GenericRefreshProtocolClientSideTranslatorPB -->
  <!-- start class org.apache.hadoop.ipc.protocolPB.GenericRefreshProtocolServerSideTranslatorPB -->
  <class name="GenericRefreshProtocolServerSideTranslatorPB" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.ipc.protocolPB.GenericRefreshProtocolPB"/>
    <constructor name="GenericRefreshProtocolServerSideTranslatorPB" type="org.apache.hadoop.ipc.GenericRefreshProtocol"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="refresh" return="org.apache.hadoop.ipc.proto.GenericRefreshProtocolProtos.GenericRefreshResponseCollectionProto"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="controller" type="com.google.protobuf.RpcController"/>
      <param name="request" type="org.apache.hadoop.ipc.proto.GenericRefreshProtocolProtos.GenericRefreshRequestProto"/>
      <exception name="ServiceException" type="com.google.protobuf.ServiceException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.ipc.protocolPB.GenericRefreshProtocolServerSideTranslatorPB -->
  <!-- start class org.apache.hadoop.ipc.protocolPB.RefreshCallQueueProtocolClientSideTranslatorPB -->
  <class name="RefreshCallQueueProtocolClientSideTranslatorPB" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.ipc.ProtocolMetaInterface"/>
    <implements name="org.apache.hadoop.ipc.RefreshCallQueueProtocol"/>
    <implements name="java.io.Closeable"/>
    <constructor name="RefreshCallQueueProtocolClientSideTranslatorPB" type="org.apache.hadoop.ipc.protocolPB.RefreshCallQueueProtocolPB"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="refreshCallQueue"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="isMethodSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="methodName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.ipc.protocolPB.RefreshCallQueueProtocolClientSideTranslatorPB -->
  <!-- start class org.apache.hadoop.ipc.protocolPB.RefreshCallQueueProtocolServerSideTranslatorPB -->
  <class name="RefreshCallQueueProtocolServerSideTranslatorPB" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.ipc.protocolPB.RefreshCallQueueProtocolPB"/>
    <constructor name="RefreshCallQueueProtocolServerSideTranslatorPB" type="org.apache.hadoop.ipc.RefreshCallQueueProtocol"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="refreshCallQueue" return="org.apache.hadoop.ipc.proto.RefreshCallQueueProtocolProtos.RefreshCallQueueResponseProto"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="controller" type="com.google.protobuf.RpcController"/>
      <param name="request" type="org.apache.hadoop.ipc.proto.RefreshCallQueueProtocolProtos.RefreshCallQueueRequestProto"/>
      <exception name="ServiceException" type="com.google.protobuf.ServiceException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.ipc.protocolPB.RefreshCallQueueProtocolServerSideTranslatorPB -->
</package>
<package name="org.apache.hadoop.jmx">
  <!-- start class org.apache.hadoop.jmx.JMXJsonServlet -->
  <class name="JMXJsonServlet" extends="javax.servlet.http.HttpServlet"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JMXJsonServlet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ServletException" type="javax.servlet.ServletException"/>
      <doc>
      <![CDATA[Initialize this servlet.]]>
      </doc>
    </method>
    <method name="isInstrumentationAccessAllowed" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="request" type="javax.servlet.http.HttpServletRequest"/>
      <param name="response" type="javax.servlet.http.HttpServletResponse"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="doGet"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="request" type="javax.servlet.http.HttpServletRequest"/>
      <param name="response" type="javax.servlet.http.HttpServletResponse"/>
      <doc>
      <![CDATA[Process a GET request for the specified resource.
 
 @param request
          The servlet request we are processing
 @param response
          The servlet response we are creating]]>
      </doc>
    </method>
    <field name="mBeanServer" type="javax.management.MBeanServer"
      transient="true" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[MBean server.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Provides Read only web access to JMX.
 <p>
 This servlet generally will be placed under the /jmx URL for each
 HttpServer.  It provides read only
 access to JMX metrics.  The optional <code>qry</code> parameter
 may be used to query only a subset of the JMX Beans.  This query
 functionality is provided through the
 {@link MBeanServer#queryNames(ObjectName, javax.management.QueryExp)}
 method.
 <p>
 For example <code>http://.../jmx?qry=Hadoop:*</code> will return
 all hadoop metrics exposed through JMX.
 <p>
 The optional <code>get</code> parameter is used to query an specific 
 attribute of a JMX bean.  The format of the URL is
 <code>http://.../jmx?get=MXBeanName::AttributeName<code>
 <p>
 For example 
 <code>
 http://../jmx?get=Hadoop:service=NameNode,name=NameNodeInfo::ClusterId
 </code> will return the cluster id of the namenode mxbean.
 <p>
 If the <code>qry</code> or the <code>get</code> parameter is not formatted 
 correctly then a 400 BAD REQUEST http response code will be returned. 
 <p>
 If a resouce such as a mbean or attribute can not be found, 
 a 404 SC_NOT_FOUND http response code will be returned. 
 <p>
 The return format is JSON and in the form
 <p>
  <code><pre>
  {
    "beans" : [
      {
        "name":"bean-name"
        ...
      }
    ]
  }
  </pre></code>
  <p>
  The servlet attempts to convert the the JMXBeans into JSON. Each
  bean's attributes will be converted to a JSON object member.
  
  If the attribute is a boolean, a number, a string, or an array
  it will be converted to the JSON equivalent. 
  
  If the value is a {@link CompositeData} then it will be converted
  to a JSON object with the keys as the name of the JSON member and
  the value is converted following these same rules.
  
  If the value is a {@link TabularData} then it will be converted
  to an array of the {@link CompositeData} elements that it contains.
  
  All other objects will be converted to a string and output as such.
  
  The bean's name and modelerType will be returned for all beans.

  Optional paramater "callback" should be used to deliver JSONP response.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.jmx.JMXJsonServlet -->
</package>
<package name="org.apache.hadoop.log">
  <!-- start class org.apache.hadoop.log.EventCounter -->
  <class name="EventCounter" extends="org.apache.hadoop.log.metrics.EventCounter"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="use {@link org.apache.hadoop.log.metrics.EventCounter} instead">
    <constructor name="EventCounter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[A log4J Appender that simply counts logging events in three levels:
 fatal, error and warn. The class name is used in log4j.properties
 @deprecated use {@link org.apache.hadoop.log.metrics.EventCounter} instead]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.log.EventCounter -->
  <!-- start class org.apache.hadoop.log.Log4Json -->
  <class name="Log4Json" extends="org.apache.log4j.Layout"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Log4Json"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getContentType" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the mime type of JSON]]>
      </doc>
    </method>
    <method name="format" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="org.apache.log4j.spi.LoggingEvent"/>
    </method>
    <method name="toJson" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="org.apache.log4j.spi.LoggingEvent"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Convert an event to JSON

 @param event the event -must not be null
 @return a string value
 @throws IOException on problems generating the JSON]]>
      </doc>
    </method>
    <method name="toJson" return="java.io.Writer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.io.Writer"/>
      <param name="event" type="org.apache.log4j.spi.LoggingEvent"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Convert an event to JSON

 @param writer the destination writer
 @param event the event -must not be null
 @return the writer
 @throws IOException on problems generating the JSON]]>
      </doc>
    </method>
    <method name="toJson" return="java.io.Writer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writer" type="java.io.Writer"/>
      <param name="loggerName" type="java.lang.String"/>
      <param name="timeStamp" type="long"/>
      <param name="level" type="java.lang.String"/>
      <param name="threadName" type="java.lang.String"/>
      <param name="message" type="java.lang.String"/>
      <param name="ti" type="org.apache.log4j.spi.ThrowableInformation"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Build a JSON entry from the parameters. This is public for testing.

 @param writer destination
 @param loggerName logger name
 @param timeStamp time_t value
 @param level level string
 @param threadName name of the thread
 @param message rendered message
 @param ti nullable thrown information
 @return the writer
 @throws IOException on any problem]]>
      </doc>
    </method>
    <method name="ignoresThrowable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This appender does not ignore throwables

 @return false, always]]>
      </doc>
    </method>
    <method name="activateOptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Do nothing]]>
      </doc>
    </method>
    <method name="parse" return="org.codehaus.jackson.node.ContainerNode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="json" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[For use in tests

 @param json incoming JSON to parse
 @return a node tree
 @throws IOException on any parsing problems]]>
      </doc>
    </method>
    <field name="DATE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EXCEPTION_CLASS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LEVEL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MESSAGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="STACK" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="THREAD" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TIME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JSON_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This offers a log layout for JSON, with some test entry points. It's purpose is
 to allow Log4J to generate events that are easy for other programs to parse, but which are somewhat
 human-readable.

 Some features.

 <ol>
     <li>Every event is a standalone JSON clause</li>
     <li>Time is published as a time_t event since 1/1/1970
      -this is the fastest to generate.</li>
     <li>An ISO date is generated, but this is cached and will only be accurate to within a second</li>
     <li>the stack trace is included as an array</li>
 </ol>

 A simple log event will resemble the following
 <pre>
     {"name":"test","time":1318429136789,"date":"2011-10-12 15:18:56,789","level":"INFO","thread":"main","message":"test message"}
 </pre>

 An event with an error will contain data similar to that below (which has been reformatted to be multi-line).

 <pre>
     {
     "name":"testException",
     "time":1318429136789,
     "date":"2011-10-12 15:18:56,789",
     "level":"INFO",
     "thread":"quoted\"",
     "message":"new line\n and {}",
     "exceptionclass":"java.net.NoRouteToHostException",
     "stack":[
         "java.net.NoRouteToHostException: that box caught fire 3 years ago",
         "\tat org.apache.hadoop.log.TestLog4Json.testException(TestLog4Json.java:49)",
         "\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)",
         "\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)",
         "\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)",
         "\tat java.lang.reflect.Method.invoke(Method.java:597)",
         "\tat junit.framework.TestCase.runTest(TestCase.java:168)",
         "\tat junit.framework.TestCase.runBare(TestCase.java:134)",
         "\tat junit.framework.TestResult$1.protect(TestResult.java:110)",
         "\tat junit.framework.TestResult.runProtected(TestResult.java:128)",
         "\tat junit.framework.TestResult.run(TestResult.java:113)",
         "\tat junit.framework.TestCase.run(TestCase.java:124)",
         "\tat junit.framework.TestSuite.runTest(TestSuite.java:232)",
         "\tat junit.framework.TestSuite.run(TestSuite.java:227)",
         "\tat org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83)",
         "\tat org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:59)",
         "\tat org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.executeTestSet(AbstractDirectoryTestSuite.java:120)",
         "\tat org.apache.maven.surefire.suite.AbstractDirectoryTestSuite.execute(AbstractDirectoryTestSuite.java:145)",
         "\tat org.apache.maven.surefire.Surefire.run(Surefire.java:104)",
         "\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)",
         "\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)",
         "\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)",
         "\tat java.lang.reflect.Method.invoke(Method.java:597)",
         "\tat org.apache.maven.surefire.booter.SurefireBooter.runSuitesInProcess(SurefireBooter.java:290)",
         "\tat org.apache.maven.surefire.booter.SurefireBooter.main(SurefireBooter.java:1017)"
         ]
     }
 </pre>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.log.Log4Json -->
  <!-- start class org.apache.hadoop.log.LogLevel -->
  <class name="LogLevel" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LogLevel"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <doc>
      <![CDATA[A command line implementation]]>
      </doc>
    </method>
    <field name="USAGES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Change log level in runtime.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.log.LogLevel -->
</package>
<package name="org.apache.hadoop.log.metrics">
  <!-- start class org.apache.hadoop.log.metrics.EventCounter -->
  <class name="EventCounter" extends="org.apache.log4j.AppenderSkeleton"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EventCounter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getFatal" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getError" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getWarn" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInfo" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="org.apache.log4j.spi.LoggingEvent"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="requiresLayout" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A log4J Appender that simply counts logging events in three levels:
 fatal, error and warn. The class name is used in log4j.properties]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.log.metrics.EventCounter -->
</package>
<package name="org.apache.hadoop.metrics">
  <doc>
  <![CDATA[This package defines an API for reporting performance metric information.
<p/>
The API is abstract so that it can be implemented on top of
a variety of metrics client libraries.  The choice of 
client library is a configuration option, and different 
modules within the same application can use
different metrics implementation libraries.
<p/>
Sub-packages:
<dl>
    <dt><code>org.apache.hadoop.metrics.spi</code></dt>
    <dd>The abstract Server Provider Interface package. Those wishing to
    integrate the metrics API with a particular metrics client library should 
    extend this package.</dd>
    
    <dt><code>org.apache.hadoop.metrics.file</code></dt>
    <dd>An implementation package which writes the metric data to 
    a file, or sends it to the standard output stream.</dd>
 
    <dt> <code>org.apache.hadoop.metrics.ganglia</code></dt>
    <dd>An implementation package which sends metric data to 
    <a href="http://ganglia.sourceforge.net/">Ganglia</a>.</dd>
</dl>

<h3>Introduction to the Metrics API</h3>

Here is a simple example of how to use this package to report a single
metric value:
<pre>
    private ContextFactory contextFactory = ContextFactory.getFactory();
    
    void reportMyMetric(float myMetric) {
        MetricsContext myContext = contextFactory.getContext("myContext");
        MetricsRecord myRecord = myContext.getRecord("myRecord");
        myRecord.setMetric("myMetric", myMetric);
        myRecord.update();
    }
</pre>
  
In this example there are three names:
<dl>
  <dt><i>myContext</i></dt>
  <dd>The context name will typically identify either the application, or else a
  module within an application or library.</dd>
  
  <dt><i>myRecord</i></dt>
  <dd>The record name generally identifies some entity for which a set of
  metrics are to be reported.  For example, you could have a record named 
  "cacheStats" for reporting a number of statistics relating to the usage of
  some cache in your application.</dd>
  
  <dt><i>myMetric</i></dt>
  <dd>This identifies a particular metric.  For example, you might have metrics
  named "cache_hits" and "cache_misses".
  </dd>
</dl>

<h3>Tags</h3>

In some cases it is useful to have multiple records with the same name. For 
example, suppose that you want to report statistics about each disk on a computer. 
In this case, the record name would be something like "diskStats", but you also
need to identify the disk which is done by adding a <i>tag</i> to the record.
The code could look something like this:
<pre>
    private MetricsRecord diskStats =
            contextFactory.getContext("myContext").getRecord("diskStats");
            
    void reportDiskMetrics(String diskName, float diskBusy, float diskUsed) {
        diskStats.setTag("diskName", diskName);
        diskStats.setMetric("diskBusy", diskBusy);
        diskStats.setMetric("diskUsed", diskUsed);
        diskStats.update();
    }
</pre>

<h3>Buffering and Callbacks</h3>

Data is not sent immediately to the metrics system when 
<code>MetricsRecord.update()</code> is called. Instead it is stored in an
internal table, and the contents of the table are sent periodically.
This can be important for two reasons:
<ol>
    <li>It means that a programmer is free to put calls to this API in an 
    inner loop, since updates can be very frequent without slowing down
    the application significantly.</li>
    <li>Some implementations can gain efficiency by combining many metrics 
    into a single UDP message.</li>
</ol>

The API provides a timer-based callback via the 
<code>registerUpdater()</code> method.  The benefit of this
versus using <code>java.util.Timer</code> is that the callbacks will be done 
immediately before sending the data, making the data as current as possible.

<h3>Configuration</h3>

It is possible to programmatically examine and modify configuration data
before creating a context, like this:
<pre>
    ContextFactory factory = ContextFactory.getFactory();
    ... examine and/or modify factory attributes ...
    MetricsContext context = factory.getContext("myContext");
</pre>
The factory attributes can be examined and modified using the following
<code>ContextFactory</code>methods:
<ul>
    <li><code>Object getAttribute(String attributeName)</code></li>
    <li><code>String[] getAttributeNames()</code></li>
    <li><code>void setAttribute(String name, Object value)</code></li>
    <li><code>void removeAttribute(attributeName)</code></li>
</ul>

<p/>
<code>ContextFactory.getFactory()</code> initializes the factory attributes by
reading the properties file <code>hadoop-metrics.properties</code> if it exists 
on the class path.

<p/>
A factory attribute named:
<pre>
<i>contextName</i>.class
</pre>
should have as its value the fully qualified name of the class to be 
instantiated by a call of the <code>CodeFactory</code> method
<code>getContext(<i>contextName</i>)</code>.  If this factory attribute is not 
specified, the default is to instantiate 
<code>org.apache.hadoop.metrics.file.FileContext</code>.

<p/>
Other factory attributes are specific to a particular implementation of this 
API and are documented elsewhere.  For example, configuration attributes for
the file and Ganglia implementations can be found in the javadoc for 
their respective packages.]]>
  </doc>
</package>
<package name="org.apache.hadoop.metrics.file">
  <!-- start class org.apache.hadoop.metrics.file.FileContext -->
  <class name="FileContext" extends="org.apache.hadoop.metrics.spi.AbstractMetricsContext"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FileContext"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of FileContext]]>
      </doc>
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="factory" type="org.apache.hadoop.metrics.ContextFactory"/>
    </method>
    <method name="getFileName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the configured file name, or null.]]>
      </doc>
    </method>
    <method name="startMonitoring"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Starts or restarts monitoring, by opening in append-mode, the
 file specified by the <code>fileName</code> attribute,
 if specified. Otherwise the data will be written to standard
 output.]]>
      </doc>
    </method>
    <method name="stopMonitoring"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stops monitoring, closing the file.
 @see #close()]]>
      </doc>
    </method>
    <method name="emitRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="recordName" type="java.lang.String"/>
      <param name="outRec" type="org.apache.hadoop.metrics.spi.OutputRecord"/>
      <doc>
      <![CDATA[Emits a metrics record to a file.]]>
      </doc>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Flushes the output writer, forcing updates to disk.]]>
      </doc>
    </method>
    <field name="FILE_NAME_PROPERTY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="PERIOD_PROPERTY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Metrics context for writing metrics to a file.<p/>

 This class is configured by setting ContextFactory attributes which in turn
 are usually configured through a properties file.  All the attributes are
 prefixed by the contextName. For example, the properties file might contain:
 <pre>
 myContextName.fileName=/tmp/metrics.log
 myContextName.period=5
 </pre>
 @see org.apache.hadoop.metrics2.sink.FileSink for metrics 2.0.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.file.FileContext -->
  <doc>
  <![CDATA[Implementation of the metrics package that writes the metrics to a file.
Programmers should not normally need to use this package directly. Instead
they should use org.hadoop.metrics.

<p/>
These are the implementation specific factory attributes 
(See ContextFactory.getFactory()):

<dl>
    <dt><i>contextName</i>.fileName</dt>
    <dd>The path of the file to which metrics in context <i>contextName</i>
    are to be appended.  If this attribute is not specified, the metrics
    are written to standard output by default.</dd>
    
    <dt><i>contextName</i>.period</dt>
    <dd>The period in seconds on which the metric data is written to the
    file.</dd>
    
</dl>]]>
  </doc>
</package>
<package name="org.apache.hadoop.metrics.ganglia">
  <!-- start class org.apache.hadoop.metrics.ganglia.GangliaContext -->
  <class name="GangliaContext" extends="org.apache.hadoop.metrics.spi.AbstractMetricsContext"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GangliaContext"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of GangliaContext]]>
      </doc>
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="factory" type="org.apache.hadoop.metrics.ContextFactory"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[method to close the datagram socket]]>
      </doc>
    </method>
    <method name="emitRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="recordName" type="java.lang.String"/>
      <param name="outRec" type="org.apache.hadoop.metrics.spi.OutputRecord"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="emitMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="type" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getUnits" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
    </method>
    <method name="getSlope" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
    </method>
    <method name="getTmax" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
    </method>
    <method name="getDmax" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
    </method>
    <method name="xdr_string"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <doc>
      <![CDATA[Puts a string into the buffer by first writing the size of the string
 as an int, followed by the bytes of the string, padded if necessary to
 a multiple of 4.]]>
      </doc>
    </method>
    <method name="xdr_int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <doc>
      <![CDATA[Puts an integer into the buffer as 4 bytes, big-endian.]]>
      </doc>
    </method>
    <field name="buffer" type="byte[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="offset" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="metricsServers" type="java.util.List"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="datagramSocket" type="java.net.DatagramSocket"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Context for sending metrics to Ganglia.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.ganglia.GangliaContext -->
  <!-- start class org.apache.hadoop.metrics.ganglia.GangliaContext31 -->
  <class name="GangliaContext31" extends="org.apache.hadoop.metrics.ganglia.GangliaContext"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GangliaContext31"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="factory" type="org.apache.hadoop.metrics.ContextFactory"/>
    </method>
    <method name="emitMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="type" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Context for sending metrics to Ganglia version 3.1.x.
 
 3.1.1 has a slightly different wire portal compared to 3.0.x.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.ganglia.GangliaContext31 -->
  <doc>
  <![CDATA[<!--
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
-->

Implementation of the metrics package that sends metric data to 
<a href="http://ganglia.sourceforge.net/">Ganglia</a>.
Programmers should not normally need to use this package directly. Instead
they should use org.hadoop.metrics.

<p/>
These are the implementation specific factory attributes 
(See ContextFactory.getFactory()):

<dl>
    <dt><i>contextName</i>.servers</dt>
    <dd>Space and/or comma separated sequence of servers to which UDP
    messages should be sent.</dd>
    
    <dt><i>contextName</i>.period</dt>
    <dd>The period in seconds on which the metric data is sent to the
    server(s).</dd>
    
    <dt><i>contextName</i>.units.<i>recordName</i>.<i>metricName</i></dt>
    <dd>The units for the specified metric in the specified record.</dd>
    
    <dt><i>contextName</i>.slope.<i>recordName</i>.<i>metricName</i></dt>
    <dd>The slope for the specified metric in the specified record.</dd>
    
    <dt><i>contextName</i>.tmax.<i>recordName</i>.<i>metricName</i></dt>
    <dd>The tmax for the specified metric in the specified record.</dd>
    
    <dt><i>contextName</i>.dmax.<i>recordName</i>.<i>metricName</i></dt>
    <dd>The dmax for the specified metric in the specified record.</dd>
    
</dl>]]>
  </doc>
</package>
<package name="org.apache.hadoop.metrics.spi">
  <!-- start class org.apache.hadoop.metrics.spi.AbstractMetricsContext -->
  <class name="AbstractMetricsContext" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics.MetricsContext"/>
    <constructor name="AbstractMetricsContext"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of AbstractMetricsContext]]>
      </doc>
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="factory" type="org.apache.hadoop.metrics.ContextFactory"/>
      <doc>
      <![CDATA[Initializes the context.]]>
      </doc>
    </method>
    <method name="getAttribute" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="attributeName" type="java.lang.String"/>
      <doc>
      <![CDATA[Convenience method for subclasses to access factory attributes.]]>
      </doc>
    </method>
    <method name="getAttributeTable" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="tableName" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns an attribute-value map derived from the factory attributes
 by finding all factory attributes that begin with 
 <i>contextName</i>.<i>tableName</i>.  The returned map consists of
 those attributes with the contextName and tableName stripped off.]]>
      </doc>
    </method>
    <method name="getContextName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the context name.]]>
      </doc>
    </method>
    <method name="getContextFactory" return="org.apache.hadoop.metrics.ContextFactory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the factory by which this context was created.]]>
      </doc>
    </method>
    <method name="startMonitoring"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Starts or restarts monitoring, the emitting of metrics records.]]>
      </doc>
    </method>
    <method name="stopMonitoring"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stops monitoring.  This does not free buffered data. 
 @see #close()]]>
      </doc>
    </method>
    <method name="isMonitoring" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if monitoring is currently in progress.]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stops monitoring and frees buffered data, returning this
 object to its initial state.]]>
      </doc>
    </method>
    <method name="createRecord" return="org.apache.hadoop.metrics.MetricsRecord"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="recordName" type="java.lang.String"/>
      <doc>
      <![CDATA[Creates a new AbstractMetricsRecord instance with the given <code>recordName</code>.
 Throws an exception if the metrics implementation is configured with a fixed
 set of record names and <code>recordName</code> is not in that set.
 
 @param recordName the name of the record
 @throws MetricsException if recordName conflicts with configuration data]]>
      </doc>
    </method>
    <method name="newRecord" return="org.apache.hadoop.metrics.MetricsRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="recordName" type="java.lang.String"/>
      <doc>
      <![CDATA[Subclasses should override this if they subclass MetricsRecordImpl.
 @param recordName the name of the record
 @return newly created instance of MetricsRecordImpl or subclass]]>
      </doc>
    </method>
    <method name="registerUpdater"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="updater" type="org.apache.hadoop.metrics.Updater"/>
      <doc>
      <![CDATA[Registers a callback to be called at time intervals determined by
 the configuration.

 @param updater object to be run periodically; it should update
 some metrics records]]>
      </doc>
    </method>
    <method name="unregisterUpdater"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="updater" type="org.apache.hadoop.metrics.Updater"/>
      <doc>
      <![CDATA[Removes a callback, if it exists.

 @param updater object to be removed from the callback list]]>
      </doc>
    </method>
    <method name="getAllRecords" return="java.util.Map"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Retrieves all the records managed by this MetricsContext.
 Useful for monitoring systems that are polling-based.
 @return A non-null collection of all monitoring records.]]>
      </doc>
    </method>
    <method name="emitRecord"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="recordName" type="java.lang.String"/>
      <param name="outRec" type="org.apache.hadoop.metrics.spi.OutputRecord"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Sends a record to the metrics system.]]>
      </doc>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Called each period after all records have been emitted, this method does nothing.
 Subclasses may override it in order to perform some kind of flush.]]>
      </doc>
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics.spi.MetricsRecordImpl"/>
      <doc>
      <![CDATA[Called by MetricsRecordImpl.update().  Creates or updates a row in
 the internal table of metric data.]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics.spi.MetricsRecordImpl"/>
      <doc>
      <![CDATA[Called by MetricsRecordImpl.remove().  Removes all matching rows in
 the internal table of metric data.  A row matches if it has the same
 tag names and values as record, but it may also have additional
 tags.]]>
      </doc>
    </method>
    <method name="getPeriod" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the timer period.]]>
      </doc>
    </method>
    <method name="setPeriod"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="period" type="int"/>
      <doc>
      <![CDATA[Sets the timer period]]>
      </doc>
    </method>
    <method name="parseAndSetPeriod"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="attributeName" type="java.lang.String"/>
      <doc>
      <![CDATA[If a period is set in the attribute passed in, override
 the default with it.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The main class of the Service Provider Interface.  This class should be
 extended in order to integrate the Metrics API with a specific metrics
 client library. <p/>

 This class implements the internal table of metric data, and the timer
 on which data is to be sent to the metrics system.  Subclasses must
 override the abstract <code>emitRecord</code> method in order to transmit
 the data. <p/>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.spi.AbstractMetricsContext -->
  <!-- start class org.apache.hadoop.metrics.spi.CompositeContext -->
  <class name="CompositeContext" extends="org.apache.hadoop.metrics.spi.AbstractMetricsContext"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CompositeContext"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="factory" type="org.apache.hadoop.metrics.ContextFactory"/>
    </method>
    <method name="newRecord" return="org.apache.hadoop.metrics.MetricsRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recordName" type="java.lang.String"/>
    </method>
    <method name="emitRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="recordName" type="java.lang.String"/>
      <param name="outRec" type="org.apache.hadoop.metrics.spi.OutputRecord"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startMonitoring"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="stopMonitoring"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isMonitoring" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return true if all subcontexts are monitoring.]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="registerUpdater"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="updater" type="org.apache.hadoop.metrics.Updater"/>
    </method>
    <method name="unregisterUpdater"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="updater" type="org.apache.hadoop.metrics.Updater"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.metrics.spi.CompositeContext -->
  <!-- start class org.apache.hadoop.metrics.spi.MetricsRecordImpl -->
  <class name="MetricsRecordImpl" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics.MetricsRecord"/>
    <constructor name="MetricsRecordImpl" type="java.lang.String, org.apache.hadoop.metrics.spi.AbstractMetricsContext"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of FileRecord]]>
      </doc>
    </constructor>
    <method name="getRecordName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the record name. 

 @return the record name]]>
      </doc>
    </method>
    <method name="setTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagName" type="java.lang.String"/>
      <param name="tagValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the named tag to the specified value.

 @param tagName name of the tag
 @param tagValue new value of the tag
 @throws MetricsException if the tagName conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagName" type="java.lang.String"/>
      <param name="tagValue" type="int"/>
      <doc>
      <![CDATA[Sets the named tag to the specified value.

 @param tagName name of the tag
 @param tagValue new value of the tag
 @throws MetricsException if the tagName conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagName" type="java.lang.String"/>
      <param name="tagValue" type="long"/>
      <doc>
      <![CDATA[Sets the named tag to the specified value.

 @param tagName name of the tag
 @param tagValue new value of the tag
 @throws MetricsException if the tagName conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagName" type="java.lang.String"/>
      <param name="tagValue" type="short"/>
      <doc>
      <![CDATA[Sets the named tag to the specified value.

 @param tagName name of the tag
 @param tagValue new value of the tag
 @throws MetricsException if the tagName conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagName" type="java.lang.String"/>
      <param name="tagValue" type="byte"/>
      <doc>
      <![CDATA[Sets the named tag to the specified value.

 @param tagName name of the tag
 @param tagValue new value of the tag
 @throws MetricsException if the tagName conflicts with the configuration]]>
      </doc>
    </method>
    <method name="removeTag"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagName" type="java.lang.String"/>
      <doc>
      <![CDATA[Removes any tag of the specified name.]]>
      </doc>
    </method>
    <method name="setMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="int"/>
      <doc>
      <![CDATA[Sets the named metric to the specified value.

 @param metricName name of the metric
 @param metricValue new value of the metric
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="long"/>
      <doc>
      <![CDATA[Sets the named metric to the specified value.

 @param metricName name of the metric
 @param metricValue new value of the metric
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="short"/>
      <doc>
      <![CDATA[Sets the named metric to the specified value.

 @param metricName name of the metric
 @param metricValue new value of the metric
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="byte"/>
      <doc>
      <![CDATA[Sets the named metric to the specified value.

 @param metricName name of the metric
 @param metricValue new value of the metric
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="setMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="float"/>
      <doc>
      <![CDATA[Sets the named metric to the specified value.

 @param metricName name of the metric
 @param metricValue new value of the metric
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="incrMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="int"/>
      <doc>
      <![CDATA[Increments the named metric by the specified value.

 @param metricName name of the metric
 @param metricValue incremental value
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="incrMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="long"/>
      <doc>
      <![CDATA[Increments the named metric by the specified value.

 @param metricName name of the metric
 @param metricValue incremental value
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="incrMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="short"/>
      <doc>
      <![CDATA[Increments the named metric by the specified value.

 @param metricName name of the metric
 @param metricValue incremental value
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="incrMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="byte"/>
      <doc>
      <![CDATA[Increments the named metric by the specified value.

 @param metricName name of the metric
 @param metricValue incremental value
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="incrMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <param name="metricValue" type="float"/>
      <doc>
      <![CDATA[Increments the named metric by the specified value.

 @param metricName name of the metric
 @param metricValue incremental value
 @throws MetricsException if the metricName or the type of the metricValue 
 conflicts with the configuration]]>
      </doc>
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Updates the table of buffered data which is to be sent periodically.
 If the tag values match an existing row, that row is updated; 
 otherwise, a new row is added.]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Removes the row, if it exists, in the buffered data table having tags 
 that equal the tags that have been set on this record.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An implementation of MetricsRecord.  Keeps a back-pointer to the context
 from which it was created, and delegates back to it on <code>update</code>
 and <code>remove()</code>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.spi.MetricsRecordImpl -->
  <!-- start class org.apache.hadoop.metrics.spi.MetricValue -->
  <class name="MetricValue" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricValue" type="java.lang.Number, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of MetricValue]]>
      </doc>
    </constructor>
    <method name="isIncrement" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isAbsolute" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getNumber" return="java.lang.Number"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="ABSOLUTE" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INCREMENT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A Number that is either an absolute or an incremental amount.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.spi.MetricValue -->
  <!-- start class org.apache.hadoop.metrics.spi.NoEmitMetricsContext -->
  <class name="NoEmitMetricsContext" extends="org.apache.hadoop.metrics.spi.AbstractMetricsContext"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NoEmitMetricsContext"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of NullContextWithUpdateThread]]>
      </doc>
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="factory" type="org.apache.hadoop.metrics.ContextFactory"/>
    </method>
    <method name="emitRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="recordName" type="java.lang.String"/>
      <param name="outRec" type="org.apache.hadoop.metrics.spi.OutputRecord"/>
      <doc>
      <![CDATA[Do-nothing version of emitRecord]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A MetricsContext that does not emit data, but, unlike NullContextWithUpdate,
 does save it for retrieval with getAllRecords().
 
 This is useful if you want to support {@link MetricsServlet}, but
 not emit metrics in any other way.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.spi.NoEmitMetricsContext -->
  <!-- start class org.apache.hadoop.metrics.spi.NullContext -->
  <class name="NullContext" extends="org.apache.hadoop.metrics.spi.AbstractMetricsContext"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NullContext"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of NullContext]]>
      </doc>
    </constructor>
    <method name="startMonitoring"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Do-nothing version of startMonitoring]]>
      </doc>
    </method>
    <method name="emitRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="recordName" type="java.lang.String"/>
      <param name="outRec" type="org.apache.hadoop.metrics.spi.OutputRecord"/>
      <doc>
      <![CDATA[Do-nothing version of emitRecord]]>
      </doc>
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics.spi.MetricsRecordImpl"/>
      <doc>
      <![CDATA[Do-nothing version of update]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics.spi.MetricsRecordImpl"/>
      <doc>
      <![CDATA[Do-nothing version of remove]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Null metrics context: a metrics context which does nothing.  Used as the
 default context, so that no performance data is emitted if no configuration
 data is found.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.spi.NullContext -->
  <!-- start class org.apache.hadoop.metrics.spi.NullContextWithUpdateThread -->
  <class name="NullContextWithUpdateThread" extends="org.apache.hadoop.metrics.spi.AbstractMetricsContext"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NullContextWithUpdateThread"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of NullContextWithUpdateThread]]>
      </doc>
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="factory" type="org.apache.hadoop.metrics.ContextFactory"/>
    </method>
    <method name="emitRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="contextName" type="java.lang.String"/>
      <param name="recordName" type="java.lang.String"/>
      <param name="outRec" type="org.apache.hadoop.metrics.spi.OutputRecord"/>
      <doc>
      <![CDATA[Do-nothing version of emitRecord]]>
      </doc>
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics.spi.MetricsRecordImpl"/>
      <doc>
      <![CDATA[Do-nothing version of update]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics.spi.MetricsRecordImpl"/>
      <doc>
      <![CDATA[Do-nothing version of remove]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A null context which has a thread calling 
 periodically when monitoring is started. This keeps the data sampled 
 correctly.
 In all other respects, this is like the NULL context: No data is emitted.
 This is suitable for Monitoring systems like JMX which reads the metrics
  when someone reads the data from JMX.
 
 The default impl of start and stop monitoring:
  is the AbstractMetricsContext is good enough.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.spi.NullContextWithUpdateThread -->
  <!-- start class org.apache.hadoop.metrics.spi.OutputRecord -->
  <class name="OutputRecord" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getTagNames" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the set of tag names]]>
      </doc>
    </method>
    <method name="getTag" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a tag object which is can be a String, Integer, Short or Byte.

 @return the tag value, or null if there is no such tag]]>
      </doc>
    </method>
    <method name="getMetricNames" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the set of metric names.]]>
      </doc>
    </method>
    <method name="getMetric" return="java.lang.Number"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the metric object which can be a Float, Integer, Short or Byte.]]>
      </doc>
    </method>
    <method name="getTagsCopy" return="org.apache.hadoop.metrics.spi.AbstractMetricsContext.TagMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a copy of this record's tags.]]>
      </doc>
    </method>
    <method name="getMetricsCopy" return="org.apache.hadoop.metrics.spi.AbstractMetricsContext.MetricMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a copy of this record's metrics.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents a record of metric data to be sent to a metrics system.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.spi.OutputRecord -->
  <!-- start class org.apache.hadoop.metrics.spi.Util -->
  <class name="Util" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="parse" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="specs" type="java.lang.String"/>
      <param name="defaultPort" type="int"/>
      <doc>
      <![CDATA[Parses a space and/or comma separated sequence of server specifications
 of the form <i>hostname</i> or <i>hostname:port</i>.  If 
 the specs string is null, defaults to localhost:defaultPort.
 
 @return a list of InetSocketAddress objects.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Static utility methods]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics.spi.Util -->
  <doc>
  <![CDATA[The Service Provider Interface for the Metrics API.  This package provides
an interface allowing a variety of metrics reporting implementations to be
plugged in to the Metrics API.  Examples of such implementations can be found 
in the packages <code>org.apache.hadoop.metrics.file</code> and
<code>org.apache.hadoop.metrics.ganglia</code>.<p/>

Plugging in an implementation involves writing a concrete subclass of 
<code>AbstractMetricsContext</code>.  The subclass should get its
 configuration information using the <code>getAttribute(<i>attributeName</i>)</code>
 method.]]>
  </doc>
</package>
<package name="org.apache.hadoop.metrics2">
  <!-- start class org.apache.hadoop.metrics2.AbstractMetric -->
  <class name="AbstractMetric" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics2.MetricsInfo"/>
    <constructor name="AbstractMetric" type="org.apache.hadoop.metrics2.MetricsInfo"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the metric
 @param info  about the metric]]>
      </doc>
    </constructor>
    <method name="name" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="description" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="info" return="org.apache.hadoop.metrics2.MetricsInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="value" return="java.lang.Number"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the value of the metric
 @return the value of the metric]]>
      </doc>
    </method>
    <method name="type" return="org.apache.hadoop.metrics2.MetricType"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type of the metric
 @return the type of the metric]]>
      </doc>
    </method>
    <method name="visit"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="org.apache.hadoop.metrics2.MetricsVisitor"/>
      <doc>
      <![CDATA[Accept a visitor interface
 @param visitor of the metric]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[The immutable metric]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.AbstractMetric -->
  <!-- start interface org.apache.hadoop.metrics2.MetricsCollector -->
  <interface name="MetricsCollector"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="addRecord" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a metrics record
 @param name  of the record
 @return  a metrics record builder for the record]]>
      </doc>
    </method>
    <method name="addRecord" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <doc>
      <![CDATA[Add a metrics record
 @param info  of the record
 @return  a metrics record builder for the record]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The metrics collector interface]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.metrics2.MetricsCollector -->
  <!-- start class org.apache.hadoop.metrics2.MetricsException -->
  <class name="MetricsException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricsException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the exception with a message
 @param message for the exception]]>
      </doc>
    </constructor>
    <constructor name="MetricsException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the exception with a message and a cause
 @param message for the exception
 @param cause of the exception]]>
      </doc>
    </constructor>
    <constructor name="MetricsException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the exception with a cause
 @param cause of the exception]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A general metrics exception wrapper]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.MetricsException -->
  <!-- start class org.apache.hadoop.metrics2.MetricsFilter -->
  <class name="MetricsFilter" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics2.MetricsPlugin"/>
    <constructor name="MetricsFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="accepts" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Whether to accept the name
 @param name  to filter on
 @return  true to accept; false otherwise.]]>
      </doc>
    </method>
    <method name="accepts" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="org.apache.hadoop.metrics2.MetricsTag"/>
      <doc>
      <![CDATA[Whether to accept the tag
 @param tag to filter on
 @return  true to accept; false otherwise]]>
      </doc>
    </method>
    <method name="accepts" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tags" type="java.lang.Iterable"/>
      <doc>
      <![CDATA[Whether to accept the tags
 @param tags to filter on
 @return  true to accept; false otherwise]]>
      </doc>
    </method>
    <method name="accepts" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics2.MetricsRecord"/>
      <doc>
      <![CDATA[Whether to accept the record
 @param record  to filter on
 @return  true to accept; false otherwise.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The metrics filter interface]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.MetricsFilter -->
  <!-- start interface org.apache.hadoop.metrics2.MetricsInfo -->
  <interface name="MetricsInfo"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="name" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the name of the metric/tag]]>
      </doc>
    </method>
    <method name="description" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the description of the metric/tag]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface to provide immutable meta info for metrics]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.metrics2.MetricsInfo -->
  <!-- start interface org.apache.hadoop.metrics2.MetricsPlugin -->
  <interface name="MetricsPlugin"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.commons.configuration.SubsetConfiguration"/>
      <doc>
      <![CDATA[Initialize the plugin
 @param conf  the configuration object for the plugin]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The plugin interface for the metrics framework]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.metrics2.MetricsPlugin -->
  <!-- start interface org.apache.hadoop.metrics2.MetricsRecord -->
  <interface name="MetricsRecord"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="timestamp" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the timestamp of the metrics
 @return  the timestamp]]>
      </doc>
    </method>
    <method name="name" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the record name]]>
      </doc>
    </method>
    <method name="description" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the description of the record]]>
      </doc>
    </method>
    <method name="context" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the context name of the record]]>
      </doc>
    </method>
    <method name="tags" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the tags of the record
 Note: returning a collection instead of iterable as we
 need to use tags as keys (hence Collection#hashCode etc.) in maps
 @return an unmodifiable collection of tags]]>
      </doc>
    </method>
    <method name="metrics" return="java.lang.Iterable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the metrics of the record
 @return an immutable iterable interface for metrics]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An immutable snapshot of metrics with a timestamp]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.metrics2.MetricsRecord -->
  <!-- start class org.apache.hadoop.metrics2.MetricsRecordBuilder -->
  <class name="MetricsRecordBuilder" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricsRecordBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="tag" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a metrics tag
 @param info  metadata of the tag
 @param value of the tag
 @return self]]>
      </doc>
    </method>
    <method name="add" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="org.apache.hadoop.metrics2.MetricsTag"/>
      <doc>
      <![CDATA[Add an immutable metrics tag object
 @param tag a pre-made tag object (potentially save an object construction)
 @return self]]>
      </doc>
    </method>
    <method name="add" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metric" type="org.apache.hadoop.metrics2.AbstractMetric"/>
      <doc>
      <![CDATA[Add a pre-made immutable metric object
 @param metric  the pre-made metric to save an object construction
 @return self]]>
      </doc>
    </method>
    <method name="setContext" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the context tag
 @param value of the context
 @return self]]>
      </doc>
    </method>
    <method name="addCounter" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Add an integer metric
 @param info  metadata of the metric
 @param value of the metric
 @return self]]>
      </doc>
    </method>
    <method name="addCounter" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Add an long metric
 @param info  metadata of the metric
 @param value of the metric
 @return self]]>
      </doc>
    </method>
    <method name="addGauge" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Add a integer gauge metric
 @param info  metadata of the metric
 @param value of the metric
 @return self]]>
      </doc>
    </method>
    <method name="addGauge" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Add a long gauge metric
 @param info  metadata of the metric
 @param value of the metric
 @return self]]>
      </doc>
    </method>
    <method name="addGauge" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Add a float gauge metric
 @param info  metadata of the metric
 @param value of the metric
 @return self]]>
      </doc>
    </method>
    <method name="addGauge" return="org.apache.hadoop.metrics2.MetricsRecordBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Add a double gauge metric
 @param info  metadata of the metric
 @param value of the metric
 @return self]]>
      </doc>
    </method>
    <method name="parent" return="org.apache.hadoop.metrics2.MetricsCollector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the parent metrics collector object]]>
      </doc>
    </method>
    <method name="endRecord" return="org.apache.hadoop.metrics2.MetricsCollector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Syntactic sugar to add multiple records in a collector in a one liner.
 @return the parent metrics collector object]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The metrics record builder interface]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.MetricsRecordBuilder -->
  <!-- start interface org.apache.hadoop.metrics2.MetricsSink -->
  <interface name="MetricsSink"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics2.MetricsPlugin"/>
    <method name="putMetrics"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics2.MetricsRecord"/>
      <doc>
      <![CDATA[Put a metrics record in the sink
 @param record  the record to put]]>
      </doc>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Flush any buffered metrics]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The metrics sink interface. <p>
 Implementations of this interface consume the {@link MetricsRecord} generated
 from {@link MetricsSource}. It registers with {@link MetricsSystem} which
 periodically pushes the {@link MetricsRecord} to the sink using
 {@link #putMetrics(MetricsRecord)} method.  If the implementing class also
 implements {@link Closeable}, then the MetricsSystem will close the sink when
 it is stopped.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.metrics2.MetricsSink -->
  <!-- start interface org.apache.hadoop.metrics2.MetricsSource -->
  <interface name="MetricsSource"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getMetrics"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collector" type="org.apache.hadoop.metrics2.MetricsCollector"/>
      <param name="all" type="boolean"/>
      <doc>
      <![CDATA[Get metrics from the source
 @param collector to contain the resulting metrics snapshot
 @param all if true, return all metrics even if unchanged.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The metrics source interface]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.metrics2.MetricsSource -->
  <!-- start class org.apache.hadoop.metrics2.MetricsSystem -->
  <class name="MetricsSystem" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics2.MetricsSystemMXBean"/>
    <constructor name="MetricsSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init" return="org.apache.hadoop.metrics2.MetricsSystem"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
    </method>
    <method name="register" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="source" type="T"/>
      <doc>
      <![CDATA[Register a metrics source
 @param <T>   the actual type of the source object
 @param source object to register
 @param name  of the source. Must be unique or null (then extracted from
              the annotations of the source object.)
 @param desc  the description of the source (or null. See above.)
 @return the source object
 @exception MetricsException]]>
      </doc>
    </method>
    <method name="unregisterSource"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Unregister a metrics source
 @param name of the source. This is the name you use to call register()]]>
      </doc>
    </method>
    <method name="register" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="T"/>
      <doc>
      <![CDATA[Register a metrics source (deriving name and description from the object)
 @param <T>   the actual type of the source object
 @param source  object to register
 @return  the source object
 @exception MetricsException]]>
      </doc>
    </method>
    <method name="getSource" return="org.apache.hadoop.metrics2.MetricsSource"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[@param name  of the metrics source
 @return the metrics source (potentially wrapped) object]]>
      </doc>
    </method>
    <method name="register" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="sink" type="T"/>
      <doc>
      <![CDATA[Register a metrics sink
 @param <T>   the type of the sink
 @param sink  to register
 @param name  of the sink. Must be unique.
 @param desc  the description of the sink
 @return the sink
 @exception MetricsException]]>
      </doc>
    </method>
    <method name="register"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callback" type="org.apache.hadoop.metrics2.MetricsSystem.Callback"/>
      <doc>
      <![CDATA[Register a callback interface for JMX events
 @param callback  the callback object implementing the MBean interface.]]>
      </doc>
    </method>
    <method name="publishMetricsNow"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Requests an immediate publish of all metrics from sources to sinks.
 
 This is a "soft" request: the expectation is that a best effort will be
 done to synchronously snapshot the metrics from all the sources and put
 them in all the sinks (including flushing the sinks) before returning to
 the caller. If this can't be accomplished in reasonable time it's OK to
 return to the caller before everything is done.]]>
      </doc>
    </method>
    <method name="shutdown" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shutdown the metrics system completely (usually during server shutdown.)
 The MetricsSystemMXBean will be unregistered.
 @return true if shutdown completed]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The metrics system interface]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.MetricsSystem -->
  <!-- start class org.apache.hadoop.metrics2.MetricsSystem.AbstractCallback -->
  <class name="MetricsSystem.AbstractCallback" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics2.MetricsSystem.Callback"/>
    <constructor name="MetricsSystem.AbstractCallback"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="preStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="postStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="preStop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="postStop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Convenient abstract class for implementing callback interface]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.MetricsSystem.AbstractCallback -->
  <!-- start interface org.apache.hadoop.metrics2.MetricsSystem.Callback -->
  <interface name="MetricsSystem.Callback"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="preStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Called before start()]]>
      </doc>
    </method>
    <method name="postStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Called after start()]]>
      </doc>
    </method>
    <method name="preStop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Called before stop()]]>
      </doc>
    </method>
    <method name="postStop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Called after stop()]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The metrics system callback interface (needed for proxies.)]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.metrics2.MetricsSystem.Callback -->
  <!-- start interface org.apache.hadoop.metrics2.MetricsSystemMXBean -->
  <interface name="MetricsSystemMXBean"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Start the metrics system
 @throws MetricsException]]>
      </doc>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stop the metrics system
 @throws MetricsException]]>
      </doc>
    </method>
    <method name="startMetricsMBeans"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Start metrics MBeans
 @throws MetricsException]]>
      </doc>
    </method>
    <method name="stopMetricsMBeans"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stop metrics MBeans.
 Note, it doesn't stop the metrics system control MBean,
 i.e this interface.
 @throws MetricsException]]>
      </doc>
    </method>
    <method name="currentConfig" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the current config
 Avoided getConfig, as it'll turn into a "Config" attribute,
 which doesn't support multiple line values in jconsole.
 @throws MetricsException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The JMX interface to the metrics system]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.metrics2.MetricsSystemMXBean -->
  <!-- start class org.apache.hadoop.metrics2.MetricsTag -->
  <class name="MetricsTag" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics2.MetricsInfo"/>
    <constructor name="MetricsTag" type="org.apache.hadoop.metrics2.MetricsInfo, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the tag with name, description and value
 @param info  of the tag
 @param value of the tag]]>
      </doc>
    </constructor>
    <method name="name" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="description" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="info" return="org.apache.hadoop.metrics2.MetricsInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the info object of the tag]]>
      </doc>
    </method>
    <method name="value" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the value of the tag
 @return  the value]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Immutable tag for metrics (for grouping on host/queue/username etc.)]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.MetricsTag -->
  <!-- start interface org.apache.hadoop.metrics2.MetricsVisitor -->
  <interface name="MetricsVisitor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="gauge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Callback for integer value gauges
 @param info  the metric info
 @param value of the metric]]>
      </doc>
    </method>
    <method name="gauge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Callback for long value gauges
 @param info  the metric info
 @param value of the metric]]>
      </doc>
    </method>
    <method name="gauge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Callback for float value gauges
 @param info  the metric info
 @param value of the metric]]>
      </doc>
    </method>
    <method name="gauge"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Callback for double value gauges
 @param info  the metric info
 @param value of the metric]]>
      </doc>
    </method>
    <method name="counter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Callback for integer value counters
 @param info  the metric info
 @param value of the metric]]>
      </doc>
    </method>
    <method name="counter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Callback for long value counters
 @param info  the metric info
 @param value of the metric]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A visitor interface for metrics]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.metrics2.MetricsVisitor -->
  <!-- start class org.apache.hadoop.metrics2.MetricType -->
  <class name="MetricType" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.metrics2.MetricType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.metrics2.MetricType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.metrics2.MetricType -->
</package>
<package name="org.apache.hadoop.metrics2.annotation">
  <!-- start class org.apache.hadoop.metrics2.annotation.Metric -->
  <class name="Metric"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotation interface for a single metric]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.annotation.Metric -->
  <!-- start class org.apache.hadoop.metrics2.annotation.Metric.Type -->
  <class name="Metric.Type" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.metrics2.annotation.Metric.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.metrics2.annotation.Metric.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.metrics2.annotation.Metric.Type -->
  <!-- start class org.apache.hadoop.metrics2.annotation.Metrics -->
  <class name="Metrics"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotation interface for a group of metrics]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.annotation.Metrics -->
</package>
<package name="org.apache.hadoop.metrics2.filter">
  <!-- start class org.apache.hadoop.metrics2.filter.GlobFilter -->
  <class name="GlobFilter" extends="org.apache.hadoop.metrics2.filter.AbstractPatternFilter"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GlobFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compile" return="java.util.regex.Pattern"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[A glob pattern filter for metrics.

 The class name is used in metrics config files]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.filter.GlobFilter -->
  <!-- start class org.apache.hadoop.metrics2.filter.RegexFilter -->
  <class name="RegexFilter" extends="org.apache.hadoop.metrics2.filter.AbstractPatternFilter"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="RegexFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compile" return="java.util.regex.Pattern"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[A regex pattern filter for metrics]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.filter.RegexFilter -->
</package>
<package name="org.apache.hadoop.metrics2.lib">
  <!-- start class org.apache.hadoop.metrics2.lib.DefaultMetricsSystem -->
  <class name="DefaultMetricsSystem" extends="java.lang.Enum"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.metrics2.lib.DefaultMetricsSystem[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.metrics2.lib.DefaultMetricsSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="initialize" return="org.apache.hadoop.metrics2.MetricsSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prefix" type="java.lang.String"/>
      <doc>
      <![CDATA[Convenience method to initialize the metrics system
 @param prefix  for the metrics system configuration
 @return the metrics system instance]]>
      </doc>
    </method>
    <method name="instance" return="org.apache.hadoop.metrics2.MetricsSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the metrics system object]]>
      </doc>
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shutdown the metrics system]]>
      </doc>
    </method>
    <method name="setInstance" return="org.apache.hadoop.metrics2.MetricsSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ms" type="org.apache.hadoop.metrics2.MetricsSystem"/>
    </method>
    <method name="setMiniClusterMode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="choice" type="boolean"/>
    </method>
    <method name="inMiniClusterMode" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="newMBeanName" return="javax.management.ObjectName"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="removeMBeanName"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="javax.management.ObjectName"/>
    </method>
    <method name="sourceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="dupOK" type="boolean"/>
    </method>
    <doc>
    <![CDATA[The default metrics system singleton]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.DefaultMetricsSystem -->
  <!-- start class org.apache.hadoop.metrics2.lib.Interns -->
  <class name="Interns" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Interns"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="info" return="org.apache.hadoop.metrics2.MetricsInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="description" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a metric info object
 @param name
 @param description
 @return an interned metric info object]]>
      </doc>
    </method>
    <method name="tag" return="org.apache.hadoop.metrics2.MetricsTag"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a metrics tag
 @param info  of the tag
 @param value of the tag
 @return an interned metrics tag]]>
      </doc>
    </method>
    <method name="tag" return="org.apache.hadoop.metrics2.MetricsTag"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="description" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a metrics tag
 @param name  of the tag
 @param description of the tag
 @param value of the tag
 @return an interned metrics tag]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Helpers to create interned metrics info]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.Interns -->
  <!-- start class org.apache.hadoop.metrics2.lib.MetricsRegistry -->
  <class name="MetricsRegistry" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricsRegistry" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the registry with a record name
 @param name  of the record of the metrics]]>
      </doc>
    </constructor>
    <constructor name="MetricsRegistry" type="org.apache.hadoop.metrics2.MetricsInfo"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the registry with a metadata object
 @param info  the info object for the metrics record/group]]>
      </doc>
    </constructor>
    <method name="info" return="org.apache.hadoop.metrics2.MetricsInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the info object of the metrics registry]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.metrics2.lib.MutableMetric"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a metric by name
 @param name  of the metric
 @return the metric object]]>
      </doc>
    </method>
    <method name="getTag" return="org.apache.hadoop.metrics2.MetricsTag"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a tag by name
 @param name  of the tag
 @return the tag object]]>
      </doc>
    </method>
    <method name="newCounter" return="org.apache.hadoop.metrics2.lib.MutableCounterInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="iVal" type="int"/>
      <doc>
      <![CDATA[Create a mutable integer counter
 @param name  of the metric
 @param desc  metric description
 @param iVal  initial value
 @return a new counter object]]>
      </doc>
    </method>
    <method name="newCounter" return="org.apache.hadoop.metrics2.lib.MutableCounterInt"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="iVal" type="int"/>
      <doc>
      <![CDATA[Create a mutable integer counter
 @param info  metadata of the metric
 @param iVal  initial value
 @return a new counter object]]>
      </doc>
    </method>
    <method name="newCounter" return="org.apache.hadoop.metrics2.lib.MutableCounterLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="iVal" type="long"/>
      <doc>
      <![CDATA[Create a mutable long integer counter
 @param name  of the metric
 @param desc  metric description
 @param iVal  initial value
 @return a new counter object]]>
      </doc>
    </method>
    <method name="newCounter" return="org.apache.hadoop.metrics2.lib.MutableCounterLong"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="iVal" type="long"/>
      <doc>
      <![CDATA[Create a mutable long integer counter
 @param info  metadata of the metric
 @param iVal  initial value
 @return a new counter object]]>
      </doc>
    </method>
    <method name="newGauge" return="org.apache.hadoop.metrics2.lib.MutableGaugeInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="iVal" type="int"/>
      <doc>
      <![CDATA[Create a mutable integer gauge
 @param name  of the metric
 @param desc  metric description
 @param iVal  initial value
 @return a new gauge object]]>
      </doc>
    </method>
    <method name="newGauge" return="org.apache.hadoop.metrics2.lib.MutableGaugeInt"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="iVal" type="int"/>
      <doc>
      <![CDATA[Create a mutable integer gauge
 @param info  metadata of the metric
 @param iVal  initial value
 @return a new gauge object]]>
      </doc>
    </method>
    <method name="newGauge" return="org.apache.hadoop.metrics2.lib.MutableGaugeLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="iVal" type="long"/>
      <doc>
      <![CDATA[Create a mutable long integer gauge
 @param name  of the metric
 @param desc  metric description
 @param iVal  initial value
 @return a new gauge object]]>
      </doc>
    </method>
    <method name="newGauge" return="org.apache.hadoop.metrics2.lib.MutableGaugeLong"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="iVal" type="long"/>
      <doc>
      <![CDATA[Create a mutable long integer gauge
 @param info  metadata of the metric
 @param iVal  initial value
 @return a new gauge object]]>
      </doc>
    </method>
    <method name="newQuantiles" return="org.apache.hadoop.metrics2.lib.MutableQuantiles"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="sampleName" type="java.lang.String"/>
      <param name="valueName" type="java.lang.String"/>
      <param name="interval" type="int"/>
      <doc>
      <![CDATA[Create a mutable metric that estimates quantiles of a stream of values
 @param name of the metric
 @param desc metric description
 @param sampleName of the metric (e.g., "Ops")
 @param valueName of the metric (e.g., "Time" or "Latency")
 @param interval rollover interval of estimator in seconds
 @return a new quantile estimator object]]>
      </doc>
    </method>
    <method name="newStat" return="org.apache.hadoop.metrics2.lib.MutableStat"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="sampleName" type="java.lang.String"/>
      <param name="valueName" type="java.lang.String"/>
      <param name="extended" type="boolean"/>
      <doc>
      <![CDATA[Create a mutable metric with stats
 @param name  of the metric
 @param desc  metric description
 @param sampleName  of the metric (e.g., "Ops")
 @param valueName   of the metric (e.g., "Time" or "Latency")
 @param extended    produce extended stat (stdev, min/max etc.) if true.
 @return a new mutable stat metric object]]>
      </doc>
    </method>
    <method name="newStat" return="org.apache.hadoop.metrics2.lib.MutableStat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="sampleName" type="java.lang.String"/>
      <param name="valueName" type="java.lang.String"/>
      <doc>
      <![CDATA[Create a mutable metric with stats
 @param name  of the metric
 @param desc  metric description
 @param sampleName  of the metric (e.g., "Ops")
 @param valueName   of the metric (e.g., "Time" or "Latency")
 @return a new mutable metric object]]>
      </doc>
    </method>
    <method name="newRate" return="org.apache.hadoop.metrics2.lib.MutableRate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Create a mutable rate metric
 @param name  of the metric
 @return a new mutable metric object]]>
      </doc>
    </method>
    <method name="newRate" return="org.apache.hadoop.metrics2.lib.MutableRate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="description" type="java.lang.String"/>
      <doc>
      <![CDATA[Create a mutable rate metric
 @param name  of the metric
 @param description of the metric
 @return a new mutable rate metric object]]>
      </doc>
    </method>
    <method name="newRate" return="org.apache.hadoop.metrics2.lib.MutableRate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="extended" type="boolean"/>
      <doc>
      <![CDATA[Create a mutable rate metric (for throughput measurement)
 @param name  of the metric
 @param desc  description
 @param extended  produce extended stat (stdev/min/max etc.) if true
 @return a new mutable rate metric object]]>
      </doc>
    </method>
    <method name="newRate" return="org.apache.hadoop.metrics2.lib.MutableRate"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="extended" type="boolean"/>
      <param name="returnExisting" type="boolean"/>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Add sample to a stat metric by name.
 @param name  of the metric
 @param value of the snapshot to add]]>
      </doc>
    </method>
    <method name="setContext" return="org.apache.hadoop.metrics2.lib.MetricsRegistry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the metrics context tag
 @param name of the context
 @return the registry itself as a convenience]]>
      </doc>
    </method>
    <method name="tag" return="org.apache.hadoop.metrics2.lib.MetricsRegistry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="description" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a tag to the metrics
 @param name  of the tag
 @param description of the tag
 @param value of the tag
 @return the registry (for keep adding tags)]]>
      </doc>
    </method>
    <method name="tag" return="org.apache.hadoop.metrics2.lib.MetricsRegistry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="description" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <param name="override" type="boolean"/>
      <doc>
      <![CDATA[Add a tag to the metrics
 @param name  of the tag
 @param description of the tag
 @param value of the tag
 @param override  existing tag if true
 @return the registry (for keep adding tags)]]>
      </doc>
    </method>
    <method name="tag" return="org.apache.hadoop.metrics2.lib.MetricsRegistry"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="java.lang.String"/>
      <param name="override" type="boolean"/>
      <doc>
      <![CDATA[Add a tag to the metrics
 @param info  metadata of the tag
 @param value of the tag
 @param override existing tag if true
 @return the registry (for keep adding tags etc.)]]>
      </doc>
    </method>
    <method name="tag" return="org.apache.hadoop.metrics2.lib.MetricsRegistry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="info" type="org.apache.hadoop.metrics2.MetricsInfo"/>
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="snapshot"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <param name="all" type="boolean"/>
      <doc>
      <![CDATA[Sample all the mutable metrics and put the snapshot in the builder
 @param builder to contain the metrics snapshot
 @param all get all the metrics even if the values are not changed.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An optional metrics registry class for creating and maintaining a
 collection of MetricsMutables, making writing metrics source easier.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MetricsRegistry -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableCounter -->
  <class name="MutableCounter" extends="org.apache.hadoop.metrics2.lib.MutableMetric"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MutableCounter" type="org.apache.hadoop.metrics2.MetricsInfo"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="info" return="org.apache.hadoop.metrics2.MetricsInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="incr"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increment the metric value by 1.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The mutable counter (monotonically increasing) metric interface]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableCounter -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableCounterInt -->
  <class name="MutableCounterInt" extends="org.apache.hadoop.metrics2.lib.MutableCounter"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="incr"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="incr"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delta" type="int"/>
      <doc>
      <![CDATA[Increment the value by a delta
 @param delta of the increment]]>
      </doc>
    </method>
    <method name="value" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="snapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <param name="all" type="boolean"/>
    </method>
    <doc>
    <![CDATA[A mutable int counter for implementing metrics sources]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableCounterInt -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableCounterLong -->
  <class name="MutableCounterLong" extends="org.apache.hadoop.metrics2.lib.MutableCounter"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="incr"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="incr"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delta" type="long"/>
      <doc>
      <![CDATA[Increment the value by a delta
 @param delta of the increment]]>
      </doc>
    </method>
    <method name="value" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="snapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <param name="all" type="boolean"/>
    </method>
    <doc>
    <![CDATA[A mutable long counter]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableCounterLong -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableGauge -->
  <class name="MutableGauge" extends="org.apache.hadoop.metrics2.lib.MutableMetric"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MutableGauge" type="org.apache.hadoop.metrics2.MetricsInfo"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="info" return="org.apache.hadoop.metrics2.MetricsInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="incr"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Increment the value of the metric by 1]]>
      </doc>
    </method>
    <method name="decr"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Decrement the value of the metric by 1]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The mutable gauge metric interface]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableGauge -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableGaugeInt -->
  <class name="MutableGaugeInt" extends="org.apache.hadoop.metrics2.lib.MutableGauge"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="value" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="incr"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="incr"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delta" type="int"/>
      <doc>
      <![CDATA[Increment by delta
 @param delta of the increment]]>
      </doc>
    </method>
    <method name="decr"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="decr"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delta" type="int"/>
      <doc>
      <![CDATA[decrement by delta
 @param delta of the decrement]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Set the value of the metric
 @param value to set]]>
      </doc>
    </method>
    <method name="snapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <param name="all" type="boolean"/>
    </method>
    <doc>
    <![CDATA[A mutable int gauge]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableGaugeInt -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableGaugeLong -->
  <class name="MutableGaugeLong" extends="org.apache.hadoop.metrics2.lib.MutableGauge"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="value" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="incr"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="incr"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delta" type="long"/>
      <doc>
      <![CDATA[Increment by delta
 @param delta of the increment]]>
      </doc>
    </method>
    <method name="decr"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="decr"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delta" type="long"/>
      <doc>
      <![CDATA[decrement by delta
 @param delta of the decrement]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Set the value of the metric
 @param value to set]]>
      </doc>
    </method>
    <method name="snapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <param name="all" type="boolean"/>
    </method>
    <doc>
    <![CDATA[A mutable long gauge]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableGaugeLong -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableMetric -->
  <class name="MutableMetric" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MutableMetric"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="snapshot"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <param name="all" type="boolean"/>
      <doc>
      <![CDATA[Get a snapshot of the metric
 @param builder the metrics record builder
 @param all if true, snapshot unchanged metrics as well]]>
      </doc>
    </method>
    <method name="snapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <doc>
      <![CDATA[Get a snapshot of metric if changed
 @param builder the metrics record builder]]>
      </doc>
    </method>
    <method name="setChanged"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Set the changed flag in mutable operations]]>
      </doc>
    </method>
    <method name="clearChanged"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clear the changed flag in the snapshot operations]]>
      </doc>
    </method>
    <method name="changed" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return  true if metric is changed since last snapshot/snapshot]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The mutable metric interface]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableMetric -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableQuantiles -->
  <class name="MutableQuantiles" extends="org.apache.hadoop.metrics2.lib.MutableMetric"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MutableQuantiles" type="java.lang.String, java.lang.String, java.lang.String, java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instantiates a new {@link MutableQuantiles} for a metric that rolls itself
 over on the specified time interval.
 
 @param name
          of the metric
 @param description
          long-form textual description of the metric
 @param sampleName
          type of items in the stream (e.g., "Ops")
 @param valueName
          type of the values
 @param interval
          rollover interval (in seconds) of the estimator]]>
      </doc>
    </constructor>
    <method name="snapshot"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <param name="all" type="boolean"/>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
    </method>
    <method name="getInterval" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="quantiles" type="org.apache.hadoop.metrics2.util.Quantile[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="previousSnapshot" type="java.util.Map"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Watches a stream of long values, maintaining online estimates of specific
 quantiles with provably low error bounds. This is particularly useful for
 accurate high-percentile (e.g. 95th, 99th) latency metrics.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableQuantiles -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableRate -->
  <class name="MutableRate" extends="org.apache.hadoop.metrics2.lib.MutableStat"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[A convenient mutable metric for throughput measurement]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableRate -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableRates -->
  <class name="MutableRates" extends="org.apache.hadoop.metrics2.lib.MutableMetric"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <doc>
      <![CDATA[Initialize the registry with all the methods in a protocol
 so they all show up in the first snapshot.
 Convenient for JMX implementations.
 @param protocol the protocol class]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="elapsed" type="long"/>
      <doc>
      <![CDATA[Add a rate sample for a rate metric
 @param name of the rate metric
 @param elapsed time]]>
      </doc>
    </method>
    <method name="snapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rb" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <param name="all" type="boolean"/>
    </method>
    <doc>
    <![CDATA[Helper class to manage a group of mutable rate metrics]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableRates -->
  <!-- start class org.apache.hadoop.metrics2.lib.MutableStat -->
  <class name="MutableStat" extends="org.apache.hadoop.metrics2.lib.MutableMetric"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MutableStat" type="java.lang.String, java.lang.String, java.lang.String, java.lang.String, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a sample statistics metric
 @param name        of the metric
 @param description of the metric
 @param sampleName  of the metric (e.g. "Ops")
 @param valueName   of the metric (e.g. "Time", "Latency")
 @param extended    create extended stats (stdev, min/max etc.) by default.]]>
      </doc>
    </constructor>
    <constructor name="MutableStat" type="java.lang.String, java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a snapshot stat metric with extended stat off by default
 @param name        of the metric
 @param description of the metric
 @param sampleName  of the metric (e.g. "Ops")
 @param valueName   of the metric (e.g. "Time", "Latency")]]>
      </doc>
    </constructor>
    <method name="setExtended"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="extended" type="boolean"/>
      <doc>
      <![CDATA[Set whether to display the extended stats (stdev, min/max etc.) or not
 @param extended enable/disable displaying extended stats]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="numSamples" type="long"/>
      <param name="sum" type="long"/>
      <doc>
      <![CDATA[Add a number of samples and their sum to the running stat
 @param numSamples  number of samples
 @param sum of the samples]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Add a snapshot to the metric
 @param value of the metric]]>
      </doc>
    </method>
    <method name="snapshot"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="org.apache.hadoop.metrics2.MetricsRecordBuilder"/>
      <param name="all" type="boolean"/>
    </method>
    <method name="resetMinMax"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reset the all time min max of the metric]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A mutable metric with stats.

 Useful for keeping throughput/latency stats.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.lib.MutableStat -->
</package>
<package name="org.apache.hadoop.metrics2.sink">
  <!-- start class org.apache.hadoop.metrics2.sink.FileSink -->
  <class name="FileSink" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics2.MetricsSink"/>
    <implements name="java.io.Closeable"/>
    <constructor name="FileSink"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.commons.configuration.SubsetConfiguration"/>
    </method>
    <method name="putMetrics"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics2.MetricsRecord"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A metrics sink that writes to a file]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.sink.FileSink -->
  <!-- start class org.apache.hadoop.metrics2.sink.GraphiteSink -->
  <class name="GraphiteSink" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics2.MetricsSink"/>
    <implements name="java.io.Closeable"/>
    <constructor name="GraphiteSink"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.commons.configuration.SubsetConfiguration"/>
    </method>
    <method name="putMetrics"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics2.MetricsRecord"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[A metrics sink that writes to a Graphite server]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.sink.GraphiteSink -->
</package>
<package name="org.apache.hadoop.metrics2.sink.ganglia">
  <!-- start class org.apache.hadoop.metrics2.sink.ganglia.AbstractGangliaSink -->
  <class name="AbstractGangliaSink" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.metrics2.MetricsSink"/>
    <constructor name="AbstractGangliaSink"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.commons.configuration.SubsetConfiguration"/>
    </method>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getGangliaConfForMetric" return="org.apache.hadoop.metrics2.sink.ganglia.GangliaConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="metricName" type="java.lang.String"/>
      <doc>
      <![CDATA[Lookup GangliaConf from cache. If not found, return default values

 @param metricName
 @return looked up GangliaConf]]>
      </doc>
    </method>
    <method name="getHostName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the hostName]]>
      </doc>
    </method>
    <method name="xdr_string"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <doc>
      <![CDATA[Puts a string into the buffer by first writing the size of the string as an
 int, followed by the bytes of the string, padded if necessary to a multiple
 of 4.
 @param s the string to be written to buffer at offset location]]>
      </doc>
    </method>
    <method name="xdr_int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <doc>
      <![CDATA[Puts an integer into the buffer as 4 bytes, big-endian.]]>
      </doc>
    </method>
    <method name="emitToGangliaHosts"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Sends Ganglia Metrics to the configured hosts
 @throws IOException]]>
      </doc>
    </method>
    <method name="isSupportSparseMetrics" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return whether sparse metrics are supported]]>
      </doc>
    </method>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_UNITS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_TMAX" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_DMAX" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_SLOPE" type="org.apache.hadoop.metrics2.sink.ganglia.AbstractGangliaSink.GangliaSlope"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_PORT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SERVERS_PROPERTY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BUFFER_SIZE" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SUPPORT_SPARSE_METRICS_PROPERTY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SUPPORT_SPARSE_METRICS_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="EQUAL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="gangliaMetricVisitor" type="org.apache.hadoop.metrics2.sink.ganglia.GangliaMetricVisitor"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Used for visiting Metrics]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This the base class for Ganglia sink classes using metrics2. Lot of the code
 has been derived from org.apache.hadoop.metrics.ganglia.GangliaContext.
 As per the documentation, sink implementations doesn't have to worry about
 thread safety. Hence the code wasn't written for thread safety and should
 be modified in case the above assumption changes in the future.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.sink.ganglia.AbstractGangliaSink -->
  <!-- start class org.apache.hadoop.metrics2.sink.ganglia.AbstractGangliaSink.GangliaConfType -->
  <class name="AbstractGangliaSink.GangliaConfType" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.metrics2.sink.ganglia.AbstractGangliaSink.GangliaConfType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.metrics2.sink.ganglia.AbstractGangliaSink.GangliaConfType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[define enum for various type of conf]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.sink.ganglia.AbstractGangliaSink.GangliaConfType -->
  <!-- start class org.apache.hadoop.metrics2.sink.ganglia.AbstractGangliaSink.GangliaSlope -->
  <class name="AbstractGangliaSink.GangliaSlope" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.metrics2.sink.ganglia.AbstractGangliaSink.GangliaSlope[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.metrics2.sink.ganglia.AbstractGangliaSink.GangliaSlope"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[ganglia slope values which equal the ordinal]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.sink.ganglia.AbstractGangliaSink.GangliaSlope -->
  <!-- start class org.apache.hadoop.metrics2.sink.ganglia.GangliaSink30 -->
  <class name="GangliaSink30" extends="org.apache.hadoop.metrics2.sink.ganglia.AbstractGangliaSink"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GangliaSink30"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.commons.configuration.SubsetConfiguration"/>
    </method>
    <method name="appendPrefix"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics2.MetricsRecord"/>
      <param name="sb" type="java.lang.StringBuilder"/>
    </method>
    <method name="putMetrics"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.apache.hadoop.metrics2.MetricsRecord"/>
    </method>
    <method name="emitMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="groupName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <param name="type" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <param name="gConf" type="org.apache.hadoop.metrics2.sink.ganglia.GangliaConf"/>
      <param name="gSlope" type="org.apache.hadoop.metrics2.sink.ganglia.AbstractGangliaSink.GangliaSlope"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The method sends metrics to Ganglia servers. The method has been taken from
 org.apache.hadoop.metrics.ganglia.GangliaContext30 with minimal changes in
 order to keep it in sync.
 @param groupName The group name of the metric
 @param name The metric name
 @param type The type of the metric
 @param value The value of the metric
 @param gConf The GangliaConf for this metric
 @param gSlope The slope for this metric
 @throws IOException]]>
      </doc>
    </method>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This code supports Ganglia 3.0]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.sink.ganglia.GangliaSink30 -->
  <!-- start class org.apache.hadoop.metrics2.sink.ganglia.GangliaSink31 -->
  <class name="GangliaSink31" extends="org.apache.hadoop.metrics2.sink.ganglia.GangliaSink30"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GangliaSink31"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="emitMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="groupName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <param name="type" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <param name="gConf" type="org.apache.hadoop.metrics2.sink.ganglia.GangliaConf"/>
      <param name="gSlope" type="org.apache.hadoop.metrics2.sink.ganglia.AbstractGangliaSink.GangliaSlope"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The method sends metrics to Ganglia servers. The method has been taken from
 org.apache.hadoop.metrics.ganglia.GangliaContext31 with minimal changes in
 order to keep it in sync.
 @param groupName The group name of the metric
 @param name The metric name
 @param type The type of the metric
 @param value The value of the metric
 @param gConf The GangliaConf for this metric
 @param gSlope The slope for this metric
 @throws IOException]]>
      </doc>
    </method>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[This code supports Ganglia 3.1]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.sink.ganglia.GangliaSink31 -->
</package>
<package name="org.apache.hadoop.metrics2.source">
</package>
<package name="org.apache.hadoop.metrics2.util">
  <!-- start class org.apache.hadoop.metrics2.util.MBeans -->
  <class name="MBeans" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MBeans"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="register" return="javax.management.ObjectName"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serviceName" type="java.lang.String"/>
      <param name="nameName" type="java.lang.String"/>
      <param name="theMbean" type="java.lang.Object"/>
      <doc>
      <![CDATA[Register the MBean using our standard MBeanName format
 "hadoop:service=<serviceName>,name=<nameName>"
 Where the <serviceName> and <nameName> are the supplied parameters

 @param serviceName
 @param nameName
 @param theMbean - the MBean to register
 @return the named used to register the MBean]]>
      </doc>
    </method>
    <method name="unregister"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mbeanName" type="javax.management.ObjectName"/>
    </method>
    <doc>
    <![CDATA[This util class provides a method to register an MBean using
 our standard naming convention as described in the doc
  for {link {@link #register(String, String, Object)}]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.util.MBeans -->
  <!-- start class org.apache.hadoop.metrics2.util.MetricsCache -->
  <class name="MetricsCache" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricsCache"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MetricsCache" type="int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a metrics cache
 @param maxRecsPerName  limit of the number records per record name]]>
      </doc>
    </constructor>
    <method name="update" return="org.apache.hadoop.metrics2.util.MetricsCache.Record"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mr" type="org.apache.hadoop.metrics2.MetricsRecord"/>
      <param name="includingTags" type="boolean"/>
      <doc>
      <![CDATA[Update the cache and return the current cached record
 @param mr the update record
 @param includingTags cache tag values (for later lookup by name) if true
 @return the updated cache record]]>
      </doc>
    </method>
    <method name="update" return="org.apache.hadoop.metrics2.util.MetricsCache.Record"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mr" type="org.apache.hadoop.metrics2.MetricsRecord"/>
      <doc>
      <![CDATA[Update the cache and return the current cache record
 @param mr the update record
 @return the updated cache record]]>
      </doc>
    </method>
    <method name="get" return="org.apache.hadoop.metrics2.util.MetricsCache.Record"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="tags" type="java.util.Collection"/>
      <doc>
      <![CDATA[Get the cached record
 @param name of the record
 @param tags of the record
 @return the cached record or null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A metrics cache for sinks that don't support sparse updates.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.util.MetricsCache -->
  <!-- start class org.apache.hadoop.metrics2.util.MetricsCache.Record -->
  <class name="MetricsCache.Record" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MetricsCache.Record"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getTag" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Lookup a tag value
 @param key name of the tag
 @return the tag value]]>
      </doc>
    </method>
    <method name="getMetric" return="java.lang.Number"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Lookup a metric value
 @param key name of the metric
 @return the metric value]]>
      </doc>
    </method>
    <method name="getMetricInstance" return="org.apache.hadoop.metrics2.AbstractMetric"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Lookup a metric instance
 @param key name of the metric
 @return the metric instance]]>
      </doc>
    </method>
    <method name="tags" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the entry set of the tags of the record]]>
      </doc>
    </method>
    <method name="metrics" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use metricsEntrySet() instead">
      <doc>
      <![CDATA[@deprecated use metricsEntrySet() instead
 @return entry set of metrics]]>
      </doc>
    </method>
    <method name="metricsEntrySet" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return entry set of metrics]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Cached record]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.util.MetricsCache.Record -->
  <!-- start class org.apache.hadoop.metrics2.util.SampleStat.MinMax -->
  <class name="SampleStat.MinMax" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SampleStat.MinMax"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="double"/>
    </method>
    <method name="min" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="max" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="org.apache.hadoop.metrics2.util.SampleStat.MinMax"/>
    </method>
    <doc>
    <![CDATA[Helper to keep running min/max]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.util.SampleStat.MinMax -->
  <!-- start class org.apache.hadoop.metrics2.util.Servers -->
  <class name="Servers" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="parse" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="specs" type="java.lang.String"/>
      <param name="defaultPort" type="int"/>
      <doc>
      <![CDATA[Parses a space and/or comma separated sequence of server specifications
 of the form <i>hostname</i> or <i>hostname:port</i>.  If
 the specs string is null, defaults to localhost:defaultPort.

 @param specs   server specs (see description)
 @param defaultPort the default port if not specified
 @return a list of InetSocketAddress objects.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Helpers to handle server addresses]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.metrics2.util.Servers -->
</package>
<package name="org.apache.hadoop.net">
  <!-- start class org.apache.hadoop.net.AbstractDNSToSwitchMapping -->
  <class name="AbstractDNSToSwitchMapping" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.net.DNSToSwitchMapping"/>
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="AbstractDNSToSwitchMapping"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an unconfigured instance]]>
      </doc>
    </constructor>
    <constructor name="AbstractDNSToSwitchMapping" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance, caching the configuration file.
 This constructor does not call {@link #setConf(Configuration)}; if
 a subclass extracts information in that method, it must call it explicitly.
 @param conf the configuration]]>
      </doc>
    </constructor>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="isSingleSwitch" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Predicate that indicates that the switch mapping is known to be
 single-switch. The base class returns false: it assumes all mappings are
 multi-rack. Subclasses may override this with methods that are more aware
 of their topologies.

 <p/>

 This method is used when parts of Hadoop need know whether to apply
 single rack vs multi-rack policies, such as during block placement.
 Such algorithms behave differently if they are on multi-switch systems.
 </p>

 @return true if the mapping thinks that it is on a single switch]]>
      </doc>
    </method>
    <method name="getSwitchMap" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a copy of the map (for diagnostics)
 @return a clone of the map or null for none known]]>
      </doc>
    </method>
    <method name="dumpTopology" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Generate a string listing the switch mapping implementation,
 the mapping for every known node and the number of nodes and
 unique switches known about -each entry to a separate line.
 @return a string that can be presented to the ops team or used in
 debug messages.]]>
      </doc>
    </method>
    <method name="isSingleSwitchByScriptPolicy" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="isMappingSingleSwitch" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mapping" type="org.apache.hadoop.net.DNSToSwitchMapping"/>
      <doc>
      <![CDATA[Query for a {@link DNSToSwitchMapping} instance being on a single
 switch.
 <p/>
 This predicate simply assumes that all mappings not derived from
 this class are multi-switch.
 @param mapping the mapping to query
 @return true if the base class says it is single switch, or the mapping
 is not derived from this class.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This is a base class for DNS to Switch mappings. <p/> It is not mandatory to
 derive {@link DNSToSwitchMapping} implementations from it, but it is strongly
 recommended, as it makes it easy for the Hadoop developers to add new methods
 to this base class that are automatically picked up by all implementations.
 <p/>

 This class does not extend the <code>Configured</code>
 base class, and should not be changed to do so, as it causes problems
 for subclasses. The constructor of the <code>Configured</code> calls
 the  {@link #setConf(Configuration)} method, which will call into the
 subclasses before they have been fully constructed.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.AbstractDNSToSwitchMapping -->
  <!-- start class org.apache.hadoop.net.CachedDNSToSwitchMapping -->
  <class name="CachedDNSToSwitchMapping" extends="org.apache.hadoop.net.AbstractDNSToSwitchMapping"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CachedDNSToSwitchMapping" type="org.apache.hadoop.net.DNSToSwitchMapping"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[cache a raw DNS mapping
 @param rawMapping the raw mapping to cache]]>
      </doc>
    </constructor>
    <method name="resolve" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.util.List"/>
    </method>
    <method name="getSwitchMap" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the (host x switch) map.
 @return a copy of the cached map of hosts to rack]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isSingleSwitch" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Delegate the switch topology query to the raw mapping, via
 {@link AbstractDNSToSwitchMapping#isMappingSingleSwitch(DNSToSwitchMapping)}
 @return true iff the raw mapper is considered single-switch.]]>
      </doc>
    </method>
    <method name="reloadCachedMappings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reloadCachedMappings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.util.List"/>
    </method>
    <field name="rawMapping" type="org.apache.hadoop.net.DNSToSwitchMapping"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The uncached mapping]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A cached implementation of DNSToSwitchMapping that takes an
 raw DNSToSwitchMapping and stores the resolved network location in 
 a cache. The following calls to a resolved network location
 will get its location from the cache.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.CachedDNSToSwitchMapping -->
  <!-- start class org.apache.hadoop.net.ConnectTimeoutException -->
  <class name="ConnectTimeoutException" extends="java.net.SocketTimeoutException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConnectTimeoutException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Thrown by {@link NetUtils#connect(java.net.Socket, java.net.SocketAddress, int)}
 if it times out while connecting to the remote host.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.ConnectTimeoutException -->
  <!-- start interface org.apache.hadoop.net.DNSToSwitchMapping -->
  <interface name="DNSToSwitchMapping"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="resolve" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.util.List"/>
      <doc>
      <![CDATA[Resolves a list of DNS-names/IP-addresses and returns back a list of
 switch information (network paths). One-to-one correspondence must be 
 maintained between the elements in the lists. 
 Consider an element in the argument list - x.y.com. The switch information
 that is returned must be a network path of the form /foo/rack, 
 where / is the root, and 'foo' is the switch where 'rack' is connected.
 Note the hostname/ip-address is not part of the returned path.
 The network topology of the cluster would determine the number of
 components in the network path.
 <p/>

 If a name cannot be resolved to a rack, the implementation
 should return {@link NetworkTopology#DEFAULT_RACK}. This
 is what the bundled implementations do, though it is not a formal requirement

 @param names the list of hosts to resolve (can be empty)
 @return list of resolved network paths.
 If <i>names</i> is empty, the returned list is also empty]]>
      </doc>
    </method>
    <method name="reloadCachedMappings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reload all of the cached mappings.

 If there is a cache, this method will clear it, so that future accesses
 will get a chance to see the new data.]]>
      </doc>
    </method>
    <method name="reloadCachedMappings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.util.List"/>
      <doc>
      <![CDATA[Reload cached mappings on specific nodes.

 If there is a cache on these nodes, this method will clear it, so that 
 future accesses will see updated data.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An interface that must be implemented to allow pluggable
 DNS-name/IP-address to RackID resolvers.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.net.DNSToSwitchMapping -->
  <!-- start class org.apache.hadoop.net.NetworkTopology.InvalidTopologyException -->
  <class name="NetworkTopology.InvalidTopologyException" extends="java.lang.RuntimeException"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NetworkTopology.InvalidTopologyException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.net.NetworkTopology.InvalidTopologyException -->
  <!-- start class org.apache.hadoop.net.ScriptBasedMapping -->
  <class name="ScriptBasedMapping" extends="org.apache.hadoop.net.CachedDNSToSwitchMapping"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ScriptBasedMapping"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance with the default configuration.
 </p>
 Calling {@link #setConf(Configuration)} will trigger a
 re-evaluation of the configuration settings and so be used to
 set up the mapping script.]]>
      </doc>
    </constructor>
    <constructor name="ScriptBasedMapping" type="org.apache.hadoop.net.DNSToSwitchMapping"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance from the given raw mapping
 @param rawMap raw DNSTOSwithMapping]]>
      </doc>
    </constructor>
    <constructor name="ScriptBasedMapping" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance from the given configuration
 @param conf configuration]]>
      </doc>
    </constructor>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[{@inheritDoc}
 <p/>
 This will get called in the superclass constructor, so a check is needed
 to ensure that the raw mapping is defined before trying to relaying a null
 configuration.
 @param conf]]>
      </doc>
    </method>
    <field name="NO_SCRIPT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Text used in the {@link #toString()} method if there is no string
 {@value}]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This class implements the {@link DNSToSwitchMapping} interface using a 
 script configured via the
 {@link CommonConfigurationKeys#NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY} option.
 <p/>
 It contains a static class <code>RawScriptBasedMapping</code> that performs
 the work: reading the configuration parameters, executing any defined
 script, handling errors and such like. The outer
 class extends {@link CachedDNSToSwitchMapping} to cache the delegated
 queries.
 <p/>
 This DNS mapper's {@link #isSingleSwitch()} predicate returns
 true if and only if a script is defined.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.ScriptBasedMapping -->
  <!-- start class org.apache.hadoop.net.ScriptBasedMapping.RawScriptBasedMapping -->
  <class name="ScriptBasedMapping.RawScriptBasedMapping" extends="org.apache.hadoop.net.AbstractDNSToSwitchMapping"
    abstract="false"
    static="true" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="ScriptBasedMapping.RawScriptBasedMapping"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor. The mapping is not ready to use until
 {@link #setConf(Configuration)} has been called]]>
      </doc>
    </constructor>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Set the configuration and extract the configuration parameters of interest
 @param conf the new configuration]]>
      </doc>
    </method>
    <method name="resolve" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.util.List"/>
    </method>
    <method name="runResolveCommand" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="args" type="java.util.List"/>
      <param name="commandScriptName" type="java.lang.String"/>
      <doc>
      <![CDATA[Build and execute the resolution command. The command is
 executed in the directory specified by the system property
 "user.dir" if set; otherwise the current working directory is used
 @param args a list of arguments
 @return null if the number of arguments is out of range,
 or the output of the command.]]>
      </doc>
    </method>
    <method name="isSingleSwitch" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Declare that the mapper is single-switched if a script was not named
 in the configuration.
 @return true iff there is no script]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reloadCachedMappings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reloadCachedMappings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.util.List"/>
    </method>
    <doc>
    <![CDATA[This is the uncached script mapping that is fed into the cache managed
 by the superclass {@link CachedDNSToSwitchMapping}]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.ScriptBasedMapping.RawScriptBasedMapping -->
  <!-- start class org.apache.hadoop.net.SocksSocketFactory -->
  <class name="SocksSocketFactory" extends="javax.net.SocketFactory"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="SocksSocketFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default empty constructor (for use with the reflection API).]]>
      </doc>
    </constructor>
    <constructor name="SocksSocketFactory" type="java.net.Proxy"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with a supplied Proxy
 
 @param proxy the proxy to use to create sockets]]>
      </doc>
    </constructor>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addr" type="java.net.InetAddress"/>
      <param name="port" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addr" type="java.net.InetAddress"/>
      <param name="port" type="int"/>
      <param name="localHostAddr" type="java.net.InetAddress"/>
      <param name="localPort" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="port" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="port" type="int"/>
      <param name="localHostAddr" type="java.net.InetAddress"/>
      <param name="localPort" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <doc>
    <![CDATA[Specialized SocketFactory to create sockets with a SOCKS proxy]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.SocksSocketFactory -->
  <!-- start class org.apache.hadoop.net.StandardSocketFactory -->
  <class name="StandardSocketFactory" extends="javax.net.SocketFactory"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="StandardSocketFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default empty constructor (for use with the reflection API).]]>
      </doc>
    </constructor>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addr" type="java.net.InetAddress"/>
      <param name="port" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="addr" type="java.net.InetAddress"/>
      <param name="port" type="int"/>
      <param name="localHostAddr" type="java.net.InetAddress"/>
      <param name="localPort" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="port" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
    </method>
    <method name="createSocket" return="java.net.Socket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="port" type="int"/>
      <param name="localHostAddr" type="java.net.InetAddress"/>
      <param name="localPort" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Specialized SocketFactory to create sockets with a SOCKS proxy]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.StandardSocketFactory -->
  <!-- start class org.apache.hadoop.net.TableMapping -->
  <class name="TableMapping" extends="org.apache.hadoop.net.CachedDNSToSwitchMapping"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TableMapping"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="reloadCachedMappings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 Simple {@link DNSToSwitchMapping} implementation that reads a 2 column text
 file. The columns are separated by whitespace. The first column is a DNS or
 IP address and the second column specifies the rack where the address maps.
 </p>
 <p>
 This class uses the configuration parameter {@code
 net.topology.table.file.name} to locate the mapping file.
 </p>
 <p>
 Calls to {@link #resolve(List)} will look up the address as defined in the
 mapping file. If no entry corresponding to the address is found, the value
 {@code /default-rack} is returned.
 </p>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.net.TableMapping -->
  <doc>
  <![CDATA[Network-related classes.]]>
  </doc>
</package>
<package name="org.apache.hadoop.net.unix">
  <!-- start interface org.apache.hadoop.net.unix.DomainSocketWatcher.Handler -->
  <interface name="DomainSocketWatcher.Handler"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handle" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sock" type="org.apache.hadoop.net.unix.DomainSocket"/>
      <doc>
      <![CDATA[Handles an event on a socket.  An event may be the socket becoming
 readable, or the remote end being closed.

 @param sock    The socket that the event occurred on.
 @return        Whether we should close the socket.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.net.unix.DomainSocketWatcher.Handler -->
</package>
<package name="org.apache.hadoop.record">
  <!-- start class org.apache.hadoop.record.BinaryRecordInput -->
  <class name="BinaryRecordInput" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <implements name="org.apache.hadoop.record.RecordInput"/>
    <constructor name="BinaryRecordInput" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of BinaryRecordInput]]>
      </doc>
    </constructor>
    <constructor name="BinaryRecordInput" type="java.io.DataInput"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of BinaryRecordInput]]>
      </doc>
    </constructor>
    <method name="get" return="org.apache.hadoop.record.BinaryRecordInput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inp" type="java.io.DataInput"/>
      <doc>
      <![CDATA[Get a thread-local record input for the supplied DataInput.
 @param inp data input stream
 @return binary record input corresponding to the supplied DataInput.]]>
      </doc>
    </method>
    <method name="readByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readBool" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readBuffer" return="org.apache.hadoop.record.Buffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startVector" return="org.apache.hadoop.record.Index"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startMap" return="org.apache.hadoop.record.Index"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.BinaryRecordInput -->
  <!-- start class org.apache.hadoop.record.BinaryRecordOutput -->
  <class name="BinaryRecordOutput" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <implements name="org.apache.hadoop.record.RecordOutput"/>
    <constructor name="BinaryRecordOutput" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of BinaryRecordOutput]]>
      </doc>
    </constructor>
    <constructor name="BinaryRecordOutput" type="java.io.DataOutput"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of BinaryRecordOutput]]>
      </doc>
    </constructor>
    <method name="get" return="org.apache.hadoop.record.BinaryRecordOutput"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <doc>
      <![CDATA[Get a thread-local record output for the supplied DataOutput.
 @param out data output stream
 @return binary record output corresponding to the supplied DataOutput.]]>
      </doc>
    </method>
    <method name="writeByte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeBool"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="boolean"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="long"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="float"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeDouble"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="d" type="double"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeString"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="org.apache.hadoop.record.Buffer"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="org.apache.hadoop.record.Record"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="org.apache.hadoop.record.Record"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.ArrayList"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.ArrayList"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.TreeMap"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.TreeMap"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.BinaryRecordOutput -->
  <!-- start class org.apache.hadoop.record.Buffer -->
  <class name="Buffer" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <implements name="java.lang.Comparable"/>
    <implements name="java.lang.Cloneable"/>
    <constructor name="Buffer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a zero-count sequence.]]>
      </doc>
    </constructor>
    <constructor name="Buffer" type="byte[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a Buffer using the byte array as the initial value.

 @param bytes This array becomes the backing storage for the object.]]>
      </doc>
    </constructor>
    <constructor name="Buffer" type="byte[], int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a Buffer using the byte range as the initial value.

 @param bytes Copy of this array becomes the backing storage for the object.
 @param offset offset into byte array
 @param length length of data]]>
      </doc>
    </constructor>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Use the specified bytes array as underlying sequence.

 @param bytes byte sequence]]>
      </doc>
    </method>
    <method name="copy"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Copy the specified byte array to the Buffer. Replaces the current buffer.

 @param bytes byte array to be assigned
 @param offset offset into byte array
 @param length length of data]]>
      </doc>
    </method>
    <method name="get" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the data from the Buffer.
 
 @return The data is only valid between 0 and getCount() - 1.]]>
      </doc>
    </method>
    <method name="getCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current count of the buffer.]]>
      </doc>
    </method>
    <method name="getCapacity" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the capacity, which is the maximum count that could handled without
 resizing the backing storage.
 
 @return The number of bytes]]>
      </doc>
    </method>
    <method name="setCapacity"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newCapacity" type="int"/>
      <doc>
      <![CDATA[Change the capacity of the backing storage.
 The data is preserved if newCapacity >= getCount().
 @param newCapacity The new capacity in bytes.]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reset the buffer to 0 size]]>
      </doc>
    </method>
    <method name="truncate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Change the capacity of the backing store to be the same as the current 
 count of buffer.]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="length" type="int"/>
      <doc>
      <![CDATA[Append specified bytes to the buffer.

 @param bytes byte array to be appended
 @param offset offset into byte array
 @param length length of data]]>
      </doc>
    </method>
    <method name="append"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <doc>
      <![CDATA[Append specified bytes to the buffer

 @param bytes byte array to be appended]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
      <doc>
      <![CDATA[Define the sort order of the Buffer.
 
 @param other The other buffer
 @return Positive if this is bigger than other, 0 if they are equal, and
         negative if this is smaller than other.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="charsetName" type="java.lang.String"/>
      <exception name="UnsupportedEncodingException" type="java.io.UnsupportedEncodingException"/>
      <doc>
      <![CDATA[Convert the byte buffer to a string an specific character encoding

 @param charsetName Valid Java Character Set Name]]>
      </doc>
    </method>
    <method name="clone" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="CloneNotSupportedException" type="java.lang.CloneNotSupportedException"/>
    </method>
    <doc>
    <![CDATA[A byte sequence that is used as a Java native type for buffer.
 It is resizable and distinguishes between the count of the seqeunce and
 the current capacity.
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.Buffer -->
  <!-- start class org.apache.hadoop.record.CsvRecordInput -->
  <class name="CsvRecordInput" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <implements name="org.apache.hadoop.record.RecordInput"/>
    <constructor name="CsvRecordInput" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of CsvRecordInput]]>
      </doc>
    </constructor>
    <method name="readByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readBool" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readBuffer" return="org.apache.hadoop.record.Buffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startVector" return="org.apache.hadoop.record.Index"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startMap" return="org.apache.hadoop.record.Index"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.CsvRecordInput -->
  <!-- start class org.apache.hadoop.record.CsvRecordOutput -->
  <class name="CsvRecordOutput" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <implements name="org.apache.hadoop.record.RecordOutput"/>
    <constructor name="CsvRecordOutput" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of CsvRecordOutput]]>
      </doc>
    </constructor>
    <method name="writeByte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeBool"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="boolean"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="long"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="float"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeDouble"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="d" type="double"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeString"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="org.apache.hadoop.record.Buffer"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="org.apache.hadoop.record.Record"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="org.apache.hadoop.record.Record"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.ArrayList"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.ArrayList"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.TreeMap"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.TreeMap"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.CsvRecordOutput -->
  <!-- start interface org.apache.hadoop.record.Index -->
  <interface name="Index"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <method name="done" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="incr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Interface that acts as an iterator for deserializing maps.
 The deserializer returns an instance that the record uses to
 read vectors and maps. An example of usage is as follows:

 <code>
 Index idx = startVector(...);
 while (!idx.done()) {
   .... // read element of a vector
   idx.incr();
 }
 </code>
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.record.Index -->
  <!-- start class org.apache.hadoop.record.Record -->
  <class name="Record" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <implements name="org.apache.hadoop.io.WritableComparable"/>
    <implements name="java.lang.Cloneable"/>
    <constructor name="Record"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="serialize"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rout" type="org.apache.hadoop.record.RecordOutput"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serialize a record with tag (ususally field name)
 @param rout Record output destination
 @param tag record tag (Used only in tagged serialization e.g. XML)]]>
      </doc>
    </method>
    <method name="deserialize"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rin" type="org.apache.hadoop.record.RecordInput"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deserialize a record with a tag (usually field name)
 @param rin Record input source
 @param tag Record tag (Used only in tagged serialization e.g. XML)]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="peer" type="java.lang.Object"/>
      <exception name="ClassCastException" type="java.lang.ClassCastException"/>
    </method>
    <method name="serialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rout" type="org.apache.hadoop.record.RecordOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serialize a record without a tag
 @param rout Record output destination]]>
      </doc>
    </method>
    <method name="deserialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rin" type="org.apache.hadoop.record.RecordInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deserialize a record without a tag
 @param rin Record input source]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="din" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Abstract class that is extended by generated classes.
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.Record -->
  <!-- start class org.apache.hadoop.record.RecordComparator -->
  <class name="RecordComparator" extends="org.apache.hadoop.io.WritableComparator"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="RecordComparator" type="java.lang.Class"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a raw {@link Record} comparison implementation.]]>
      </doc>
    </constructor>
    <method name="compare" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
    </method>
    <method name="define"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="c" type="java.lang.Class"/>
      <param name="comparator" type="org.apache.hadoop.record.RecordComparator"/>
      <doc>
      <![CDATA[Register an optimized comparator for a {@link Record} implementation.

 @param c record classs for which a raw comparator is provided
 @param comparator Raw comparator instance for class c]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A raw record comparator base class
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.RecordComparator -->
  <!-- start interface org.apache.hadoop.record.RecordInput -->
  <interface name="RecordInput"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <method name="readByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a byte from serialized record.
 @param tag Used by tagged serialization formats (such as XML)
 @return value read from serialized record.]]>
      </doc>
    </method>
    <method name="readBool" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a boolean from serialized record.
 @param tag Used by tagged serialization formats (such as XML)
 @return value read from serialized record.]]>
      </doc>
    </method>
    <method name="readInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read an integer from serialized record.
 @param tag Used by tagged serialization formats (such as XML)
 @return value read from serialized record.]]>
      </doc>
    </method>
    <method name="readLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a long integer from serialized record.
 @param tag Used by tagged serialization formats (such as XML)
 @return value read from serialized record.]]>
      </doc>
    </method>
    <method name="readFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a single-precision float from serialized record.
 @param tag Used by tagged serialization formats (such as XML)
 @return value read from serialized record.]]>
      </doc>
    </method>
    <method name="readDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a double-precision number from serialized record.
 @param tag Used by tagged serialization formats (such as XML)
 @return value read from serialized record.]]>
      </doc>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a UTF-8 encoded string from serialized record.
 @param tag Used by tagged serialization formats (such as XML)
 @return value read from serialized record.]]>
      </doc>
    </method>
    <method name="readBuffer" return="org.apache.hadoop.record.Buffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read byte array from serialized record.
 @param tag Used by tagged serialization formats (such as XML)
 @return value read from serialized record.]]>
      </doc>
    </method>
    <method name="startRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Check the mark for start of the serialized record.
 @param tag Used by tagged serialization formats (such as XML)]]>
      </doc>
    </method>
    <method name="endRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Check the mark for end of the serialized record.
 @param tag Used by tagged serialization formats (such as XML)]]>
      </doc>
    </method>
    <method name="startVector" return="org.apache.hadoop.record.Index"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Check the mark for start of the serialized vector.
 @param tag Used by tagged serialization formats (such as XML)
 @return Index that is used to count the number of elements.]]>
      </doc>
    </method>
    <method name="endVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Check the mark for end of the serialized vector.
 @param tag Used by tagged serialization formats (such as XML)]]>
      </doc>
    </method>
    <method name="startMap" return="org.apache.hadoop.record.Index"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Check the mark for start of the serialized map.
 @param tag Used by tagged serialization formats (such as XML)
 @return Index that is used to count the number of map entries.]]>
      </doc>
    </method>
    <method name="endMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Check the mark for end of the serialized map.
 @param tag Used by tagged serialization formats (such as XML)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface that all the Deserializers have to implement.
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.record.RecordInput -->
  <!-- start interface org.apache.hadoop.record.RecordOutput -->
  <interface name="RecordOutput"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <method name="writeByte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a byte to serialized record.
 @param b Byte to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="writeBool"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="boolean"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a boolean to serialized record.
 @param b Boolean to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="writeInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write an integer to serialized record.
 @param i Integer to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="writeLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="long"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a long integer to serialized record.
 @param l Long to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="writeFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="float"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a single-precision float to serialized record.
 @param f Float to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="writeDouble"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="d" type="double"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a double precision floating point number to serialized record.
 @param d Double to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="writeString"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a unicode string to serialized record.
 @param s String to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="writeBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="org.apache.hadoop.record.Buffer"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write a buffer to serialized record.
 @param buf Buffer to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="startRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="org.apache.hadoop.record.Record"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Mark the start of a record to be serialized.
 @param r Record to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="endRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="org.apache.hadoop.record.Record"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Mark the end of a serialized record.
 @param r Record to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="startVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.ArrayList"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Mark the start of a vector to be serialized.
 @param v Vector to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="endVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.ArrayList"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Mark the end of a serialized vector.
 @param v Vector to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="startMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.TreeMap"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Mark the start of a map to be serialized.
 @param m Map to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <method name="endMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.util.TreeMap"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Mark the end of a serialized map.
 @param m Map to be serialized
 @param tag Used by tagged serialization formats (such as XML)
 @throws IOException Indicates error in serialization]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface that all the serializers have to implement.
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.record.RecordOutput -->
  <!-- start class org.apache.hadoop.record.Utils -->
  <class name="Utils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <method name="readFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Parse a float from a byte array.]]>
      </doc>
    </method>
    <method name="readDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <doc>
      <![CDATA[Parse a double from a byte array.]]>
      </doc>
    </method>
    <method name="readVLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a zero-compressed encoded long from a byte array and returns it.
 @param bytes byte array with decode long
 @param start starting index
 @throws java.io.IOException
 @return deserialized long]]>
      </doc>
    </method>
    <method name="readVInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bytes" type="byte[]"/>
      <param name="start" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a zero-compressed encoded integer from a byte array and returns it.
 @param bytes byte array with the encoded integer
 @param start start index
 @throws java.io.IOException
 @return deserialized integer]]>
      </doc>
    </method>
    <method name="readVLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a zero-compressed encoded long from a stream and return it.
 @param in input stream
 @throws java.io.IOException
 @return deserialized long]]>
      </doc>
    </method>
    <method name="readVInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads a zero-compressed encoded integer from a stream and returns it.
 @param in input stream
 @throws java.io.IOException
 @return deserialized integer]]>
      </doc>
    </method>
    <method name="getVIntSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="long"/>
      <doc>
      <![CDATA[Get the encoded length if an integer is stored in a variable-length format
 @return the encoded length]]>
      </doc>
    </method>
    <method name="writeVLong"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.DataOutput"/>
      <param name="i" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serializes a long to a binary stream with zero-compressed encoding.
 For -112 <= i <= 127, only one byte is used with the actual value.
 For other values of i, the first byte value indicates whether the
 long is positive or negative, and the number of bytes that follow.
 If the first byte value v is between -113 and -120, the following long
 is positive, with number of bytes that follow are -(v+112).
 If the first byte value v is between -121 and -128, the following long
 is negative, with number of bytes that follow are -(v+120). Bytes are
 stored in the high-non-zero-byte-first order.

 @param stream Binary output stream
 @param i Long to be serialized
 @throws java.io.IOException]]>
      </doc>
    </method>
    <method name="writeVInt"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.DataOutput"/>
      <param name="i" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serializes an int to a binary stream with zero-compressed encoding.

 @param stream Binary output stream
 @param i int to be serialized
 @throws java.io.IOException]]>
      </doc>
    </method>
    <method name="compareBytes" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b1" type="byte[]"/>
      <param name="s1" type="int"/>
      <param name="l1" type="int"/>
      <param name="b2" type="byte[]"/>
      <param name="s2" type="int"/>
      <param name="l2" type="int"/>
      <doc>
      <![CDATA[Lexicographic order of binary data.]]>
      </doc>
    </method>
    <field name="hexchars" type="char[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Various utility functions for Hadooop record I/O runtime.
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.Utils -->
  <!-- start class org.apache.hadoop.record.XmlRecordInput -->
  <class name="XmlRecordInput" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <implements name="org.apache.hadoop.record.RecordInput"/>
    <constructor name="XmlRecordInput" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of XmlRecordInput]]>
      </doc>
    </constructor>
    <method name="readByte" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readBool" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readBuffer" return="org.apache.hadoop.record.Buffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startVector" return="org.apache.hadoop.record.Index"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startMap" return="org.apache.hadoop.record.Index"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[XML Deserializer.
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.XmlRecordInput -->
  <!-- start class org.apache.hadoop.record.XmlRecordOutput -->
  <class name="XmlRecordOutput" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <implements name="org.apache.hadoop.record.RecordOutput"/>
    <constructor name="XmlRecordOutput" type="java.io.OutputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of XmlRecordOutput]]>
      </doc>
    </constructor>
    <method name="writeByte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeBool"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="boolean"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="i" type="int"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="long"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="float"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeDouble"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="d" type="double"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeString"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeBuffer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="org.apache.hadoop.record.Buffer"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="org.apache.hadoop.record.Record"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="r" type="org.apache.hadoop.record.Record"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.ArrayList"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.ArrayList"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="startMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.TreeMap"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="endMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="v" type="java.util.TreeMap"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[XML Serializer.
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.XmlRecordOutput -->
  <doc>
  <![CDATA[<p>
    (DEPRECATED) Hadoop record I/O contains classes and a record description language
    translator for simplifying serialization and deserialization of records in a
    language-neutral manner.
    </p>
    
    <p>
    DEPRECATED: Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.
    </p>
  
  <h2>Introduction</h2>
  
  Software systems of any significant complexity require mechanisms for data 
interchange with the outside world. These interchanges typically involve the
marshaling and unmarshaling of logical units of data to and from data streams
(files, network connections, memory buffers etc.). Applications usually have
some code for serializing and deserializing the data types that they manipulate
embedded in them. The work of serialization has several features that make
automatic code generation for it worthwhile. Given a particular output encoding
(binary, XML, etc.), serialization of primitive types and simple compositions
of primitives (structs, vectors etc.) is a very mechanical task. Manually
written serialization code can be susceptible to bugs especially when records
have a large number of fields or a record definition changes between software
versions. Lastly, it can be very useful for applications written in different
programming languages to be able to share and interchange data. This can be 
made a lot easier by describing the data records manipulated by these
applications in a language agnostic manner and using the descriptions to derive
implementations of serialization in multiple target languages. 

This document describes Hadoop Record I/O, a mechanism that is aimed 
at
<ul> 
<li> enabling the specification of simple serializable data types (records) 
<li> enabling the generation of code in multiple target languages for
marshaling and unmarshaling such types
<li> providing target language specific support that will enable application 
programmers to incorporate generated code into their applications
</ul>

The goals of Hadoop Record I/O are similar to those of mechanisms such as XDR,
ASN.1, PADS and ICE. While these systems all include a DDL that enables
the specification of most record types, they differ widely in what else they
focus on. The focus in Hadoop Record I/O is on data marshaling and
multi-lingual support.  We take a translator-based approach to serialization.
Hadoop users have to describe their data in a simple data description
language. The Hadoop DDL translator rcc generates code that users
can invoke in order to read/write their data from/to simple stream 
abstractions. Next we list explicitly some of the goals and non-goals of
Hadoop Record I/O.


<h3>Goals</h3>

<ul>
<li> Support for commonly used primitive types. Hadoop should include as
primitives commonly used builtin types from programming languages we intend to
support.

<li> Support for common data compositions (including recursive compositions).
Hadoop should support widely used composite types such as structs and
vectors.

<li> Code generation in multiple target languages. Hadoop should be capable of
generating serialization code in multiple target languages and should be
easily extensible to new target languages. The initial target languages are
C++ and Java.

<li> Support for generated target languages. Hadooop should include support
in the form of headers, libraries, packages for supported target languages 
that enable easy inclusion and use of generated code in applications.

<li> Support for multiple output encodings. Candidates include
packed binary, comma-separated text, XML etc.

<li> Support for specifying record types in a backwards/forwards compatible
manner. This will probably be in the form of support for optional fields in
records. This version of the document does not include a description of the
planned mechanism, we intend to include it in the next iteration.

</ul>

<h3>Non-Goals</h3>

<ul>
  <li> Serializing existing arbitrary C++ classes.
  <li> Serializing complex data structures such as trees, linked lists etc.
  <li> Built-in indexing schemes, compression, or check-sums.
  <li> Dynamic construction of objects from an XML schema.
</ul>

The remainder of this document describes the features of Hadoop record I/O
in more detail. Section 2 describes the data types supported by the system.
Section 3 lays out the DDL syntax with some examples of simple records. 
Section 4 describes the process of code generation with rcc. Section 5
describes target language mappings and support for Hadoop types. We include a
fairly complete description of C++ mappings with intent to include Java and
others in upcoming iterations of this document. The last section talks about
supported output encodings.


<h2>Data Types and Streams</h2>

This section describes the primitive and composite types supported by Hadoop.
We aim to support a set of types that can be used to simply and efficiently
express a wide range of record types in different programming languages.

<h3>Primitive Types</h3>

For the most part, the primitive types of Hadoop map directly to primitive
types in high level programming languages. Special cases are the
ustring (a Unicode string) and buffer types, which we believe
find wide use and which are usually implemented in library code and not
available as language built-ins. Hadoop also supplies these via library code
when a target language built-in is not present and there is no widely
adopted "standard" implementation. The complete list of primitive types is:

<ul>
  <li> byte: An 8-bit unsigned integer.
  <li> boolean: A boolean value.
  <li> int: A 32-bit signed integer.
  <li> long: A 64-bit signed integer.
  <li> float: A single precision floating point number as described by
    IEEE-754.
  <li> double: A double precision floating point number as described by
    IEEE-754.
  <li> ustring: A string consisting of Unicode characters.
  <li> buffer: An arbitrary sequence of bytes. 
</ul>


<h3>Composite Types</h3>
Hadoop supports a small set of composite types that enable the description
of simple aggregate types and containers. A composite type is serialized
by sequentially serializing it constituent elements. The supported
composite types are:

<ul>

  <li> record: An aggregate type like a C-struct. This is a list of
typed fields that are together considered a single unit of data. A record
is serialized by sequentially serializing its constituent fields. In addition
to serialization a record has comparison operations (equality and less-than)
implemented for it, these are defined as memberwise comparisons.

  <li>vector: A sequence of entries of the same data type, primitive
or composite.

  <li> map: An associative container mapping instances of a key type to
instances of a value type. The key and value types may themselves be primitive
or composite types. 

</ul>

<h3>Streams</h3>

Hadoop generates code for serializing and deserializing record types to
abstract streams. For each target language Hadoop defines very simple input
and output stream interfaces. Application writers can usually develop
concrete implementations of these by putting a one method wrapper around
an existing stream implementation.


<h2>DDL Syntax and Examples</h2>

We now describe the syntax of the Hadoop data description language. This is
followed by a few examples of DDL usage.
 
<h3>Hadoop DDL Syntax</h3>

<pre><code>
recfile = *include module *record
include = "include" path
path = (relative-path / absolute-path)
module = "module" module-name
module-name = name *("." name)
record := "class" name "{" 1*(field) "}"
field := type name ";"
name :=  ALPHA (ALPHA / DIGIT / "_" )*
type := (ptype / ctype)
ptype := ("byte" / "boolean" / "int" |
          "long" / "float" / "double"
          "ustring" / "buffer")
ctype := (("vector" "<" type ">") /
          ("map" "<" type "," type ">" ) ) / name)
</code></pre>

A DDL file describes one or more record types. It begins with zero or
more include declarations, a single mandatory module declaration
followed by zero or more class declarations. The semantics of each of
these declarations are described below:

<ul>

<li>include: An include declaration specifies a DDL file to be
referenced when generating code for types in the current DDL file. Record types
in the current compilation unit may refer to types in all included files.
File inclusion is recursive. An include does not trigger code
generation for the referenced file.

<li> module: Every Hadoop DDL file must have a single module
declaration that follows the list of includes and precedes all record
declarations. A module declaration identifies a scope within which
the names of all types in the current file are visible. Module names are
mapped to C++ namespaces, Java packages etc. in generated code.

<li> class: Records types are specified through class
declarations. A class declaration is like a Java class declaration.
It specifies a named record type and a list of fields that constitute records
of the type. Usage is illustrated in the following examples.

</ul>

<h3>Examples</h3>

<ul>
<li>A simple DDL file links.jr with just one record declaration. 
<pre><code>
module links {
    class Link {
        ustring URL;
        boolean isRelative;
        ustring anchorText;
    };
}
</code></pre>

<li> A DDL file outlinks.jr which includes another
<pre><code>
include "links.jr"

module outlinks {
    class OutLinks {
        ustring baseURL;
        vector<links.Link> outLinks;
    };
}
</code></pre>
</ul>

<h2>Code Generation</h2>

The Hadoop translator is written in Java. Invocation is done by executing a 
wrapper shell script named named rcc. It takes a list of
record description files as a mandatory argument and an
optional language argument (the default is Java) --language or
-l. Thus a typical invocation would look like:
<pre><code>
$ rcc -l C++ <filename> ...
</code></pre>


<h2>Target Language Mappings and Support</h2>

For all target languages, the unit of code generation is a record type. 
For each record type, Hadoop generates code for serialization and
deserialization, record comparison and access to record members.

<h3>C++</h3>

Support for including Hadoop generated C++ code in applications comes in the
form of a header file recordio.hh which needs to be included in source
that uses Hadoop types and a library librecordio.a which applications need
to be linked with. The header declares the Hadoop C++ namespace which defines
appropriate types for the various primitives, the basic interfaces for
records and streams and enumerates the supported serialization encodings.
Declarations of these interfaces and a description of their semantics follow:

<pre><code>
namespace hadoop {

  enum RecFormat { kBinary, kXML, kCSV };

  class InStream {
  public:
    virtual ssize_t read(void *buf, size_t n) = 0;
  };

  class OutStream {
  public:
    virtual ssize_t write(const void *buf, size_t n) = 0;
  };

  class IOError : public runtime_error {
  public:
    explicit IOError(const std::string& msg);
  };

  class IArchive;
  class OArchive;

  class RecordReader {
  public:
    RecordReader(InStream& in, RecFormat fmt);
    virtual ~RecordReader(void);

    virtual void read(Record& rec);
  };

  class RecordWriter {
  public:
    RecordWriter(OutStream& out, RecFormat fmt);
    virtual ~RecordWriter(void);

    virtual void write(Record& rec);
  };


  class Record {
  public:
    virtual std::string type(void) const = 0;
    virtual std::string signature(void) const = 0;
  protected:
    virtual bool validate(void) const = 0;

    virtual void
    serialize(OArchive& oa, const std::string& tag) const = 0;

    virtual void
    deserialize(IArchive& ia, const std::string& tag) = 0;
  };
}
</code></pre>

<ul>

<li> RecFormat: An enumeration of the serialization encodings supported
by this implementation of Hadoop.

<li> InStream: A simple abstraction for an input stream. This has a 
single public read method that reads n bytes from the stream into
the buffer buf. Has the same semantics as a blocking read system
call. Returns the number of bytes read or -1 if an error occurs.

<li> OutStream: A simple abstraction for an output stream. This has a 
single write method that writes n bytes to the stream from the
buffer buf. Has the same semantics as a blocking write system
call. Returns the number of bytes written or -1 if an error occurs.

<li> RecordReader: A RecordReader reads records one at a time from
an underlying stream in a specified record format. The reader is instantiated
with a stream and a serialization format. It has a read method that
takes an instance of a record and deserializes the record from the stream.

<li> RecordWriter: A RecordWriter writes records one at a
time to an underlying stream in a specified record format. The writer is
instantiated with a stream and a serialization format. It has a
write method that takes an instance of a record and serializes the
record to the stream.

<li> Record: The base class for all generated record types. This has two
public methods type and signature that return the typename and the
type signature of the record.

</ul>

Two files are generated for each record file (note: not for each record). If a
record file is named "name.jr", the generated files are 
"name.jr.cc" and "name.jr.hh" containing serialization 
implementations and record type declarations respectively.

For each record in the DDL file, the generated header file will contain a
class definition corresponding to the record type, method definitions for the
generated type will be present in the '.cc' file.  The generated class will
inherit from the abstract class hadoop::Record. The DDL files
module declaration determines the namespace the record belongs to.
Each '.' delimited token in the module declaration results in the
creation of a namespace. For instance, the declaration module docs.links
results in the creation of a docs namespace and a nested 
docs::links namespace. In the preceding examples, the Link class
is placed in the links namespace. The header file corresponding to
the links.jr file will contain:

<pre><code>
namespace links {
  class Link : public hadoop::Record {
    // ....
  };
};
</code></pre>

Each field within the record will cause the generation of a private member
declaration of the appropriate type in the class declaration, and one or more
acccessor methods. The generated class will implement the serialize and
deserialize methods defined in hadoop::Record+. It will also 
implement the inspection methods type and signature from
hadoop::Record. A default constructor and virtual destructor will also
be generated. Serialization code will read/write records into streams that
implement the hadoop::InStream and the hadoop::OutStream interfaces.

For each member of a record an accessor method is generated that returns 
either the member or a reference to the member. For members that are returned 
by value, a setter method is also generated. This is true for primitive 
data members of the types byte, int, long, boolean, float and 
double. For example, for a int field called MyField the folowing
code is generated.

<pre><code>
...
private:
  int32_t mMyField;
  ...
public:
  int32_t getMyField(void) const {
    return mMyField;
  };

  void setMyField(int32_t m) {
    mMyField = m;
  };
  ...
</code></pre>

For a ustring or buffer or composite field. The generated code
only contains accessors that return a reference to the field. A const
and a non-const accessor are generated. For example:

<pre><code>
...
private:
  std::string mMyBuf;
  ...
public:

  std::string& getMyBuf() {
    return mMyBuf;
  };

  const std::string& getMyBuf() const {
    return mMyBuf;
  };
  ...
</code></pre>

<h4>Examples</h4>

Suppose the inclrec.jr file contains:
<pre><code>
module inclrec {
    class RI {
        int      I32;
        double   D;
        ustring  S;
    };
}
</code></pre>

and the testrec.jr file contains:

<pre><code>
include "inclrec.jr"
module testrec {
    class R {
        vector<float> VF;
        RI            Rec;
        buffer        Buf;
    };
}
</code></pre>

Then the invocation of rcc such as:
<pre><code>
$ rcc -l c++ inclrec.jr testrec.jr
</code></pre>
will result in generation of four files:
inclrec.jr.{cc,hh} and testrec.jr.{cc,hh}.

The inclrec.jr.hh will contain:

<pre><code>
#ifndef _INCLREC_JR_HH_
#define _INCLREC_JR_HH_

#include "recordio.hh"

namespace inclrec {
  
  class RI : public hadoop::Record {

  private:

    int32_t      I32;
    double       D;
    std::string  S;

  public:

    RI(void);
    virtual ~RI(void);

    virtual bool operator==(const RI& peer) const;
    virtual bool operator<(const RI& peer) const;

    virtual int32_t getI32(void) const { return I32; }
    virtual void setI32(int32_t v) { I32 = v; }

    virtual double getD(void) const { return D; }
    virtual void setD(double v) { D = v; }

    virtual std::string& getS(void) const { return S; }
    virtual const std::string& getS(void) const { return S; }

    virtual std::string type(void) const;
    virtual std::string signature(void) const;

  protected:

    virtual void serialize(hadoop::OArchive& a) const;
    virtual void deserialize(hadoop::IArchive& a);
  };
} // end namespace inclrec

#endif /* _INCLREC_JR_HH_ */

</code></pre>

The testrec.jr.hh file will contain:


<pre><code>

#ifndef _TESTREC_JR_HH_
#define _TESTREC_JR_HH_

#include "inclrec.jr.hh"

namespace testrec {
  class R : public hadoop::Record {

  private:

    std::vector<float> VF;
    inclrec::RI        Rec;
    std::string        Buf;

  public:

    R(void);
    virtual ~R(void);

    virtual bool operator==(const R& peer) const;
    virtual bool operator<(const R& peer) const;

    virtual std::vector<float>& getVF(void) const;
    virtual const std::vector<float>& getVF(void) const;

    virtual std::string& getBuf(void) const ;
    virtual const std::string& getBuf(void) const;

    virtual inclrec::RI& getRec(void) const;
    virtual const inclrec::RI& getRec(void) const;
    
    virtual bool serialize(hadoop::OutArchive& a) const;
    virtual bool deserialize(hadoop::InArchive& a);
    
    virtual std::string type(void) const;
    virtual std::string signature(void) const;
  };
}; // end namespace testrec
#endif /* _TESTREC_JR_HH_ */

</code></pre>

<h3>Java</h3>

Code generation for Java is similar to that for C++. A Java class is generated
for each record type with private members corresponding to the fields. Getters
and setters for fields are also generated. Some differences arise in the
way comparison is expressed and in the mapping of modules to packages and
classes to files. For equality testing, an equals method is generated
for each record type. As per Java requirements a hashCode method is also
generated. For comparison a compareTo method is generated for each
record type. This has the semantics as defined by the Java Comparable
interface, that is, the method returns a negative integer, zero, or a positive
integer as the invoked object is less than, equal to, or greater than the
comparison parameter.

A .java file is generated per record type as opposed to per DDL
file as in C++. The module declaration translates to a Java
package declaration. The module name maps to an identical Java package
name. In addition to this mapping, the DDL compiler creates the appropriate
directory hierarchy for the package and places the generated .java
files in the correct directories.

<h2>Mapping Summary</h2>

<pre><code>
DDL Type        C++ Type            Java Type 

boolean         bool                boolean
byte            int8_t              byte
int             int32_t             int
long            int64_t             long
float           float               float
double          double              double
ustring         std::string         java.lang.String
buffer          std::string         org.apache.hadoop.record.Buffer
class type      class type          class type
vector<type>    std::vector<type>   java.util.ArrayList<type>
map<type,type>  std::map<type,type> java.util.TreeMap<type,type>
</code></pre>

<h2>Data encodings</h2>

This section describes the format of the data encodings supported by Hadoop.
Currently, three data encodings are supported, namely binary, CSV and XML.

<h3>Binary Serialization Format</h3>

The binary data encoding format is fairly dense. Serialization of composite
types is simply defined as a concatenation of serializations of the constituent
elements (lengths are included in vectors and maps).

Composite types are serialized as follows:
<ul>
<li> class: Sequence of serialized members.
<li> vector: The number of elements serialized as an int. Followed by a
sequence of serialized elements.
<li> map: The number of key value pairs serialized as an int. Followed
by a sequence of serialized (key,value) pairs.
</ul>

Serialization of primitives is more interesting, with a zero compression
optimization for integral types and normalization to UTF-8 for strings. 
Primitive types are serialized as follows:

<ul>
<li> byte: Represented by 1 byte, as is.
<li> boolean: Represented by 1-byte (0 or 1)
<li> int/long: Integers and longs are serialized zero compressed.
Represented as 1-byte if -120 <= value < 128. Otherwise, serialized as a
sequence of 2-5 bytes for ints, 2-9 bytes for longs. The first byte represents
the number of trailing bytes, N, as the negative number (-120-N). For example,
the number 1024 (0x400) is represented by the byte sequence 'x86 x04 x00'.
This doesn't help much for 4-byte integers but does a reasonably good job with
longs without bit twiddling.
<li> float/double: Serialized in IEEE 754 single and double precision
format in network byte order. This is the format used by Java.
<li> ustring: Serialized as 4-byte zero compressed length followed by
data encoded as UTF-8. Strings are normalized to UTF-8 regardless of native
language representation.
<li> buffer: Serialized as a 4-byte zero compressed length followed by the
raw bytes in the buffer.
</ul>


<h3>CSV Serialization Format</h3>

The CSV serialization format has a lot more structure than the "standard"
Excel CSV format, but we believe the additional structure is useful because

<ul>
<li> it makes parsing a lot easier without detracting too much from legibility
<li> the delimiters around composites make it obvious when one is reading a
sequence of Hadoop records
</ul>

Serialization formats for the various types are detailed in the grammar that
follows. The notable feature of the formats is the use of delimiters for 
indicating the certain field types.

<ul>
<li> A string field begins with a single quote (').
<li> A buffer field begins with a sharp (#).
<li> A class, vector or map begins with 's{', 'v{' or 'm{' respectively and
ends with '}'.
</ul>

The CSV format can be described by the following grammar:

<pre><code>
record = primitive / struct / vector / map
primitive = boolean / int / long / float / double / ustring / buffer

boolean = "T" / "F"
int = ["-"] 1*DIGIT
long = ";" ["-"] 1*DIGIT
float = ["-"] 1*DIGIT "." 1*DIGIT ["E" / "e" ["-"] 1*DIGIT]
double = ";" ["-"] 1*DIGIT "." 1*DIGIT ["E" / "e" ["-"] 1*DIGIT]

ustring = "'" *(UTF8 char except NULL, LF, % and , / "%00" / "%0a" / "%25" / "%2c" )

buffer = "#" *(BYTE except NULL, LF, % and , / "%00" / "%0a" / "%25" / "%2c" )

struct = "s{" record *("," record) "}"
vector = "v{" [record *("," record)] "}"
map = "m{" [*(record "," record)] "}"
</code></pre>

<h3>XML Serialization Format</h3>

The XML serialization format is the same used by Apache XML-RPC
(http://ws.apache.org/xmlrpc/types.html). This is an extension of the original
XML-RPC format and adds some additional data types. All record I/O types are
not directly expressible in this format, and access to a DDL is required in
order to convert these to valid types. All types primitive or composite are
represented by &lt;value&gt; elements. The particular XML-RPC type is
indicated by a nested element in the &lt;value&gt; element. The encoding for
records is always UTF-8. Primitive types are serialized as follows:

<ul>
<li> byte: XML tag &lt;ex:i1&gt;. Values: 1-byte unsigned 
integers represented in US-ASCII
<li> boolean: XML tag &lt;boolean&gt;. Values: "0" or "1"
<li> int: XML tags &lt;i4&gt; or &lt;int&gt;. Values: 4-byte
signed integers represented in US-ASCII.
<li> long: XML tag &lt;ex:i8&gt;. Values: 8-byte signed integers
represented in US-ASCII.
<li> float: XML tag &lt;ex:float&gt;. Values: Single precision
floating point numbers represented in US-ASCII.
<li> double: XML tag &lt;double&gt;. Values: Double precision
floating point numbers represented in US-ASCII.
<li> ustring: XML tag &lt;;string&gt;. Values: String values
represented as UTF-8. XML does not permit all Unicode characters in literal
data. In particular, NULLs and control chars are not allowed. Additionally,
XML processors are required to replace carriage returns with line feeds and to
replace CRLF sequences with line feeds. Programming languages that we work
with do not impose these restrictions on string types. To work around these
restrictions, disallowed characters and CRs are percent escaped in strings.
The '%' character is also percent escaped.
<li> buffer: XML tag &lt;string&&gt;. Values: Arbitrary binary
data. Represented as hexBinary, each byte is replaced by its 2-byte
hexadecimal representation.
</ul>

Composite types are serialized as follows:

<ul>
<li> class: XML tag &lt;struct&gt;. A struct is a sequence of
&lt;member&gt; elements. Each &lt;member&gt; element has a &lt;name&gt;
element and a &lt;value&gt; element. The &lt;name&gt; is a string that must
match /[a-zA-Z][a-zA-Z0-9_]*/. The value of the member is represented
by a &lt;value&gt; element.

<li> vector: XML tag &lt;array&lt;. An &lt;array&gt; contains a
single &lt;data&gt; element. The &lt;data&gt; element is a sequence of
&lt;value&gt; elements each of which represents an element of the vector.

<li> map: XML tag &lt;array&gt;. Same as vector.

</ul>

For example:

<pre><code>
class {
  int           MY_INT;            // value 5
  vector<float> MY_VEC;            // values 0.1, -0.89, 2.45e4
  buffer        MY_BUF;            // value '\00\n\tabc%'
}
</code></pre>

is serialized as

<pre><code class="XML">
&lt;value&gt;
  &lt;struct&gt;
    &lt;member&gt;
      &lt;name&gt;MY_INT&lt;/name&gt;
      &lt;value&gt;&lt;i4&gt;5&lt;/i4&gt;&lt;/value&gt;
    &lt;/member&gt;
    &lt;member&gt;
      &lt;name&gt;MY_VEC&lt;/name&gt;
      &lt;value&gt;
        &lt;array&gt;
          &lt;data&gt;
            &lt;value&gt;&lt;ex:float&gt;0.1&lt;/ex:float&gt;&lt;/value&gt;
            &lt;value&gt;&lt;ex:float&gt;-0.89&lt;/ex:float&gt;&lt;/value&gt;
            &lt;value&gt;&lt;ex:float&gt;2.45e4&lt;/ex:float&gt;&lt;/value&gt;
          &lt;/data&gt;
        &lt;/array&gt;
      &lt;/value&gt;
    &lt;/member&gt;
    &lt;member&gt;
      &lt;name&gt;MY_BUF&lt;/name&gt;
      &lt;value&gt;&lt;string&gt;%00\n\tabc%25&lt;/string&gt;&lt;/value&gt;
    &lt;/member&gt;
  &lt;/struct&gt;
&lt;/value&gt; 
</code></pre>]]>
  </doc>
</package>
<package name="org.apache.hadoop.record.compiler">
  <!-- start class org.apache.hadoop.record.compiler.CodeBuffer -->
  <class name="CodeBuffer" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A wrapper around StringBuffer that automatically does indentation
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.CodeBuffer -->
  <!-- start class org.apache.hadoop.record.compiler.Consts -->
  <class name="Consts" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <field name="RIO_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RTI_VAR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RTI_FILTER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RTI_FILTER_FIELDS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RECORD_OUTPUT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RECORD_INPUT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TAG" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[const definitions for Record I/O compiler
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.Consts -->
  <!-- start class org.apache.hadoop.record.compiler.JBoolean -->
  <class name="JBoolean" extends="org.apache.hadoop.record.compiler.JType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="JBoolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JBoolean]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[@deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JBoolean -->
  <!-- start class org.apache.hadoop.record.compiler.JBuffer -->
  <class name="JBuffer" extends="org.apache.hadoop.record.compiler.JCompType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="JBuffer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JBuffer]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Code generator for "buffer" type.
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JBuffer -->
  <!-- start class org.apache.hadoop.record.compiler.JByte -->
  <class name="JByte" extends="org.apache.hadoop.record.compiler.JType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="JByte"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Code generator for "byte" type.
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JByte -->
  <!-- start class org.apache.hadoop.record.compiler.JDouble -->
  <class name="JDouble" extends="org.apache.hadoop.record.compiler.JType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="JDouble"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JDouble]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[@deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JDouble -->
  <!-- start class org.apache.hadoop.record.compiler.JField -->
  <class name="JField" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="JField" type="java.lang.String, T"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JField]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[A thin wrappper around record field.
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JField -->
  <!-- start class org.apache.hadoop.record.compiler.JFile -->
  <class name="JFile" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="JFile" type="java.lang.String, java.util.ArrayList, java.util.ArrayList"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JFile

 @param name possibly full pathname to the file
 @param inclFiles included files (as JFile)
 @param recList List of records defined within this file]]>
      </doc>
    </constructor>
    <method name="genCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="language" type="java.lang.String"/>
      <param name="destDir" type="java.lang.String"/>
      <param name="options" type="java.util.ArrayList"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Generate record code in given language. Language should be all
  lowercase.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Container for the Hadoop Record DDL.
 The main components of the file are filename, list of included files,
 and records defined in that file.
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JFile -->
  <!-- start class org.apache.hadoop.record.compiler.JFloat -->
  <class name="JFloat" extends="org.apache.hadoop.record.compiler.JType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="JFloat"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JFloat]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[@deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JFloat -->
  <!-- start class org.apache.hadoop.record.compiler.JInt -->
  <class name="JInt" extends="org.apache.hadoop.record.compiler.JType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="JInt"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JInt]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Code generator for "int" type
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JInt -->
  <!-- start class org.apache.hadoop.record.compiler.JLong -->
  <class name="JLong" extends="org.apache.hadoop.record.compiler.JType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="JLong"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JLong]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Code generator for "long" type
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JLong -->
  <!-- start class org.apache.hadoop.record.compiler.JMap -->
  <class name="JMap" extends="org.apache.hadoop.record.compiler.JCompType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="JMap" type="org.apache.hadoop.record.compiler.JType, org.apache.hadoop.record.compiler.JType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JMap]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[@deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JMap -->
  <!-- start class org.apache.hadoop.record.compiler.JRecord -->
  <class name="JRecord" extends="org.apache.hadoop.record.compiler.JCompType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="JRecord" type="java.lang.String, java.util.ArrayList"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JRecord]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[@deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JRecord -->
  <!-- start class org.apache.hadoop.record.compiler.JString -->
  <class name="JString" extends="org.apache.hadoop.record.compiler.JCompType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="JString"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JString]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[@deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JString -->
  <!-- start class org.apache.hadoop.record.compiler.JType -->
  <class name="JType" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="JType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Abstract Base class for all types supported by Hadoop Record I/O.
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JType -->
  <!-- start class org.apache.hadoop.record.compiler.JVector -->
  <class name="JVector" extends="org.apache.hadoop.record.compiler.JCompType"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="JVector" type="org.apache.hadoop.record.compiler.JType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of JVector]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[@deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.JVector -->
  <doc>
  <![CDATA[<p>
    (DEPRECATED) This package contains classes needed for code generation
    from the hadoop record compiler. CppGenerator and JavaGenerator
    are the main entry points from the parser. There are classes
    corrsponding to every primitive type and compound type
    included in Hadoop record I/O syntax.
    </p>
    
    <p>
    DEPRECATED: Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.
    </p>]]>
  </doc>
</package>
<package name="org.apache.hadoop.record.compiler.ant">
  <!-- start class org.apache.hadoop.record.compiler.ant.RccTask -->
  <class name="RccTask" extends="org.apache.tools.ant.Task"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="RccTask"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new instance of RccTask]]>
      </doc>
    </constructor>
    <method name="setLanguage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="language" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the output language option
 @param language "java"/"c++"]]>
      </doc>
    </method>
    <method name="setFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <doc>
      <![CDATA[Sets the record definition file attribute
 @param file record definition file]]>
      </doc>
    </method>
    <method name="setFailonerror"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="flag" type="boolean"/>
      <doc>
      <![CDATA[Given multiple files (via fileset), set the error handling behavior
 @param flag true will throw build exception in case of failure (default)]]>
      </doc>
    </method>
    <method name="setDestdir"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="java.io.File"/>
      <doc>
      <![CDATA[Sets directory where output files will be generated
 @param dir output directory]]>
      </doc>
    </method>
    <method name="addFileset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="set" type="org.apache.tools.ant.types.FileSet"/>
      <doc>
      <![CDATA[Adds a fileset that can consist of one or more files
 @param set Set of record definition files]]>
      </doc>
    </method>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="BuildException" type="org.apache.tools.ant.BuildException"/>
      <doc>
      <![CDATA[Invoke the Hadoop record compiler on each record definition file]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Hadoop record compiler ant Task
<p> This task takes the given record definition files and compiles them into
 java or c++
 files. It is then up to the user to compile the generated files.

 <p> The task requires the <code>file</code> or the nested fileset element to be
 specified. Optional attributes are <code>language</code> (set the output
 language, default is "java"),
 <code>destdir</code> (name of the destination directory for generated java/c++
 code, default is ".") and <code>failonerror</code> (specifies error handling
 behavior. default is true).
 <p><h4>Usage</h4>
 <pre>
 &lt;recordcc
       destdir="${basedir}/gensrc"
       language="java"&gt;
   &lt;fileset include="**\/*.jr" /&gt;
 &lt;/recordcc&gt;
 </pre>
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.ant.RccTask -->
</package>
<package name="org.apache.hadoop.record.compiler.generated">
  <!-- start class org.apache.hadoop.record.compiler.generated.ParseException -->
  <class name="ParseException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="ParseException" type="org.apache.hadoop.record.compiler.generated.Token, int[][], java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This constructor is used by the method "generateParseException"
 in the generated parser.  Calling this constructor generates
 a new object of this type with the fields "currentToken",
 "expectedTokenSequences", and "tokenImage" set.  The boolean
 flag "specialConstructor" is also set to true to indicate that
 this constructor was used to create this object.
 This constructor calls its super class with the empty string
 to force the "toString" method of parent class "Throwable" to
 print the error message in the form:
     ParseException: <result of getMessage>]]>
      </doc>
    </constructor>
    <constructor name="ParseException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The following constructors are for use by you for whatever
 purpose you can think of.  Constructing the exception in this
 manner makes the exception behave in the normal way - i.e., as
 documented in the class "Throwable".  The fields "errorToken",
 "expectedTokenSequences", and "tokenImage" do not contain
 relevant information.  The JavaCC generated code does not use
 these constructors.]]>
      </doc>
    </constructor>
    <constructor name="ParseException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This method has the standard behavior when this object has been
 created using the standard constructors.  Otherwise, it uses
 "currentToken" and "expectedTokenSequences" to generate a parse
 error message and returns it.  If this object has been created
 due to a parse error, and you do not catch it (it gets thrown
 from the parser), then this method is called during the printing
 of the final stack trace, and hence the correct error message
 gets displayed.]]>
      </doc>
    </method>
    <method name="add_escapes" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <doc>
      <![CDATA[Used to convert raw characters to their escaped version
 when these raw version cannot be used as part of an ASCII
 string literal.]]>
      </doc>
    </method>
    <field name="specialConstructor" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This variable determines which constructor was used to create
 this object and thereby affects the semantics of the
 "getMessage" method (see below).]]>
      </doc>
    </field>
    <field name="currentToken" type="org.apache.hadoop.record.compiler.generated.Token"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This is the last token that has been consumed successfully.  If
 this object has been created due to a parse error, the token
 followng this token will (therefore) be the first error token.]]>
      </doc>
    </field>
    <field name="expectedTokenSequences" type="int[][]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Each entry in this array is an array of integers.  Each array
 of integers represents a sequence of tokens (by their ordinal
 values) that is expected at this point of the parse.]]>
      </doc>
    </field>
    <field name="tokenImage" type="java.lang.String[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This is a reference to the "tokenImage" array of the generated
 parser within which the parse error occurred.  This array is
 defined in the generated ...Constants interface.]]>
      </doc>
    </field>
    <field name="eol" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The end of line string for this machine.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This exception is thrown when parse errors are encountered.
 You can explicitly create objects of this exception type by
 calling the method generateParseException in the generated
 parser.

 You can modify this class to customize your error reporting
 mechanisms so long as you retain the public fields.
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.generated.ParseException -->
  <!-- start class org.apache.hadoop.record.compiler.generated.Rcc -->
  <class name="Rcc" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <implements name="org.apache.hadoop.record.compiler.generated.RccConstants"/>
    <constructor name="Rcc" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Rcc" type="java.io.InputStream, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Rcc" type="java.io.Reader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Rcc" type="org.apache.hadoop.record.compiler.generated.RccTokenManager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
    </method>
    <method name="usage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="driver" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
    </method>
    <method name="Input" return="org.apache.hadoop.record.compiler.JFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="ParseException" type="org.apache.hadoop.record.compiler.generated.ParseException"/>
    </method>
    <method name="Include" return="org.apache.hadoop.record.compiler.JFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="ParseException" type="org.apache.hadoop.record.compiler.generated.ParseException"/>
    </method>
    <method name="Module" return="java.util.ArrayList"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="ParseException" type="org.apache.hadoop.record.compiler.generated.ParseException"/>
    </method>
    <method name="ModuleName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="ParseException" type="org.apache.hadoop.record.compiler.generated.ParseException"/>
    </method>
    <method name="RecordList" return="java.util.ArrayList"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="ParseException" type="org.apache.hadoop.record.compiler.generated.ParseException"/>
    </method>
    <method name="Record" return="org.apache.hadoop.record.compiler.JRecord"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="ParseException" type="org.apache.hadoop.record.compiler.generated.ParseException"/>
    </method>
    <method name="Field" return="org.apache.hadoop.record.compiler.JField"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="ParseException" type="org.apache.hadoop.record.compiler.generated.ParseException"/>
    </method>
    <method name="Type" return="org.apache.hadoop.record.compiler.JType"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="ParseException" type="org.apache.hadoop.record.compiler.generated.ParseException"/>
    </method>
    <method name="Map" return="org.apache.hadoop.record.compiler.JMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="ParseException" type="org.apache.hadoop.record.compiler.generated.ParseException"/>
    </method>
    <method name="Vector" return="org.apache.hadoop.record.compiler.JVector"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="ParseException" type="org.apache.hadoop.record.compiler.generated.ParseException"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.InputStream"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.InputStream"/>
      <param name="encoding" type="java.lang.String"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.Reader"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tm" type="org.apache.hadoop.record.compiler.generated.RccTokenManager"/>
    </method>
    <method name="getNextToken" return="org.apache.hadoop.record.compiler.generated.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getToken" return="org.apache.hadoop.record.compiler.generated.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
    </method>
    <method name="generateParseException" return="org.apache.hadoop.record.compiler.generated.ParseException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="enable_tracing"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="disable_tracing"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="token_source" type="org.apache.hadoop.record.compiler.generated.RccTokenManager"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="token" type="org.apache.hadoop.record.compiler.generated.Token"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="jj_nt" type="org.apache.hadoop.record.compiler.generated.Token"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.generated.Rcc -->
  <!-- start interface org.apache.hadoop.record.compiler.generated.RccConstants -->
  <interface name="RccConstants"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <field name="EOF" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MODULE_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RECORD_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INCLUDE_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BYTE_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BOOLEAN_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INT_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LONG_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FLOAT_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DOUBLE_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="USTRING_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BUFFER_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="VECTOR_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MAP_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LBRACE_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RBRACE_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LT_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="GT_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SEMICOLON_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="COMMA_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DOT_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CSTRING_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="IDENT_TKN" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WithinOneLineComment" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WithinMultiLineComment" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="tokenImage" type="java.lang.String[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.record.compiler.generated.RccConstants -->
  <!-- start class org.apache.hadoop.record.compiler.generated.RccTokenManager -->
  <class name="RccTokenManager" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <implements name="org.apache.hadoop.record.compiler.generated.RccConstants"/>
    <constructor name="RccTokenManager" type="org.apache.hadoop.record.compiler.generated.SimpleCharStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="RccTokenManager" type="org.apache.hadoop.record.compiler.generated.SimpleCharStream, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setDebugStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ds" type="java.io.PrintStream"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="org.apache.hadoop.record.compiler.generated.SimpleCharStream"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="org.apache.hadoop.record.compiler.generated.SimpleCharStream"/>
      <param name="lexState" type="int"/>
    </method>
    <method name="SwitchTo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lexState" type="int"/>
    </method>
    <method name="jjFillToken" return="org.apache.hadoop.record.compiler.generated.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="getNextToken" return="org.apache.hadoop.record.compiler.generated.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="debugStream" type="java.io.PrintStream"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="jjstrLiteralImages" type="java.lang.String[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="lexStateNames" type="java.lang.String[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="jjnewLexState" type="int[]"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="input_stream" type="org.apache.hadoop.record.compiler.generated.SimpleCharStream"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="curChar" type="char"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[@deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.generated.RccTokenManager -->
  <!-- start class org.apache.hadoop.record.compiler.generated.SimpleCharStream -->
  <class name="SimpleCharStream" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="SimpleCharStream" type="java.io.Reader, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SimpleCharStream" type="java.io.Reader, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SimpleCharStream" type="java.io.Reader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SimpleCharStream" type="java.io.InputStream, java.lang.String, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedEncodingException" type="java.io.UnsupportedEncodingException"/>
    </constructor>
    <constructor name="SimpleCharStream" type="java.io.InputStream, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SimpleCharStream" type="java.io.InputStream, java.lang.String, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedEncodingException" type="java.io.UnsupportedEncodingException"/>
    </constructor>
    <constructor name="SimpleCharStream" type="java.io.InputStream, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SimpleCharStream" type="java.io.InputStream, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="UnsupportedEncodingException" type="java.io.UnsupportedEncodingException"/>
    </constructor>
    <constructor name="SimpleCharStream" type="java.io.InputStream"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setTabSize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="i" type="int"/>
    </method>
    <method name="getTabSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="i" type="int"/>
    </method>
    <method name="ExpandBuff"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="wrapAround" type="boolean"/>
    </method>
    <method name="FillBuff"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="BeginToken" return="char"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="UpdateLineColumn"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="c" type="char"/>
    </method>
    <method name="readChar" return="char"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getEndColumn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getEndLine" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBeginColumn" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBeginLine" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="backup"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="amount" type="int"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dstream" type="java.io.Reader"/>
      <param name="startline" type="int"/>
      <param name="startcolumn" type="int"/>
      <param name="buffersize" type="int"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dstream" type="java.io.Reader"/>
      <param name="startline" type="int"/>
      <param name="startcolumn" type="int"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dstream" type="java.io.Reader"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dstream" type="java.io.InputStream"/>
      <param name="encoding" type="java.lang.String"/>
      <param name="startline" type="int"/>
      <param name="startcolumn" type="int"/>
      <param name="buffersize" type="int"/>
      <exception name="UnsupportedEncodingException" type="java.io.UnsupportedEncodingException"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dstream" type="java.io.InputStream"/>
      <param name="startline" type="int"/>
      <param name="startcolumn" type="int"/>
      <param name="buffersize" type="int"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dstream" type="java.io.InputStream"/>
      <param name="encoding" type="java.lang.String"/>
      <exception name="UnsupportedEncodingException" type="java.io.UnsupportedEncodingException"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dstream" type="java.io.InputStream"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dstream" type="java.io.InputStream"/>
      <param name="encoding" type="java.lang.String"/>
      <param name="startline" type="int"/>
      <param name="startcolumn" type="int"/>
      <exception name="UnsupportedEncodingException" type="java.io.UnsupportedEncodingException"/>
    </method>
    <method name="ReInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dstream" type="java.io.InputStream"/>
      <param name="startline" type="int"/>
      <param name="startcolumn" type="int"/>
    </method>
    <method name="GetImage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="GetSuffix" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="len" type="int"/>
    </method>
    <method name="Done"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="adjustBeginLineColumn"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newLine" type="int"/>
      <param name="newCol" type="int"/>
      <doc>
      <![CDATA[Method to adjust line and column numbers for the start of a token.]]>
      </doc>
    </method>
    <field name="staticFlag" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="bufpos" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="bufline" type="int[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="bufcolumn" type="int[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="column" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="line" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="prevCharIsCR" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="prevCharIsLF" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="inputStream" type="java.io.Reader"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="buffer" type="char[]"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="maxNextCharInd" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="inBuf" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="tabSize" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[An implementation of interface CharStream, where the stream is assumed to
 contain only ASCII characters (without unicode processing).
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.generated.SimpleCharStream -->
  <!-- start class org.apache.hadoop.record.compiler.generated.Token -->
  <class name="Token" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="Token"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the image.]]>
      </doc>
    </method>
    <method name="newToken" return="org.apache.hadoop.record.compiler.generated.Token"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="ofKind" type="int"/>
      <doc>
      <![CDATA[Returns a new Token object, by default. However, if you want, you
 can create and return subclass objects based on the value of ofKind.
 Simply add the cases to the switch for all those special cases.
 For example, if you have a subclass of Token called IDToken that
 you want to create if ofKind is ID, simlpy add something like :

    case MyParserConstants.ID : return new IDToken();

 to the following switch statement. Then you can cast matchedToken
 variable to the appropriate type and use it in your lexical actions.]]>
      </doc>
    </method>
    <field name="kind" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[An integer that describes the kind of this token.  This numbering
 system is determined by JavaCCParser, and a table of these numbers is
 stored in the file ...Constants.java.]]>
      </doc>
    </field>
    <field name="beginLine" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[beginLine and beginColumn describe the position of the first character
 of this token; endLine and endColumn describe the position of the
 last character of this token.]]>
      </doc>
    </field>
    <field name="beginColumn" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[beginLine and beginColumn describe the position of the first character
 of this token; endLine and endColumn describe the position of the
 last character of this token.]]>
      </doc>
    </field>
    <field name="endLine" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[beginLine and beginColumn describe the position of the first character
 of this token; endLine and endColumn describe the position of the
 last character of this token.]]>
      </doc>
    </field>
    <field name="endColumn" type="int"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[beginLine and beginColumn describe the position of the first character
 of this token; endLine and endColumn describe the position of the
 last character of this token.]]>
      </doc>
    </field>
    <field name="image" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The string image of the token.]]>
      </doc>
    </field>
    <field name="next" type="org.apache.hadoop.record.compiler.generated.Token"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A reference to the next regular (non-special) token from the input
 stream.  If this is the last token from the input stream, or if the
 token manager has not read tokens beyond this one, this field is
 set to null.  This is true only if this token is also a regular
 token.  Otherwise, see below for a description of the contents of
 this field.]]>
      </doc>
    </field>
    <field name="specialToken" type="org.apache.hadoop.record.compiler.generated.Token"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This field is used to access special tokens that occur prior to this
 token, but after the immediately preceding regular (non-special) token.
 If there are no such special tokens, this field is set to null.
 When there are more than one such special token, this field refers
 to the last of these special tokens, which in turn refers to the next
 previous special token through its specialToken field, and so on
 until the first special token (whose specialToken field is null).
 The next fields of special tokens refer to other special tokens that
 immediately follow it (without an intervening regular token).  If there
 is no such token, this field is null.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Describes the input token stream.
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.generated.Token -->
  <!-- start class org.apache.hadoop.record.compiler.generated.TokenMgrError -->
  <class name="TokenMgrError" extends="java.lang.Error"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="TokenMgrError"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TokenMgrError" type="java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TokenMgrError" type="boolean, int, int, int, java.lang.String, char, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="addEscapes" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
      <doc>
      <![CDATA[Replaces unprintable characters by their espaced (or unicode escaped)
 equivalents in the given string]]>
      </doc>
    </method>
    <method name="LexicalError" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="EOFSeen" type="boolean"/>
      <param name="lexState" type="int"/>
      <param name="errorLine" type="int"/>
      <param name="errorColumn" type="int"/>
      <param name="errorAfter" type="java.lang.String"/>
      <param name="curChar" type="char"/>
      <doc>
      <![CDATA[Returns a detailed message for the Error when it is thrown by the
 token manager to indicate a lexical error.
 Parameters : 
    EOFSeen     : indicates if EOF caused the lexicl error
    curLexState : lexical state in which this error occured
    errorLine   : line number when the error occured
    errorColumn : column number when the error occured
    errorAfter  : prefix that was seen before this error occured
    curchar     : the offending character
 Note: You can customize the lexical error message by modifying this method.]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[You can also modify the body of this method to customize your error messages.
 For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
 of end-users concern, so you can return something like : 

     "Internal Error : Please file a bug report .... "

 from this method for such cases in the release version of your parser.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.compiler.generated.TokenMgrError -->
  <doc>
  <![CDATA[<p>
    (DEPRECATED) This package contains code generated by JavaCC from the
    Hadoop record syntax file rcc.jj. For details about the
    record file syntax please @see org.apache.hadoop.record.
    </p>
  
    <p>
    DEPRECATED: Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.
    </p>]]>
  </doc>
</package>
<package name="org.apache.hadoop.record.meta">
  <!-- start class org.apache.hadoop.record.meta.FieldTypeInfo -->
  <class name="FieldTypeInfo" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <method name="getTypeID" return="org.apache.hadoop.record.meta.TypeID"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the field's TypeID object]]>
      </doc>
    </method>
    <method name="getFieldID" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the field's id (name)]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Two FieldTypeInfos are equal if ach of their fields matches]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[We use a basic hashcode implementation, since this class will likely not
 be used as a hashmap key]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ti" type="org.apache.hadoop.record.meta.FieldTypeInfo"/>
    </method>
    <doc>
    <![CDATA[Represents a type information for a field, which is made up of its 
 ID (name) and its type (a TypeID object).
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.meta.FieldTypeInfo -->
  <!-- start class org.apache.hadoop.record.meta.MapTypeID -->
  <class name="MapTypeID" extends="org.apache.hadoop.record.meta.TypeID"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="MapTypeID" type="org.apache.hadoop.record.meta.TypeID, org.apache.hadoop.record.meta.TypeID"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKeyTypeID" return="org.apache.hadoop.record.meta.TypeID"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the TypeID of the map's key element]]>
      </doc>
    </method>
    <method name="getValueTypeID" return="org.apache.hadoop.record.meta.TypeID"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the TypeID of the map's value element]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Two map  typeIDs are equal if their constituent elements have the 
 same type]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[We use a basic hashcode implementation, since this class will likely not
 be used as a hashmap key]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents typeID for a Map 
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.meta.MapTypeID -->
  <!-- start class org.apache.hadoop.record.meta.RecordTypeInfo -->
  <class name="RecordTypeInfo" extends="org.apache.hadoop.record.Record"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="RecordTypeInfo"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an empty RecordTypeInfo object.]]>
      </doc>
    </constructor>
    <constructor name="RecordTypeInfo" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a RecordTypeInfo object representing a record with the given name
 @param name Name of the record]]>
      </doc>
    </constructor>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[return the name of the record]]>
      </doc>
    </method>
    <method name="setName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[set the name of the record]]>
      </doc>
    </method>
    <method name="addField"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldName" type="java.lang.String"/>
      <param name="tid" type="org.apache.hadoop.record.meta.TypeID"/>
      <doc>
      <![CDATA[Add a field. 
 @param fieldName Name of the field
 @param tid Type ID of the field]]>
      </doc>
    </method>
    <method name="getFieldTypeInfos" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a collection of field type infos]]>
      </doc>
    </method>
    <method name="getNestedStructTypeInfo" return="org.apache.hadoop.record.meta.RecordTypeInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Return the type info of a nested record. We only consider nesting 
 to one level. 
 @param name Name of the nested record]]>
      </doc>
    </method>
    <method name="serialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rout" type="org.apache.hadoop.record.RecordOutput"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Serialize the type information for a record]]>
      </doc>
    </method>
    <method name="deserialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rin" type="org.apache.hadoop.record.RecordInput"/>
      <param name="tag" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Deserialize the type information for a record]]>
      </doc>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="peer_" type="java.lang.Object"/>
      <exception name="ClassCastException" type="java.lang.ClassCastException"/>
      <doc>
      <![CDATA[This class doesn't implement Comparable as it's not meant to be used 
 for anything besides de/serializing.
 So we always throw an exception.
 Not implemented. Always returns 0 if another RecordTypeInfo is passed in.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A record's Type Information object which can read/write itself. 
 
 Type information for a record comprises metadata about the record, 
 as well as a collection of type information for each field in the record. 
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.meta.RecordTypeInfo -->
  <!-- start class org.apache.hadoop.record.meta.StructTypeID -->
  <class name="StructTypeID" extends="org.apache.hadoop.record.meta.TypeID"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="StructTypeID" type="org.apache.hadoop.record.meta.RecordTypeInfo"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a StructTypeID based on the RecordTypeInfo of some record]]>
      </doc>
    </constructor>
    <method name="getFieldTypeInfos" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents typeID for a struct 
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.meta.StructTypeID -->
  <!-- start class org.apache.hadoop.record.meta.TypeID -->
  <class name="TypeID" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <method name="getTypeVal" return="byte"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the type value. One of the constants in RIOType.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Two base typeIDs are equal if they refer to the same type]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[We use a basic hashcode implementation, since this class will likely not
 be used as a hashmap key]]>
      </doc>
    </method>
    <field name="BoolTypeID" type="org.apache.hadoop.record.meta.TypeID"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constant classes for the basic types, so we can share them.]]>
      </doc>
    </field>
    <field name="BufferTypeID" type="org.apache.hadoop.record.meta.TypeID"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ByteTypeID" type="org.apache.hadoop.record.meta.TypeID"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DoubleTypeID" type="org.apache.hadoop.record.meta.TypeID"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FloatTypeID" type="org.apache.hadoop.record.meta.TypeID"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="IntTypeID" type="org.apache.hadoop.record.meta.TypeID"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LongTypeID" type="org.apache.hadoop.record.meta.TypeID"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="StringTypeID" type="org.apache.hadoop.record.meta.TypeID"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="typeVal" type="byte"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Represents typeID for basic types.
  
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.meta.TypeID -->
  <!-- start class org.apache.hadoop.record.meta.TypeID.RIOType -->
  <class name="TypeID.RIOType" extends="java.lang.Object"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="TypeID.RIOType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="BOOL" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BUFFER" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BYTE" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DOUBLE" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FLOAT" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="INT" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LONG" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MAP" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="STRING" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="STRUCT" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="VECTOR" type="byte"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[constants representing the IDL types we support]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.meta.TypeID.RIOType -->
  <!-- start class org.apache.hadoop.record.meta.Utils -->
  <class name="Utils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <method name="skip"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rin" type="org.apache.hadoop.record.RecordInput"/>
      <param name="tag" type="java.lang.String"/>
      <param name="typeID" type="org.apache.hadoop.record.meta.TypeID"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[read/skip bytes from stream based on a type]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Various utility functions for Hadooop record I/O platform.
 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.meta.Utils -->
  <!-- start class org.apache.hadoop.record.meta.VectorTypeID -->
  <class name="VectorTypeID" extends="org.apache.hadoop.record.meta.TypeID"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Replaced by lEsS_tHaNa href=quote_cHaRhttp://hadoop.apache.org/avro/quote_cHaR>AvrolEsS_tHaN/a>.">
    <constructor name="VectorTypeID" type="org.apache.hadoop.record.meta.TypeID"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getElementTypeID" return="org.apache.hadoop.record.meta.TypeID"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
      <doc>
      <![CDATA[Two vector typeIDs are equal if their constituent elements have the 
 same type]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[We use a basic hashcode implementation, since this class will likely not
 be used as a hashmap key]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Represents typeID for vector. 
 @deprecated Replaced by <a href="http://hadoop.apache.org/avro/">Avro</a>.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.record.meta.VectorTypeID -->
</package>
<package name="org.apache.hadoop.security">
  <!-- start class org.apache.hadoop.security.AnnotatedSecurityInfo -->
  <class name="AnnotatedSecurityInfo" extends="org.apache.hadoop.security.SecurityInfo"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AnnotatedSecurityInfo"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getKerberosInfo" return="org.apache.hadoop.security.KerberosInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getTokenInfo" return="org.apache.hadoop.security.token.TokenInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <doc>
    <![CDATA[Constructs SecurityInfo from Annotations provided in protocol interface.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.AnnotatedSecurityInfo -->
  <!-- start class org.apache.hadoop.security.AuthenticationFilterInitializer -->
  <class name="AuthenticationFilterInitializer" extends="org.apache.hadoop.http.FilterInitializer"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AuthenticationFilterInitializer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="initFilter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="container" type="org.apache.hadoop.http.FilterContainer"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Initializes hadoop-auth AuthenticationFilter.
 <p/>
 Propagates to hadoop-auth AuthenticationFilter configuration all Hadoop
 configuration properties prefixed with "hadoop.http.authentication."

 @param container The filter container
 @param conf Configuration for run-time parameters]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Initializes hadoop-auth AuthenticationFilter which provides support for
 Kerberos HTTP SPNEGO authentication.
 <p/>
 It enables anonymous access, simple/pseudo and Kerberos HTTP SPNEGO
 authentication  for Hadoop JobTracker, NameNode, DataNodes and
 TaskTrackers.
 <p/>
 Refer to the <code>core-default.xml</code> file, after the comment
 'HTTP Authentication' for details on the configuration options.
 All related configuration properties have 'hadoop.http.authentication.'
 as prefix.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.AuthenticationFilterInitializer -->
  <!-- start interface org.apache.hadoop.security.GroupMappingServiceProvider -->
  <interface name="GroupMappingServiceProvider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getGroups" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all various group memberships of a given user.
 Returns EMPTY list in case of non-existing user
 @param user User's name
 @return group memberships of user
 @throws IOException]]>
      </doc>
    </method>
    <method name="cacheGroupsRefresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Refresh the cache of groups and user mapping
 @throws IOException]]>
      </doc>
    </method>
    <method name="cacheGroupsAdd"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="groups" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Caches the group user information
 @param groups list of groups to add to cache
 @throws IOException]]>
      </doc>
    </method>
    <field name="GROUP_MAPPING_CONFIG_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[An interface for the implementation of a user-to-groups mapping service
 used by {@link Groups}.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.security.GroupMappingServiceProvider -->
  <!-- start class org.apache.hadoop.security.IdMappingConstant -->
  <class name="IdMappingConstant" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="IdMappingConstant"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="USERGROUPID_UPDATE_MILLIS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Do user/group update every 15 minutes by default, minimum 1 minute]]>
      </doc>
    </field>
    <field name="USERGROUPID_UPDATE_MILLIS_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="USERGROUPID_UPDATE_MILLIS_MIN" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="UNKNOWN_USER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="UNKNOWN_GROUP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="STATIC_ID_MAPPING_FILE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="STATIC_ID_MAPPING_FILE_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Some constants for IdMapping]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.IdMappingConstant -->
  <!-- start interface org.apache.hadoop.security.IdMappingServiceProvider -->
  <interface name="IdMappingServiceProvider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getUid" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getGid" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="group" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getUserName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uid" type="int"/>
      <param name="unknown" type="java.lang.String"/>
    </method>
    <method name="getGroupName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="gid" type="int"/>
      <param name="unknown" type="java.lang.String"/>
    </method>
    <method name="getUidAllowingUnknown" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
    </method>
    <method name="getGidAllowingUnknown" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="group" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[An interface for the implementation of <userId, userName> mapping
 and <groupId, groupName> mapping]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.security.IdMappingServiceProvider -->
  <!-- start class org.apache.hadoop.security.JniBasedUnixGroupsMappingWithFallback -->
  <class name="JniBasedUnixGroupsMappingWithFallback" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.security.GroupMappingServiceProvider"/>
    <constructor name="JniBasedUnixGroupsMappingWithFallback"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getGroups" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="cacheGroupsRefresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="cacheGroupsAdd"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="groups" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.security.JniBasedUnixGroupsMappingWithFallback -->
  <!-- start class org.apache.hadoop.security.JniBasedUnixGroupsNetgroupMappingWithFallback -->
  <class name="JniBasedUnixGroupsNetgroupMappingWithFallback" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.security.GroupMappingServiceProvider"/>
    <constructor name="JniBasedUnixGroupsNetgroupMappingWithFallback"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getGroups" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="cacheGroupsRefresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="cacheGroupsAdd"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="groups" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.security.JniBasedUnixGroupsNetgroupMappingWithFallback -->
  <!-- start class org.apache.hadoop.security.ProviderUtils -->
  <class name="ProviderUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ProviderUtils"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="unnestUri" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nestedUri" type="java.net.URI"/>
      <doc>
      <![CDATA[Convert a nested URI to decode the underlying path. The translation takes
 the authority and parses it into the underlying scheme and authority.
 For example, "myscheme://hdfs@nn/my/path" is converted to
 "hdfs://nn/my/path".
 @param nestedUri the URI from the nested URI
 @return the unnested path]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.security.ProviderUtils -->
  <!-- start class org.apache.hadoop.security.SaslPlainServer.SaslPlainServerFactory -->
  <class name="SaslPlainServer.SaslPlainServerFactory" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.security.sasl.SaslServerFactory"/>
    <constructor name="SaslPlainServer.SaslPlainServerFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createSaslServer" return="javax.security.sasl.SaslServer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mechanism" type="java.lang.String"/>
      <param name="protocol" type="java.lang.String"/>
      <param name="serverName" type="java.lang.String"/>
      <param name="props" type="java.util.Map"/>
      <param name="cbh" type="javax.security.auth.callback.CallbackHandler"/>
      <exception name="SaslException" type="javax.security.sasl.SaslException"/>
    </method>
    <method name="getMechanismNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="props" type="java.util.Map"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.security.SaslPlainServer.SaslPlainServerFactory -->
  <!-- start class org.apache.hadoop.security.SaslPlainServer.SecurityProvider -->
  <class name="SaslPlainServer.SecurityProvider" extends="java.security.Provider"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SaslPlainServer.SecurityProvider"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.security.SaslPlainServer.SecurityProvider -->
  <!-- start class org.apache.hadoop.security.SaslPropertiesResolver -->
  <class name="SaslPropertiesResolver" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="SaslPropertiesResolver"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getInstance" return="org.apache.hadoop.security.SaslPropertiesResolver"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Returns an instance of SaslPropertiesResolver.
 Looks up the configuration to see if there is custom class specified.
 Constructs the instance by passing the configuration directly to the
 constructor to achieve thread safety using final fields.
 @param conf
 @return SaslPropertiesResolver]]>
      </doc>
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDefaultProperties" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The default Sasl Properties read from the configuration
 @return sasl Properties]]>
      </doc>
    </method>
    <method name="getServerProperties" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clientAddress" type="java.net.InetAddress"/>
      <doc>
      <![CDATA[Identify the Sasl Properties to be used for a connection with a  client.
 @param clientAddress client's address
 @return the sasl properties to be used for the connection.]]>
      </doc>
    </method>
    <method name="getClientProperties" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serverAddress" type="java.net.InetAddress"/>
      <doc>
      <![CDATA[Identify the Sasl Properties to be used for a connection with a server.
 @param serverAddress server's address
 @return the sasl properties to be used for the connection.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides SaslProperties to be used for a connection.
 The default implementation is to read the values from configuration.
 This class can be overridden to provide custom SaslProperties. 
 The custom class can be specified via configuration.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.SaslPropertiesResolver -->
  <!-- start class org.apache.hadoop.security.SaslRpcServer.AuthMethod -->
  <class name="SaslRpcServer.AuthMethod" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.security.SaslRpcServer.AuthMethod[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.security.SaslRpcServer.AuthMethod"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getMechanismName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the SASL mechanism name]]>
      </doc>
    </method>
    <method name="read" return="org.apache.hadoop.security.SaslRpcServer.AuthMethod"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read from in]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write to out]]>
      </doc>
    </method>
    <field name="code" type="byte"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The code for this method.]]>
      </doc>
    </field>
    <field name="mechanismName" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Authentication method]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.SaslRpcServer.AuthMethod -->
  <!-- start class org.apache.hadoop.security.SaslRpcServer.QualityOfProtection -->
  <class name="SaslRpcServer.QualityOfProtection" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.security.SaslRpcServer.QualityOfProtection[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.security.SaslRpcServer.QualityOfProtection"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getSaslQop" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="saslQop" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.security.SaslRpcServer.QualityOfProtection -->
  <!-- start class org.apache.hadoop.security.SaslRpcServer.SaslDigestCallbackHandler -->
  <class name="SaslRpcServer.SaslDigestCallbackHandler" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.security.auth.callback.CallbackHandler"/>
    <constructor name="SaslRpcServer.SaslDigestCallbackHandler" type="org.apache.hadoop.security.token.SecretManager, org.apache.hadoop.ipc.Server.Connection"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="handle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callbacks" type="javax.security.auth.callback.Callback[]"/>
      <exception name="SecretManager.InvalidToken" type="org.apache.hadoop.security.token.SecretManager.InvalidToken"/>
      <exception name="UnsupportedCallbackException" type="javax.security.auth.callback.UnsupportedCallbackException"/>
      <exception name="StandbyException" type="org.apache.hadoop.ipc.StandbyException"/>
      <exception name="RetriableException" type="org.apache.hadoop.ipc.RetriableException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[CallbackHandler for SASL DIGEST-MD5 mechanism]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.SaslRpcServer.SaslDigestCallbackHandler -->
  <!-- start class org.apache.hadoop.security.SaslRpcServer.SaslGssCallbackHandler -->
  <class name="SaslRpcServer.SaslGssCallbackHandler" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="javax.security.auth.callback.CallbackHandler"/>
    <constructor name="SaslRpcServer.SaslGssCallbackHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="handle"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="callbacks" type="javax.security.auth.callback.Callback[]"/>
      <exception name="UnsupportedCallbackException" type="javax.security.auth.callback.UnsupportedCallbackException"/>
    </method>
    <doc>
    <![CDATA[CallbackHandler for SASL GSSAPI Kerberos mechanism]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.SaslRpcServer.SaslGssCallbackHandler -->
  <!-- start class org.apache.hadoop.security.SecurityUtil.QualifiedHostResolver -->
  <class name="SecurityUtil.QualifiedHostResolver" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="protected"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.security.SecurityUtil.HostResolver"/>
    <constructor name="SecurityUtil.QualifiedHostResolver"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getByName" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
      <doc>
      <![CDATA[Create an InetAddress with a fully qualified hostname of the given
 hostname.  InetAddress does not qualify an incomplete hostname that
 is resolved via the domain search list.
 {@link InetAddress#getCanonicalHostName()} will fully qualify the
 hostname, but it always return the A record whereas the given hostname
 may be a CNAME.
 
 @param host a hostname or ip address
 @return InetAddress with the fully qualified hostname or ip
 @throws UnknownHostException if host does not exist]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This an alternate resolver with important properties that the standard
 java resolver lacks:
 1) The hostname is fully qualified.  This avoids security issues if not
    all hosts in the cluster do not share the same search domains.  It
    also prevents other hosts from performing unnecessary dns searches.
    In contrast, InetAddress simply returns the host as given.
 2) The InetAddress is instantiated with an exact host and IP to prevent
    further unnecessary lookups.  InetAddress may perform an unnecessary
    reverse lookup for an IP.
 3) A call to getHostName() will always return the qualified hostname, or
    more importantly, the IP if instantiated with an IP.  This avoids
    unnecessary dns timeouts if the host is not resolvable.
 4) Point 3 also ensures that if the host is re-resolved, ex. during a
    connection re-attempt, that a reverse lookup to host and forward
    lookup to IP is not performed since the reverse/forward mappings may
    not always return the same IP.  If the client initiated a connection
    with an IP, then that IP is all that should ever be contacted.
    
 NOTE: this resolver is only used if:
       hadoop.security.token.service.use_ip=false]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.SecurityUtil.QualifiedHostResolver -->
  <!-- start class org.apache.hadoop.security.ShellBasedIdMapping -->
  <class name="ShellBasedIdMapping" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.security.IdMappingServiceProvider"/>
    <constructor name="ShellBasedIdMapping" type="org.apache.hadoop.conf.Configuration, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <constructor name="ShellBasedIdMapping" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="getTimeout" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="updateMapInternal"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="map" type="com.google.common.collect.BiMap"/>
      <param name="mapName" type="java.lang.String"/>
      <param name="command" type="java.lang.String"/>
      <param name="regex" type="java.lang.String"/>
      <param name="staticMapping" type="java.util.Map"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the whole list of users and groups and save them in the maps.
 @throws IOException]]>
      </doc>
    </method>
    <method name="updateMaps"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getUid" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getGid" return="int"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="group" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getUserName" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uid" type="int"/>
      <param name="unknown" type="java.lang.String"/>
    </method>
    <method name="getGroupName" return="java.lang.String"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="gid" type="int"/>
      <param name="unknown" type="java.lang.String"/>
    </method>
    <method name="getUidAllowingUnknown" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
    </method>
    <method name="getGidAllowingUnknown" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="group" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[A simple shell-based implementation of {@link IdMappingServiceProvider} 
 Map id to user name or group name. It does update every 15 minutes. Only a
 single instance of this class is expected to be on the server.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.ShellBasedIdMapping -->
  <!-- start class org.apache.hadoop.security.UserGroupInformation.AuthenticationMethod -->
  <class name="UserGroupInformation.AuthenticationMethod" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.security.UserGroupInformation.AuthenticationMethod[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.security.UserGroupInformation.AuthenticationMethod"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getAuthMethod" return="org.apache.hadoop.security.SaslRpcServer.AuthMethod"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.security.UserGroupInformation.AuthenticationMethod"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="authMethod" type="org.apache.hadoop.security.SaslRpcServer.AuthMethod"/>
    </method>
    <doc>
    <![CDATA[existing types of authentications' methods]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.UserGroupInformation.AuthenticationMethod -->
  <!-- start class org.apache.hadoop.security.WhitelistBasedResolver -->
  <class name="WhitelistBasedResolver" extends="org.apache.hadoop.security.SaslPropertiesResolver"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="WhitelistBasedResolver"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getServerProperties" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clientAddress" type="java.net.InetAddress"/>
      <doc>
      <![CDATA[Identify the Sasl Properties to be used for a connection with a client.
 @param clientAddress client's address
 @return the sasl properties to be used for the connection.]]>
      </doc>
    </method>
    <method name="getServerProperties" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clientAddress" type="java.lang.String"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
    </method>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SECURITY_SASL_FIXEDWHITELIST_FILE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Path to the file to containing subnets and ip addresses to form fixed whitelist.]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_SASL_VARIABLEWHITELIST_ENABLE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Enables/Disables variable whitelist]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_SASL_VARIABLEWHITELIST_FILE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Path to the file to containing subnets and ip addresses to form variable whitelist.]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_SASL_VARIABLEWHITELIST_CACHE_SECS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[time in seconds by which the variable whitelist file is checked for updates]]>
      </doc>
    </field>
    <field name="HADOOP_RPC_PROTECTION_NON_WHITELIST" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[comma separated list containing alternate hadoop.rpc.protection values for
 clients which are not in whitelist]]>
      </doc>
    </field>
    <doc>
    <![CDATA[An implementation of the SaslPropertiesResolver.
 Uses a white list of IPs.
 If the connection's IP address is in the list of IP addresses, the salProperties
 will be unchanged.
 If the connection's IP is not in the list of IP addresses, then QOP for the
 connection will be restricted to "hadoop.rpc.protection.non-whitelist"

 Uses 3 IPList implementations together to form an aggregate whitelist.
 1. ConstantIPList - to check against a set of hardcoded IPs
 2. Fixed IP List - to check against a list of IP addresses which are specified externally, but
 will not change over runtime.
 3. Variable IP List - to check against a list of IP addresses which are specified externally and
 could change during runtime.
 A connection IP address will checked against these 3 IP Lists in the order specified above.
 Once a match is found , the IP address is determined to be in whitelist.

 The behavior can be configured using a bunch of configuration parameters.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.WhitelistBasedResolver -->
</package>
<package name="org.apache.hadoop.security.alias">
  <!-- start class org.apache.hadoop.security.alias.CredentialProvider -->
  <class name="CredentialProvider" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CredentialProvider"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isTransient" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this provider represents a store
 that is intended for transient use - such as the UserProvider
 is. These providers are generally used to provide job access to
 passwords rather than for long term storage.
 @return true if transient, false otherwise]]>
      </doc>
    </method>
    <method name="flush"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Ensures that any changes to the credentials are written to persistent store.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getCredentialEntry" return="org.apache.hadoop.security.alias.CredentialProvider.CredentialEntry"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="alias" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the credential entry for a specific alias.
 @param alias the name of a specific credential
 @return the credentialEntry
 @throws IOException]]>
      </doc>
    </method>
    <method name="getAliases" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the aliases for all credentials.
 @return the list of alias names
 @throws IOException]]>
      </doc>
    </method>
    <method name="createCredentialEntry" return="org.apache.hadoop.security.alias.CredentialProvider.CredentialEntry"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="credential" type="char[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a new credential. The given alias must not already exist.
 @param name the alias of the credential
 @param credential the credential value for the alias.
 @throws IOException]]>
      </doc>
    </method>
    <method name="deleteCredentialEntry"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete the given credential.
 @param name the alias of the credential to delete
 @throws IOException]]>
      </doc>
    </method>
    <field name="CLEAR_TEXT_FALLBACK" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A provider of credentials or password for Hadoop applications. Provides an
 abstraction to separate credential storage from users of them. It
 is intended to support getting or storing passwords in a variety of ways,
 including third party bindings.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.alias.CredentialProvider -->
  <!-- start class org.apache.hadoop.security.alias.CredentialProvider.CredentialEntry -->
  <class name="CredentialProvider.CredentialEntry" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CredentialProvider.CredentialEntry" type="java.lang.String, char[]"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getAlias" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCredential" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[The combination of both the alias and the actual credential value.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.alias.CredentialProvider.CredentialEntry -->
  <!-- start class org.apache.hadoop.security.alias.CredentialProviderFactory -->
  <class name="CredentialProviderFactory" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CredentialProviderFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createProvider" return="org.apache.hadoop.security.alias.CredentialProvider"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerName" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getProviders" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <field name="CREDENTIAL_PROVIDER_PATH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A factory to create a list of CredentialProvider based on the path given in a
 Configuration. It uses a service loader interface to find the available
 CredentialProviders and create them based on the list of URIs.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.alias.CredentialProviderFactory -->
  <!-- start class org.apache.hadoop.security.alias.CredentialShell -->
  <class name="CredentialShell" extends="org.apache.hadoop.conf.Configured"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.Tool"/>
    <constructor name="CredentialShell"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="init" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Parse the command line arguments and initialize the data
 <pre>
 % hadoop credential create alias [-provider providerPath]
 % hadoop credential list [-provider providerPath]
 % hadoop credential delete alias [-provider providerPath] [-i]
 </pre>
 @param args
 @return 0 if the argument(s) were recognized, 1 otherwise
 @throws IOException]]>
      </doc>
    </method>
    <method name="promptForCredential" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getPasswordReader" return="org.apache.hadoop.security.alias.CredentialShell.PasswordReader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setPasswordReader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="reader" type="org.apache.hadoop.security.alias.CredentialShell.PasswordReader"/>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Main program.

 @param args
          Command line arguments
 @throws Exception]]>
      </doc>
    </method>
    <field name="out" type="java.io.PrintStream"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[allows stdout to be captured if necessary]]>
      </doc>
    </field>
    <field name="err" type="java.io.PrintStream"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[allows stderr to be captured if necessary]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This program is the CLI utility for the CredentialProvider facilities in 
 Hadoop.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.alias.CredentialShell -->
  <!-- start class org.apache.hadoop.security.alias.CredentialShell.PasswordReader -->
  <class name="CredentialShell.PasswordReader" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CredentialShell.PasswordReader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="readPassword" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prompt" type="java.lang.String"/>
    </method>
    <method name="format"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.security.alias.CredentialShell.PasswordReader -->
  <!-- start class org.apache.hadoop.security.alias.JavaKeyStoreProvider.Factory -->
  <class name="JavaKeyStoreProvider.Factory" extends="org.apache.hadoop.security.alias.CredentialProviderFactory"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JavaKeyStoreProvider.Factory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createProvider" return="org.apache.hadoop.security.alias.CredentialProvider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerName" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[The factory to create JksProviders, which is used by the ServiceLoader.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.alias.JavaKeyStoreProvider.Factory -->
  <!-- start class org.apache.hadoop.security.alias.UserProvider.Factory -->
  <class name="UserProvider.Factory" extends="org.apache.hadoop.security.alias.CredentialProviderFactory"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UserProvider.Factory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createProvider" return="org.apache.hadoop.security.alias.CredentialProvider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerName" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.security.alias.UserProvider.Factory -->
</package>
<package name="org.apache.hadoop.security.protocolPB">
  <!-- start class org.apache.hadoop.security.protocolPB.RefreshAuthorizationPolicyProtocolClientSideTranslatorPB -->
  <class name="RefreshAuthorizationPolicyProtocolClientSideTranslatorPB" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.ipc.ProtocolMetaInterface"/>
    <implements name="org.apache.hadoop.security.authorize.RefreshAuthorizationPolicyProtocol"/>
    <implements name="java.io.Closeable"/>
    <constructor name="RefreshAuthorizationPolicyProtocolClientSideTranslatorPB" type="org.apache.hadoop.security.protocolPB.RefreshAuthorizationPolicyProtocolPB"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="refreshServiceAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="isMethodSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="methodName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.security.protocolPB.RefreshAuthorizationPolicyProtocolClientSideTranslatorPB -->
  <!-- start class org.apache.hadoop.security.protocolPB.RefreshAuthorizationPolicyProtocolServerSideTranslatorPB -->
  <class name="RefreshAuthorizationPolicyProtocolServerSideTranslatorPB" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.security.protocolPB.RefreshAuthorizationPolicyProtocolPB"/>
    <constructor name="RefreshAuthorizationPolicyProtocolServerSideTranslatorPB" type="org.apache.hadoop.security.authorize.RefreshAuthorizationPolicyProtocol"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="refreshServiceAcl" return="org.apache.hadoop.security.proto.RefreshAuthorizationPolicyProtocolProtos.RefreshServiceAclResponseProto"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="controller" type="com.google.protobuf.RpcController"/>
      <param name="request" type="org.apache.hadoop.security.proto.RefreshAuthorizationPolicyProtocolProtos.RefreshServiceAclRequestProto"/>
      <exception name="ServiceException" type="com.google.protobuf.ServiceException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.security.protocolPB.RefreshAuthorizationPolicyProtocolServerSideTranslatorPB -->
  <!-- start class org.apache.hadoop.security.protocolPB.RefreshUserMappingsProtocolClientSideTranslatorPB -->
  <class name="RefreshUserMappingsProtocolClientSideTranslatorPB" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.ipc.ProtocolMetaInterface"/>
    <implements name="org.apache.hadoop.security.RefreshUserMappingsProtocol"/>
    <implements name="java.io.Closeable"/>
    <constructor name="RefreshUserMappingsProtocolClientSideTranslatorPB" type="org.apache.hadoop.security.protocolPB.RefreshUserMappingsProtocolPB"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="refreshUserToGroupsMappings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="refreshSuperUserGroupsConfiguration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="isMethodSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="methodName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.security.protocolPB.RefreshUserMappingsProtocolClientSideTranslatorPB -->
  <!-- start class org.apache.hadoop.security.protocolPB.RefreshUserMappingsProtocolServerSideTranslatorPB -->
  <class name="RefreshUserMappingsProtocolServerSideTranslatorPB" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.security.protocolPB.RefreshUserMappingsProtocolPB"/>
    <constructor name="RefreshUserMappingsProtocolServerSideTranslatorPB" type="org.apache.hadoop.security.RefreshUserMappingsProtocol"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="refreshUserToGroupsMappings" return="org.apache.hadoop.security.proto.RefreshUserMappingsProtocolProtos.RefreshUserToGroupsMappingsResponseProto"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="controller" type="com.google.protobuf.RpcController"/>
      <param name="request" type="org.apache.hadoop.security.proto.RefreshUserMappingsProtocolProtos.RefreshUserToGroupsMappingsRequestProto"/>
      <exception name="ServiceException" type="com.google.protobuf.ServiceException"/>
    </method>
    <method name="refreshSuperUserGroupsConfiguration" return="org.apache.hadoop.security.proto.RefreshUserMappingsProtocolProtos.RefreshSuperUserGroupsConfigurationResponseProto"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="controller" type="com.google.protobuf.RpcController"/>
      <param name="request" type="org.apache.hadoop.security.proto.RefreshUserMappingsProtocolProtos.RefreshSuperUserGroupsConfigurationRequestProto"/>
      <exception name="ServiceException" type="com.google.protobuf.ServiceException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.security.protocolPB.RefreshUserMappingsProtocolServerSideTranslatorPB -->
</package>
<package name="org.apache.hadoop.security.ssl">
  <!-- start class org.apache.hadoop.security.ssl.SSLHostnameVerifier.AbstractVerifier -->
  <class name="SSLHostnameVerifier.AbstractVerifier" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.security.ssl.SSLHostnameVerifier"/>
    <constructor name="SSLHostnameVerifier.AbstractVerifier"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="verify" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="session" type="javax.net.ssl.SSLSession"/>
      <doc>
      <![CDATA[The javax.net.ssl.HostnameVerifier contract.

 @param host    'hostname' we used to create our socket
 @param session SSLSession with the remote server
 @return true if the host matched the one in the certificate.]]>
      </doc>
    </method>
    <method name="check"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="ssl" type="javax.net.ssl.SSLSocket"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="check"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="cert" type="java.security.cert.X509Certificate"/>
      <exception name="SSLException" type="javax.net.ssl.SSLException"/>
    </method>
    <method name="check"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="cns" type="java.lang.String[]"/>
      <param name="subjectAlts" type="java.lang.String[]"/>
      <exception name="SSLException" type="javax.net.ssl.SSLException"/>
    </method>
    <method name="check"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String[]"/>
      <param name="ssl" type="javax.net.ssl.SSLSocket"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="check"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String[]"/>
      <param name="cert" type="java.security.cert.X509Certificate"/>
      <exception name="SSLException" type="javax.net.ssl.SSLException"/>
    </method>
    <method name="check"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hosts" type="java.lang.String[]"/>
      <param name="cns" type="java.lang.String[]"/>
      <param name="subjectAlts" type="java.lang.String[]"/>
      <param name="ie6" type="boolean"/>
      <param name="strictWithSubDomains" type="boolean"/>
      <exception name="SSLException" type="javax.net.ssl.SSLException"/>
    </method>
    <method name="isIP4Address" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cn" type="java.lang.String"/>
    </method>
    <method name="acceptableCountryWildcard" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cn" type="java.lang.String"/>
    </method>
    <method name="isLocalhost" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
    </method>
    <method name="countDots" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <doc>
      <![CDATA[Counts the number of dots "." in a string.

 @param s string to count dots from
 @return number of dots]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.security.ssl.SSLHostnameVerifier.AbstractVerifier -->
  <!-- start class org.apache.hadoop.security.ssl.SSLHostnameVerifier.Certificates -->
  <class name="SSLHostnameVerifier.Certificates" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SSLHostnameVerifier.Certificates"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCNs" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cert" type="java.security.cert.X509Certificate"/>
    </method>
    <method name="getDNSSubjectAlts" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cert" type="java.security.cert.X509Certificate"/>
      <doc>
      <![CDATA[Extracts the array of SubjectAlt DNS names from an X509Certificate.
 Returns null if there aren't any.
 <p/>
 Note:  Java doesn't appear able to extract international characters
 from the SubjectAlts.  It can only extract international characters
 from the CN field.
 <p/>
 (Or maybe the version of OpenSSL I'm using to test isn't storing the
 international characters correctly in the SubjectAlts?).

 @param cert X509Certificate
 @return Array of SubjectALT DNS names stored in the certificate.]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.security.ssl.SSLHostnameVerifier.Certificates -->
  <!-- start class org.apache.hadoop.security.ssl.SslSocketConnectorSecure -->
  <class name="SslSocketConnectorSecure" extends="org.mortbay.jetty.security.SslSocketConnector"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SslSocketConnectorSecure"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newServerSocket" return="java.net.ServerSocket"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <param name="port" type="int"/>
      <param name="backlog" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a new ServerSocket that will not accept SSLv3 connections,
 but will accept TLSv1.x connections.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This subclass of the Jetty SslSocketConnector exists solely to control
 the TLS protocol versions allowed.  This is fallout from the POODLE
 vulnerability (CVE-2014-3566), which requires that SSLv3 be disabled.
 Only TLS 1.0 and later protocols are allowed.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.ssl.SslSocketConnectorSecure -->
</package>
<package name="org.apache.hadoop.security.token.delegation.web">
  <!-- start class org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL -->
  <class name="DelegationTokenAuthenticatedURL" extends="org.apache.hadoop.security.authentication.client.AuthenticatedURL"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DelegationTokenAuthenticatedURL"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an <code>DelegationTokenAuthenticatedURL</code>.
 <p/>
 An instance of the default {@link DelegationTokenAuthenticator} will be
 used.]]>
      </doc>
    </constructor>
    <constructor name="DelegationTokenAuthenticatedURL" type="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an <code>DelegationTokenAuthenticatedURL</code>.

 @param authenticator the {@link DelegationTokenAuthenticator} instance to
 use, if <code>null</code> the default one will be used.]]>
      </doc>
    </constructor>
    <constructor name="DelegationTokenAuthenticatedURL" type="org.apache.hadoop.security.authentication.client.ConnectionConfigurator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an <code>DelegationTokenAuthenticatedURL</code> using the default
 {@link DelegationTokenAuthenticator} class.

 @param connConfigurator a connection configurator.]]>
      </doc>
    </constructor>
    <constructor name="DelegationTokenAuthenticatedURL" type="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticator, org.apache.hadoop.security.authentication.client.ConnectionConfigurator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates an <code>DelegationTokenAuthenticatedURL</code>.

 @param authenticator the {@link DelegationTokenAuthenticator} instance to
 use, if <code>null</code> the default one will be used.
 @param connConfigurator a connection configurator.]]>
      </doc>
    </constructor>
    <method name="setDefaultDelegationTokenAuthenticator"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="authenticator" type="java.lang.Class"/>
      <doc>
      <![CDATA[Sets the default {@link DelegationTokenAuthenticator} class to use when an
 {@link DelegationTokenAuthenticatedURL} instance is created without
 specifying one.

 The default class is {@link KerberosDelegationTokenAuthenticator}

 @param authenticator the authenticator class to use as default.]]>
      </doc>
    </method>
    <method name="getDefaultDelegationTokenAuthenticator" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the default {@link DelegationTokenAuthenticator} class to use when
 an {@link DelegationTokenAuthenticatedURL} instance is created without
 specifying one.
 <p/>
 The default class is {@link KerberosDelegationTokenAuthenticator}

 @return the delegation token authenticator class to use as default.]]>
      </doc>
    </method>
    <method name="setUseQueryStringForDelegationToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="useQueryString" type="boolean"/>
      <doc>
      <![CDATA[Sets if delegation token should be transmitted in the URL query string.
 By default it is transmitted using the
 {@link DelegationTokenAuthenticator#DELEGATION_TOKEN_HEADER} HTTP header.
 <p/>
 This method is provided to enable WebHDFS backwards compatibility.

 @param useQueryString  <code>TRUE</code> if the token is transmitted in the
 URL query string, <code>FALSE</code> if the delegation token is transmitted
 using the {@link DelegationTokenAuthenticator#DELEGATION_TOKEN_HEADER} HTTP
 header.]]>
      </doc>
    </method>
    <method name="useQueryStringForDelegationToken" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns if delegation token is transmitted as a HTTP header.

 @return <code>TRUE</code> if the token is transmitted in the URL query
 string, <code>FALSE</code> if the delegation token is transmitted using the
 {@link DelegationTokenAuthenticator#DELEGATION_TOKEN_HEADER} HTTP header.]]>
      </doc>
    </method>
    <method name="openConnection" return="java.net.HttpURLConnection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.authentication.client.AuthenticatedURL.Token"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Returns an authenticated {@link HttpURLConnection}, it uses a Delegation
 Token only if the given auth token is an instance of {@link Token} and
 it contains a Delegation Token, otherwise use the configured
 {@link DelegationTokenAuthenticator} to authenticate the connection.

 @param url the URL to connect to. Only HTTP/S URLs are supported.
 @param token the authentication token being used for the user.
 @return an authenticated {@link HttpURLConnection}.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.]]>
      </doc>
    </method>
    <method name="openConnection" return="java.net.HttpURLConnection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL.Token"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Returns an authenticated {@link HttpURLConnection}. If the Delegation
 Token is present, it will be used taking precedence over the configured
 <code>Authenticator</code>.

 @param url the URL to connect to. Only HTTP/S URLs are supported.
 @param token the authentication token being used for the user.
 @return an authenticated {@link HttpURLConnection}.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.]]>
      </doc>
    </method>
    <method name="openConnection" return="java.net.HttpURLConnection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL.Token"/>
      <param name="doAs" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Returns an authenticated {@link HttpURLConnection}. If the Delegation
 Token is present, it will be used taking precedence over the configured
 <code>Authenticator</code>. If the <code>doAs</code> parameter is not NULL,
 the request will be done on behalf of the specified <code>doAs</code> user.

 @param url the URL to connect to. Only HTTP/S URLs are supported.
 @param token the authentication token being used for the user.
 @param doAs user to do the the request on behalf of, if NULL the request is
 as self.
 @return an authenticated {@link HttpURLConnection}.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.]]>
      </doc>
    </method>
    <method name="getDelegationToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL.Token"/>
      <param name="renewer" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Requests a delegation token using the configured <code>Authenticator</code>
 for authentication.

 @param url the URL to get the delegation token from. Only HTTP/S URLs are
 supported.
 @param token the authentication token being used for the user where the
 Delegation token will be stored.
 @param renewer the renewer user.
 @return a delegation token.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.]]>
      </doc>
    </method>
    <method name="getDelegationToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL.Token"/>
      <param name="renewer" type="java.lang.String"/>
      <param name="doAsUser" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Requests a delegation token using the configured <code>Authenticator</code>
 for authentication.

 @param url the URL to get the delegation token from. Only HTTP/S URLs are
 supported.
 @param token the authentication token being used for the user where the
 Delegation token will be stored.
 @param renewer the renewer user.
 @param doAsUser the user to do as, which will be the token owner.
 @return a delegation token.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.]]>
      </doc>
    </method>
    <method name="renewDelegationToken" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL.Token"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Renews a delegation token from the server end-point using the
 configured <code>Authenticator</code> for authentication.

 @param url the URL to renew the delegation token from. Only HTTP/S URLs are
 supported.
 @param token the authentication token with the Delegation Token to renew.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.]]>
      </doc>
    </method>
    <method name="renewDelegationToken" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL.Token"/>
      <param name="doAsUser" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Renews a delegation token from the server end-point using the
 configured <code>Authenticator</code> for authentication.

 @param url the URL to renew the delegation token from. Only HTTP/S URLs are
 supported.
 @param token the authentication token with the Delegation Token to renew.
 @param doAsUser the user to do as, which will be the token owner.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.]]>
      </doc>
    </method>
    <method name="cancelDelegationToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL.Token"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Cancels a delegation token from the server end-point. It does not require
 being authenticated by the configured <code>Authenticator</code>.

 @param url the URL to cancel the delegation token from. Only HTTP/S URLs
 are supported.
 @param token the authentication token with the Delegation Token to cancel.
 @throws IOException if an IO error occurred.]]>
      </doc>
    </method>
    <method name="cancelDelegationToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL.Token"/>
      <param name="doAsUser" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Cancels a delegation token from the server end-point. It does not require
 being authenticated by the configured <code>Authenticator</code>.

 @param url the URL to cancel the delegation token from. Only HTTP/S URLs
 are supported.
 @param token the authentication token with the Delegation Token to cancel.
 @param doAsUser the user to do as, which will be the token owner.
 @throws IOException if an IO error occurred.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The <code>DelegationTokenAuthenticatedURL</code> is a
 {@link AuthenticatedURL} sub-class with built-in Hadoop Delegation Token
 functionality.
 <p/>
 The authentication mechanisms supported by default are Hadoop Simple
 authentication (also known as pseudo authentication) and Kerberos SPNEGO
 authentication.
 <p/>
 Additional authentication mechanisms can be supported via {@link
 DelegationTokenAuthenticator} implementations.
 <p/>
 The default {@link DelegationTokenAuthenticator} is the {@link
 KerberosDelegationTokenAuthenticator} class which supports
 automatic fallback from Kerberos SPNEGO to Hadoop Simple authentication via
 the {@link PseudoDelegationTokenAuthenticator} class.
 <p/>
 <code>AuthenticatedURL</code> instances are not thread-safe.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL -->
  <!-- start class org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL.Token -->
  <class name="DelegationTokenAuthenticatedURL.Token" extends="org.apache.hadoop.security.authentication.client.AuthenticatedURL.Token"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DelegationTokenAuthenticatedURL.Token"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getDelegationToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setDelegationToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delegationToken" type="org.apache.hadoop.security.token.Token"/>
    </method>
    <doc>
    <![CDATA[Client side authentication token that handles Delegation Tokens.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticatedURL.Token -->
  <!-- start class org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticator -->
  <class name="DelegationTokenAuthenticator" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.security.authentication.client.Authenticator"/>
    <constructor name="DelegationTokenAuthenticator" type="org.apache.hadoop.security.authentication.client.Authenticator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setConnectionConfigurator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="configurator" type="org.apache.hadoop.security.authentication.client.ConnectionConfigurator"/>
    </method>
    <method name="authenticate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.authentication.client.AuthenticatedURL.Token"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
    </method>
    <method name="getDelegationToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.authentication.client.AuthenticatedURL.Token"/>
      <param name="renewer" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Requests a delegation token using the configured <code>Authenticator</code>
 for authentication.

 @param url the URL to get the delegation token from. Only HTTP/S URLs are
 supported.
 @param token the authentication token being used for the user where the
 Delegation token will be stored.
 @param renewer the renewer user.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.]]>
      </doc>
    </method>
    <method name="getDelegationToken" return="org.apache.hadoop.security.token.Token"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.authentication.client.AuthenticatedURL.Token"/>
      <param name="renewer" type="java.lang.String"/>
      <param name="doAsUser" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Requests a delegation token using the configured <code>Authenticator</code>
 for authentication.

 @param url the URL to get the delegation token from. Only HTTP/S URLs are
 supported.
 @param token the authentication token being used for the user where the
 Delegation token will be stored.
 @param renewer the renewer user.
 @param doAsUser the user to do as, which will be the token owner.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.]]>
      </doc>
    </method>
    <method name="renewDelegationToken" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.authentication.client.AuthenticatedURL.Token"/>
      <param name="dToken" type="org.apache.hadoop.security.token.Token"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Renews a delegation token from the server end-point using the
 configured <code>Authenticator</code> for authentication.

 @param url the URL to renew the delegation token from. Only HTTP/S URLs are
 supported.
 @param token the authentication token with the Delegation Token to renew.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.]]>
      </doc>
    </method>
    <method name="renewDelegationToken" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.authentication.client.AuthenticatedURL.Token"/>
      <param name="dToken" type="org.apache.hadoop.security.token.Token"/>
      <param name="doAsUser" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="AuthenticationException" type="org.apache.hadoop.security.authentication.client.AuthenticationException"/>
      <doc>
      <![CDATA[Renews a delegation token from the server end-point using the
 configured <code>Authenticator</code> for authentication.

 @param url the URL to renew the delegation token from. Only HTTP/S URLs are
 supported.
 @param token the authentication token with the Delegation Token to renew.
 @param doAsUser the user to do as, which will be the token owner.
 @throws IOException if an IO error occurred.
 @throws AuthenticationException if an authentication exception occurred.]]>
      </doc>
    </method>
    <method name="cancelDelegationToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.authentication.client.AuthenticatedURL.Token"/>
      <param name="dToken" type="org.apache.hadoop.security.token.Token"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Cancels a delegation token from the server end-point. It does not require
 being authenticated by the configured <code>Authenticator</code>.

 @param url the URL to cancel the delegation token from. Only HTTP/S URLs
 are supported.
 @param token the authentication token with the Delegation Token to cancel.
 @throws IOException if an IO error occurred.]]>
      </doc>
    </method>
    <method name="cancelDelegationToken"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="token" type="org.apache.hadoop.security.authentication.client.AuthenticatedURL.Token"/>
      <param name="dToken" type="org.apache.hadoop.security.token.Token"/>
      <param name="doAsUser" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Cancels a delegation token from the server end-point. It does not require
 being authenticated by the configured <code>Authenticator</code>.

 @param url the URL to cancel the delegation token from. Only HTTP/S URLs
 are supported.
 @param token the authentication token with the Delegation Token to cancel.
 @param doAsUser the user to do as, which will be the token owner.
 @throws IOException if an IO error occurred.]]>
      </doc>
    </method>
    <field name="OP_PARAM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DELEGATION_TOKEN_HEADER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DELEGATION_PARAM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TOKEN_PARAM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RENEWER_PARAM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DELEGATION_TOKEN_JSON" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DELEGATION_TOKEN_URL_STRING_JSON" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RENEW_DELEGATION_TOKEN_JSON" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[{@link Authenticator} wrapper that enhances an {@link Authenticator} with
 Delegation Token support.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticator -->
  <!-- start class org.apache.hadoop.security.token.delegation.web.KerberosDelegationTokenAuthenticator -->
  <class name="KerberosDelegationTokenAuthenticator" extends="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticator"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KerberosDelegationTokenAuthenticator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[The <code>KerberosDelegationTokenAuthenticator</code> provides support for
 Kerberos SPNEGO authentication mechanism and support for Hadoop Delegation
 Token operations.
 <p/>
 It falls back to the {@link PseudoDelegationTokenAuthenticator} if the HTTP
 endpoint does not trigger a SPNEGO authentication]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.token.delegation.web.KerberosDelegationTokenAuthenticator -->
  <!-- start class org.apache.hadoop.security.token.delegation.web.PseudoDelegationTokenAuthenticator -->
  <class name="PseudoDelegationTokenAuthenticator" extends="org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticator"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PseudoDelegationTokenAuthenticator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[The <code>PseudoDelegationTokenAuthenticator</code> provides support for
 Hadoop's pseudo authentication mechanism that accepts
 the user name specified as a query string parameter and support for Hadoop
 Delegation Token operations.
 <p/>
 This mimics the model of Hadoop Simple authentication trusting the
 {@link UserGroupInformation#getCurrentUser()} value.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.security.token.delegation.web.PseudoDelegationTokenAuthenticator -->
</package>
<package name="org.apache.hadoop.service">
  <!-- start class org.apache.hadoop.service.AbstractService -->
  <class name="AbstractService" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.service.Service"/>
    <constructor name="AbstractService" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct the service.
 @param name service name]]>
      </doc>
    </constructor>
    <method name="getServiceState" return="org.apache.hadoop.service.Service.STATE"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFailureCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="true"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFailureState" return="org.apache.hadoop.service.Service.STATE"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConfig"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Set the configuration for this service.
 This method is called during {@link #init(Configuration)}
 and should only be needed if for some reason a service implementation
 needs to override that initial setting -for example replacing
 it with a new subclass of {@link Configuration}
 @param conf new configuration.]]>
      </doc>
    </method>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[{@inheritDoc}
 This invokes {@link #serviceInit}
 @param conf the configuration of the service. This must not be null
 @throws ServiceStateException if the configuration was null,
 the state change not permitted, or something else went wrong]]>
      </doc>
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}
 @throws ServiceStateException if the current service state does not permit
 this action]]>
      </doc>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[{@inheritDoc}]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Relay to {@link #stop()}
 @throws IOException]]>
      </doc>
    </method>
    <method name="noteFailure"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Failure handling: record the exception
 that triggered it -if there was not one already.
 Services are free to call this themselves.
 @param exception the exception]]>
      </doc>
    </method>
    <method name="waitForServiceToStop" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
    </method>
    <method name="serviceInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[All initialization code needed by a service.

 This method will only ever be called once during the lifecycle of
 a specific service instance.

 Implementations do not need to be synchronized as the logic
 in {@link #init(Configuration)} prevents re-entrancy.

 The base implementation checks to see if the subclass has created
 a new configuration instance, and if so, updates the base class value
 @param conf configuration
 @throws Exception on a failure -these will be caught,
 possibly wrapped, and wil; trigger a service stop]]>
      </doc>
    </method>
    <method name="serviceStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Actions called during the INITED to STARTED transition.

 This method will only ever be called once during the lifecycle of
 a specific service instance.

 Implementations do not need to be synchronized as the logic
 in {@link #start()} prevents re-entrancy.

 @throws Exception if needed -these will be caught,
 wrapped, and trigger a service stop]]>
      </doc>
    </method>
    <method name="serviceStop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Actions called during the transition to the STOPPED state.

 This method will only ever be called once during the lifecycle of
 a specific service instance.

 Implementations do not need to be synchronized as the logic
 in {@link #stop()} prevents re-entrancy.

 Implementations MUST write this to be robust against failures, including
 checks for null references -and for the first failure to not stop other
 attempts to shut down parts of the service.

 @throws Exception if needed -these will be caught and logged.]]>
      </doc>
    </method>
    <method name="registerServiceListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="org.apache.hadoop.service.ServiceStateChangeListener"/>
    </method>
    <method name="unregisterServiceListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="org.apache.hadoop.service.ServiceStateChangeListener"/>
    </method>
    <method name="registerGlobalListener"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="org.apache.hadoop.service.ServiceStateChangeListener"/>
      <doc>
      <![CDATA[Register a global listener, which receives notifications
 from the state change events of all services in the JVM
 @param l listener]]>
      </doc>
    </method>
    <method name="unregisterGlobalListener" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="org.apache.hadoop.service.ServiceStateChangeListener"/>
      <doc>
      <![CDATA[unregister a global listener.
 @param l listener to unregister
 @return true if the listener was found (and then deleted)]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getConfig" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getStartTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLifecycleHistory" return="java.util.List"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isInState" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="expected" type="org.apache.hadoop.service.Service.STATE"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="putBlocker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="details" type="java.lang.String"/>
      <doc>
      <![CDATA[Put a blocker to the blocker map -replacing any
 with the same name.
 @param name blocker name
 @param details any specifics on the block. This must be non-null.]]>
      </doc>
    </method>
    <method name="removeBlocker"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Remove a blocker from the blocker map -
 this is a no-op if the blocker is not present
 @param name the name of the blocker]]>
      </doc>
    </method>
    <method name="getBlockers" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This is the base implementation class for services.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.service.AbstractService -->
  <!-- start class org.apache.hadoop.service.CompositeService -->
  <class name="CompositeService" extends="org.apache.hadoop.service.AbstractService"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CompositeService" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getServices" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a cloned list of services
 @return a list of child services at the time of invocation -
 added services will not be picked up.]]>
      </doc>
    </method>
    <method name="addService"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.service.Service"/>
      <doc>
      <![CDATA[Add the passed {@link Service} to the list of services managed by this
 {@link CompositeService}
 @param service the {@link Service} to be added]]>
      </doc>
    </method>
    <method name="addIfService" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="object" type="java.lang.Object"/>
      <doc>
      <![CDATA[If the passed object is an instance of {@link Service},
 add it to the list of services managed by this {@link CompositeService}
 @param object
 @return true if a service is added, false otherwise.]]>
      </doc>
    </method>
    <method name="removeService" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.service.Service"/>
    </method>
    <method name="serviceInit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="serviceStart"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="serviceStop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <field name="STOP_ONLY_STARTED_SERVICES" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Policy on shutdown: attempt to close everything (purest) or
 only try to close started services (which assumes
 that the service implementations may not handle the stop() operation
 except when started.
 Irrespective of this policy, if a child service fails during
 its init() or start() operations, it will have stop() called on it.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Composition of services.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.service.CompositeService -->
  <!-- start class org.apache.hadoop.service.CompositeService.CompositeServiceShutdownHook -->
  <class name="CompositeService.CompositeServiceShutdownHook" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Runnable"/>
    <constructor name="CompositeService.CompositeServiceShutdownHook" type="org.apache.hadoop.service.CompositeService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="run"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[JVM Shutdown hook for CompositeService which will stop the give
 CompositeService gracefully in case of JVM shutdown.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.service.CompositeService.CompositeServiceShutdownHook -->
  <!-- start class org.apache.hadoop.service.LifecycleEvent -->
  <class name="LifecycleEvent" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="LifecycleEvent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="time" type="long"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Local time in milliseconds when the event occurred]]>
      </doc>
    </field>
    <field name="state" type="org.apache.hadoop.service.Service.STATE"
      transient="false" volatile="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[new state]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A serializable lifecycle event: the time a state
 transition occurred, and what state was entered.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.service.LifecycleEvent -->
  <!-- start class org.apache.hadoop.service.LoggingStateChangeListener -->
  <class name="LoggingStateChangeListener" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.service.ServiceStateChangeListener"/>
    <constructor name="LoggingStateChangeListener" type="org.apache.commons.logging.Log"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Log events to the given log
 @param log destination for events]]>
      </doc>
    </constructor>
    <constructor name="LoggingStateChangeListener"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Log events to the static log for this class]]>
      </doc>
    </constructor>
    <method name="stateChanged"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.service.Service"/>
      <doc>
      <![CDATA[Callback for a state change event: log it
 @param service the service that has changed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This is a state change listener that logs events at INFO level]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.service.LoggingStateChangeListener -->
  <!-- start interface org.apache.hadoop.service.Service -->
  <interface name="Service"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Initialize the service.

 The transition MUST be from {@link STATE#NOTINITED} to {@link STATE#INITED}
 unless the operation failed and an exception was raised, in which case
 {@link #stop()} MUST be invoked and the service enter the state
 {@link STATE#STOPPED}.
 @param config the configuration of the service
 @throws RuntimeException on any failure during the operation]]>
      </doc>
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Start the service.

 The transition MUST be from {@link STATE#INITED} to {@link STATE#STARTED}
 unless the operation failed and an exception was raised, in which case
 {@link #stop()} MUST be invoked and the service enter the state
 {@link STATE#STOPPED}.
 @throws RuntimeException on any failure during the operation]]>
      </doc>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Stop the service. This MUST be a no-op if the service is already
 in the {@link STATE#STOPPED} state. It SHOULD be a best-effort attempt
 to stop all parts of the service.

 The implementation must be designed to complete regardless of the service
 state, including the initialized/uninitialized state of all its internal
 fields.
 @throws RuntimeException on any failure during the stop operation]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[A version of stop() that is designed to be usable in Java7 closure
 clauses.
 Implementation classes MUST relay this directly to {@link #stop()}
 @throws IOException never
 @throws RuntimeException on any failure during the stop operation]]>
      </doc>
    </method>
    <method name="registerServiceListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="org.apache.hadoop.service.ServiceStateChangeListener"/>
      <doc>
      <![CDATA[Register a listener to the service state change events.
 If the supplied listener is already listening to this service,
 this method is a no-op.
 @param listener a new listener]]>
      </doc>
    </method>
    <method name="unregisterServiceListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="org.apache.hadoop.service.ServiceStateChangeListener"/>
      <doc>
      <![CDATA[Unregister a previously registered listener of the service state
 change events. No-op if the listener is already unregistered.
 @param listener the listener to unregister.]]>
      </doc>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the name of this service.
 @return the service name]]>
      </doc>
    </method>
    <method name="getConfig" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the configuration of this service.
 This is normally not a clone and may be manipulated, though there are no
 guarantees as to what the consequences of such actions may be
 @return the current configuration, unless a specific implentation chooses
 otherwise.]]>
      </doc>
    </method>
    <method name="getServiceState" return="org.apache.hadoop.service.Service.STATE"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current service state
 @return the state of the service]]>
      </doc>
    </method>
    <method name="getStartTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the service start time
 @return the start time of the service. This will be zero if the service
 has not yet been started.]]>
      </doc>
    </method>
    <method name="isInState" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="state" type="org.apache.hadoop.service.Service.STATE"/>
      <doc>
      <![CDATA[Query to see if the service is in a specific state.
 In a multi-threaded system, the state may not hold for very long.
 @param state the expected state
 @return true if, at the time of invocation, the service was in that state.]]>
      </doc>
    </method>
    <method name="getFailureCause" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the first exception raised during the service failure. If null,
 no exception was logged
 @return the failure logged during a transition to the stopped state]]>
      </doc>
    </method>
    <method name="getFailureState" return="org.apache.hadoop.service.Service.STATE"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the state in which the failure in {@link #getFailureCause()} occurred.
 @return the state or null if there was no failure]]>
      </doc>
    </method>
    <method name="waitForServiceToStop" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeout" type="long"/>
      <doc>
      <![CDATA[Block waiting for the service to stop; uses the termination notification
 object to do so.

 This method will only return after all the service stop actions
 have been executed (to success or failure), or the timeout elapsed
 This method can be called before the service is inited or started; this is
 to eliminate any race condition with the service stopping before
 this event occurs.
 @param timeout timeout in milliseconds. A value of zero means "forever"
 @return true iff the service stopped in the time period]]>
      </doc>
    </method>
    <method name="getLifecycleHistory" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a snapshot of the lifecycle history; it is a static list
 @return a possibly empty but never null list of lifecycle events.]]>
      </doc>
    </method>
    <method name="getBlockers" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the blockers on a service -remote dependencies
 that are stopping the service from being <i>live</i>.
 @return a (snapshotted) map of blocker name-&gt;description values]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Service LifeCycle.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.service.Service -->
  <!-- start class org.apache.hadoop.service.Service.STATE -->
  <class name="Service.STATE" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.service.Service.STATE[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.service.Service.STATE"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the integer value of a state
 @return the numeric value of the state]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the name of a state
 @return the state's name]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Service states]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.service.Service.STATE -->
  <!-- start class org.apache.hadoop.service.ServiceOperations -->
  <class name="ServiceOperations" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="stop"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.service.Service"/>
      <doc>
      <![CDATA[Stop a service.
 <p/>Do nothing if the service is null or not
 in a state in which it can be/needs to be stopped.
 <p/>
 The service state is checked <i>before</i> the operation begins.
 This process is <i>not</i> thread safe.
 @param service a service or null]]>
      </doc>
    </method>
    <method name="stopQuietly" return="java.lang.Exception"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.service.Service"/>
      <doc>
      <![CDATA[Stop a service; if it is null do nothing. Exceptions are caught and
 logged at warn level. (but not Throwables). This operation is intended to
 be used in cleanup operations

 @param service a service; may be null
 @return any exception that was caught; null if none was.]]>
      </doc>
    </method>
    <method name="stopQuietly" return="java.lang.Exception"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="log" type="org.apache.commons.logging.Log"/>
      <param name="service" type="org.apache.hadoop.service.Service"/>
      <doc>
      <![CDATA[Stop a service; if it is null do nothing. Exceptions are caught and
 logged at warn level. (but not Throwables). This operation is intended to
 be used in cleanup operations

 @param log the log to warn at
 @param service a service; may be null
 @return any exception that was caught; null if none was.
 @see ServiceOperations#stopQuietly(Service)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class contains a set of methods to work with services, especially
 to walk them through their lifecycle.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.service.ServiceOperations -->
  <!-- start class org.apache.hadoop.service.ServiceOperations.ServiceListeners -->
  <class name="ServiceOperations.ServiceListeners" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServiceOperations.ServiceListeners"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="org.apache.hadoop.service.ServiceStateChangeListener"/>
      <doc>
      <![CDATA[Thread-safe addition of a new listener to the end of a list.
 Attempts to re-register a listener that is already registered
 will be ignored.
 @param l listener]]>
      </doc>
    </method>
    <method name="remove" return="boolean"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="l" type="org.apache.hadoop.service.ServiceStateChangeListener"/>
      <doc>
      <![CDATA[Remove any registration of a listener from the listener list.
 @param l listener
 @return true if the listener was found (and then removed)]]>
      </doc>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reset the listener list]]>
      </doc>
    </method>
    <method name="notifyListeners"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.service.Service"/>
      <doc>
      <![CDATA[Change to a new state and notify all listeners.
 This method will block until all notifications have been issued.
 It caches the list of listeners before the notification begins,
 so additions or removal of listeners will not be visible.
 @param service the service that has changed state]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Class to manage a list of {@link ServiceStateChangeListener} instances,
 including a notification loop that is robust against changes to the list
 during the notification process.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.service.ServiceOperations.ServiceListeners -->
  <!-- start interface org.apache.hadoop.service.ServiceStateChangeListener -->
  <interface name="ServiceStateChangeListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="stateChanged"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="org.apache.hadoop.service.Service"/>
      <doc>
      <![CDATA[Callback to notify of a state change. The service will already
 have changed state before this callback is invoked.

 This operation is invoked on the thread that initiated the state change,
 while the service itself in in a sychronized section.
 <ol>
   <li>Any long-lived operation here will prevent the service state
   change from completing in a timely manner.</li>
   <li>If another thread is somehow invoked from the listener, and
   that thread invokes the methods of the service (including
   subclass-specific methods), there is a risk of a deadlock.</li>
 </ol>


 @param service the service that has changed.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface to notify state changes of a service.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.service.ServiceStateChangeListener -->
  <!-- start class org.apache.hadoop.service.ServiceStateException -->
  <class name="ServiceStateException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServiceStateException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServiceStateException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServiceStateException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="convert" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fault" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Convert any exception into a {@link RuntimeException}.
 If the caught exception is already of that type, it is typecast to a
 {@link RuntimeException} and returned.

 All other exception types are wrapped in a new instance of
 ServiceStateException
 @param fault exception or throwable
 @return a ServiceStateException to rethrow]]>
      </doc>
    </method>
    <method name="convert" return="java.lang.RuntimeException"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="text" type="java.lang.String"/>
      <param name="fault" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Convert any exception into a {@link RuntimeException}.
 If the caught exception is already of that type, it is typecast to a
 {@link RuntimeException} and returned.

 All other exception types are wrapped in a new instance of
 ServiceStateException
 @param text text to use if a new exception is created
 @param fault exception or throwable
 @return a ServiceStateException to rethrow]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Exception that is raised on state change operations.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.service.ServiceStateException -->
  <!-- start class org.apache.hadoop.service.ServiceStateModel -->
  <class name="ServiceStateModel" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServiceStateModel" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create the service state model in the {@link Service.STATE#NOTINITED}
 state.]]>
      </doc>
    </constructor>
    <constructor name="ServiceStateModel" type="java.lang.String, org.apache.hadoop.service.Service.STATE"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a service state model instance in the chosen state
 @param state the starting state]]>
      </doc>
    </constructor>
    <method name="getState" return="org.apache.hadoop.service.Service.STATE"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Query the service state. This is a non-blocking operation.
 @return the state]]>
      </doc>
    </method>
    <method name="isInState" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="proposed" type="org.apache.hadoop.service.Service.STATE"/>
      <doc>
      <![CDATA[Query that the state is in a specific state
 @param proposed proposed new state
 @return the state]]>
      </doc>
    </method>
    <method name="ensureCurrentState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="expectedState" type="org.apache.hadoop.service.Service.STATE"/>
      <doc>
      <![CDATA[Verify that that a service is in a given state.
 @param expectedState the desired state
 @throws ServiceStateException if the service state is different from
 the desired state]]>
      </doc>
    </method>
    <method name="enterState" return="org.apache.hadoop.service.Service.STATE"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="proposed" type="org.apache.hadoop.service.Service.STATE"/>
      <doc>
      <![CDATA[Enter a state -thread safe.

 @param proposed proposed new state
 @return the original state
 @throws ServiceStateException if the transition is not permitted]]>
      </doc>
    </method>
    <method name="checkStateTransition"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="state" type="org.apache.hadoop.service.Service.STATE"/>
      <param name="proposed" type="org.apache.hadoop.service.Service.STATE"/>
      <doc>
      <![CDATA[Check that a state tansition is valid and
 throw an exception if not
 @param name name of the service (can be null)
 @param state current state
 @param proposed proposed new state]]>
      </doc>
    </method>
    <method name="isValidStateTransition" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="current" type="org.apache.hadoop.service.Service.STATE"/>
      <param name="proposed" type="org.apache.hadoop.service.Service.STATE"/>
      <doc>
      <![CDATA[Is a state transition valid?
 There are no checks for current==proposed
 as that is considered a non-transition.

 using an array kills off all branch misprediction costs, at the expense
 of cache line misses.

 @param current current state
 @param proposed proposed new state
 @return true if the transition to a new state is valid]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[return the state text as the toString() value
 @return the current state's description]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implements the service state model.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.service.ServiceStateModel -->
</package>
<package name="org.apache.hadoop.tools.protocolPB">
  <!-- start class org.apache.hadoop.tools.protocolPB.GetUserMappingsProtocolClientSideTranslatorPB -->
  <class name="GetUserMappingsProtocolClientSideTranslatorPB" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.ipc.ProtocolMetaInterface"/>
    <implements name="org.apache.hadoop.tools.GetUserMappingsProtocol"/>
    <implements name="java.io.Closeable"/>
    <constructor name="GetUserMappingsProtocolClientSideTranslatorPB" type="org.apache.hadoop.tools.protocolPB.GetUserMappingsProtocolPB"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getGroupsForUser" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="user" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="isMethodSupported" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="methodName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.tools.protocolPB.GetUserMappingsProtocolClientSideTranslatorPB -->
  <!-- start class org.apache.hadoop.tools.protocolPB.GetUserMappingsProtocolServerSideTranslatorPB -->
  <class name="GetUserMappingsProtocolServerSideTranslatorPB" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.tools.protocolPB.GetUserMappingsProtocolPB"/>
    <constructor name="GetUserMappingsProtocolServerSideTranslatorPB" type="org.apache.hadoop.tools.GetUserMappingsProtocol"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getGroupsForUser" return="org.apache.hadoop.tools.proto.GetUserMappingsProtocolProtos.GetGroupsForUserResponseProto"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="controller" type="com.google.protobuf.RpcController"/>
      <param name="request" type="org.apache.hadoop.tools.proto.GetUserMappingsProtocolProtos.GetGroupsForUserRequestProto"/>
      <exception name="ServiceException" type="com.google.protobuf.ServiceException"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.tools.protocolPB.GetUserMappingsProtocolServerSideTranslatorPB -->
</package>
<package name="org.apache.hadoop.tracing">
  <!-- start class org.apache.hadoop.tracing.SpanReceiverInfo -->
  <class name="SpanReceiverInfo" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getId" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getClassName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.tracing.SpanReceiverInfo -->
  <!-- start class org.apache.hadoop.tracing.SpanReceiverInfoBuilder -->
  <class name="SpanReceiverInfoBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SpanReceiverInfoBuilder" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="addConfigurationPair"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="build" return="org.apache.hadoop.tracing.SpanReceiverInfo"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.tracing.SpanReceiverInfoBuilder -->
  <!-- start interface org.apache.hadoop.tracing.TraceAdminProtocol -->
  <interface name="TraceAdminProtocol"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="listSpanReceivers" return="org.apache.hadoop.tracing.SpanReceiverInfo[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the currently active trace span receivers.
 
 @throws IOException        On error.]]>
      </doc>
    </method>
    <method name="addSpanReceiver" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="desc" type="org.apache.hadoop.tracing.SpanReceiverInfo"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Add a new trace span receiver.
 
 @param desc                The span receiver description.
 @return                    The ID of the new trace span receiver.

 @throws IOException        On error.]]>
      </doc>
    </method>
    <method name="removeSpanReceiver"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="spanReceiverId" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Remove a trace span receiver.

 @param spanReceiverId      The id of the span receiver to remove.
 @throws IOException        On error.]]>
      </doc>
    </method>
    <field name="versionID" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Protocol interface that provides tracing.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.tracing.TraceAdminProtocol -->
  <!-- start interface org.apache.hadoop.tracing.TraceAdminProtocolPB -->
  <interface name="TraceAdminProtocolPB"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.tracing.TraceAdminPB.TraceAdminService.BlockingInterface"/>
    <implements name="org.apache.hadoop.ipc.VersionedProtocol"/>
  </interface>
  <!-- end interface org.apache.hadoop.tracing.TraceAdminProtocolPB -->
</package>
<package name="org.apache.hadoop.util">
  <!-- start class org.apache.hadoop.util.ApplicationClassLoader -->
  <class name="ApplicationClassLoader" extends="java.net.URLClassLoader"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ApplicationClassLoader" type="java.net.URL[], java.lang.ClassLoader, java.util.List"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ApplicationClassLoader" type="java.lang.String, java.lang.ClassLoader, java.util.List"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="MalformedURLException" type="java.net.MalformedURLException"/>
    </constructor>
    <method name="getResource" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="loadClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
    </method>
    <method name="loadClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="resolve" type="boolean"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
    </method>
    <method name="isSystemClass" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="systemClasses" type="java.util.List"/>
    </method>
    <field name="SYSTEM_CLASSES_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value of the system classes if the user did not override them.
 JDK classes, hadoop classes and resources, and some select third-party
 classes are considered system classes, and are not loaded by the
 application classloader.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[A {@link URLClassLoader} for application isolation. Classes from the
 application JARs are loaded in preference to the parent loader.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.ApplicationClassLoader -->
  <!-- start class org.apache.hadoop.util.CacheableIPList -->
  <class name="CacheableIPList" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.IPList"/>
    <constructor name="CacheableIPList" type="org.apache.hadoop.util.FileBasedIPList, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="refresh"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Refreshes the ip list]]>
      </doc>
    </method>
    <method name="isIn" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ipAddress" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[CacheableIPList loads a list of subnets from a file.
 The list is cached and the cache can be refreshed by specifying cache timeout.
 A negative value of cache timeout disables any caching.

 Thread safe.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.CacheableIPList -->
  <!-- start class org.apache.hadoop.util.CloseableReferenceCount -->
  <class name="CloseableReferenceCount" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CloseableReferenceCount"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="reference"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ClosedChannelException" type="java.nio.channels.ClosedChannelException"/>
      <doc>
      <![CDATA[Increment the reference count.

 @throws ClosedChannelException      If the status is closed.]]>
      </doc>
    </method>
    <method name="unreference" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Decrement the reference count.

 @return          True if the object is closed and has no outstanding
                  references.]]>
      </doc>
    </method>
    <method name="unreferenceCheckClosed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ClosedChannelException" type="java.nio.channels.ClosedChannelException"/>
      <doc>
      <![CDATA[Decrement the reference count, checking to make sure that the
 CloseableReferenceCount is not closed.

 @throws AsynchronousCloseException  If the status is closed.]]>
      </doc>
    </method>
    <method name="isOpen" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return true if the status is currently open.

 @return                 True if the status is currently open.]]>
      </doc>
    </method>
    <method name="setClosed" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ClosedChannelException" type="java.nio.channels.ClosedChannelException"/>
      <doc>
      <![CDATA[Mark the status as closed.

 Once the status is closed, it cannot be reopened.

 @return                         The current reference count.
 @throws ClosedChannelException  If someone else closes the object
                                 before we do.]]>
      </doc>
    </method>
    <method name="getReferenceCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the current reference count.

 @return                 The current reference count.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A closeable object that maintains a reference count.

 Once the object is closed, attempting to take a new reference will throw
 ClosedChannelException.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.CloseableReferenceCount -->
  <!-- start class org.apache.hadoop.util.CombinedIPWhiteList -->
  <class name="CombinedIPWhiteList" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.IPList"/>
    <constructor name="CombinedIPWhiteList" type="java.lang.String, java.lang.String, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="isIn" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ipAddress" type="java.lang.String"/>
    </method>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.util.CombinedIPWhiteList -->
  <!-- start class org.apache.hadoop.util.ComparableVersion -->
  <class name="ComparableVersion" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Comparable"/>
    <constructor name="ComparableVersion" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="parseVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="version" type="java.lang.String"/>
    </method>
    <method name="compareTo" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="org.apache.hadoop.util.ComparableVersion"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Generic implementation of version comparison.
 
 <p>Features:
 <ul>
 <li>mixing of '<code>-</code>' (dash) and '<code>.</code>' (dot) separators,</li>
 <li>transition between characters and digits also constitutes a separator:
     <code>1.0alpha1 =&gt; [1, 0, alpha, 1]</code></li>
 <li>unlimited number of version components,</li>
 <li>version components in the text can be digits or strings,</li>
 <li>strings are checked for well-known qualifiers and the qualifier ordering is used for version ordering.
     Well-known qualifiers (case insensitive) are:<ul>
     <li><code>alpha</code> or <code>a</code></li>
     <li><code>beta</code> or <code>b</code></li>
     <li><code>milestone</code> or <code>m</code></li>
     <li><code>rc</code> or <code>cr</code></li>
     <li><code>snapshot</code></li>
     <li><code>(the empty string)</code> or <code>ga</code> or <code>final</code></li>
     <li><code>sp</code></li>
     </ul>
     Unknown qualifiers are considered after known qualifiers, with lexical order (always case insensitive),
   </li>
 <li>a dash usually precedes a qualifier, and is always less important than something preceded with a dot.</li>
 </ul></p>

 @see <a href="https://cwiki.apache.org/confluence/display/MAVENOLD/Versioning">"Versioning" on Maven Wiki</a>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.ComparableVersion -->
  <!-- start class org.apache.hadoop.util.DataChecksum.Type -->
  <class name="DataChecksum.Type" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.util.DataChecksum.Type[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.util.DataChecksum.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="valueOf" return="org.apache.hadoop.util.DataChecksum.Type"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="int"/>
      <doc>
      <![CDATA[@return the type corresponding to the id.]]>
      </doc>
    </method>
    <field name="id" type="int"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="size" type="int"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[The checksum types]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.DataChecksum.Type -->
  <!-- start class org.apache.hadoop.util.DiskChecker.DiskErrorException -->
  <class name="DiskChecker.DiskErrorException" extends="java.io.IOException"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DiskChecker.DiskErrorException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DiskChecker.DiskErrorException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.util.DiskChecker.DiskErrorException -->
  <!-- start class org.apache.hadoop.util.DiskChecker.DiskOutOfSpaceException -->
  <class name="DiskChecker.DiskOutOfSpaceException" extends="java.io.IOException"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DiskChecker.DiskOutOfSpaceException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class org.apache.hadoop.util.DiskChecker.DiskOutOfSpaceException -->
  <!-- start class org.apache.hadoop.util.ExitUtil.ExitException -->
  <class name="ExitUtil.ExitException" extends="java.lang.RuntimeException"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ExitUtil.ExitException" type="int, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="status" type="int"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.util.ExitUtil.ExitException -->
  <!-- start class org.apache.hadoop.util.ExitUtil.HaltException -->
  <class name="ExitUtil.HaltException" extends="java.lang.RuntimeException"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ExitUtil.HaltException" type="int, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="status" type="int"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.util.ExitUtil.HaltException -->
  <!-- start class org.apache.hadoop.util.FileBasedIPList -->
  <class name="FileBasedIPList" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.IPList"/>
    <constructor name="FileBasedIPList" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="reload" return="org.apache.hadoop.util.FileBasedIPList"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isIn" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ipAddress" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[FileBasedIPList loads a list of subnets in CIDR format and ip addresses from a file.

 Given an ip address, isIn  method returns true if ip belongs to one of the subnets.

 Thread safe.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.FileBasedIPList -->
  <!-- start interface org.apache.hadoop.util.IdentityHashStore.Visitor -->
  <interface name="IdentityHashStore.Visitor"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="accept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k" type="K"/>
      <param name="v" type="V"/>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.util.IdentityHashStore.Visitor -->
  <!-- start class org.apache.hadoop.util.IntrusiveCollection.IntrusiveIterator -->
  <class name="IntrusiveCollection.IntrusiveIterator" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator"/>
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="next" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[An iterator over the intrusive collection.

 Currently, you can remove elements from the list using
 #{IntrusiveIterator#remove()}, but modifying the collection in other
 ways during the iteration is not supported.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.IntrusiveCollection.IntrusiveIterator -->
  <!-- start interface org.apache.hadoop.util.IPList -->
  <interface name="IPList"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="isIn" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ipAddress" type="java.lang.String"/>
      <doc>
      <![CDATA[returns true if the ipAddress is in the IPList.
 @param ipAddress
 @return boolean value indicating whether the ipAddress is in the IPList]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.util.IPList -->
  <!-- start interface org.apache.hadoop.util.LightWeightCache.Entry -->
  <interface name="LightWeightCache.Entry"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.LightWeightGSet.LinkedElement"/>
    <method name="setExpirationTime"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeNano" type="long"/>
      <doc>
      <![CDATA[Set the expiration time.]]>
      </doc>
    </method>
    <method name="getExpirationTime" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the expiration time.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Entries of {@link LightWeightCache}.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.util.LightWeightCache.Entry -->
  <!-- start interface org.apache.hadoop.util.LightWeightGSet.LinkedElement -->
  <interface name="LightWeightGSet.LinkedElement"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setNext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="next" type="org.apache.hadoop.util.LightWeightGSet.LinkedElement"/>
      <doc>
      <![CDATA[Set the next element.]]>
      </doc>
    </method>
    <method name="getNext" return="org.apache.hadoop.util.LightWeightGSet.LinkedElement"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the next element.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Elements of {@link LightWeightGSet}.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.util.LightWeightGSet.LinkedElement -->
  <!-- start class org.apache.hadoop.util.LightWeightGSet.SetIterator -->
  <class name="LightWeightGSet.SetIterator" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator"/>
    <constructor name="LightWeightGSet.SetIterator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="next" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setTrackModification"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="trackModification" type="boolean"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.util.LightWeightGSet.SetIterator -->
  <!-- start class org.apache.hadoop.util.LimitInputStream -->
  <class name="LimitInputStream" extends="java.io.FilterInputStream"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="LimitInputStream" type="java.io.InputStream, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="available" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="mark"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readLimit" type="int"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="skip" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Copied from guava source code v15 (LimitedInputStream)
 Guava deprecated LimitInputStream in v14 and removed it in v15. Copying this class here
 allows to be compatible with guava 11 to 15+.
 
 Originally: org.apache.hadoop.hbase.io.LimitInputStream]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.LimitInputStream -->
  <!-- start class org.apache.hadoop.util.MachineList -->
  <class name="MachineList" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MachineList" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param hostEntries comma separated ip/cidr/host addresses]]>
      </doc>
    </constructor>
    <constructor name="MachineList" type="java.util.Collection"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param hostEntries collection of separated ip/cidr/host addresses]]>
      </doc>
    </constructor>
    <constructor name="MachineList" type="java.util.Collection, org.apache.hadoop.util.MachineList.InetAddressFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Accepts a collection of ip/cidr/host addresses
 
 @param hostEntries
 @param addressFactory addressFactory to convert host to InetAddress]]>
      </doc>
    </constructor>
    <method name="includes" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ipAddress" type="java.lang.String"/>
      <doc>
      <![CDATA[Accepts an ip address and return true if ipAddress is in the list
 @param ipAddress
 @return true if ipAddress is part of the list]]>
      </doc>
    </method>
    <method name="getCollection" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[returns the contents of the MachineList as a Collection<String>
 This can be used for testing 
 @return contents of the MachineList]]>
      </doc>
    </method>
    <field name="LOG" type="org.apache.commons.logging.Log"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Container class which holds a list of ip/host addresses and 
 answers membership queries.

 Accepts list of ip addresses, ip addreses in CIDR format and/or 
 host addresses.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.MachineList -->
  <!-- start class org.apache.hadoop.util.MachineList.InetAddressFactory -->
  <class name="MachineList.InetAddressFactory" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MachineList.InetAddressFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getByName" return="java.net.InetAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="host" type="java.lang.String"/>
      <exception name="UnknownHostException" type="java.net.UnknownHostException"/>
    </method>
    <doc>
    <![CDATA[InetAddressFactory is used to obtain InetAddress from host.
 This class makes it easy to simulate host to ip mappings during testing.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.MachineList.InetAddressFactory -->
  <!-- start class org.apache.hadoop.util.Options -->
  <class name="Options" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getOption" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cls" type="java.lang.Class"/>
      <param name="opts" type="base[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Find the first option of the required class.
 @param <T> the static class to find
 @param <base> the parent class of the array
 @param cls the dynamic class to find
 @param opts the list of options to look through
 @return the first option that matches
 @throws IOException]]>
      </doc>
    </method>
    <method name="prependOptions" return="T[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="oldOpts" type="T[]"/>
      <param name="newOpts" type="T[]"/>
      <doc>
      <![CDATA[Prepend some new options to the old options
 @param <T> the type of options
 @param oldOpts the old options
 @param newOpts the new options
 @return a new array of options]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This class allows generic access to variable length type-safe parameter
 lists.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.Options -->
  <!-- start class org.apache.hadoop.util.Options.BooleanOption -->
  <class name="Options.BooleanOption" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options.BooleanOption" type="boolean"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.util.Options.BooleanOption -->
  <!-- start class org.apache.hadoop.util.Options.ClassOption -->
  <class name="Options.ClassOption" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options.ClassOption" type="java.lang.Class"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.util.Options.ClassOption -->
  <!-- start class org.apache.hadoop.util.Options.FSDataInputStreamOption -->
  <class name="Options.FSDataInputStreamOption" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options.FSDataInputStreamOption" type="org.apache.hadoop.fs.FSDataInputStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.util.Options.FSDataInputStreamOption -->
  <!-- start class org.apache.hadoop.util.Options.FSDataOutputStreamOption -->
  <class name="Options.FSDataOutputStreamOption" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options.FSDataOutputStreamOption" type="org.apache.hadoop.fs.FSDataOutputStream"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.util.Options.FSDataOutputStreamOption -->
  <!-- start class org.apache.hadoop.util.Options.IntegerOption -->
  <class name="Options.IntegerOption" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options.IntegerOption" type="int"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.util.Options.IntegerOption -->
  <!-- start class org.apache.hadoop.util.Options.LongOption -->
  <class name="Options.LongOption" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options.LongOption" type="long"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.util.Options.LongOption -->
  <!-- start class org.apache.hadoop.util.Options.PathOption -->
  <class name="Options.PathOption" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options.PathOption" type="org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.util.Options.PathOption -->
  <!-- start class org.apache.hadoop.util.Options.ProgressableOption -->
  <class name="Options.ProgressableOption" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options.ProgressableOption" type="org.apache.hadoop.util.Progressable"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="org.apache.hadoop.util.Progressable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.util.Options.ProgressableOption -->
  <!-- start class org.apache.hadoop.util.Options.StringOption -->
  <class name="Options.StringOption" extends="java.lang.Object"
    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Options.StringOption" type="java.lang.String"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.apache.hadoop.util.Options.StringOption -->
  <!-- start class org.apache.hadoop.util.PerformanceAdvisory -->
  <class name="PerformanceAdvisory" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PerformanceAdvisory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="LOG" type="org.slf4j.Logger"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class org.apache.hadoop.util.PerformanceAdvisory -->
  <!-- start interface org.apache.hadoop.util.Progressable -->
  <interface name="Progressable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="progress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Report progress to the Hadoop framework.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A facility for reporting progress.
 
 <p>Clients and/or applications can use the provided <code>Progressable</code>
 to explicitly report progress to the Hadoop framework. This is especially
 important for operations which take significant amount of time since,
 in-lieu of the reported progress, the framework has to assume that an error
 has occured and time-out the operation.</p>]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.util.Progressable -->
  <!-- start class org.apache.hadoop.util.ProtoUtil -->
  <class name="ProtoUtil" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ProtoUtil"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="readRawVarint32" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Read a variable length integer in the same format that ProtoBufs encodes.
 @param in the input stream to read from
 @return the integer
 @throws IOException if it is malformed or EOF.]]>
      </doc>
    </method>
    <method name="makeIpcConnectionContext" return="org.apache.hadoop.ipc.protobuf.IpcConnectionContextProtos.IpcConnectionContextProto"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="protocol" type="java.lang.String"/>
      <param name="ugi" type="org.apache.hadoop.security.UserGroupInformation"/>
      <param name="authMethod" type="org.apache.hadoop.security.SaslRpcServer.AuthMethod"/>
      <doc>
      <![CDATA[This method creates the connection context  using exactly the same logic
 as the old connection context as was done for writable where
 the effective and real users are set based on the auth method.]]>
      </doc>
    </method>
    <method name="getUgi" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="context" type="org.apache.hadoop.ipc.protobuf.IpcConnectionContextProtos.IpcConnectionContextProto"/>
    </method>
    <method name="getUgi" return="org.apache.hadoop.security.UserGroupInformation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="userInfo" type="org.apache.hadoop.ipc.protobuf.IpcConnectionContextProtos.UserInformationProto"/>
    </method>
    <method name="convert" return="org.apache.hadoop.ipc.RPC.RpcKind"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="kind" type="org.apache.hadoop.ipc.protobuf.RpcHeaderProtos.RpcKindProto"/>
    </method>
    <method name="makeRpcRequestHeader" return="org.apache.hadoop.ipc.protobuf.RpcHeaderProtos.RpcRequestHeaderProto"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="rpcKind" type="org.apache.hadoop.ipc.RPC.RpcKind"/>
      <param name="operation" type="org.apache.hadoop.ipc.protobuf.RpcHeaderProtos.RpcRequestHeaderProto.OperationProto"/>
      <param name="callId" type="int"/>
      <param name="retryCount" type="int"/>
      <param name="uuid" type="byte[]"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.util.ProtoUtil -->
  <!-- start class org.apache.hadoop.util.PureJavaCrc32 -->
  <class name="PureJavaCrc32" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.zip.Checksum"/>
    <constructor name="PureJavaCrc32"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new PureJavaCrc32 object.]]>
      </doc>
    </constructor>
    <method name="getValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="offset" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
    </method>
    <doc>
    <![CDATA[A pure-java implementation of the CRC32 checksum that uses
 the same polynomial as the built-in native CRC32.

 This is to avoid the JNI overhead for certain uses of Checksumming
 where many small pieces of data are checksummed in succession.

 The current version is ~10x to 1.8x as fast as Sun's native
 java.util.zip.CRC32 in Java 1.6

 @see java.util.zip.CRC32]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.PureJavaCrc32 -->
  <!-- start class org.apache.hadoop.util.PureJavaCrc32C -->
  <class name="PureJavaCrc32C" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.zip.Checksum"/>
    <constructor name="PureJavaCrc32C"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new PureJavaCrc32 object.]]>
      </doc>
    </constructor>
    <method name="getValue" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="reset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
    </method>
    <method name="update"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="int"/>
    </method>
    <doc>
    <![CDATA[A pure-java implementation of the CRC32 checksum that uses
 the CRC32-C polynomial, the same polynomial used by iSCSI
 and implemented on many Intel chipsets supporting SSE4.2.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.PureJavaCrc32C -->
  <!-- start class org.apache.hadoop.util.ReflectionUtils -->
  <class name="ReflectionUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ReflectionUtils"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="theObject" type="java.lang.Object"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Check and set 'configuration' if necessary.
 
 @param theObject object for which to set configuration
 @param conf Configuration]]>
      </doc>
    </method>
    <method name="newInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="theClass" type="java.lang.Class"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Create an object for the given class and initialize it from conf
 
 @param theClass class of which an object is created
 @param conf Configuration
 @return a new object]]>
      </doc>
    </method>
    <method name="setContentionTracing"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="boolean"/>
    </method>
    <method name="printThreadInfo"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stream" type="java.io.PrintWriter"/>
      <param name="title" type="java.lang.String"/>
      <doc>
      <![CDATA[Print all of the thread's information and stack traces.
 
 @param stream the stream to
 @param title a string title for the stack trace]]>
      </doc>
    </method>
    <method name="logThreadInfo"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="log" type="org.apache.commons.logging.Log"/>
      <param name="title" type="java.lang.String"/>
      <param name="minInterval" type="long"/>
      <doc>
      <![CDATA[Log the current thread stacks at INFO level.
 @param log the logger that logs the stack trace
 @param title a descriptive title for the call stacks
 @param minInterval the minimum time from the last]]>
      </doc>
    </method>
    <method name="getClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="T"/>
      <doc>
      <![CDATA[Return the correctly-typed {@link Class} of the given object.
  
 @param o object whose correctly-typed <code>Class</code> is to be obtained
 @return the correctly typed <code>Class</code> of the given object.]]>
      </doc>
    </method>
    <method name="copy" return="T"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="src" type="T"/>
      <param name="dst" type="T"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Make a copy of the writable object using serialization to a buffer
 @param src the object to copy from
 @param dst the object to copy into, which is destroyed
 @return dst param (the copy)
 @throws IOException]]>
      </doc>
    </method>
    <method name="cloneWritableInto"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dst" type="org.apache.hadoop.io.Writable"/>
      <param name="src" type="org.apache.hadoop.io.Writable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getDeclaredFieldsIncludingInherited" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <doc>
      <![CDATA[Gets all the declared fields of a class including fields declared in
 superclasses.]]>
      </doc>
    </method>
    <method name="getDeclaredMethodsIncludingInherited" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clazz" type="java.lang.Class"/>
      <doc>
      <![CDATA[Gets all the declared methods of a class including methods declared in
 superclasses.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[General reflection utils]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.ReflectionUtils -->
  <!-- start interface org.apache.hadoop.util.Shell.CommandExecutor -->
  <interface name="Shell.CommandExecutor"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getExitCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getOutput" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.util.Shell.CommandExecutor -->
  <!-- start class org.apache.hadoop.util.Shell.ExitCodeException -->
  <class name="Shell.ExitCodeException" extends="java.io.IOException"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Shell.ExitCodeException" type="int, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getExitCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This is an IOException with exit code added.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.Shell.ExitCodeException -->
  <!-- start class org.apache.hadoop.util.Shell.OSType -->
  <class name="Shell.OSType" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.util.Shell.OSType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.util.Shell.OSType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.apache.hadoop.util.Shell.OSType -->
  <!-- start class org.apache.hadoop.util.Shell.ShellCommandExecutor -->
  <class name="Shell.ShellCommandExecutor" extends="org.apache.hadoop.util.Shell"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.Shell.CommandExecutor"/>
    <constructor name="Shell.ShellCommandExecutor" type="java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Shell.ShellCommandExecutor" type="java.lang.String[], java.io.File"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Shell.ShellCommandExecutor" type="java.lang.String[], java.io.File, java.util.Map"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Shell.ShellCommandExecutor" type="java.lang.String[], java.io.File, java.util.Map, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new instance of the ShellCommandExecutor to execute a command.
 
 @param execString The command to execute with arguments
 @param dir If not-null, specifies the directory which should be set
            as the current working directory for the command.
            If null, the current working directory is not modified.
 @param env If not-null, environment of the command will include the
            key-value pairs specified in the map. If null, the current
            environment is not modified.
 @param timeout Specifies the time in milliseconds, after which the
                command will be killed and the status marked as timedout.
                If 0, the command will not be timed out.]]>
      </doc>
    </constructor>
    <method name="execute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Execute the shell command.]]>
      </doc>
    </method>
    <method name="getExecString" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="parseExecResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="lines" type="java.io.BufferedReader"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getOutput" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the output of the shell command.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the commands of this instance.
 Arguments with spaces in are presented with quotes round; other
 arguments are presented raw

 @return a string representation of the object.]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A simple shell command executor.
 
 <code>ShellCommandExecutor</code>should be used in cases where the output 
 of the command needs no explicit parsing and where the command, working 
 directory and the environment remains unchanged. The output of the command 
 is stored as-is and is expected to be small.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.Shell.ShellCommandExecutor -->
  <!-- start class org.apache.hadoop.util.ShutdownHookManager -->
  <class name="ShutdownHookManager" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="org.apache.hadoop.util.ShutdownHookManager"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return <code>ShutdownHookManager</code> singleton.

 @return <code>ShutdownHookManager</code> singleton.]]>
      </doc>
    </method>
    <method name="addShutdownHook"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shutdownHook" type="java.lang.Runnable"/>
      <param name="priority" type="int"/>
      <doc>
      <![CDATA[Adds a shutdownHook with a priority, the higher the priority
 the earlier will run. ShutdownHooks with same priority run
 in a non-deterministic order.

 @param shutdownHook shutdownHook <code>Runnable</code>
 @param priority priority of the shutdownHook.]]>
      </doc>
    </method>
    <method name="removeShutdownHook" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shutdownHook" type="java.lang.Runnable"/>
      <doc>
      <![CDATA[Removes a shutdownHook.

 @param shutdownHook shutdownHook to remove.
 @return TRUE if the shutdownHook was registered and removed,
 FALSE otherwise.]]>
      </doc>
    </method>
    <method name="hasShutdownHook" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shutdownHook" type="java.lang.Runnable"/>
      <doc>
      <![CDATA[Indicates if a shutdownHook is registered or not.

 @param shutdownHook shutdownHook to check if registered.
 @return TRUE/FALSE depending if the shutdownHook is is registered.]]>
      </doc>
    </method>
    <method name="isShutdownInProgress" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates if shutdown is in progress or not.
 
 @return TRUE if the shutdown is in progress, otherwise FALSE.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[The <code>ShutdownHookManager</code> enables running shutdownHook
 in a deterministic order, higher priority first.
 <p/>
 The JVM runs ShutdownHooks in a non-deterministic order or in parallel.
 This class registers a single JVM shutdownHook and run all the
 shutdownHooks registered to it (to this class) in order based on their
 priority.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.ShutdownHookManager -->
  <!-- start class org.apache.hadoop.util.ShutdownThreadsHelper -->
  <class name="ShutdownThreadsHelper" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ShutdownThreadsHelper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="shutdownThread" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="thread" type="java.lang.Thread"/>
      <doc>
      <![CDATA[@param thread {@link Thread to be shutdown}
 @return <tt>true</tt> if the thread is successfully interrupted,
 <tt>false</tt> otherwise
 @throws InterruptedException]]>
      </doc>
    </method>
    <method name="shutdownThread" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="thread" type="java.lang.Thread"/>
      <param name="timeoutInMilliSeconds" type="long"/>
      <doc>
      <![CDATA[@param thread {@link Thread to be shutdown}
 @param timeoutInMilliSeconds time to wait for thread to join after being
                              interrupted
 @return <tt>true</tt> if the thread is successfully interrupted,
 <tt>false</tt> otherwise
 @throws InterruptedException]]>
      </doc>
    </method>
    <method name="shutdownExecutorService" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.util.concurrent.ExecutorService"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[@param service {@link ExecutorService to be shutdown}
 @return <tt>true</tt> if the service is terminated,
 <tt>false</tt> otherwise
 @throws InterruptedException]]>
      </doc>
    </method>
    <method name="shutdownExecutorService" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="service" type="java.util.concurrent.ExecutorService"/>
      <param name="timeoutInMs" type="long"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[@param service {@link ExecutorService to be shutdown}
 @param timeoutInMs time to wait for {@link
 ExecutorService#awaitTermination(long, java.util.concurrent.TimeUnit)}
                    calls in milli seconds.
 @return <tt>true</tt> if the service is terminated,
 <tt>false</tt> otherwise
 @throws InterruptedException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Helper class to shutdown {@link Thread}s and {@link ExecutorService}s.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.ShutdownThreadsHelper -->
  <!-- start class org.apache.hadoop.util.StringInterner -->
  <class name="StringInterner" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="StringInterner"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="strongIntern" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sample" type="java.lang.String"/>
      <doc>
      <![CDATA[Interns and returns a reference to the representative instance 
 for any of a collection of string instances that are equal to each other.
 Retains strong reference to the instance, 
 thus preventing it from being garbage-collected. 
 
 @param sample string instance to be interned
 @return strong reference to interned string instance]]>
      </doc>
    </method>
    <method name="weakIntern" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sample" type="java.lang.String"/>
      <doc>
      <![CDATA[Interns and returns a reference to the representative instance 
 for any of a collection of string instances that are equal to each other.
 Retains weak reference to the instance, 
 and so does not prevent it from being garbage-collected.
 
 @param sample string instance to be interned
 @return weak reference to interned string instance]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides equivalent behavior to String.intern() to optimize performance, 
 whereby does not consume memory in the permanent generation.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.StringInterner -->
  <!-- start class org.apache.hadoop.util.StringUtils.TraditionalBinaryPrefix -->
  <class name="StringUtils.TraditionalBinaryPrefix" extends="java.lang.Enum"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.apache.hadoop.util.StringUtils.TraditionalBinaryPrefix[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.apache.hadoop.util.StringUtils.TraditionalBinaryPrefix"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="valueOf" return="org.apache.hadoop.util.StringUtils.TraditionalBinaryPrefix"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="symbol" type="char"/>
      <doc>
      <![CDATA[@return The TraditionalBinaryPrefix object corresponding to the symbol.]]>
      </doc>
    </method>
    <method name="string2long" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <doc>
      <![CDATA[Convert a string to long.
 The input string is first be trimmed
 and then it is parsed with traditional binary prefix.

 For example,
 "-1230k" will be converted to -1230 * 1024 = -1259520;
 "891g" will be converted to 891 * 1024^3 = 956703965184;

 @param s input string
 @return a long value represented by the input string.]]>
      </doc>
    </method>
    <method name="long2String" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="n" type="long"/>
      <param name="unit" type="java.lang.String"/>
      <param name="decimalPlaces" type="int"/>
      <doc>
      <![CDATA[Convert a long integer to a string with traditional binary prefix.
 
 @param n the value to be converted
 @param unit The unit, e.g. "B" for bytes.
 @param decimalPlaces The number of decimal places.
 @return a string with traditional binary prefix.]]>
      </doc>
    </method>
    <field name="value" type="long"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="symbol" type="char"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="bitShift" type="int"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="bitMask" type="long"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[The traditional binary prefixes, kilo, mega, ..., exa,
 which can be represented by a 64-bit integer.
 TraditionalBinaryPrefix symbol are case insensitive.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.StringUtils.TraditionalBinaryPrefix -->
  <!-- start class org.apache.hadoop.util.ThreadUtil -->
  <class name="ThreadUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ThreadUtil"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="sleepAtLeastIgnoreInterrupts"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="millis" type="long"/>
      <doc>
      <![CDATA[Cause the current thread to sleep as close as possible to the provided
 number of milliseconds. This method will log and ignore any
 {@link InterruptedException} encountered.
 
 @param millis the number of milliseconds for the current thread to sleep]]>
      </doc>
    </method>
  </class>
  <!-- end class org.apache.hadoop.util.ThreadUtil -->
  <!-- start interface org.apache.hadoop.util.Tool -->
  <interface name="Tool"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Execute the command with the given arguments.
 
 @param args command specific arguments.
 @return exit code.
 @throws Exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A tool interface that supports handling of generic command-line options.
 
 <p><code>Tool</code>, is the standard for any Map-Reduce tool/application. 
 The tool/application should delegate the handling of 
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/CommandsManual.html#Generic_Options">
 standard command-line options</a> to {@link ToolRunner#run(Tool, String[])} 
 and only handle its custom arguments.</p>
 
 <p>Here is how a typical <code>Tool</code> is implemented:</p>
 <p><blockquote><pre>
     public class MyApp extends Configured implements Tool {
     
       public int run(String[] args) throws Exception {
         // <code>Configuration</code> processed by <code>ToolRunner</code>
         Configuration conf = getConf();
         
         // Create a JobConf using the processed <code>conf</code>
         JobConf job = new JobConf(conf, MyApp.class);
         
         // Process custom command-line options
         Path in = new Path(args[1]);
         Path out = new Path(args[2]);
         
         // Specify various job-specific parameters     
         job.setJobName("my-app");
         job.setInputPath(in);
         job.setOutputPath(out);
         job.setMapperClass(MyMapper.class);
         job.setReducerClass(MyReducer.class);

         // Submit the job, then poll for progress until the job is complete
         JobClient.runJob(job);
         return 0;
       }
       
       public static void main(String[] args) throws Exception {
         // Let <code>ToolRunner</code> handle generic command-line options 
         int res = ToolRunner.run(new Configuration(), new MyApp(), args);
         
         System.exit(res);
       }
     }
 </pre></blockquote></p>
 
 @see GenericOptionsParser
 @see ToolRunner]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.util.Tool -->
  <!-- start class org.apache.hadoop.util.ToolRunner -->
  <class name="ToolRunner" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ToolRunner"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="tool" type="org.apache.hadoop.util.Tool"/>
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Runs the given <code>Tool</code> by {@link Tool#run(String[])}, after 
 parsing with the given generic arguments. Uses the given 
 <code>Configuration</code>, or builds one if null.
 
 Sets the <code>Tool</code>'s configuration with the possibly modified 
 version of the <code>conf</code>.  
 
 @param conf <code>Configuration</code> for the <code>Tool</code>.
 @param tool <code>Tool</code> to run.
 @param args command-line arguments to the tool.
 @return exit code of the {@link Tool#run(String[])} method.]]>
      </doc>
    </method>
    <method name="run" return="int"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tool" type="org.apache.hadoop.util.Tool"/>
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Runs the <code>Tool</code> with its <code>Configuration</code>.
 
 Equivalent to <code>run(tool.getConf(), tool, args)</code>.
 
 @param tool <code>Tool</code> to run.
 @param args command-line arguments to the tool.
 @return exit code of the {@link Tool#run(String[])} method.]]>
      </doc>
    </method>
    <method name="printGenericCommandUsage"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.PrintStream"/>
      <doc>
      <![CDATA[Prints generic command-line argurments and usage information.
 
  @param out stream to write usage information to.]]>
      </doc>
    </method>
    <method name="confirmPrompt" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prompt" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Print out a prompt to the user, and return true if the user
 responds with "y" or "yes". (case insensitive)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A utility to help run {@link Tool}s.
 
 <p><code>ToolRunner</code> can be used to run classes implementing 
 <code>Tool</code> interface. It works in conjunction with 
 {@link GenericOptionsParser} to parse the 
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/CommandsManual.html#Generic_Options">
 generic hadoop command line arguments</a> and modifies the 
 <code>Configuration</code> of the <code>Tool</code>. The 
 application-specific options are passed along without being modified.
 </p>
 
 @see Tool
 @see GenericOptionsParser]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.ToolRunner -->
  <!-- start class org.apache.hadoop.util.Waitable -->
  <class name="Waitable" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Waitable" type="java.util.concurrent.locks.Condition"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="await" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="provide"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="T"/>
    </method>
    <method name="hasVal" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getVal" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents an object that you can wait for.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.Waitable -->
  <doc>
  <![CDATA[Common utilities.]]>
  </doc>
</package>
<package name="org.apache.hadoop.util.bloom">
  <!-- start class org.apache.hadoop.util.bloom.BloomFilter -->
  <class name="BloomFilter" extends="org.apache.hadoop.util.bloom.Filter"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BloomFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor - use with readFields]]>
      </doc>
    </constructor>
    <constructor name="BloomFilter" type="int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor
 @param vectorSize The vector size of <i>this</i> filter.
 @param nbHash The number of hash function to consider.
 @param hashType type of the hashing function (see
 {@link org.apache.hadoop.util.hash.Hash}).]]>
      </doc>
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="and"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="membershipTest" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="not"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="or"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="xor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getVectorSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return size of the the bloomfilter]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Implements a <i>Bloom filter</i>, as defined by Bloom in 1970.
 <p>
 The Bloom filter is a data structure that was introduced in 1970 and that has been adopted by 
 the networking research community in the past decade thanks to the bandwidth efficiencies that it
 offers for the transmission of set membership information between networked hosts.  A sender encodes 
 the information into a bit vector, the Bloom filter, that is more compact than a conventional 
 representation. Computation and space costs for construction are linear in the number of elements.  
 The receiver uses the filter to test whether various elements are members of the set. Though the 
 filter will occasionally return a false positive, it will never return a false negative. When creating 
 the filter, the sender can choose its desired point in a trade-off between the false positive rate and the size. 
 
 <p>
 Originally created by
 <a href="http://www.one-lab.org">European Commission One-Lab Project 034819</a>.
 
 @see Filter The general behavior of a filter
 
 @see <a href="http://portal.acm.org/citation.cfm?id=362692&dl=ACM&coll=portal">Space/Time Trade-Offs in Hash Coding with Allowable Errors</a>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.bloom.BloomFilter -->
  <!-- start class org.apache.hadoop.util.bloom.CountingBloomFilter -->
  <class name="CountingBloomFilter" extends="org.apache.hadoop.util.bloom.Filter"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="CountingBloomFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor - use with readFields]]>
      </doc>
    </constructor>
    <constructor name="CountingBloomFilter" type="int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor
 @param vectorSize The vector size of <i>this</i> filter.
 @param nbHash The number of hash function to consider.
 @param hashType type of the hashing function (see
 {@link org.apache.hadoop.util.hash.Hash}).]]>
      </doc>
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="delete"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
      <doc>
      <![CDATA[Removes a specified key from <i>this</i> counting Bloom filter.
 <p>
 <b>Invariant</b>: nothing happens if the specified key does not belong to <i>this</i> counter Bloom filter.
 @param key The key to remove.]]>
      </doc>
    </method>
    <method name="and"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="membershipTest" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="approximateCount" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
      <doc>
      <![CDATA[This method calculates an approximate count of the key, i.e. how many
 times the key was added to the filter. This allows the filter to be
 used as an approximate <code>key -&gt; count</code> map.
 <p>NOTE: due to the bucket size of this filter, inserting the same
 key more than 15 times will cause an overflow at all filter positions
 associated with this key, and it will significantly increase the error
 rate for this and other keys. For this reason the filter can only be
 used to store small count values <code>0 &lt;= N &lt;&lt; 15</code>.
 @param key key to be tested
 @return 0 if the key is not present. Otherwise, a positive value v will
 be returned such that <code>v == count</code> with probability equal to the
 error rate of this filter, and <code>v &gt; count</code> otherwise.
 Additionally, if the filter experienced an underflow as a result of
 {@link #delete(Key)} operation, the return value may be lower than the
 <code>count</code> with the probability of the false negative rate of such
 filter.]]>
      </doc>
    </method>
    <method name="not"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="or"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="xor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Implements a <i>counting Bloom filter</i>, as defined by Fan et al. in a ToN
 2000 paper.
 <p>
 A counting Bloom filter is an improvement to standard a Bloom filter as it
 allows dynamic additions and deletions of set membership information.  This 
 is achieved through the use of a counting vector instead of a bit vector.
 <p>
 Originally created by
 <a href="http://www.one-lab.org">European Commission One-Lab Project 034819</a>.

 @see Filter The general behavior of a filter
 
 @see <a href="http://portal.acm.org/citation.cfm?id=343571.343572">Summary cache: a scalable wide-area web cache sharing protocol</a>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.bloom.CountingBloomFilter -->
  <!-- start class org.apache.hadoop.util.bloom.DynamicBloomFilter -->
  <class name="DynamicBloomFilter" extends="org.apache.hadoop.util.bloom.Filter"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DynamicBloomFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Zero-args constructor for the serialization.]]>
      </doc>
    </constructor>
    <constructor name="DynamicBloomFilter" type="int, int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor.
 <p>
 Builds an empty Dynamic Bloom filter.
 @param vectorSize The number of bits in the vector.
 @param nbHash The number of hash function to consider.
 @param hashType type of the hashing function (see
 {@link org.apache.hadoop.util.hash.Hash}).
 @param nr The threshold for the maximum number of keys to record in a
 dynamic Bloom filter row.]]>
      </doc>
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="and"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="membershipTest" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="not"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="or"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="xor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filter" type="org.apache.hadoop.util.bloom.Filter"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Implements a <i>dynamic Bloom filter</i>, as defined in the INFOCOM 2006 paper.
 <p>
 A dynamic Bloom filter (DBF) makes use of a <code>s * m</code> bit matrix but
 each of the <code>s</code> rows is a standard Bloom filter. The creation 
 process of a DBF is iterative. At the start, the DBF is a <code>1 * m</code>
 bit matrix, i.e., it is composed of a single standard Bloom filter.
 It assumes that <code>n<sub>r</sub></code> elements are recorded in the 
 initial bit vector, where <code>n<sub>r</sub> <= n</code> (<code>n</code> is
 the cardinality of the set <code>A</code> to record in the filter).  
 <p>
 As the size of <code>A</code> grows during the execution of the application,
 several keys must be inserted in the DBF.  When inserting a key into the DBF,
 one must first get an active Bloom filter in the matrix.  A Bloom filter is
 active when the number of recorded keys, <code>n<sub>r</sub></code>, is 
 strictly less than the current cardinality of <code>A</code>, <code>n</code>.
 If an active Bloom filter is found, the key is inserted and 
 <code>n<sub>r</sub></code> is incremented by one. On the other hand, if there
 is no active Bloom filter, a new one is created (i.e., a new row is added to
 the matrix) according to the current size of <code>A</code> and the element
 is added in this new Bloom filter and the <code>n<sub>r</sub></code> value of
 this new Bloom filter is set to one.  A given key is said to belong to the
 DBF if the <code>k</code> positions are set to one in one of the matrix rows.
 <p>
 Originally created by
 <a href="http://www.one-lab.org">European Commission One-Lab Project 034819</a>.

 @see Filter The general behavior of a filter
 @see BloomFilter A Bloom filter
 
 @see <a href="http://www.cse.fau.edu/~jie/research/publications/Publication_files/infocom2006.pdf">Theory and Network Applications of Dynamic Bloom Filters</a>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.bloom.DynamicBloomFilter -->
  <!-- start class org.apache.hadoop.util.bloom.HashFunction -->
  <class name="HashFunction" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="HashFunction" type="int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor.
 <p>
 Builds a hash function that must obey to a given maximum number of returned values and a highest value.
 @param maxValue The maximum highest returned value.
 @param nbHash The number of resulting hashed values.
 @param hashType type of the hashing function (see {@link Hash}).]]>
      </doc>
    </constructor>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears <i>this</i> hash function. A NOOP]]>
      </doc>
    </method>
    <method name="hash" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k" type="org.apache.hadoop.util.bloom.Key"/>
      <doc>
      <![CDATA[Hashes a specified key into several integers.
 @param k The specified key.
 @return The array of hashed values.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implements a hash object that returns a certain number of hashed values.
 
 @see Key The general behavior of a key being stored in a filter
 @see Filter The general behavior of a filter]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.bloom.HashFunction -->
  <!-- start interface org.apache.hadoop.util.bloom.RemoveScheme -->
  <interface name="RemoveScheme"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="RANDOM" type="short"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Random selection.
 <p>
 The idea is to randomly select a bit to reset.]]>
      </doc>
    </field>
    <field name="MINIMUM_FN" type="short"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[MinimumFN Selection.
 <p>
 The idea is to select the bit to reset that will generate the minimum
 number of false negative.]]>
      </doc>
    </field>
    <field name="MAXIMUM_FP" type="short"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[MaximumFP Selection.
 <p>
 The idea is to select the bit to reset that will remove the maximum number
 of false positive.]]>
      </doc>
    </field>
    <field name="RATIO" type="short"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Ratio Selection.
 <p>
 The idea is to select the bit to reset that will, at the same time, remove
 the maximum number of false positve while minimizing the amount of false
 negative generated.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Defines the different remove scheme for retouched Bloom filters.
 <p>
 Originally created by
 <a href="http://www.one-lab.org">European Commission One-Lab Project 034819</a>.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.util.bloom.RemoveScheme -->
  <!-- start class org.apache.hadoop.util.bloom.RetouchedBloomFilter -->
  <class name="RetouchedBloomFilter" extends="org.apache.hadoop.util.bloom.BloomFilter"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.util.bloom.RemoveScheme"/>
    <constructor name="RetouchedBloomFilter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default constructor - use with readFields]]>
      </doc>
    </constructor>
    <constructor name="RetouchedBloomFilter" type="int, int, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor
 @param vectorSize The vector size of <i>this</i> filter.
 @param nbHash The number of hash function to consider.
 @param hashType type of the hashing function (see
 {@link org.apache.hadoop.util.hash.Hash}).]]>
      </doc>
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
    </method>
    <method name="addFalsePositive"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.apache.hadoop.util.bloom.Key"/>
      <doc>
      <![CDATA[Adds a false positive information to <i>this</i> retouched Bloom filter.
 <p>
 <b>Invariant</b>: if the false positive is <code>null</code>, nothing happens.
 @param key The false positive key to add.]]>
      </doc>
    </method>
    <method name="addFalsePositive"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="coll" type="java.util.Collection"/>
      <doc>
      <![CDATA[Adds a collection of false positive information to <i>this</i> retouched Bloom filter.
 @param coll The collection of false positive.]]>
      </doc>
    </method>
    <method name="addFalsePositive"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="java.util.List"/>
      <doc>
      <![CDATA[Adds a list of false positive information to <i>this</i> retouched Bloom filter.
 @param keys The list of false positive.]]>
      </doc>
    </method>
    <method name="addFalsePositive"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="keys" type="org.apache.hadoop.util.bloom.Key[]"/>
      <doc>
      <![CDATA[Adds an array of false positive information to <i>this</i> retouched Bloom filter.
 @param keys The array of false positive.]]>
      </doc>
    </method>
    <method name="selectiveClearing"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="k" type="org.apache.hadoop.util.bloom.Key"/>
      <param name="scheme" type="short"/>
      <doc>
      <![CDATA[Performs the selective clearing for a given key.
 @param k The false positive key to remove from <i>this</i> retouched Bloom filter.
 @param scheme The selective clearing scheme to apply.]]>
      </doc>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Implements a <i>retouched Bloom filter</i>, as defined in the CoNEXT 2006 paper.
 <p>
 It allows the removal of selected false positives at the cost of introducing
 random false negatives, and with the benefit of eliminating some random false
 positives at the same time.
 
 <p>
 Originally created by
 <a href="http://www.one-lab.org">European Commission One-Lab Project 034819</a>.
 
 @see Filter The general behavior of a filter
 @see BloomFilter A Bloom filter
 @see RemoveScheme The different selective clearing algorithms
 
 @see <a href="http://www-rp.lip6.fr/site_npa/site_rp/_publications/740-rbf_cameraready.pdf">Retouched Bloom Filters: Allowing Networked Applications to Trade Off Selected False Positives Against False Negatives</a>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.util.bloom.RetouchedBloomFilter -->
</package>
<package name="org.apache.hadoop.util.hash">
</package>

</api>
