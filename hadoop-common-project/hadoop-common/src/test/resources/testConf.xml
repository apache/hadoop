<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="testConf.xsl"?>
<!--
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->
<configuration>
  <!-- Normal mode is test. To run just the commands and dump the output
       to the log, set it to nocompare -->
  <mode>test</mode>
  
  <!--  Comparator types:
           ExactComparator
           SubstringComparator
           RegexpComparator
           TokenComparator
           -->
  <tests>
    <!-- Tests for help -->
    <test> <!-- TESTED -->
      <description>help: check if fs help message is shown</description>
      <test-commands>
        <command>-help</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>SubstringComparator</type>
          <expected-output>Usage: hadoop fs [generic options]</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for ls</description>
      <test-commands>
        <command>-help ls</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-ls \[-d\] \[-h\] \[-R\] \[&lt;path&gt; \.\.\.\] :( |\t)*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*List the contents that match the specified file pattern. If path is not</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*specified, the contents of /user/&lt;currentUser&gt; will be listed. Directory entries( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*are of the form:( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*permissions - userId groupId sizeOfDirectory\(in bytes\)( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*modificationDate\(yyyy-MM-dd HH:mm\) directoryName( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*and file entries are of the form:( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*permissions numberOfReplicas userId groupId sizeOfFile\(in bytes\)( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*modificationDate\(yyyy-MM-dd HH:mm\) fileName( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-d\s+Directories are listed as plain files\.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-h\s+Formats the sizes of files in a human-readable fashion rather than a number( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*of bytes\.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-R\s+Recursively list the contents of directories\.( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for lsr</description>
      <test-commands>
        <command>-help lsr</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-lsr :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s+\(DEPRECATED\) Same as 'ls -R'</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for get</description>
      <test-commands>
        <command>-help get</command>
      </test-commands>
      <cleanup-commands>
        <!-- No cleanup -->
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-get( )*\[-p\]( )*\[-ignoreCrc\]( )*\[-crc\]( )*&lt;src&gt; \.\.\. &lt;localdst&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>\s*Copy files that match the file pattern &lt;src&gt; to the local name.  &lt;src&gt; is kept.\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>\s*When copying multiple files, the destination must be a directory. Passing -p\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*preserves access and modification times, ownership and the mode.*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for du</description>
      <test-commands>
        <command>-help du</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-du \[-s\] \[-h\] &lt;path&gt; \.\.\. :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Show the amount of space, in bytes, used by the files that match the specified\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*file pattern. The following flags are optional:\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-s\s*Rather than showing the size of each individual file that matches the\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*pattern, shows the total \(summary\) size.\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-h\s*Formats the sizes of files in a human-readable fashion rather than a number\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>\s*of bytes.\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Note that, even without the -s option, this only shows size summaries one level\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*deep into a directory.</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*The output is in the form </expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*size\s+name\(full path\)\s*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for dus</description>
      <test-commands>
        <command>-help dus</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-dus :</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*\(DEPRECATED\) Same as 'du -s'</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for count</description>
      <test-commands>
        <command>-help count</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-count \[-q\] \[-h\] &lt;path&gt; \.\.\. :( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Count the number of directories, files and bytes under the paths( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*that match the specified file pattern.  The output columns are:( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*DIR_COUNT FILE_COUNT CONTENT_SIZE FILE_NAME or( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*QUOTA REMAINING_QUOTA SPACE_QUOTA REMAINING_SPACE_QUOTA( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*DIR_COUNT FILE_COUNT CONTENT_SIZE FILE_NAME( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*The -h option shows file sizes in human readable format.( )*</expected-output>
        </comparator>
      </comparators>
    </test>

   <test> <!-- TESTED -->
      <description>help: help for mv</description>
      <test-commands>
        <command>-help mv</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-mv &lt;src&gt; \.\.\. &lt;dst&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>\s*Move files that match the specified file pattern &lt;src&gt; to a destination &lt;dst&gt;.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*When moving multiple files, the destination must be a directory.( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for cp</description>
      <test-commands>
        <command>-help cp</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-cp \[-f\] \[-p \| -p\[topax\]\] &lt;src&gt; \.\.\. &lt;dst&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Copy files that match the file pattern &lt;src&gt; to a destination.  When copying( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*multiple files, the destination must be a directory.( )*Passing -p preserves status( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*\[topax\] \(timestamps, ownership, permission, ACLs, XAttr\). If -p is specified( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*with no &lt;arg&gt;, then preserves timestamps, ownership, permission. If -pa is( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*specified, then preserves permission also because ACL is a super-set of( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*permission. Passing -f overwrites the destination if it already exists.( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for rm</description>
      <test-commands>
        <command>-help rm</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-rm \[-f\] \[-r\|-R\] \[-skipTrash\] &lt;src&gt; \.\.\. :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Delete all files that match the specified file pattern. Equivalent to the Unix( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*command "rm &lt;src&gt;"( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-skipTrash\s+option bypasses trash, if enabled, and immediately deletes &lt;src&gt;( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s+-f\s+If the file does not exist, do not display a diagnostic message or\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s+modify the exit status to reflect an error\.\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s+-\[rR\]\s+Recursively deletes directories\s*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for rmdir</description>
      <test-commands>
        <command>-help rmdir</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-rmdir \[--ignore-fail-on-non-empty\] &lt;dir&gt; \.\.\. :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>\s+Removes the directory entry specified by each directory argument, provided it is\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>\s+empty\.\s*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for rmr</description>
      <test-commands>
        <command>-help rmr</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-rmr :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*\(DEPRECATED\) Same as 'rm -r'\s*</expected-output>
        </comparator>
      </comparators>
    </test>

   <test> <!-- TESTED -->
      <description>help: help for put</description>
      <test-commands>
        <command>-help put</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-put \[-f\] \[-p\] &lt;localsrc&gt; \.\.\. &lt;dst&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Copy files from the local file system into fs.( )*Copying fails if the file already( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*exists, unless the -f flag is given.( )*Passing -p preserves access and( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*modification times, ownership and the mode. Passing -f overwrites the( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*destination if it already exists.( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for copyFromLocal</description>
      <test-commands>
        <command>-help copyFromLocal</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-copyFromLocal \[-f\] \[-p\] &lt;localsrc&gt; \.\.\. &lt;dst&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Identical to the -put command\.\s*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for moveFromLocal</description>
      <test-commands>
        <command>-help moveFromLocal</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-moveFromLocal &lt;localsrc&gt; \.\.\. &lt;dst&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*Same as -put, except that the source is deleted after it's copied.</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for get</description>
      <test-commands>
        <command>-help get</command>
      </test-commands>
      <cleanup-commands>
        <!-- No cleanup -->
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-get( )*\[-p\]( )*\[-ignoreCrc\]( )*\[-crc\]( )*&lt;src&gt; \.\.\. &lt;localdst&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*Copy files that match the file pattern &lt;src&gt; to the local name.( )*&lt;src&gt; is kept.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*When copying multiple files, the destination must be a directory. Passing -p( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*preserves access and modification times, ownership and the mode.( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for getmerge</description>
      <test-commands>
        <command>-help getmerge</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-getmerge \[-nl\] &lt;src&gt; &lt;localdst&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*Get all the files in the directories that match the source file pattern and( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*merge and sort them to only one file on local fs. &lt;src&gt; is kept.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*-nl\s+Add a newline character at the end of each file.( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for cat</description>
      <test-commands>
        <command>-help cat</command>
      </test-commands>
      <cleanup-commands>
        <!-- No cleanup -->
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-cat \[-ignoreCrc\] &lt;src&gt; \.\.\. :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Fetch all files that match the file pattern &lt;src&gt; and display their content on\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*stdout.</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for checksum</description>
      <test-commands>
        <command>-help checksum</command>
      </test-commands>
      <cleanup-commands>
        <!-- No cleanup -->
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-checksum &lt;src&gt; \.\.\. :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Dump checksum information for files that match the file pattern &lt;src&gt; to stdout\.\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Note that this requires a round-trip to a datanode storing each block of the\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*file, and thus is not efficient to run on a large number of files\. The checksum\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*of a file depends on its content, block size and the checksum algorithm and\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*parameters used for creating the file\.\s*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for copyToLocal</description>
      <test-commands>
        <command>-help copyToLocal</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-copyToLocal \[-p\] \[-ignoreCrc\] \[-crc\] &lt;src&gt; \.\.\. &lt;localdst&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Identical to the -get command.\s*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for moveToLocal</description>
      <test-commands>
        <command>-help moveToLocal</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-moveToLocal &lt;src&gt; &lt;localdst&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Not implemented yet</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for mkdir</description>
      <test-commands>
        <command>-help mkdir</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-mkdir \[-p\] &lt;path&gt; \.\.\. :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Create a directory in specified location.( )*</expected-output>
        </comparator>
        <comparator>
          <type>TokenComparator</type>
          <expected-output>-p  Do not fail if the directory already exists</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for setrep</description>
      <test-commands>
        <command>-help setrep</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-setrep \[-R\] \[-w\] &lt;rep&gt; &lt;path&gt; \.\.\. :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Set the replication level of a file. If &lt;path&gt; is a directory then the command( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*recursively changes the replication factor of all files under the directory tree( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*rooted at &lt;path&gt;\.( )*</expected-output>
        </comparator>
        <comparator>
            <type>RegexpComparator</type>
            <expected-output>^\s*-w\s+It requests that the command waits for the replication to complete\. This( )*</expected-output>
        </comparator>
        <comparator>
            <type>RegexpComparator</type>
            <expected-output>^( |\t)*can potentially take a very long time\.( )*</expected-output>
        </comparator>
          <comparator>
              <type>RegexpComparator</type>
              <expected-output>^( |\t)*-R\s+It is accepted for backwards compatibility\. It has no effect\.( )*</expected-output>
          </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for touchz</description>
      <test-commands>
        <command>-help touchz</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-touchz &lt;path&gt; \.\.\. :( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*Creates a file of zero length at &lt;path&gt; with current time as the timestamp of( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)* that &lt;path&gt;\. An error is returned if the file exists with non-zero length( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for test</description>
      <test-commands>
        <command>-help test</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-test -\[defsz\] &lt;path&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Answer various questions about &lt;path&gt;, with result via exit status.</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*-[defsz]\s+return 0 if .*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for stat</description>
      <test-commands>
        <command>-help stat</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-stat \[format\] &lt;path&gt; \.\.\. :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*Print statistics about the file/directory at &lt;path&gt; in the specified format.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*Format accepts filesize in blocks \(%b\), group name of owner\(%g\), filename \(%n\),( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*block size \(%o\), replication \(%r\), user name of owner\(%u\), modification date( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*\(%y, %Y\)( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for tail</description>
      <test-commands>
        <command>-help tail</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-tail \[-f\] &lt;file&gt; :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Show the last 1KB of the file.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*-f\s+Shows appended data as the file grows.( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for chmod</description>
      <test-commands>
        <command>-help chmod</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-chmod \[-R\] &lt;MODE\[,MODE\]... \| OCTALMODE&gt; PATH... :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*Changes permissions of a file. This works similar to the shell's chmod command( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*with a few exceptions.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*-R\s*modifies the files recursively. This is the only option currently( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*supported.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*&lt;MODE&gt;\s*Mode is the same as mode used for the shell's command. The only( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*letters recognized are 'rwxXt', e\.g\. \+t,a\+r,g-w,\+rwx,o=r\.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*&lt;OCTALMODE&gt;\s+Mode specifed in 3 or 4 digits. If 4 digits, the first may be 1 or( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*0 to turn the sticky bit on or off, respectively.( )*Unlike( |\t)*the( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*shell command, it is not possible to specify only part of the( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*mode, e\.g\. 754 is same as u=rwx,g=rx,o=r\.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*If none of 'augo' is specified, 'a' is assumed and unlike the shell command, no( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*umask is applied.( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for chown</description>
      <test-commands>
        <command>-help chown</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-chown \[-R\] \[OWNER\]\[:\[GROUP\]\] PATH... :\s*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^\s*Changes owner and group of a file\. This is similar to the shell's chown command( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*with a few exceptions.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*-R( |\t)*modifies the files recursively. This is the only option currently( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*supported.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*If only the owner or group is specified, then only the owner or group is( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*modified. The owner and group names may only consist of digits, alphabet, and( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*any of .+?. The names are case sensitive.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*WARNING: Avoid using '.' to separate user name and group though Linux allows it.( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*If user names have dots in them and you are using local file system, you might( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*see surprising results since the shell command 'chown' is used for local files.( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for chgrp</description>
      <test-commands>
        <command>-help chgrp</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-chgrp \[-R\] GROUP PATH... :( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*This is equivalent to -chown ... :GROUP ...( )*</expected-output>
        </comparator>
      </comparators>
    </test>

    <test> <!-- TESTED -->
      <description>help: help for help</description>
      <test-commands>
        <command>-help help</command>
      </test-commands>
      <cleanup-commands>
      </cleanup-commands>
      <comparators>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^-help \[cmd ...\] :( )*</expected-output>
        </comparator>
        <comparator>
          <type>RegexpComparator</type>
          <expected-output>^( |\t)*Displays help for given command or all commands if none is specified.( )*</expected-output>
        </comparator>
      </comparators>
    </test>

  </tests>
</configuration>
